<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Arduino-ESP32 是由乐鑫科技在 GitHub 开源社区推出的一款基于 Arduino IDE 的板级支持包（BSP，Board Support Package），除了兼容大部分通用的 Arduino API 之外，还能够支持 ESP32 系列芯片一些独有的特性化 API。由于几年以前已经撰写过一篇基于标准 Arduino API 的《玩转 Arduino Uno、Me"><meta property="og:type" content="blog"><meta property="og:title" content="基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程"><meta property="og:url" content="http://www.uinio.com/Project/Arduino-ESP32/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="Arduino-ESP32 是由乐鑫科技在 GitHub 开源社区推出的一款基于 Arduino IDE 的板级支持包（BSP，Board Support Package），除了兼容大部分通用的 Arduino API 之外，还能够支持 ESP32 系列芯片一些独有的特性化 API。由于几年以前已经撰写过一篇基于标准 Arduino API 的《玩转 Arduino Uno、Me"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2023-04-30T16:00:00.000Z"><meta property="article:modified_time" content="2025-01-05T09:16:25.103Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="Arduino"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Project/Arduino-ESP32/"},"headline":"基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程","image":["http://www.uinio.com/Project/Arduino-ESP32/logo.png"],"datePublished":"2023-04-30T16:00:00.000Z","dateModified":"2025-01-05T09:16:25.103Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"Arduino-ESP32\r 是由乐鑫科技在 GitHub\r 开源社区推出的一款基于 Arduino IDE\r 的板级支持包（BSP，Board Support\r Package），除了兼容大部分通用的 Arduino\r API 之外，还能够支持 ESP32\r 系列芯片一些独有的特性化\r API。由于几年以前已经撰写过一篇基于标准 Arduino API\r 的《玩转 Arduino\r Uno、Me"}</script><link rel="canonical" href="http://www.uinio.com/Project/Arduino-ESP32/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-30T16:00:00.000Z" title="2023/5/1 00:00:00">2023-05-01</time>发表</span><span class="level-item"><time dateTime="2025-01-05T09:16:25.103Z" title="2025/1/5 17:16:25">2025-01-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/">UINIO 开源项目资料</a></span><span class="level-item">4 小时读完 (大约33228个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程</h1><div class="content"><p><a target="_blank" rel="noopener" href="https://github.com/espressif/arduino-esp32"><strong>Arduino-ESP32</strong></a>
是由<strong>乐鑫科技</strong>在 <strong>GitHub</strong>
开源社区推出的一款基于 <strong>Arduino IDE</strong>
的<strong>板级支持包</strong>（<strong>BSP</strong>，Board Support
Package），除了兼容大部分通用的 <a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/"><strong>Arduino
API</strong></a> 之外，还能够支持 <strong>ESP32</strong>
系列芯片一些独有的特性化
<strong>API</strong>。由于几年以前已经撰写过一篇基于标准 Arduino API
的<a target="_blank" rel="noopener" href="http://uinio.com/Embedded/Arduino/">《玩转 Arduino
Uno、Mega、ESP 开源硬件》</a>，所以本篇文章不再赘述相关内容，而是结合
<code>U8G2</code>、<code>AsyncTimer</code>、<code>RBD_BUTTON</code>、<code>LiquidCrystal_I2C</code>、<code>ESP32SPISlave</code>、<code>Servo</code>、<code>SdFat</code>
等常用第三方库，通过分析注释典型的示例代码，分门别类的介绍了各种片上资源外设的实例化运用。</p>
<p><img src="/Project/Arduino-ESP32/logo.png"></p>
<p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>
是当前市场上比较流行的两款物联网主控芯片方案，它们分别基于开源的
<strong>RISC-V</strong> 内核，以及商业化的 <strong>Xtensa</strong>
内核，并且同时支持 WiFi 与 Bluetooth
无线连接。由于日常工作当中经常使用到这两款微控制器，所以特意设计了 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>
和 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>
两款核心板，关于它们硬件电路设计方面的相关内容，可以进一步参考本篇文章的姊妹篇<a target="_blank" rel="noopener" href="http://uinio.com/Project/UINIO-MCU-ESP32/">《UINIO-MCU-ESP32
核心板电路设计》</a>。由于本文属于 Arduino
进阶性质的教程，阅读时需要具备一定的嵌入式开发经验，萌新可以阅读笔者更早之前撰写的<a target="_blank" rel="noopener" href="http://uinio.com/Embedded/Arduino/">《玩转 Arduino Uno、Mega、ESP
开源硬件》</a>。</p>
<span id="more"></span>
<h1 id="arduino-ide-2-开发环境">Arduino IDE 2 开发环境</h1>
<p><strong>Arduino IDE 2</strong> 相较于之前的 <code>1.8.19</code>
版本，提供了更加友好的用户界面，新增了<code>自动补全</code>、<code>内置调试器</code>、<code>Arduino Cloud 同步</code>
等功能，拥有一个改进的侧边栏，使得常用的功能更加易于访问，详细用法可以查阅
<strong>Arduino</strong> 官方提供的<a target="_blank" rel="noopener" href="https://docs.arduino.cc/software/ide-v2">《<strong>Arduino IDE 2
Tutorials</strong>》</a>：</p>
<p><img src="/Project/Arduino-ESP32/0.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>Arduino IDE</strong> 创建的以
<code>.ino</code>
作为后缀名的源代码文件，被称为<strong>草图</strong>（Sketche）文件。</p>
</blockquote>
<h1 id="arduino-esp32-库概览">Arduino-ESP32 库概览</h1>
<p><strong>乐鑫科技</strong>在 <strong>GitHub</strong> 开源社区推出的 <a target="_blank" rel="noopener" href="https://github.com/espressif/arduino-esp32"><strong>Arduino-ESP32</strong></a>
板级支持包，目前已经更新到 <code>2.0.11</code> 版本，通过向
<strong>Arduino IDE</strong>
的【开发板管理器】添加如下的<code>开发板管理器地址</code>，就可以完成
<strong>Arduino-ESP32</strong> 板级支持包的安装：</p>
<ul>
<li><strong>稳定版本链接</strong>：
<code>https://espressif.github.io/arduino-esp32/package_esp32_index.json</code></li>
<li><strong>开发版本链接</strong>：
<code>https://espressif.github.io/arduino-esp32/package_esp32_dev_index.json</code></li>
</ul>
<p><strong>Arduino-ESP32</strong> 提供了对于
<strong>ESP32</strong>、<strong>ESP32-S2</strong>、<strong>ESP32-C3</strong>、<strong>ESP32-S3</strong>
系列芯片的支持，各个片上外设的具体兼容情况可以参见下表：</p>
<p><img src="/Project/Arduino-ESP32/1.png"></p>
<blockquote>
<p><strong>注意</strong>：所有 ESP32 系列芯片都支持 SPI 以太网，其中
RMII 只有 ESP32 能够支持。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/index.html">《<strong>ESP32
Arduino 核心文档</strong>》</a> 当中提供了如下这些 API
的使用说明，具体内容可以点击下面表格当中的链接逐一查阅：</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 24%">
<col style="width: 25%">
<col style="width: 24%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/adc.html">模数转换（ADC）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ble.html">低功耗蓝牙（BLE）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/bluetooth.html">传统蓝牙（Bluetooth）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/dac.html">数模转换（DAC）</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/deepsleep.html">深度休眠（Deep
Sleep）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/espnow.html">短距离无线通信（ESP-NOW）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ethernet.html">以太网（Ethernet）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/gpio.html">通用输入输出（GPIO）</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/hall_sensor.html">霍尔传感器（Hall
Sensor）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/i2c.html">内部集成电路总线（I²C）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/i2s.html">集成电路内置音频总线（I²S）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/insights.html">远程诊断（ESP
Insights）</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html">LED
控制（LEDC，LED Control）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/preferences.html">Preferences</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/pulse_counter.html">脉冲计数器（Pulse
Counter）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/rainmaker.html">ESP
Rainmaker</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/reset_reason.html">复位原因（Reset
Reason）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/rmt.html">红外收发器（RMT）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sdio.html">SDIO</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sdmmc.html">SD
MMC</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sigmadelta.html">二阶
<span class="math inline">\(\Sigma\Delta\)</span> 信号调制*</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/spi.html">串行外设接口（SPI）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html">定时器（Timer）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/touch.html">触摸
TOUCH</a></td>
</tr>
<tr>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb.html">通用串行总线（USB
API）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb_cdc.html">USB
通信设备类（USB CDC）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb_msc.html">USB
大容量存储类 API（USB MSC）</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html">无线
Wi-Fi</a></td>
</tr>
</tbody>
</table>
<p>安装完成 <a target="_blank" rel="noopener" href="https://www.wch.cn/products/CH343.html"><strong>CH343P</strong></a>
的 USB 转串口驱动程序之后，就可以将 <strong>UINIO-MCU-ESP32</strong>
核心板连接至电脑，再打开 <strong>Arduino IDE</strong>
选择【<strong>ESP32C3 Dev Module</strong>】或者【<strong>ESP32S3 Dev
Module</strong>】开发板，以及相应的 USB
端口，就可以完成全部的开发连接准备：</p>
<p><img src="/Project/Arduino-ESP32/2.png"></p>
<p>接下来，编写如下的代码，以 <code>115200</code> 波特率向
<strong>Arduino IDE</strong> 的【串口监视器】打印字符串
<code>Welcome to UinIO.com</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数只调用一次 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>); <span class="comment">// 设置波特率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该函数会循环执行 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Welcome to UinIO.com&quot;</span>); <span class="comment">// 向串口打印字符串</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <strong>Arduino IDE</strong>
的【串口监视器】当中正确打印出了如下结果，就表明当前的开发环境已经搭建成功了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Welcome to UinIO.com</span><br><span class="line">Welcome to UinIO.com</span><br><span class="line">Welcome to UinIO.com</span><br><span class="line">... .. ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：笔者设计的 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>
和 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>
两款开源硬件在本文后续内容当中。都将会被统称为
<strong>UINIO-MCU-ESP32</strong>，如果没有进行特殊说明，那么所有示例代码都同时兼容两款核心板。</p>
</blockquote>
<h1 id="led-定时闪烁阻塞-非阻塞">LED 定时闪烁（阻塞 &amp; 非阻塞）</h1>
<p><strong>发光二极管</strong>（<strong>LED</strong>，Light Emitting
Diode）在正向导通之后就会发光，对于直插式发光二极管（长脚为<strong>正</strong>，短脚为<strong>负</strong>），其<strong>红色</strong>和<strong>黄色</strong>的正向压降为
<code>2.0V ~ 2.2V</code>，而<strong>绿色</strong>、<strong>白色</strong>、<strong>蓝色</strong>产生的正向压降为
<code>3.0V ~ 3.2V</code>，额定工作电流介于 <code>5mA ~ 20mA</code>
范围之间。接下来以红色发光二极管为例，介绍其限流电阻的计算方法。</p>
<p>首先，红色 LED 正常工作时产生的压降约为 <code>2.0V</code>，而 ESP32
引脚输出的高电平为 <code>3.3V</code>，此时限流电阻上流过的电压等于
<code>3.3 - 2.0 = 1.3V</code>，而红色发光二极管的额定电流约为
<code>10mA</code>，所以这个<strong>限流电阻</strong>的取值应当为 <span class="math inline">\(\frac{1.3V}{0.01A} =
130Ω\)</span>，这里近似的取电阻标称值为
<code>120Ω</code>，并且将其连接到 <strong>Arduino-MCU-ESP32</strong> 的
<strong>GPIO0</strong> 引脚，具体的电路连接关系如下图所示：</p>
<p><img src="/Project/Arduino-ESP32/3.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>ESP32</strong>
系列芯片<strong>高电平</strong>信号的最低电压值为
<code>3.3V × 0.8 = 2.64V</code>，而<strong>低电平</strong>信号的最高电压值为
<code>3.3V × 0.1 = 0.33V</code>。</p>
</blockquote>
<ul>
<li><code>pinMode(pin, mode)</code>：配置引脚工作模式，其中
<code>mode</code> 参数可选的值有
<code>INPU</code>、<code>OUTPUT</code>、<code>INPUT_PULLUP</code>、<code>INPUT_PULLDOWN</code>；</li>
<li><code>digitalWrite(pin, value)</code>：设置数字输出引脚的电平状态，其中
<code>value</code> 参数可选的值是 <code>HIGH</code> 或者
<code>LOW</code>；</li>
<li><code>delay(ms)</code>：延时函数，其参数 <code>ms</code>
的单位为<strong>毫秒</strong>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT); <span class="comment">// 配置该引脚为输出状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, LOW);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用 <code>delay()</code>
延时函数会阻塞后续任务的执行，所以这里改用如下两个
API，通过循环计算时间差值的方式来实现 LED 灯的闪烁：</p>
<ul>
<li><code>millis()</code>：程序当前运行的<strong>毫秒</strong>数；</li>
<li><code>micros()</code>：程序当前运行的<strong>微秒</strong>数；</li>
</ul>
<p>下面的示例代码通过 <strong>UINIO-MCU-ESP32</strong> 的
<code>GPIO0</code> 引脚控制一个 LED 灯，每间隔 1
秒循环不断的进行闪烁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>;            <span class="comment">// LED 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime = <span class="number">0</span>;     <span class="comment">// 前一次 LED 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  LED_Status = HIGH;</span><br><span class="line">  prevTime = <span class="built_in">millis</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime = <span class="built_in">millis</span>(); <span class="comment">// 开始进行测试时刻的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 两次 LED 状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime - prevTime &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status = LED_Status == HIGH ? LOW : HIGH; <span class="comment">// 切换 LED 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, Status);</span><br><span class="line">    LED_Status = Status;</span><br><span class="line">    prevTime = curTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要控制多个 LED
的闪烁，则需要将电路连接关系修改为下面的样子，此时控制引脚需要变更为
<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO1</code> 和
<code>GPIO2</code>：</p>
<p><img src="/Project/Arduino-ESP32/4.png"></p>
<p>注意需要同步修改代码当中控制引脚变量 <code>LED_Pin_x</code>
的值，其它的功能代码只需要进行相应的复制粘贴即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin_1 = <span class="number">1</span>;            <span class="comment">// 将 LED 1 的控制引脚设置为 GPIO1</span></span><br><span class="line"><span class="type">int</span> LED_Status_1 = <span class="number">0</span>;         <span class="comment">// LED 1 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime_1 = <span class="number">0</span>;  <span class="comment">// 前一次 LED 1 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin_2 = <span class="number">2</span>;            <span class="comment">// 将 LED 2 的控制引脚设置为 GPIO2</span></span><br><span class="line"><span class="type">int</span> LED_Status_2 = <span class="number">0</span>;         <span class="comment">// LED 2 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime_2 = <span class="number">0</span>;  <span class="comment">// 前一次 LED 2 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* LED 1 状态设置 */</span></span><br><span class="line">  pinMode(LED_Pin_1, OUTPUT);</span><br><span class="line">  digitalWrite(LED_Pin_1, HIGH);</span><br><span class="line">  LED_Status_1 = HIGH;</span><br><span class="line">  prevTime_1 = millis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 2 状态设置 */</span></span><br><span class="line">  pinMode(LED_Pin_2, OUTPUT);</span><br><span class="line">  digitalWrite(LED_Pin_2, HIGH);</span><br><span class="line">  LED_Status_2 = HIGH;</span><br><span class="line">  prevTime_2 = millis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime_1 = millis();  <span class="comment">// LED 1 开始进行测试时刻的时间</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime_2 = millis();  <span class="comment">// LED 2 开始进行测试时刻的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 1 两次状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime_1 - prevTime_1 &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status_1 = LED_Status_1 == HIGH ? LOW : HIGH;  <span class="comment">// 切换 LED 1 的状态</span></span><br><span class="line"></span><br><span class="line">    digitalWrite(LED_Pin_1, Status_1);</span><br><span class="line">    LED_Status_1 = Status_1;</span><br><span class="line">    prevTime_1 = curTime_1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 2 两次状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime_2 - prevTime_2 &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status_2 = LED_Status_2 == HIGH ? LOW : HIGH;  <span class="comment">// 切换 LED 2 的状态</span></span><br><span class="line"></span><br><span class="line">    digitalWrite(LED_Pin_2, Status_2);</span><br><span class="line">    LED_Status_2 = Status_2;</span><br><span class="line">    prevTime_2 = curTime_2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="按键控制-与-rbd_button-库">按键控制 与 RBD_BUTTON 库</h1>
<p>本示例需要将 <strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO3</code>
和 <code>GPIO4</code> 分别连接至 <strong>LED</strong>
和<strong>按键</strong>：</p>
<p><img src="/Project/Arduino-ESP32/5.png"></p>
<p>由于按键的控制引脚被配置为<strong>输入上拉</strong>
<code>INPUT_PULLUP</code>，所以当按键被按下时<strong>低电平</strong>有效，读取引脚的电平状态需要使用到如下的
API：</p>
<ul>
<li><code>digitalRead(pin)</code>：读取指定输入引脚 <code>pin</code>
的电平状态，返回值是 <code>HIGH</code> 或者 <code>LOW</code>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;    <span class="comment">// LED 控制引脚</span></span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>; <span class="comment">// LED 当前状态</span></span><br><span class="line"><span class="type">int</span> Switch_Pin = <span class="number">4</span>; <span class="comment">// 按键控制引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(Switch_Pin, INPUT_PULLUP); <span class="comment">// 配置按键控制引脚为输入上拉</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  LED_Status = HIGH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> Switch_Status = <span class="built_in">digitalRead</span>(Switch_Pin); <span class="comment">// 读取按键引脚的状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当按键被接下时执行的代码 */</span></span><br><span class="line">  <span class="keyword">if</span>(Switch_Status == LOW) &#123;</span><br><span class="line">    LED_Status = !LED_Status;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码的运行结果，可以发现按键对于 LED
亮灭状态的控制并不准确，这是由于按键在按下时，触点的接触不够稳定所导致。在这里我们可以方便的借助
<a target="_blank" rel="noopener" href="https://github.com/alextaujenis/RBD_Button"><strong>RBD_BUTTON</strong></a>
这款第三方库来消除这种抖动。接下来在 <strong>Arduino IDE</strong>
当中安装 <strong>RBD_Button</strong> 以及关联的
<strong>RBD_Timer</strong> 依赖库，由于该库所提供的
<code>Button</code>类位于 <strong>C++</strong> 的<code>RBD</code>
命名空间当中，所以其构造函数的调用形式应当书写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RBD::Button <span class="title">constructor</span><span class="params">(pin,[input, input_pullup, input_pulldown])</span></span></span><br></pre></td></tr></table></figure>
<p><code>Button</code>
类当中提供了如下一系列可以用于消除按键抖动的方法：</p>
<ul>
<li><code>button.isPressed()</code>：当按键被按下或开启时返回
<code>true</code>，否则返回 <code>false</code>；</li>
<li><code>button.isReleased()</code>：当按键弹起或者释放时返回
<code>true</code>，否则返回 <code>false</code>；</li>
<li><code>button.onPressed()</code>：当按钮被按下（已经去除抖动）一次以后返回
<code>true</code>，接下来必须释放按钮，并且再次按下才能够返回
<code>true</code>；</li>
<li><code>button.onReleased()</code>：当按钮被释放（已经去除抖动）一次以后返回
<code>true</code>，接下来必须按下按钮，并且再次释放才能够返回
<code>true</code>；</li>
<li><code>button.setDebounceTimeout(value)</code>：设置消除抖动的时间，参数的单位为毫秒；</li>
</ul>
<p>修改前面的示例代码，加入按键消抖的处理逻辑，可以看到在消除抖动错误的同时，代码的书写也得到了极大简化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Button.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;    <span class="comment">// LED 控制引脚</span></span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>; <span class="comment">// LED 当前状态</span></span><br><span class="line"><span class="type">int</span> Switch_Pin = <span class="number">4</span>; <span class="comment">// 按键控制引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function">RBD::Button <span class="title">button</span><span class="params">(Switch_Pin, INPUT_PULLUP)</span></span>; <span class="comment">// 创建 button 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  button.<span class="built_in">setDebounceTimeout</span>(<span class="number">20</span>); <span class="comment">// 设置按键消抖延迟时间为 20 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 当按键被按下时候的处理逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span>(button.<span class="built_in">onPressed</span>()) &#123;</span><br><span class="line">    LED_Status = !LED_Status;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于-pwm-的-ledc">基于 PWM 的 LEDC</h1>
<p><strong>LED 发光二极管</strong>的正常工作电压介于
<code>1.8V ~ 2.0V</code>
之间，由于该电压变化区间的取值范围较小，难以通过电压大小来控制 LED
的亮度。而<strong>脉冲宽度调制</strong>（<strong>PWM</strong>，Pulse
Width
Modulation）则另辟蹊径，通过改变输出方波的<strong>占空比</strong>来控制
LED 的亮灭频率，从而达到调整亮度的目的。</p>
<p><img src="/Project/Arduino-ESP32/6.png"></p>
<p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 各拥有
<code>6</code> 和 <code>8</code> 个 <strong>LEDC</strong>
通道，分别用于产生独立的 PWM 波形信号，最大精度为 <strong>14</strong>
位。<strong>Arduino-ESP32</strong> 提供了专门的 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html"><strong>LED
控制 API</strong></a>（LEDC，LED Control），可以方便的以 PWM 方式来控制
LED 的亮度，具体的 API 方法可以参考下面的列表：</p>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>uint32_t ledcSetup(uint8_t channel, uint32_t freq, uint8_t resolution_bits);</code></td>
<td style="text-align: left;">用于设置 LEDC
通道的<strong>频率</strong>和<strong>分辨率</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void ledcWrite(uint8_t chan, uint32_t duty);</code></td>
<td style="text-align: left;"><strong>设置</strong>指定 LEDC
通道的<strong>占空比</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t ledcRead(uint8_t chan);</code></td>
<td style="text-align: left;"><strong>获取</strong>指定 LEDC
通道的<strong>占空比</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t ledcReadFreq(uint8_t chan);</code></td>
<td style="text-align: left;"><strong>获取</strong>指定 LEDC
通道的<strong>频率</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t ledcWriteTone(uint8_t chan, uint32_t freq);</code></td>
<td style="text-align: left;">用于在指定频率上将 LEDC 通道设置为
<code>50%</code> 占空比的 PWM <strong>音调</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t ledcWriteNote(uint8_t chan, note_t note, uint8_t octave);</code></td>
<td style="text-align: left;">用于将 LEDC
通道设置为指定的<strong>音符</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void ledcAttachPin(uint8_t pin, uint8_t chan);</code></td>
<td style="text-align: left;">用于将指定的 <strong>GPIO
引脚</strong>绑定至 <strong>LEDC 通道</strong>;</td>
</tr>
<tr>
<td style="text-align: left;"><code>void ledcDetachPin(uint8_t pin);</code></td>
<td style="text-align: left;">用于取消指定的 <strong>GPIO
引脚</strong>与 <strong>LEDC 通道</strong>的绑定;</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t ledcChangeFrequency(uint8_t chan, uint32_t freq, uint8_t bit_num);</code></td>
<td style="text-align: left;">用于动态改变 LEDC
通道的<strong>频率</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogWrite(uint8_t pin, int value);</code></td>
<td style="text-align: left;">用于在指定 GPIO
引脚上写入<strong>模拟值</strong>(PWM 波形信号)，该接口兼容 Arduino
官方的 <code>analogWrite()</code> 函数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogWriteResolution(uint8_t bits);</code></td>
<td style="text-align: left;">用于设置所有 <code>analogWrite()</code>
通道的<strong>分辨率</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogWriteFrequency(uint32_t freq);</code></td>
<td style="text-align: left;">用于设置所有 <code>analogWrite()</code>
通道的<strong>频率</strong>；</td>
</tr>
</tbody>
</table>
<p>下面的示例代码将 <strong>LEDC</strong> 配置为 <code>0</code>
通道，工作频率为 <code>5000</code> 赫兹，精度为 <code>12</code>
位（即将一个<strong>周期</strong>划分为 <span class="math inline">\(2^{12}\)</span> 等分）。如果需要将其占空比调整为
<code>50%</code>，那么高电平就需要占据 <span class="math inline">\(2^{12} \div 2 = 2^{12 - 1} = 2^{11}\)</span>
等分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> GPIO = <span class="number">4</span>;                                 <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line">  <span class="type">int</span> Channel = <span class="number">0</span>;                              <span class="comment">// 指定 LEDC 通道 0</span></span><br><span class="line">  <span class="type">int</span> Frequency = <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>); <span class="comment">// 配置 LEDC 为 0 通道、频率为 5000 赫兹、精度为 12 位</span></span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Frequency == <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;LEDC 配置失败&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;LEDC 配置成功&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO, Channel);   <span class="comment">// 绑定 GPIO4 引脚与通道 0</span></span><br><span class="line">  <span class="built_in">ledcWrite</span>(Channel, <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">11</span>)); <span class="comment">// 将通道 0 的占空比调整为 50%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再利用 LEDC 和 PWM
实现一个呼吸灯效果，具体策略为每秒钟调整占空比 <code>50</code> 次，假设
<code>T</code> 为呼吸周期，那么 LED 从熄灭到最高亮度需要经过的时间为
<span class="math inline">\(\frac{T}{2}\)</span>（即半个呼吸周期）。这样每半个周期就需要进行
<span class="math inline">\(50 \times \frac{T}{2}\)</span>
次占空比调整，而 <code>count</code> 表示占空比为 <code>100%</code>
时候的等分数量，<code>step</code> 就是每次占空比调整所需要增加的步进值
<span class="math inline">\(step = \frac{count}{50 \times \frac{T}{2}} =
2 \times \frac{count}{50 \times T}\)</span>，当占空比超过
<code>Count</code> 时，就需要逐步将 <code>Step</code> 步进值递减至
<code>0</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GPIO4 = <span class="number">4</span>;    <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line"><span class="type">int</span> Channel = <span class="number">1</span>;  <span class="comment">// 指定 LEDC 通道 1</span></span><br><span class="line"><span class="type">int</span> Duty = <span class="number">0</span>;     <span class="comment">// 当前信号的占空比</span></span><br><span class="line"><span class="type">int</span> Count = <span class="number">0</span>;    <span class="comment">// 占空比为 100% 时的等分数量</span></span><br><span class="line"><span class="type">int</span> Step = <span class="number">0</span>;     <span class="comment">// 占空比的步进值</span></span><br><span class="line"><span class="type">int</span> Breath = <span class="number">3</span>;   <span class="comment">// 每次呼吸的时间长度，单位为秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>);      <span class="comment">// 配置 LEDC 为 1 通道、频率为 1000 赫兹、精度为 12 位</span></span><br><span class="line">  Count = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">12</span>);                <span class="comment">// 获取占空比为 100% 时候的等分数量</span></span><br><span class="line">  Step = <span class="number">2</span> * Count / (<span class="number">50</span> * Breath);  <span class="comment">// 每次占空比调整所需要增加的步进值</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO4, Channel);     <span class="comment">// 绑定 GPIO4 引脚与通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcWrite</span>(Channel, Duty);          <span class="comment">// 每次循环都改变一次 PWM 信号的占空比</span></span><br><span class="line">  Duty += Step;                      <span class="comment">// 步进值递增</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当占空比高于 100% 等分数量的时候 */</span></span><br><span class="line">  <span class="keyword">if</span> (Duty &gt; Count) &#123;</span><br><span class="line">    Duty = Count;                    <span class="comment">// 将占空比 Duty 限制为 100% 等分数量</span></span><br><span class="line">    Step = -Step;                    <span class="comment">// 修改步进值为负数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 当占空比小于 0 等分数量的时候 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Duty &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Duty = <span class="number">0</span>;                        <span class="comment">// 将占空比设置为 0</span></span><br><span class="line">    Step = -Step;                    <span class="comment">// 修改步进值为负数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">30</span>);                         <span class="comment">// 等待 30 毫秒再进行下一次的占空比调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中的 <code>delay()</code> 函数会阻塞
<strong>UINIO-MCU-ESP32</strong> 的后续代码运行，下面通过
<code>prevTime</code> 和 <code>curTime</code>
两个变量来循环计算时间差值，实现一个非阻塞式的呼吸灯：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GPIO4 = <span class="number">4</span>;     <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line"><span class="type">int</span> Channel = <span class="number">1</span>;   <span class="comment">// 指定 LEDC 通道 1</span></span><br><span class="line"><span class="type">int</span> Duty = <span class="number">0</span>;      <span class="comment">// 当前信号的占空比</span></span><br><span class="line"><span class="type">int</span> Count = <span class="number">0</span>;     <span class="comment">// 占空比为 100% 时的等分数量</span></span><br><span class="line"><span class="type">int</span> Step = <span class="number">0</span>;      <span class="comment">// 占空比的步进值</span></span><br><span class="line"><span class="type">int</span> Breath = <span class="number">3</span>;    <span class="comment">// 每次呼吸的时间长度，单位为秒</span></span><br><span class="line"><span class="type">int</span> prevTime = <span class="number">0</span>;  <span class="comment">// 记录前一次调整占空比的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>);      <span class="comment">// 配置 LEDC 为 1 通道、频率为 1000 赫兹、精度为 12 位</span></span><br><span class="line">  Count = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">12</span>);                <span class="comment">// 获取占空比为 100% 时候的等分数量</span></span><br><span class="line">  Step = <span class="number">2</span> * Count / (<span class="number">50</span> * Breath);  <span class="comment">// 每次占空比调整所需要增加的步进值</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO4, Channel);     <span class="comment">// 绑定 GPIO4 引脚与通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> curTime = <span class="built_in">millis</span>();            <span class="comment">// 记录执行到此处的当前时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断距离上一次占空比调整是否超过 30 毫秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime - prevTime &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">ledcWrite</span>(Channel, Duty);        <span class="comment">// 每次循环都改变一次 PWM 信号的占空比</span></span><br><span class="line">    Duty += Step;                    <span class="comment">// 步进值递增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当占空比高于 100% 等分数量的时候 */</span></span><br><span class="line">    <span class="keyword">if</span> (Duty &gt; Count) &#123;</span><br><span class="line">      Duty = Count;                   <span class="comment">// 将占空比 Duty 限制为 100% 等分数量</span></span><br><span class="line">      Step = -Step;                   <span class="comment">// 修改步进值为负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当占空比小于 0 等分数量的时候 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Duty &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      Duty = <span class="number">0</span>;                      <span class="comment">// 将占空比设置为 0</span></span><br><span class="line">      Step = -Step;                  <span class="comment">// 修改步进值为负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    prevTime = curTime;              <span class="comment">// 更新时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="软件定时器-与-asynctimer-库">软件定时器 与 AsyncTimer 库</h1>
<p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 分别拥有
<code>2</code> 个和 <code>4</code>
个<strong>硬件定时器</strong>，虽然它们的精度较高，但是数量着实有限。在一些对于精度要求不高的场合，可以考虑使用诸如
<a target="_blank" rel="noopener" href="https://github.com/Aasim-A/AsyncTimer"><strong>AsyncTimer</strong></a>
这样的第三方库来作为<strong>软件定时器</strong>使用，它适用于一些对于精度要求不高的场合（精度为毫秒级别），具体的使用步骤如下面所示：</p>
<ol type="1">
<li>首先，在 <strong>Arduino IDE</strong>
的【<strong>库管理器</strong>】当中安装 <code>AsyncTimer</code>
库；</li>
<li>然后，在工程代码当中包含头文件
<code>#include &lt;AsyncTimer.h&gt;</code>；</li>
<li>接下来，声明定时器变量 <code>AsyncTimer timer</code>；</li>
<li>最后，在 <code>void loop()</code> 函数当中调用
<code>t.handle()</code>；</li>
</ol>
<p>下面的示例代码，会通过 <strong>AsyncTimer</strong> 提供的
<code>setTimeout()</code> 函数，分别延时 <code>3</code> 秒和
<code>5</code> 秒向串口打印提示信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以普通函数方式使用 setTimeout() */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 normal 函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id1 = timer.<span class="built_in">setTimeout</span>(task, <span class="number">3000</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Timeout ID 1：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以 Lambda 函数方式使用 setTimeout() */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id2 = timer.<span class="built_in">setTimeout</span>([]()&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 lambda 函数&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Timeout ID 2：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timeout ID 1：62510</span></span><br><span class="line"><span class="comment">   Timeout ID 2：36048</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数 */</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以通过类似的方式调用 <strong>AsyncTimer</strong> 的
<code>setInterval()</code>
函数，周期性的不断重复向串口打印提示信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以普通函数方式使用 setInterval() */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 normal 函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id1 = timer.<span class="built_in">setInterval</span>(task, <span class="number">500</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Interval ID 1：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以 Lambda 函数方式使用 setInterval() */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id2 = timer.<span class="built_in">setInterval</span>([]()&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 lambda 函数&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">800</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Interval ID 2：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interval ID 1：62510</span></span><br><span class="line"><span class="comment">   Interval ID 2：36048</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   ... ... ... ... */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：注意每次调用 <code>setTimeout()</code> 和
<code>setInterval()</code> 之后返回的 ID 值都并不相同。</p>
</blockquote>
<p>接下来，结合前面介绍的 <strong>RBD_Button</strong> 和
<strong>AsyncTimer</strong> 两个第三方库，让一个 LED
在刚开始启动的时候，每间隔 1
秒钟进行闪烁，而在按下按键之后，再切换至间隔 3
秒进行闪烁，再次按下按键则切换回间隔 1
秒进行闪烁，这里依然沿用之前的按键与 LED 实验电路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Button.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;       <span class="comment">// LED GPIO</span></span><br><span class="line"><span class="type">int</span> switch_Pin = <span class="number">4</span>;    <span class="comment">// 按键 GPIO</span></span><br><span class="line"><span class="type">int</span> LED_Status = HIGH; <span class="comment">// 设定 LED 初始状态为点亮</span></span><br><span class="line"><span class="type">int</span> blink = <span class="number">1</span>;         <span class="comment">// 设定 LED 闪烁的间隔时间</span></span><br><span class="line"><span class="type">int</span> taskID = <span class="number">0</span>;        <span class="comment">// 定时任务 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义带有消抖功能的按键，低电平有效 */</span></span><br><span class="line"><span class="function">RBD::Button <span class="title">button</span><span class="params">(switch_Pin, INPUT_PULLUP)</span></span>;</span><br><span class="line">AsyncTimer timer;      <span class="comment">// 声明定时器变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换 LED 状态的定时器任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_LED_Status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LED_Status = !LED_Status;  <span class="comment">// 切换 LED 的亮灭状态</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);                                    <span class="comment">// 设置 LED 引脚为输出模式</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);                                 <span class="comment">// 执行 LED 的点亮操作</span></span><br><span class="line">  button.<span class="built_in">setDebounceTimeout</span>(<span class="number">20</span>);                               <span class="comment">// 设置按键消抖延时为 20 毫秒</span></span><br><span class="line">  taskID = timer.<span class="built_in">setInterval</span>(change_LED_Status, blink * <span class="number">1000</span>); <span class="comment">// 创建周期性重复执行的定时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 启用 AsyncTimer 定时器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断按键状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (button.<span class="built_in">onPressed</span>()) &#123;</span><br><span class="line">    blink = blink == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">1</span>;              <span class="comment">// 如果当前 LED 闪烁间隔为 1 秒，那么就将其修改为 3 秒，反之亦然</span></span><br><span class="line">    timer.<span class="built_in">changeDelay</span>(taskID, blink * <span class="number">1000</span>); <span class="comment">// 执行定时器 LED 闪烁间隔时间的修改操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="adc-模数转换">ADC 模数转换</h1>
<p><strong>模数转换器</strong>（ADC，Analog to Digital
Converter）是一种常见外设，用于将模拟信号转换为便于 ESP32
微控制器，读取与处理的数字信号。</p>
<ul>
<li><strong>ESP32-C3</strong> 集成有两个 <strong>12</strong>
位的<strong>逐次逼近寄存器型</strong>（<strong>SAR</strong>, Successive
Approximation Register）ADC，一共支持 <strong>6</strong>
个模拟通道输入，其中 <strong>ADC1</strong> 支持 <strong>5</strong>
个模拟通道输入（已工厂校准），而<strong>ADC2</strong> 支持
<strong>1</strong> 个模拟通道输入（未工厂校准）；</li>
<li><strong>ESP32-S3</strong> 同样集成有两个 <strong>12</strong>
位<strong>逐次逼近寄存器型</strong> ADC，一共拥有 <strong>20</strong>
个模拟输入通道，乐鑫官方推荐优先使用 <strong>ADC1</strong>；</li>
</ul>
<p><strong>Arduino-ESP32</strong> 当中针对 ADC
外设，提供了如下一系列通用的 API 函数：</p>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Arduino 通用的 ADC API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>uint16_t analogRead(uint8_t pin);</code></td>
<td style="text-align: left;">获取指定引脚或者 ADC 通道的原始值。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t analogReadMilliVolts(uint8_t pin);</code></td>
<td style="text-align: left;">获取指定引脚或者 ADC
通道的原始值（以毫伏为单位）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogReadResolution(uint8_t bits);</code></td>
<td style="text-align: left;">设置 <code>analogRead()</code>
返回值的分辨率，<strong>ESP32S3</strong> 默认为 <strong>13</strong>
位（从 <code>0</code> 到 <code>8191</code>），其它型号默认为
<strong>12</strong> 位（从 <code>0</code> 到 <code>4095</code>）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogSetClockDiv(uint8_t clockDiv);</code></td>
<td style="text-align: left;">设置 ADC 时钟的分频器，范围为
<code>0 ~ 255</code>，默认值为 <code>1</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogSetAttenuation(adc_attenuation_t attenuation);</code></td>
<td style="text-align: left;">设置全部通道的衰减系数，共拥有
<code>ADC_ATTEN_DB_0</code>、<code>ADC_ATTEN_DB_2_5</code>、<code>ADC_ATTEN_DB_6</code>、<code>ADC_ATTEN_DB_11</code>
四个选项。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogSetPinAttenuation(uint8_t pin, adc_attenuation_t attenuation);</code></td>
<td style="text-align: left;">设置指定引脚或者 ADC 通道的衰减系数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool adcAttachPin(uint8_t pin);</code></td>
<td style="text-align: left;">将 GPIO 引脚关联至 ADC，关联成功返回
<code>true</code>，否则返回 <code>false</code>。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 37%">
<col style="width: 37%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">ADC 衰减系数</th>
<th style="text-align: center;">ESP32-C3 可测量输入电压范围</th>
<th style="text-align: center;">ESP32-S3 可测量输入电压范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>ADC_ATTEN_DB_0</code></td>
<td style="text-align: center;">0 mV ~ 750 mV</td>
<td style="text-align: center;">0 mV ~ 950 mV</td>
</tr>
<tr>
<td style="text-align: center;"><code>ADC_ATTEN_DB_2_5</code></td>
<td style="text-align: center;">0 mV ~ 1050 mV</td>
<td style="text-align: center;">0 mV ~ 1250 mV</td>
</tr>
<tr>
<td style="text-align: center;"><code>ADC_ATTEN_DB_6</code></td>
<td style="text-align: center;">0 mV ~ 1300 mV</td>
<td style="text-align: center;">0 mV ~ 1750 mV</td>
</tr>
<tr>
<td style="text-align: center;"><code>ADC_ATTEN_DB_11</code></td>
<td style="text-align: center;">0 mV ~ 2500 mV</td>
<td style="text-align: center;">0 mV ~ 3100 mV</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>ESP32S3</strong> 的最高采样分辨率为
<strong>13</strong> 位，由于计数范围从 <code>0</code>
开始进行计数，所以其最大计数值为 <span class="math inline">\(2^{13} - 1
= 8191\)</span>，同理 <strong>ESP32C3</strong> 的最大计数值等于 <span class="math inline">\(2^{12} - 1 = 4095\)</span>。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">ESP32 专用的 ADC API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void analogSetWidth(uint8_t bits);</code></td>
<td style="text-align: left;">设置硬件采样分辨率，取值范围为
<code>9 ~ 12</code>，默认值是 <code>12</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void analogSetVRefPin(uint8_t pin);</code></td>
<td style="text-align: left;">设置需要进行 ADC 校准的引脚。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int hallRead();</code></td>
<td style="text-align: left;">读取连接至 <code>36</code>（SVP）和
<code>39</code>（SVN）引脚的霍尔传感器 ADC 值。</td>
</tr>
</tbody>
</table>
<p>接下来通过 ADC 完成一个实验，使用<strong>电位器</strong>调整
<strong>UINIO-MCU-ESP32</strong> 的 ADC
引脚所读取到的输入电压，然后根据这个输入电压的大小，调节 GPIO
引脚输出信号的占空比，从而达到调整 LED
亮度的目的，<strong>UINIO-MCU-ESP32</strong>
的电路连接关系如下图所示：</p>
<p><img src="/Project/Arduino-ESP32/7.png"></p>
<p>可以看到，这里把 <strong>UINIO-MCU-ESP32</strong> 的
<code>GPIO2</code> 引脚连接至电位器，而 <code>GPIO1</code> 作为 LED
发光二极管的控制引脚，接着编写并且上传如下的控制逻辑代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> taskId = <span class="number">0</span>;          <span class="comment">// 定时任务 ID</span></span><br><span class="line">AsyncTimer timer;        <span class="comment">// 通过定时器，关联 LED 与 电位器</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin  = <span class="number">1</span>;        <span class="comment">// LED 连接的 GPIO</span></span><br><span class="line"><span class="type">int</span> LED_Channel = <span class="number">0</span>;     <span class="comment">// 指定输出 PWM 信号的 LEDC 通道</span></span><br><span class="line"><span class="type">int</span> Potential_Pin = <span class="number">2</span>;   <span class="comment">// 电位器连接的 GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 亮度调整函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeBrightness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> value = <span class="built_in">analogRead</span>(Potential_Pin);               <span class="comment">// 读取电位器所连接 GPIO 引脚的原始值</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> voltage = <span class="built_in">analogReadMilliVolts</span>(Potential_Pin);  <span class="comment">// 读取电位器所连接 GPIO 引脚的电压值</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(voltage);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> duty = value / <span class="number">4095.0</span> * <span class="number">1024</span>; <span class="comment">// 计算占空比，此处的常量 4095.0 必须为浮点类型（电位器为最小值 0 时，占空比也为 0，LED 熄灭；当电位器为最大值 4095 时，占空比为 1024，LED 最亮）</span></span><br><span class="line">  <span class="built_in">ledcWrite</span>(LED_Channel, duty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="built_in">analogReadResolution</span>(<span class="number">12</span>);              <span class="comment">// 设置 ADC 读取分辨率为 12 位，即读取到的最大值为 4096</span></span><br><span class="line">  <span class="built_in">analogSetAttenuation</span>(ADC_11db);        <span class="comment">// 设置 ADC 的衰减值为 11 分贝</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ledcSetup</span>(LED_Channel, <span class="number">1000</span>, <span class="number">10</span>);      <span class="comment">// 设置 LEDC 通道的频率为 1000Hz，分辨率精度为 10</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(LED_Pin, LED_Channel);   <span class="comment">// 关联 LEDC 通道与 LED 控制引脚</span></span><br><span class="line"></span><br><span class="line">  taskId = timer.<span class="built_in">setInterval</span>(changeBrightness, <span class="number">20</span>);  <span class="comment">// 每间隔 20 毫秒改变一次 LED 亮度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="i²c-总线主从通信">I²C 总线主从通信</h1>
<p><strong>内部集成电路总线</strong>（I²C，Inter-Integrated
Circuit）是一种<strong>低速串行通信协议</strong>（标准模式
<code>100 Kbit/s</code>，快速模式 <code>400 Kbit/s</code>），采用
<code>SDA</code>（串行数据线）和
<code>SCL</code>（串行时钟线）两线制结构（需要使用<strong>上拉电阻</strong>），分别可以连接多个设备，每个设备都拥有唯一的
<strong>7</strong> 位地址（最多 <strong>128</strong>
个设备）。<strong>Arduino-ESP32</strong> 的 I²C 库实现了 <a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/wire/">Arduino
Wire</a> 官方库当中的如下一系列 API 函数：</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 64%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">I²C 通用 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool begin();</code></td>
<td style="text-align: left;">基于默认参数配置 I²C
外设，正确初始化之后返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool setPins(int sdaPin, int sclPin);</code></td>
<td style="text-align: left;">用于定义 <code>SDA</code> 和
<code>SCL</code> 引脚，两个参数的默认值分别为 <code>GPIO21</code> 和
<code>GPIO22</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool setClock(uint32_t frequency);</code></td>
<td style="text-align: left;"><strong>设置</strong> I²C
总线的<strong>时钟频率</strong>，默认为 <code>100KHz</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t getClock();</code></td>
<td style="text-align: left;"><strong>获取</strong> I²C
总线的<strong>时钟频率</strong>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setTimeOut(uint16_t timeOutMillis);</code></td>
<td style="text-align: left;"><strong>设置</strong> I²C
总线<strong>超时时间</strong>（毫秒）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setTimeOut(uint16_t timeOutMillis);</code></td>
<td style="text-align: left;"><strong>获取</strong> I²C
总线<strong>超时时间</strong>（毫秒）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>size_t write(const uint8_t *, size_t);</code></td>
<td style="text-align: left;">将数据写入到总线缓冲区，返回值为写入数据的大小。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool end();</code></td>
<td style="text-align: left;">完成 I²C
通信并且释放之前所有被分配的外设资源。</td>
</tr>
</tbody>
</table>
<p><strong>Arduino-ESP32</strong> 当中的 I²C
总线可以分别运行于<strong>主设备</strong>（I²C Master
Mode）和<strong>从设备</strong>（I²C Slave
Mode）两种不同的工作模式：</p>
<p><strong>I²C
主设备模式</strong>：该模式用于向<strong>从设备</strong>发起通信，由<strong>主设备</strong>发出时钟信号，并且负责发起与<strong>从设备</strong>的通信。</p>
<p><img src="/Project/Arduino-ESP32/8.png"></p>
<p><strong>I²C
从设备模式</strong>：时钟信号依然由<strong>主设备</strong>产生，如果 I²C
地址与<strong>从设备</strong>匹配，那么这个<strong>从设备</strong>就会响应<strong>主设备</strong>。</p>
<p><img src="/Project/Arduino-ESP32/9.png"></p>
<h2 id="i²c-主设备模式">I²C 主设备模式</h2>
<p>下面的表格展示了 I²C
总线工作在<strong>主设备模式</strong>下时所使用到的 API：</p>
<table>
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">I²C 主设备模式 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool begin(int sdaPin, int sclPin, uint32_t frequency)</code></td>
<td style="text-align: left;">指定 I²C 总线的 <code>SDA</code> 和
<code>SCL</code> 引脚，以及通信频率。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void beginTransmission(uint16_t address)</code></td>
<td style="text-align: left;">开始启动与指定 I²C
地址<strong>从设备</strong>的通信。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t endTransmission(bool sendStop);</code></td>
<td style="text-align: left;">将数据写入至缓冲区以后，使用该函数把数据发送给<strong>从设备</strong>，参数
<code>sendStop</code> 用于使能 I²C 总线停止信号。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t requestFrom(uint16_t address, uint8_t size, bool sendStop)</code></td>
<td style="text-align: left;">要求<strong>从设备</strong>向<strong>主设备</strong>发送响应数据。</td>
</tr>
</tbody>
</table>
<p>上述 API 函数的基本使用步骤如下面的列表所示：</p>
<ol type="1">
<li><code>#include "Wire.h"</code>，包含 <code>Wire.h</code>
头文件；</li>
<li><code>Wire.begin()</code>，开始配置 I²C 总线；</li>
<li><code>Wire.beginTransmission(I2C_DEV_ADDR)</code>，指定 I²C
<strong>从设备</strong>地址，开始进行数据传输；</li>
<li><code>Wire.write(x)</code>，把数据写入到缓冲区；</li>
<li><code>Wire.endTransmission(true)</code>，将缓冲区的全部数据写入至<strong>从设备</strong>；</li>
<li><code>Wire.requestFrom(I2C_DEV_ADDR, SIZE)</code>，请求读取指定<strong>从设备</strong>的数据；</li>
<li><code>Wire.readBytes(temp, error)</code>，开始读取<strong>从设备</strong>响应的数据；</li>
</ol>
<p>下面是一个如何在<strong>主设备模式</strong>下使用 I²C
总线的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Address 0x55</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">begin</span>();</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Serial.<span class="built_in">setDebugOutput</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 向从设备写入数据 */</span></span><br><span class="line">  Wire.<span class="built_in">beginTransmission</span>(I2C_Address);</span><br><span class="line">  Wire.<span class="built_in">printf</span>(<span class="string">&quot;Hello UinIO.com! %u&quot;</span>, i++); <span class="comment">// 通过 I²C 总线发送数据</span></span><br><span class="line">  <span class="type">uint8_t</span> error = Wire.<span class="built_in">endTransmission</span>(<span class="literal">true</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;endTransmission: %u\n&quot;</span>, error);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取从设备 16 字节的响应数据 */</span></span><br><span class="line">  <span class="type">uint8_t</span> bytesReceived = Wire.<span class="built_in">requestFrom</span>(I2C_Address, <span class="number">16</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;requestFrom: %u\n&quot;</span>, bytesReceived);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果接收到的字节数据大于 0 */</span></span><br><span class="line">  <span class="keyword">if</span>((<span class="type">bool</span>)bytesReceived)&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp[bytesReceived];</span><br><span class="line">    Wire.<span class="built_in">readBytes</span>(temp, bytesReceived);</span><br><span class="line">    <span class="built_in">log_print_buf</span>(temp, bytesReceived);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="i²c-从设备模式">I²C 从设备模式</h2>
<p>下面的表格展示了 I²C
总线工作在<strong>从设备模式</strong>下时所使用到的 API：</p>
<table>
<colgroup>
<col style="width: 51%">
<col style="width: 48%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">I²C 从设备模式 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool Wire.begin(uint8_t addr, int sdaPin, int sclPin, uint32_t frequency)</code></td>
<td style="text-align: left;">在<strong>从设备</strong>模式下，必须通过传递<strong>从设备</strong>的地址来调用
<code>begin()</code> 函数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void onReceive( void (*)(int) )</code></td>
<td style="text-align: left;">定义<strong>从设备</strong>接收<strong>主设备</strong>数据的回调函数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void onRequest( void (*)(void) )</code></td>
<td style="text-align: left;">定义<strong>从设备</strong>请求<strong>主设备</strong>数据的回调函数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>size_t slaveWrite(const uint8_t *, size_t)</code></td>
<td style="text-align: left;">接收到响应数据之前，该函数用于向<strong>从设备</strong>的缓冲区写入数据。</td>
</tr>
</tbody>
</table>
<p>上述 API 函数的基本使用步骤如下面的列表所示：</p>
<ol type="1">
<li><code>#include "Wire.h"</code>，包含 <code>Wire.h</code>
头文件；</li>
<li><code>Wire.onReceive(onReceive)</code> 和
<code>Wire.onRequest(onRequest)</code>，创建两个回调函数来<strong>接收</strong>或者<strong>请求</strong>主设备的数据；</li>
<li><code>Wire.begin((uint8_t)I2C_DEV_ADDR);</code>，使用指定的地址配置
I²C 总线；</li>
<li><code>Wire.slaveWrite((uint8_t *)message, strlen(message));</code>，预先向<strong>从设备</strong>的缓冲区写入数据；</li>
</ol>
<p>下面是一个如何在<strong>从设备工模式</strong>下使用 I²C
总线的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DEV_ADDR 0x55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Wire.<span class="built_in">print</span>(i++);</span><br><span class="line">  Wire.<span class="built_in">print</span>(<span class="string">&quot; Packets.&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;onRequest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onReceive</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;onReceive[%d]: &quot;</span>, len);</span><br><span class="line">  <span class="comment">/* 判断是否存在可用的数据 */</span></span><br><span class="line">  <span class="keyword">while</span>(Wire.<span class="built_in">available</span>())&#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(Wire.<span class="built_in">read</span>()); <span class="comment">// 读取并且打印 I²C 总线数据到串口</span></span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Serial.<span class="built_in">setDebugOutput</span>(<span class="literal">true</span>);</span><br><span class="line">  Wire.<span class="built_in">onReceive</span>(onReceive);</span><br><span class="line">  Wire.<span class="built_in">onRequest</span>(onRequest);</span><br><span class="line">  Wire.<span class="built_in">begin</span>((<span class="type">uint8_t</span>)I2C_DEV_ADDR); <span class="comment">// 将从设备注册到 I²C 总线</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IDF_TARGET_ESP32</span></span><br><span class="line">  <span class="type">char</span> message[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(message, <span class="number">64</span>, <span class="string">&quot;%u Packets.&quot;</span>, i++);</span><br><span class="line">  Wire.<span class="built_in">slaveWrite</span>((<span class="type">uint8_t</span> *)message, <span class="built_in">strlen</span>(message));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主从设备通信实例">主从设备通信实例</h2>
<p>接下来，以 <strong>UINIO-MCU-ESP32S3</strong> 作为主设备，而
<strong>UINIO-MCU-ESP32C3</strong> 作为从设备（I²C 地址为
<code>55</code>），两者的 <code>SDA</code> 和 <code>SCK</code>
都分别指定为为 <code>GPIO5</code> 和 <code>GPIO6</code>，并且在从设备的
<code>GPIO8</code> 上面连接一枚 LED：</p>
<p><img src="/Project/Arduino-ESP32/10.png"></p>
<p><strong>UINIO-MCU-ESP32S3</strong> 作为主设备，每间隔 2
秒就会向从设备 <strong>UINIO-MCU-ESP32C3</strong>
发送一个递增的数值，<strong>从设备</strong>接收到<strong>主设备</strong>的数据之后
LED 就会闪烁 0.5 秒，并且在收到的数值后面添加 <code>已经被接收</code>
字样，然后返回给<strong>主设备</strong>打印至串口，具体的示例代码如下面所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UINIO-MCU-ESP32S3 主设备程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">1</span>;        <span class="comment">// 发送给从设备的数值</span></span><br><span class="line"><span class="type">int</span> address = <span class="number">55</span>;      <span class="comment">// 从设备 I²C 地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 设置 SDA 为 GPIO5，而 SCK 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将主设备添加至 I²C 总线 */</span></span><br><span class="line">  <span class="keyword">if</span> (Wire.<span class="built_in">begin</span>()) &#123;  <span class="comment">//</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;加入 I²C 总线成功&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;加入 I²C 总线失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 向从设备发送数据 */</span></span><br><span class="line">  <span class="type">char</span> data[<span class="number">32</span>];</span><br><span class="line">  <span class="built_in">itoa</span>(number++, data, <span class="number">10</span>);  <span class="comment">// 将整型数值 number 转换为字符串 data</span></span><br><span class="line"></span><br><span class="line">  Wire.<span class="built_in">beginTransmission</span>(address);      <span class="comment">// 开始向指定的从设备传输数据</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(data);                     <span class="comment">// 开始写入 number 数值字符串</span></span><br><span class="line">  <span class="type">int</span> result = Wire.<span class="built_in">endTransmission</span>();  <span class="comment">// 结束数据传输</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断传输是否出现错误 */</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;传输错误：%d\r\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">// 如果传输状态不为 0，那么就无需再执行后续的数据接收步骤，直接返回结束</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);   <span class="comment">// 延时 100 毫秒，给从设备处理并且响应数据留出足够时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接收从设备发送的数据 */</span></span><br><span class="line">  <span class="type">int</span> length = Wire.<span class="built_in">requestFrom</span>(address, <span class="number">32</span>);  <span class="comment">// 发起对于从设备数据的请求，最多不超过 32 字节数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果接收到了数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;主设备接收的数据大小：&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(length);      <span class="comment">// 打印接收到的数据大小</span></span><br><span class="line"></span><br><span class="line">    Wire.<span class="built_in">readBytes</span>(data, <span class="number">32</span>);    <span class="comment">// 读取接收缓冲区的数据</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(data);        <span class="comment">// 打印接收缓冲区的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把从设备发送回来的数据，以 16 进制格式打印出来 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; <span class="number">32</span>; index++) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;%2X, &quot;</span>, data[index]);</span><br><span class="line">      <span class="keyword">if</span> (index % <span class="number">8</span> == <span class="number">7</span>) &#123;</span><br><span class="line">        Serial.<span class="built_in">println</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  主设备接收的数据大小：32</span></span><br><span class="line"><span class="comment">  5674 已经被接收</span></span><br><span class="line"><span class="comment">  35, 36, 37, 34, 20, E5, B7, B2,</span></span><br><span class="line"><span class="comment">  E7, BB, 8F, E8, A2, AB, E6, 8E,</span></span><br><span class="line"><span class="comment">  A5, E6, 94, B6,  0,  0,  0,  0,</span></span><br><span class="line"><span class="comment">   0,  0,  0,  0,  0,  0,  0,  0,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果<strong>主设备</strong> <code>requestFrom()</code> 所指定的
<code>quantity</code>
参数的数据量，大于<strong>从设备</strong>发送过来的数据量，那么多出的空间将会由
<code>0xff</code> 进行填充。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UINIO-MCU-ESP32C3 从设备程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">8</span>;  <span class="comment">// 指定 LED 引脚</span></span><br><span class="line"><span class="type">int</span> address = <span class="number">55</span>; <span class="comment">// 从设备 I²C 地址</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">32</span>];  <span class="comment">// 数据接收缓冲区</span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数，参数 length 表示主机发送过来的数据量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onReceive</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> size = Wire.<span class="built_in">readBytes</span>(buffer, <span class="number">32</span>); <span class="comment">// 读取主设备发送过来的数据到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      buffer[size] = <span class="number">0</span>;                    <span class="comment">// 将缓冲区数据转换为以结束符 0 结尾的字符串</span></span><br><span class="line">      <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);         <span class="comment">// 点亮 LED</span></span><br><span class="line">      timer.<span class="built_in">setTimeout</span>([]() &#123;</span><br><span class="line">        <span class="built_in">digitalWrite</span>(LED_Pin, LOW);        <span class="comment">// 500 毫秒以后熄灭 LED</span></span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向主设备发送数据的回调函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">strcat</span>(buffer, <span class="string">&quot; 已经被接收&quot;</span>);  <span class="comment">// 在主设备的数据结尾添加字符串 OK</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(buffer);            <span class="comment">// 将数据发送回主设备</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(<span class="number">0</span>);                 <span class="comment">// 发送字符串结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  Wire.<span class="built_in">onReceive</span>(onReceive);</span><br><span class="line">  Wire.<span class="built_in">onRequest</span>(onRequest);</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);   <span class="comment">// 设置 SDA 为 GPIO5，而 SCK 为 GPIO6</span></span><br><span class="line">  Wire.<span class="built_in">begin</span>(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>();      <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pcf8574-驱动-1602-液晶屏">PCF8574 驱动 1602 液晶屏</h1>
<p><strong>1602 字符型液晶显示屏</strong>，一共可以显示 2
行内容，每一行可以显示 16
个字符，屏幕驱动芯片采用了<strong>日立</strong>的
<strong>HD44780</strong>，由于该屏幕在使用时需要占用大量 GPIO
引脚。所以需要借助德州仪器的 <strong>PCF8574</strong> 八位 GPIO
扩展器（工作电压介于 <code>2.5V ~ 5.5V</code> 范围），将其转换为两线制的
I²C 总线协议。</p>
<p><img src="/Project/Arduino-ESP32/11.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>PCF8574</strong> 的 I²C 地址默认为
<code>0x27</code>，可以通过 <code>0Ω</code> 电阻调整
<strong>PCF8574</strong> 模组
<code>A0</code>、<code>A1</code>、<code>A2</code> 位置的通断来修改其 I²C
地址。除此之外，还可以通过 <strong>PCF8574</strong>
模组上面的电位器，调整 1602 液晶显示屏的对比度。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/mrkaleArduinoLib/LiquidCrystal_I2C"><strong>LiquidCrystal_I2C</strong></a>
是一款兼容 <strong>HD44780</strong> 和 <strong>PCF8574</strong> 的 LCD
屏幕驱动库，使用时需要将其工程 <code>src</code> 目录下的
<code>LiquidCrystal_I2C.cpp</code> 和 <code>LiquidCrystal_I2C.h</code>
文件拷贝至 <strong>Arduino IDE</strong> 的草图根目录，然后通过
<code>#include "LiquidCrystal_I2C.h"</code> 语句将其包含至 Arduino
草图源文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LiquidCrystal_I2C <span class="title">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">16</span>, <span class="number">2</span>)</span></span>;     <span class="comment">// I²C 地址为 0x27，LCD 屏幕为 16 列 2 行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);                   <span class="comment">// 配置 I²C 总线的 SDA 为 GPIO5，而 SCL 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  LCD.<span class="built_in">init</span>();                           <span class="comment">// 初始化 LCD</span></span><br><span class="line">  LCD.<span class="built_in">backlight</span>();                      <span class="comment">// 开启 LCD 背光</span></span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Hello UinIO.com&quot;</span>);         <span class="comment">// 光标默认位于第 1 行第 1 列</span></span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">1</span>);                  <span class="comment">// 将光标切换至第 2 行的第 1 列</span></span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Welcome to UinIO.com !&quot;</span>);  <span class="comment">// 字符数超过 16，超出长度的部分不会显示</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将显示内容修改为 Welcome To UinIO.com ! */</span></span><br><span class="line">  <span class="comment">// LCD.setCursor(8, 1);        // 将光标切换至第 2 行的第 8 列</span></span><br><span class="line">  <span class="comment">// LCD.write(&#x27;T&#x27;);             // 把小写字母 t 替换为大写字母 T</span></span><br><span class="line">  <span class="comment">// LCD.setCursor(9, 1);        // 将光标切换至第 2 行的第 9 列</span></span><br><span class="line">  <span class="comment">// LCD.write(&#x27;O&#x27;);             // 把小写字母 o 替换为大写字母 O</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// /* 清除屏幕内容 */</span></span><br><span class="line">  <span class="comment">// LCD.clear();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 滚动字符显示 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    LCD.<span class="built_in">scrollDisplayLeft</span>();  <span class="comment">// 每一次向左滚动 1 个字符</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">500</span>);              <span class="comment">// 延时 0.5 秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：需要将 <strong>PCF8574</strong> 模块上丝印为
<code>SDA</code> 和 <code>SCL</code> 的引脚，分别连接至
<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO5</code> 和
<code>GPIO6</code> 引脚。</p>
</blockquote>
<h1 id="外部中断-自旋锁">外部中断 &amp; 自旋锁</h1>
<p><strong>中断</strong>（Interrupt）是指计算机运行过程当中，如果出现某些意外情况需要干预时，程序能够自动停止当前正在运行的代码，转而处理这个新出现的情况，处理完毕之后再返回之前的程序继续执行。在
<strong>Arduino-ESP32</strong>
当中使用外部中断时，需要注意到以下情况：</p>
<ul>
<li><code>delay()</code>
函数依赖于中断，在中断服务程序当中无法调用；</li>
<li><code>micros()</code> 函数刚开始会正常工作，但是可能会在
<code>1 ~ 2</code> 毫秒之后出现异常行为；</li>
<li><code>millis()</code>
函数依赖于中断计数器，其返回值在中断服务程序当中不会增加；</li>
<li><code>delayMicroseconds()</code>
并不会使用到中断计数器，因而能够在中断服务程序当中正常工作；</li>
</ul>
<p><strong>ESP32-Arduino</strong>
里的<strong>中断服务程序</strong>（ISR， Interrupt Service
Routines）是一种没有<strong>参数</strong>和<strong>返回值</strong>的特殊函数（如果代码中同时使用到多个中断服务程序，那么它们将会按照优先级的顺序进行执行），<strong>ESP32-Arduino</strong>
库支持以如下方式，在指定的引脚上面启用或者关闭外部中断服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(pin), ISR, mode)  <span class="comment">// 开启中断，并且添加中断服务程序</span></span><br><span class="line"><span class="built_in">detachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(pin))             <span class="comment">// 关闭中断</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pin</code>: 发生外部中断的 GPIO 引脚编号；</li>
<li><code>ISR</code>:
发生外部中断时候，自动调用的中断服务函数（无参数，无返回值）；</li>
<li><code>mode</code>: 中断触发方式，取值可以为
<strong>LOW</strong>（低电平触发）、<strong>CHANGE</strong>（状态变化触发）、<strong>RISING</strong>（上升沿触发）、<strong>FALLING</strong>（下降沿触发）四个常量当中的一个；</li>
</ul>
<p>接下来使用中断服务程序，完成一个当按键按下的时候，LED
发光二极管熄灭，而在按键弹起时 LED 点亮的程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> byte LED = <span class="number">5</span>;     <span class="comment">// LED 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> byte Button = <span class="number">6</span>;  <span class="comment">// BUTTON 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">switchPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 当 BUTTON 对应的 GPIO 引脚呈现高电平状态*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(BUTTON) == HIGH) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED, HIGH);  <span class="comment">// LED 点亮</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED, LOW);   <span class="comment">// LED 熄灭</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED, OUTPUT);           <span class="comment">// 将 LED 对应的 GPIO 引脚设置为输出模式</span></span><br><span class="line">  <span class="built_in">pinMode</span>(BUTTON, INPUT_PULLUP);  <span class="comment">// 将 BUTTON 对应的 GPIO 引脚设置为输入上拉模式</span></span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(BUTTON), switchPressed, CHANGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码只是在中断服务程序里控制 LED
的亮灭状态，如果需要使用一个<strong>全局变量</strong>，在中断服务程序与主程序之间传递数据，那么必须要将其声明为
<code>volatile</code>
类型，从而确保该全局变量总是被正确的更新，例如下面代码当中的
<code>number</code> 变量就使用了 <code>volatile</code>
关键字进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num = number;</span><br><span class="line">  Serial.<span class="built_in">println</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在下面这份示例代码当中，如果程序执行到注释的位置发生了中断，那么变量
<code>number 1</code> 的值将不会得到更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果程序执行到这个位置发生了中断，那么变量 number 1 的值不会被更新</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  Serial.<span class="built_in">println</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要确保 <code>number 1</code>
的值正常更新，就必须短暂的禁用中断。<strong>ESP32-Arduino</strong>
支持手动<strong>使能</strong> <code>interrupts()</code>
和<strong>失能</strong> <code>noInterrupts()</code> 中断服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">noInterrupts</span>();  <span class="comment">// 失能中断</span></span><br><span class="line">  <span class="comment">/* 此处放置临界的时间敏感代码 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">interrupts</span>();    <span class="comment">// 使能中断</span></span><br><span class="line">  <span class="comment">/* 其它代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以修改前面的示例代码，通过使用 <code>interrupts()</code> 和
<code>noInterrupts()</code>
函数，使得程序即使执行到注释位置发生中断，也仍然可以确保变量 number1
被正确的更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">noInterrupts</span>();  <span class="comment">// 失能中断</span></span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="comment">/******</span></span><br><span class="line"><span class="comment">    即使程序执行到这个位置发生了中断，依然可以确保变量 number1 会被正确的更新</span></span><br><span class="line"><span class="comment">  ******/</span></span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  <span class="built_in">interrupts</span>();    <span class="comment">// 使能中断</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(num1);</span><br><span class="line">  Serial.<span class="built_in">println</span>(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>
两款微控制器都拥有两个计算核心，即使禁用了当前核心的中断服务，另外一个核心也同样可能访问到<strong>临界区</strong>（访问共用资源的程序片段）的资源，所以就需要在禁用中断的同时，对临界区的资源进行上锁。由
<strong>ESP-IDF</strong> 提供的
<code>portMUX_INITIALIZER_UNLOCKED</code>
<strong>自旋锁</strong>，同样可以应用在 <strong>ESP32-Arduino</strong>
的草图代码当中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IRAM_ATTR <span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(&amp;mux);  <span class="comment">// 中断函数访问临界资源开始</span></span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(&amp;mux);   <span class="comment">// 中断函数访问临界资源结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);      <span class="comment">// 主函数访问临界资源开始</span></span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);       <span class="comment">// 主函数访问临界资源结束</span></span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(num1);</span><br><span class="line">  Serial.<span class="built_in">println</span>(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述代码当中的 <code>IRAM_ATTR</code>
关键字，同样是由 <strong>ESP-IDF</strong>
所提供，用于把这段代码保存至芯片内部的
RAM（<strong>IRAM</strong>）里面（否则放置到
Flash），从而提高中断服务程序的响应速度，建议
<strong>ESP32-Arduino</strong>
的中断服务程序都使用该关键字进行声明。</p>
</blockquote>
<h1 id="测量-pwm-的频率-占空比">测量 PWM 的频率 &amp; 占空比</h1>
<p>本示例将会基于 <strong>UINIO-MCU-ESP32</strong>
实现一个频率与占空比的测量功能。首先，需要开启指定 GPIO
引脚的外部中断，当每一次触发中断的时候，都记录下信号<strong>上升沿</strong>与<strong>下降沿</strong>发生的时间（单位为<code>微秒</code>）。然后，在中断服务程序里使用
<code>digitalRead()</code>
函数，判断当前属于高电平还是低电平。最后，记录前一次<strong>上升沿</strong>、<strong>下降沿</strong>产生的时间，并且在下一个<strong>上升沿</strong>中断发生时进行如下一系列计算：</p>
<ul>
<li><strong>脉冲宽度</strong>：脉冲<strong>高电平</strong>信号的持续时间，即下图中的
<span class="math inline">\(t_4 - t_3\)</span>；</li>
<li><strong>脉冲周期</strong>：两个<strong>相临</strong>脉冲信号之间的时间间隔，即下图里的
<span class="math inline">\(t_7 - t_5\)</span>；</li>
<li><strong>占空比</strong>：一个脉冲周期内，<strong>高电平</strong>信号持续时间占据整个周期时间的比值，即
<span class="math inline">\(\frac{1}{脉冲周期}\)</span>；</li>
<li><strong>脉冲频率</strong>：单位时间内产生的<strong>脉冲个数</strong>，即
<span class="math inline">\(\frac{脉冲宽度}{脉冲周期}\)</span>；</li>
</ul>
<p><img src="/Project/Arduino-ESP32/12.png"></p>
<p>这里同样将 1602 液晶屏 I²C 总线的 <code>SDA</code> 和
<code>SCL</code>，分别连接到 <strong>UINIO-MCU-ESP32</strong> 的
<code>GPIO5</code> 和 <code>GPIO6</code>
引脚，同时把<strong>信号发生器</strong>的输出探头连接至
<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO8</code> 引脚：</p>
<p><img src="/Project/Arduino-ESP32/13.png"></p>
<p>当信号发生器输出频率为 <code>1000Hz</code>，占空比为 <code>50%</code>
的方波信号时，下面的代码就可以使得 <strong>UINIO-MCU-ESP32</strong> 在
1602 屏幕上显示出<strong>频率</strong> <code>Freq: 1000.0</code>
和<strong>占空比</strong> <code>Duty: 0.5</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> PWM_Pin = <span class="number">8</span>;                         <span class="comment">// 输入 PWM 信号的 GPIO 引脚</span></span><br><span class="line"><span class="function">LiquidCrystal_I2C <span class="title">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">16</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> RisingTime = <span class="number">0</span>;   <span class="comment">// 上升沿发生的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> FallingTime = <span class="number">0</span>;  <span class="comment">// 下降沿发生的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面两个变量是 loop() 和 changeISR() 函数都会访问到的临界资源 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> Duty = <span class="number">0</span>;                <span class="comment">// 脉冲信号的占空比</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> Frequency = <span class="number">0</span>;           <span class="comment">// 脉冲信号的频率</span></span><br><span class="line"></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> Now = <span class="built_in">micros</span>();                      <span class="comment">// 每一次发生中断，都记录其发生的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断指定 GPIO 引脚的高低电平状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(PWM_Pin)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中断函数访问临界区变量开始 */</span></span><br><span class="line">    <span class="built_in">portENTER_CRITICAL_ISR</span>(&amp;mux);</span><br><span class="line">    <span class="keyword">auto</span> period = Now - RisingTime;         <span class="comment">// 周期等于当前中断发生的时间减去之前上升沿的时间</span></span><br><span class="line">    Frequency = <span class="number">1e6</span> / (<span class="type">double</span>)period;       <span class="comment">// 因为是以微秒作为单位，所以这里使用 1e6</span></span><br><span class="line">    <span class="keyword">auto</span> width = FallingTime - RisingTime;  <span class="comment">// 脉冲宽度等于上升沿减去下降沿的出现时间</span></span><br><span class="line">    Duty = width / (<span class="type">double</span>)period;          <span class="comment">// 占空比等于脉冲宽度除以周期</span></span><br><span class="line">    <span class="built_in">portEXIT_CRITICAL_ISR</span>(&amp;mux);</span><br><span class="line">    <span class="comment">/* 中断函数访问临界区变量结束 */</span></span><br><span class="line"></span><br><span class="line">    RisingTime = Now;   <span class="comment">// 将本次中断发生的时间，保存为前一次上升沿发生的时间</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FallingTime = Now;  <span class="comment">// 将本次中断发生的时间，保存为前一次下降沿发生的时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 设置 1602 液晶屏的 I²C 总线 */</span></span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 指定 SDA 为 GPIO5，SCL 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 1602 液晶显示屏 */</span></span><br><span class="line">  LCD.<span class="built_in">init</span>();</span><br><span class="line">  LCD.<span class="built_in">backlight</span>();</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Freq: &quot;</span>);</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Duty: &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将输入 PWM 的 GPIO 设置为输入模式，并且绑定至引脚电平发生变化时，就会触发的中断处理函数 */</span></span><br><span class="line">  <span class="built_in">pinMode</span>(PWM_Pin, INPUT);</span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(PWM_Pin), changeISR, CHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 每间隔 1 秒读取频率与占空比的全局变量 */</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 主函数访问临界区变量开始 */</span></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="type">double</span> DutyValue = Duty;</span><br><span class="line">  <span class="type">double</span> FrequencyValue = Frequency;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="comment">/* 主函数访问临界区变量结束 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1602 液晶屏幕显示频率与占空比数值 */</span></span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(FrequencyValue);</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(DutyValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器-timer-信号量-semaphore">定时器 Timer &amp; 信号量
Semaphore</h1>
<p><strong>ESP32-C3</strong> 芯片内置有 2 个 <code>54</code>
位<strong>通用定时器</strong>（具有 <code>16</code>
位<strong>预分频器</strong>和 <code>54</code>
位可自动重载的<strong>向上/向下计数器</strong>）。 而
<strong>ESP32-S3</strong> 则内置有 4 个 <code>54</code>
位<strong>通用定时器</strong>（具有 <code>16</code>
位<strong>预分频器</strong>和 <code>54</code>
位可自动重载的<strong>向上/向下计数器</strong>）。</p>
<p><img src="/Project/Arduino-ESP32/14.png"></p>
<p><strong>ESP32</strong> 的通用定时器以 <strong>APB</strong> 时钟
<code>APB_CLK</code> 作为基本时钟源（该时钟频率由 <code>CPU_CLK</code>
的时钟（即微控制器当前的运行频率）决定，其中 <strong>ESP32-C3</strong>
为 <code>160 MHz</code>，而 <strong>ESP32-S3</strong> 为
<code>240 MHz</code>），而 16 位<strong>预分频器</strong>（取值范围为
<code>1 ~ 65536</code>）的作用就是对 <strong>APB</strong>
时钟进行分频，从而产生<strong>时基计数器时钟</strong>
<code>TB_CLK</code>（每经过 1 个周期向上或者向下进行计数）。</p>
<blockquote>
<p><strong>注意</strong>：所谓<strong>分频</strong>就是将信号频率降低到原来的
<span class="math inline">\(\frac{1}{N}\)</span>，称为 <strong>N
分频</strong>。</p>
</blockquote>
<p>已知 <span class="math inline">\(CPU\_CLK_{C3} = 160MHz\)</span>，而
<span class="math inline">\(CPU\_CLK_{S3} =
240MHz\)</span>，假设每一次计数的时间间隔为 <code>10</code>
微秒，那么所需的频率等于其倒数 <span class="math inline">\(\frac{1}{10
\mu S} = 0.1MHz\)</span>，此时 <strong>ESP32-C3</strong> 和
<strong>ESP32-S3</strong> 的分频系数应当分别被设置为：</p>
<p><span class="math display">\[
\begin{cases}
\frac{CPU\_CLK\_{C3}}{0.1MHz} = \frac{160}{0.1} = 1600 \\
\frac{CPU\_CLK\_{S3}}{0.1MHz} = \frac{240}{0.1} = 2400
\end{cases}
\]</span></p>
<p>换而言之，如果计数周期为 <code>1</code> 微秒，那么
<strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>
的分频系数应当分别被设置为 <code>160</code> 和
<code>240</code>。<strong>Arduino-ESP32</strong>
封装有一系列定时器相关的 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html"><strong>API</strong></a>，它们的基本使用步骤如下面所示：</p>
<ol type="1">
<li>初始化硬件定时器，确定时钟频率以及计数方向；</li>
<li>绑定定时器中断服务程序；</li>
<li>设置定时器的计数值；</li>
<li>开始启动定时器；</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个定时器指针变量 */</span></span><br><span class="line"><span class="type">hw_timer_t</span>* timer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">onTimer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 定时器中断服务程序 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器，将 ESP32-C3 的计数周期设置为 1 微秒 */</span></span><br><span class="line">timer = timerBegin(<span class="number">0</span>, <span class="number">160</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绑定定时器与中断服务程序 */</span></span><br><span class="line">timerAttachInterrupt(timer, onTimer，<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数至 1000000 次的时候触发中断，即每间隔 1 秒触发一次中断 */</span></span><br><span class="line">timerAlarmWrite(timer，<span class="number">1000000</span>，<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启定时器 */</span></span><br><span class="line">timerAlarmEnable(timer);</span><br></pre></td></tr></table></figure>
<p>可以看到在定时器的整个使用过程当中，最为重要的就是定时器初始化函数
<code>timerBegin()</code>。如果定时器初始化成功，那么其返回值为一个
<code>timer</code> 结构体，反之则会返回
<code>NULL</code>。除此之外，该函数的第 1 个参数 <code>num</code>
是<strong>定时器编号</strong>，第 2 个参数 <code>divider</code>
是<strong>定时器分频系数</strong>，第 3 个参数 <code>countUp</code>
则是<strong>定时器计数方向</strong>，更多关于
<strong>Arduino-ESP32</strong> 当中定时器的 API 可以参考下面的表格：</p>
<table>
<colgroup>
<col style="width: 71%">
<col style="width: 28%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>hw_timer_t * timerBegin(uint8_t num, uint16_t divider, bool countUp)</code></td>
<td style="text-align: left;">配置定时器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerEnd(hw_timer_t *timer)</code></td>
<td style="text-align: left;">结束定时器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t timerGetConfig(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器配置；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerSetConfig(hw_timer_t *timer, uint32_t config)</code></td>
<td style="text-align: left;">配置已经初始化的定时器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerAttachInterrupt(hw_timer_t *timer, void (*fn)(void), bool edge)</code></td>
<td style="text-align: left;">添加定时器中断服务程序；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerDetachInterrupt(hw_timer_t *timer)</code></td>
<td style="text-align: left;">拆除定时器中断服务程序；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerStart(hw_timer_t *timer)</code></td>
<td style="text-align: left;">开始定时器计数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerStop(hw_timer_t *timer)</code></td>
<td style="text-align: left;">停止定时器计数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerRestart(hw_timer_t *timer)</code></td>
<td style="text-align: left;">重启定时器计数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerWrite(hw_timer_t *timer, uint64_t val)</code></td>
<td style="text-align: left;">设置定时器的计数值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerSetDivider(hw_timer_t *timer, uint16_t divider)</code></td>
<td style="text-align: left;">设置定时器的分频系数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerSetCountUp(hw_timer_t *timer, bool countUp)</code></td>
<td style="text-align: left;">设置定时器的计数方向；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerSetAutoReload(hw_timer_t *timer, bool autoreload)</code></td>
<td style="text-align: left;">设置定时器计数值的自动重载；</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool timerStarted(hw_timer_t *timer)</code></td>
<td style="text-align: left;">判断定时器是否在运行；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t timerRead(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的计数值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t timerReadMicros(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的计数（微秒）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t timerReadMilis(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的计数（毫秒）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>double timerReadSeconds(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的计数（秒）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint16_t timerGetDivider(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的分频系数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool timerGetCountUp(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的计数方向；</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool timerGetAutoReload(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器计数值的自动重载状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerAlarmEnable(hw_timer_t *timer)</code></td>
<td style="text-align: left;">使能定时器告警事件的生成；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerAlarmDisable(hw_timer_t *timer)</code></td>
<td style="text-align: left;">失能定时器告警事件的生成；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void timerAlarmWrite(hw_timer_t *timer, uint64_t alarm_value, bool autoreload)</code></td>
<td style="text-align: left;">设置定时器的自动加载与告警值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool timerAlarmEnabled(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的告警状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t timerAlarmRead(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的告警值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t timerAlarmReadMicros(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的告警值（微秒）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>double timerAlarmReadSeconds(hw_timer_t *timer)</code></td>
<td style="text-align: left;">获取定时器的告警值（秒）；</td>
</tr>
</tbody>
</table>
<p><strong>信号量</strong>（<strong>Semaphore</strong>
[ˈseməfɔːr]）用于解决并发任务当中的<strong>互斥</strong>与<strong>同步</strong>问题。可以简单的将其理解为一个<strong>队列</strong>（只需要关注该队列当中元素的个数），也可以将其理解为一个整型的全局变量（用于记录信号个数）。而<strong>二值信号量</strong>则表示的是一种只存在两种状态的队列（<code>有信号</code>或者<code>无信号</code>），使用时通过检测信号是否存在，再来决定是否处理相关的任务。相比于全局变量，二值信号量可以等待信号，并且保证操作的原子化，通常应用于中断服务程序与主任务之间的状态同步，其基本使用方法如下面的示例所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISR</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 中断任务</span></span><br><span class="line">  发送信号()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( 接收信号() ) &#123;</span><br><span class="line">    <span class="comment">// 执行处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <strong>Arduino-ESP32</strong> 在底层是基于嵌入式实时操作系统 <a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/"><strong>FreeRTOS</strong></a>
构建，该操作系统提供有一系列<a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/a00113.html">信号量
API</a>，因而在 <strong>Arduino-ESP32</strong>
当中同样可以直接进行调用：</p>
<table>
<colgroup>
<col style="width: 63%">
<col style="width: 36%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>SemaphoreHandle_t xSemaphoreCreateBinary()</code></td>
<td style="text-align: left;">创建一个二进制信号量，并返回一个可以引用该信号量的句柄。</td>
</tr>
<tr>
<td style="text-align: left;"><code>xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait )</code></td>
<td style="text-align: left;">获取信号量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore, signed BaseType_t *pxHigherPriorityTaskWoken)</code></td>
<td style="text-align: left;">在中断服务程序里获取信号量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</code></td>
<td style="text-align: left;">释放信号量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore, signed BaseType_t *pxHigherPriorityTaskWoken)</code></td>
<td style="text-align: left;">在中断服务程序里释放信号量。</td>
</tr>
</tbody>
</table>
<p>在下面的示例代码当中，通过结合使用定时器中断和二值信号量，每间隔
<code>1</code> 秒钟打印中断被触发的次数 <code>Count</code> 以及时间
<code>Time</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> Count = <span class="number">0</span>;                         <span class="comment">// 中断触发的次数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> Time = <span class="number">0</span>;                <span class="comment">// 中断触发的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">hw_timer_t</span>* Timer1 = <span class="literal">NULL</span>;                      <span class="comment">// 定时器 1 全局指针变量</span></span><br><span class="line">portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t timerSemaphore;      <span class="comment">// 声明全局信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器中断服务程序，每间隔 1 秒被执行一次 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">onTimer1</span><span class="params">()</span> &#123;</span><br><span class="line">  portENTER_CRITICAL_ISR(&amp;timerMux);</span><br><span class="line">  Count++;          <span class="comment">// 中断触发次数自增 1</span></span><br><span class="line">  Time = micros();  <span class="comment">// 获取当前微秒时间</span></span><br><span class="line">  portEXIT_CRITICAL_ISR(&amp;timerMux);</span><br><span class="line"></span><br><span class="line">  xSemaphoreGiveFromISR(timerSemaphore, <span class="literal">NULL</span>);   <span class="comment">// 完成中断次数与时间的赋值之后就发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  timerSemaphore = xSemaphoreCreateBinary();     <span class="comment">// 创建二值信号量</span></span><br><span class="line">  Timer1 = timerBegin(<span class="number">0</span>, <span class="number">240</span>, <span class="literal">true</span>);             <span class="comment">// 初始化定时器，分频系数为 240，即每间隔 1 微秒计数一次</span></span><br><span class="line">  timerAttachInterrupt(Timer1, onTimer1, <span class="literal">true</span>);  <span class="comment">// 添加定时器中断服务程序</span></span><br><span class="line">  timerAlarmWrite(Timer1, <span class="number">1000000</span>, <span class="literal">true</span>);        <span class="comment">// 每间隔 1 秒循环触发中断</span></span><br><span class="line">  timerAlarmEnable(Timer1);                      <span class="comment">// 启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 检测二值信号，如果检测到，就会立即执行 */</span></span><br><span class="line">  <span class="keyword">if</span> (xSemaphoreTake(timerSemaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line"></span><br><span class="line">    portENTER_CRITICAL(&amp;timerMux);</span><br><span class="line">    <span class="keyword">auto</span> count = Count;</span><br><span class="line">    <span class="keyword">auto</span> time = Time;</span><br><span class="line">    portEXIT_CRITICAL(&amp;timerMux);</span><br><span class="line"></span><br><span class="line">    Serial.println(count);</span><br><span class="line">    Serial.println(time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="hc-sr04-超声波模组">HC-SR04 超声波模组</h1>
<p>新款的 <strong>HC-SR04</strong> 超声波模组采用了
<strong>RCWL-9206</strong> 作为测距解调芯片，其工作电压范围介于
<code>3V ~ 5.5V</code> 之间，工作电流为
<code>2.2mA ~ 3mA</code>，同时支持
<strong>GPIO</strong>、<strong>UART</strong>、<strong>I²C</strong>
三种通信方式，更多的性能参数可以参考下面的表格：</p>
<p><img src="/Project/Arduino-ESP32/15.png"></p>
<p><strong>HC-SR04</strong>
超声波模组引脚接口的功能定义，如下面的表格所示：</p>
<p><img src="/Project/Arduino-ESP32/16.png"></p>
<p>通过配置模组上的电阻 <span class="math inline">\(R_4\)</span> 和
<span class="math inline">\(R_5\)</span> 可以选择
<strong>HC-SR04</strong> 的引脚通信模式：</p>
<p><img src="/Project/Arduino-ESP32/17.png"></p>
<p>由 <strong>UINIO-MCU-ESP32</strong> 发射一个持续时间至少
<code>10us</code> 的脉冲信号到 <strong>HC-SR04</strong> 的
<code>Trig</code> 引脚；此时 <strong>HC-SR04</strong> 会连续发送出 8 个
<code>40KHz</code> 频率的超声波信号，并且 <strong>HC-SR04</strong> 的
<code>Echo</code> 引脚会切换为高电平；如果超声波信号没有响应，那么
<code>Echo</code> 引脚就会在维持 <code>38ms</code>
的高电平之后，重新切换为低电平状态：</p>
<p><img src="/Project/Arduino-ESP32/18.webp"></p>
<p>如果超声波信号被物体反射，那么 <code>Echo</code>
引脚就会从高电平切换至低电平，从而产生出一个脉冲信号，
这个脉冲的宽度就是超声波从<strong>发射</strong>到被物体<strong>反射</strong>回来的间隔时间，即经过超声波探头与物体之间
<strong>2</strong> 倍距离所耗费的时间：</p>
<p><img src="/Project/Arduino-ESP32/19.webp"></p>
<p>根据超声波在空气当中的传输速度，就可以计算出超声波探头与物体之间的距离（两次测量的间隔时间不能低于
<code>200</code> 毫秒）：</p>
<p><span class="math display">\[
超声波探头与物体之间的距离 = 超声波传输速度 \times
\frac{脉冲宽度时间}{2}
\]</span></p>
<p>由于环境温度会对超声波信号的传输速度造成影响，如果需要更加精确的测量距离，那么就必须把温度的因素纳入考量范围，并且进行相应的温度补偿：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">环境温度</th>
<th style="text-align: center;">超声波典型传输速度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>0℃</code></td>
<td style="text-align: center;"><code>330.45</code> 米每秒</td>
</tr>
<tr>
<td style="text-align: center;"><code>20℃</code></td>
<td style="text-align: center;"><code>342.62</code> 米每秒</td>
</tr>
<tr>
<td style="text-align: center;"><code>40℃</code></td>
<td style="text-align: center;"><code>354.85</code> 米每秒</td>
</tr>
</tbody>
</table>
<p><strong>Arduino</strong> 官方库当中提供的 <a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/pulsein/"><code>pulseIn()</code></a>
函数可以用于读取脉冲信号的持续时间（以微秒为单位），其中参数
<code>pin</code> 是需要用于读取脉冲信号的
<strong>UINIO-MCU-ESP32</strong> 引脚编号，而参数 <code>value</code>
则用于指定脉冲的类型（<strong>高电平脉冲</strong> <code>HIGH</code>
或者<strong>低电平脉冲</strong> <code>LOW</code>），可选的参数
<code>timeout</code> 则用于设置脉冲读取的超时时间（单位为微秒，默认为
<code>1000</code>，即 <code>1</code> 秒钟）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulseIn(pin, value, timeout)</span><br></pre></td></tr></table></figure>
<p>这里把 <strong>UINIO-MCU-ESP32S3</strong> 的 <code>GPIO8</code> 和
<code>GPIO9</code> 分别作为 HC-SR04 超声波模组的 <code>Echo</code> 和
<code>Trig</code> 引脚，然后以 <strong>GPIO</strong>
通信方式，通过上面的 <code>pulseIn()</code> 函数读取 HC-SR04
传感器的数据，并且计算出以<strong>厘米</strong>作为单位的距离值，最后打印到波特率为
<code>115200</code> 的串口上面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">8</span>;  <span class="comment">// 指定 Echo 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">9</span>;  <span class="comment">// 指定 Trig 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  pinMode(Trig_Pin, OUTPUT);</span><br><span class="line">  pinMode(Echo_Pin, INPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 向 Trig 引脚发送 15us 脉冲，发出超声波信号 */</span></span><br><span class="line">  digitalWrite(Trig_Pin, HIGH);</span><br><span class="line">  delayMicroseconds(<span class="number">15</span>);             <span class="comment">// 延时 15 微秒</span></span><br><span class="line">  digitalWrite(Trig_Pin, LOW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取 Echo 引脚高电平脉冲的时间长度 */</span></span><br><span class="line">  <span class="keyword">auto</span> time = pulseIn(Echo_Pin, HIGH);</span><br><span class="line">  <span class="type">double</span> distance = time * <span class="number">0.01715</span>;  <span class="comment">// 根据脉冲时间求解出距离，单位为厘米</span></span><br><span class="line">  Serial.println(distance);</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">200</span>);                        <span class="comment">// 确保两次测量的间隔时间不低于 200 毫秒。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于上述代码当中的 <code>pulseIn()</code> 和 <code>delay()</code>
函数在运行时都是<strong>阻塞式</strong>的，会严重的迟滞其它任务的执行时间，接下来会以<strong>非阻塞式</strong>的中断方式来实现相同功能，有所不同的是，这次会把结果显示到
1602 液晶屏幕上面：</p>
<ol type="1">
<li>首先，需要把外部中断 <code>change</code> 添加至连接到超声波传感器
<code>Echo</code> 的 GPIO 引脚，然后使用硬件定时器每间隔
<code>500</code> 毫秒向超声波模组的 <code>Trig</code> 引脚发送
<code>15</code> 微秒的脉冲，即每 1 秒钟进行两次测量。</li>
<li>然后，在发生上升沿中断的时候，记录下当前时间 <span class="math inline">\(t_1\)</span>（超声波发送出去的时间）；而发生下降沿中断的时候，也记录下当前时间
<span class="math inline">\(t_2\)</span>（接受到超声波信号反射的时间），与此同时发送出一个二值信号量。</li>
<li>最后，当 <code>loop()</code> 函数在接收到信号量之后，根据获取到的
<span class="math inline">\(t_1\)</span> 与 <span class="math inline">\(t_2\)</span>
的数值，就可以计算出物体与超声波探头之间的距离，并且显示在 1602
屏幕上面。</li>
</ol>
<p>接下来，同样把 <strong>UINIO-MCU-ESP32S3</strong> 的
<code>GPIO5</code> 和 <code>GPIO6</code> 引脚，作为 1602 液晶显示屏 I²C
总线的 <code>SDA</code> 和 <code>SCL</code>。而 <code>GPIO8</code> 和
<code>GPIO9</code> 分别作为 HC-SR04 超声波模组的 <code>Echo</code> 和
<code>Trig</code> 引脚：</p>
<p><img src="/Project/Arduino-ESP32/20.png"></p>
<p>下面代码同样是以 <strong>GPIO</strong> 通信方式读取 HC-SR04
传感器的数据，并且以非阻塞式方式计算出以<strong>毫米</strong>作为单位的距离值，最后将该值显示到
1602 液晶屏幕上面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">8</span>;   <span class="comment">// 指定 Echo 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">9</span>;   <span class="comment">// 指定 Trig 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Distance = <span class="number">0</span>;                                 <span class="comment">// 探头与被测物体的间隔距离（单位为毫米）</span></span><br><span class="line"><span class="type">hw_timer_t</span>* Timer1 = <span class="literal">NULL</span>;                        <span class="comment">// 声明一个硬件定时器</span></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> StartTime = <span class="number">0</span>;             <span class="comment">// 超声波开始发射的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> EndTime = <span class="number">0</span>;               <span class="comment">// 接收到超声波反射的时间</span></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t semaphore;             <span class="comment">// 二值信号量</span></span><br><span class="line"></span><br><span class="line">LiquidCrystal_I2C <span class="title function_">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">20</span>, <span class="number">4</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬件定时器中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">TrigerPulse</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(Trig_Pin, HIGH);</span><br><span class="line">  delayMicroseconds(<span class="number">15</span>);              <span class="comment">// 提供 15 微秒的脉冲信号</span></span><br><span class="line">  digitalWrite(Trig_Pin, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo 引脚状态变化中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">EchoChange</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> now = micros();                <span class="comment">// 获取当前微秒时间</span></span><br><span class="line">  <span class="keyword">auto</span> state = digitalRead(Echo_Pin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 访问临界区资源 */</span></span><br><span class="line">  portENTER_CRITICAL_ISR(&amp;mux);</span><br><span class="line">  <span class="comment">/* 如果 Echo 引脚为高电平，表示超声波已经发出 */</span></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    StartTime = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EndTime = now;</span><br><span class="line">  &#125;</span><br><span class="line">  portEXIT_CRITICAL_ISR(&amp;mux);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 Echo 引脚为低电平，表示已经接收到超声波反射 */</span></span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    xSemaphoreGiveFromISR(semaphore, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(Trig_Pin, OUTPUT);</span><br><span class="line">  pinMode(Echo_Pin, INPUT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 1602 液晶屏的 I²C 总线 */</span></span><br><span class="line">  Wire.setPins(<span class="number">5</span>, <span class="number">6</span>);      <span class="comment">// 指定 SDA 为 GPIO5，SCL 为 GPIO6</span></span><br><span class="line">  LCD.init();</span><br><span class="line">  LCD.backlight();         <span class="comment">// 打开 1602 液晶屏背光</span></span><br><span class="line">  LCD.print(<span class="string">&quot;Distance:&quot;</span>);  <span class="comment">// 显示 1602 液晶屏第 1 行内容</span></span><br><span class="line"></span><br><span class="line">  semaphore = xSemaphoreCreateBinary();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 硬件定时器 */</span></span><br><span class="line">  Timer1 = timerBegin(<span class="number">0</span>, <span class="number">240</span>, <span class="literal">true</span>);                <span class="comment">// 把 UINIO-MCU-ESP32S3 分频系数设置为 240，即每 1 微秒进行 1 次计数</span></span><br><span class="line">  timerAttachInterrupt(Timer1, TrigerPulse, <span class="literal">true</span>);  <span class="comment">// 添加硬件定时器中断服务程序</span></span><br><span class="line">  timerAlarmWrite(Timer1, <span class="number">500000</span>, <span class="literal">true</span>);            <span class="comment">// 每间隔 500 微秒触发 1 次</span></span><br><span class="line"></span><br><span class="line">  attachInterrupt(digitalPinToInterrupt(Echo_Pin), EchoChange, CHANGE);  <span class="comment">// 添加 Echo 引脚状态变化中断服务程序</span></span><br><span class="line">  timerAlarmEnable(Timer1);                                              <span class="comment">// 启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断二值信号量 */</span></span><br><span class="line">  <span class="keyword">if</span> (xSemaphoreTake(semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    portENTER_CRITICAL(&amp;mux);</span><br><span class="line">    <span class="keyword">auto</span> time = EndTime - StartTime;  <span class="comment">// 计算出脉冲宽度对应的时间</span></span><br><span class="line">    portEXIT_CRITICAL(&amp;mux);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> distance = time * <span class="number">0.1715</span>;  <span class="comment">// 根据脉冲宽度时间，计算出距离（单位为毫米）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 由于超声波传感器的有效测量距离为 3500 毫米以内，所以这里只处理低于该数值的距离数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">3500</span>) &#123;</span><br><span class="line">      <span class="comment">/* 判断本次计算出的距离，与之前计算的距离是否一致，防止数据刷新过快导致 1602 屏幕闪烁 */</span></span><br><span class="line">      <span class="type">int</span> distance_now = (<span class="type">int</span>)distance;</span><br><span class="line">      <span class="keyword">if</span> (distance_now != Distance) &#123;</span><br><span class="line">        LCD.setCursor(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        LCD.<span class="built_in">printf</span>(<span class="string">&quot;%d mm   &quot;</span>, distance_now);  <span class="comment">// 将距离值显示到 1602 屏幕</span></span><br><span class="line">        Distance = distance_now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="伺服舵机-esp32servo-库">伺服舵机 &amp; ESP32Servo 库</h1>
<p>航模玩家经常使用到的<strong>舵机</strong>，本质上是一种低成本的<strong>伺服电机</strong>（Servomotor）系统。其工作原理是通过内部的控制电路接收
PWM
脉冲宽度调制信号，然后控制内置电机转动，内置电机带动一系列的<strong>减速齿轮</strong>组把扭矩传递至<strong>输出轴</strong>和<strong>舵盘</strong>。<strong>输出轴</strong>会与用于反馈角度位置的<strong>电位器</strong>相互连接，当舵盘转动的时候，同时会带动<strong>电位器</strong>输出一个电压信号，反馈至舵机内部的控制电路，然后控制电路根据其位置决定舵机转动的<code>角度</code>或者<code>速度</code>。</p>
<p><img src="/Project/Arduino-ESP32/21.png"></p>
<p>根据控制电路的不同，可以将舵机划分为<strong>数字舵机</strong>和<strong>模拟舵机</strong>两种类型。而根据旋转角度的不同，也可以将其进一步划分为
<code>180°</code> 舵机和 <code>360°</code> 舵机两种类型：</p>
<ul>
<li><code>180°</code> 舵机：可以通过脉冲宽度调制 PWM
信号控制旋转角度（从 <code>0°</code> 度到 <code>180°</code> 度）。</li>
<li><code>360°</code> 舵机：可以 <code>360°</code>
度转动，只能调节<strong>转动速度</strong>，不能调节<strong>转动角度</strong>。</li>
</ul>
<p>舵机的<strong>控制信号</strong>是一个周期为 <code>20</code> 毫秒的
PWM 信号，其中脉冲宽度介于 <code>0.5 ~ 2.5</code>
毫秒范围之间，与其对应的线性旋转角度为
<code>0° ~ 180°</code>。换而言之，舵机会根据 PWM
信号的脉冲宽度，将输出轴旋转到一个指定的角度上面：</p>
<p><img src="/Project/Arduino-ESP32/22.png"></p>
<p>在接下来的列表当中，分别介绍了舵机非常重要的 4 个性能参数：</p>
<ol type="1">
<li><strong>力矩</strong>：用于表示<strong>力</strong>对物体作用时所产生<strong>转动效应大小</strong>的物理量（即<strong>力</strong>
<code>F</code> 与<strong>力臂</strong> <code>r</code>
的乘积），其单位为<strong>牛顿·米</strong>（<code>N·m</code>）。</li>
<li><strong>失速力矩</strong>：指<strong>转动轴</strong>在被外力锁定的情况下，以目标温升作为约束，可以连续输出力矩的最大值，有时候也将其称为<strong>堵转力矩</strong>（<code>堵转力矩</code>通常高于<code>额定力矩</code>）。该参数的单位为<strong>千克·厘米</strong>（<code>Kg·cm</code>），即舵机发生堵转的时候，<code>1</code>
厘米的力臂所能够提起的最大质量。</li>
<li><strong>动作死区</strong>：该参数用于描述舵机的旋转精度，因为舵机内部的基准电路会产生周期为
<code>20</code> 微秒，脉冲宽度为 <code>1.5</code>
微秒的基准信号。通过内置的比较器，将控制信号与这个基准信号进行比较，从而判断出旋转的角度。但是舵机在实际工作当中，难以<strong>完全精确</strong>的控制角度，而比较器的存在又势必会导致舵机在停止点附近往复振荡，因而就需要舵机的控制电路将这个误差值吸收掉，这就是动作死区。常见小型舵机的死区时间为
<code>5</code> 微秒（对应角度为 <code>0.45°</code>
度），即如果想将舵机旋转 <code>45°</code> 度，其真正的停止位置会介于
<code>45° ± 0.45°</code> 范围之间。</li>
<li><strong>反应转速</strong>：舵机在无负载的情况下，转动
<code>60°</code> 度所需要的时间。</li>
</ol>
<p><img src="/Project/Arduino-ESP32/23.png"></p>
<p>下面的两个表格，分别展示了采用<strong>塑料</strong>齿轮和传动轴的通用型
<strong>SG90</strong>
微型舵机（上图左）的性能参数，以及采用<strong>金属</strong>齿轮和传动轴的通用型
<strong>MG996R</strong> 小型舵机（上图右）的性能参数：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">SG90 舵机性能参数</th>
<th style="text-align: left;">参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>旋转角度</strong></td>
<td style="text-align: left;"><code>180° (± 15°)</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>工作电压</strong></td>
<td style="text-align: left;"><code>4.8 V ~ 6 V</code> (典型值为
<code>5 V</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>空载电流</strong></td>
<td style="text-align: left;"><code>10 mA</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>转动电流</strong></td>
<td style="text-align: left;"><code>100 mA ~ 250 mA</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>堵转电流</strong></td>
<td style="text-align: left;"><code>360 mA</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>失速力矩</strong></td>
<td style="text-align: left;"><code>1.7 Kg·cm</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>转动速度</strong></td>
<td style="text-align: left;"><code>0.12 秒 / 60°</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">MG996R 舵机性能参数</th>
<th style="text-align: left;">参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>旋转角度</strong></td>
<td style="text-align: left;"><code>180° (± 10°)</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>工作电压</strong></td>
<td style="text-align: left;"><code>4.8 V ~ 6 V</code> (典型值为
<code>5 V</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>空载电流</strong></td>
<td style="text-align: left;"><code>10 mA</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>转动电流</strong></td>
<td style="text-align: left;"><code>170 mA ~ 400 mA</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>堵转电流</strong></td>
<td style="text-align: left;"><code>1.3 A ~ 1.5 A</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>失速力矩</strong></td>
<td style="text-align: left;"><code>13 Kg·cm</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>转动速度</strong></td>
<td style="text-align: left;"><code>0.2 秒 / 60°</code></td>
</tr>
</tbody>
</table>
<p><a target="_blank" rel="noopener" href="https://github.com/madhephaestus/ESP32Servo"><strong>ESP32Servo</strong></a>
库实现了 <strong>Arduino</strong> 官方舵机驱动库 <a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/libraries/servo/"><strong>Servo</strong></a>
的全部功能，可以直接在 <strong>Arduino IDE</strong>
的【库管理器】当中搜索安装，其主要 API 如下面的表格所示：</p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 87%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>Servo</code></td>
<td style="text-align: left;">用于操作连接到
<strong>UINIO-MCU-ESP32</strong> 引脚的舵机对象。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int attach(pin, min, max)</code></td>
<td style="text-align: left;">将指定的 GPIO 引脚关联到 1 个 <strong>LEDC
通道</strong>，并且返回通道编号（如果失败返回 <code>0</code>）。其中参数
<code>min</code> 的最小取值为 <code>500</code>（默认值为
<code>544us</code>），而 <code>max</code> 的最大取值为
<code>2500</code>（默认值为 <code>2400us</code>）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void write()</code></td>
<td style="text-align: left;">指定舵机的旋转角度（<code>0°~180°</code>）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void writeMicroseconds()</code></td>
<td style="text-align: left;">以<code>微秒</code>作为单位设置脉冲宽度（必须设置）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int read()</code></td>
<td style="text-align: left;">获取之前写入舵机的<strong>旋转角度</strong>（<code>0°~180°</code>）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int readMicroseconds()</code></td>
<td style="text-align: left;">获取之前写入舵机的<strong>脉冲宽度</strong>（以<code>微秒</code>为单位）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool attached()</code></td>
<td style="text-align: left;">如果舵机对象 <code>Servo</code> 成功绑定至
<strong>UINIO-MCU-ESP32</strong> 的 GPIO 引脚，那么就会返回
<code>true</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void detach()</code></td>
<td style="text-align: left;">停止绑定 <code>Servo</code> 对象到 GPIO
引脚，并且释放对于 LEDC 通道的占用。</td>
</tr>
<tr>
<td style="text-align: left;"><code>setTimerWidth(value)</code></td>
<td style="text-align: left;">设置 PWM 定时器输出的脉冲宽度。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int readTimerWidth()</code></td>
<td style="text-align: left;">获取 PWM 定时器输出的脉冲宽度。</td>
</tr>
</tbody>
</table>
<p>在使用上面表格当中的 <code>void write()</code>
函数指定舵机旋转角度的时候，传入的参数值会遵循如下的自动转换规则：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>&lt; 0</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>0 - 180</code></td>
<td style="text-align: left;"><code>value</code> (以度数为单位)</td>
</tr>
<tr>
<td style="text-align: left;"><code>181 - 499</code></td>
<td style="text-align: left;"><code>180</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>500 - (min-1)</code></td>
<td style="text-align: left;"><code>min</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>min - max</code></td>
<td style="text-align: left;"><code>value</code> (以微秒为单位)</td>
</tr>
<tr>
<td style="text-align: left;"><code>(max + 1) - 2500</code></td>
<td style="text-align: left;"><code>max</code></td>
</tr>
</tbody>
</table>
<p>下面的伪代码简洁的演示了 <strong>ESP32Servo</strong>
库的基本使用步骤，以及相关的重要 API 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo Servo_1;                                <span class="comment">// 声明 Servo 对象</span></span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;                             <span class="comment">// 舵机 0° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;                            <span class="comment">// 舵机 180° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Servo_1_Pin = <span class="number">15</span>;                         <span class="comment">// 声明需要绑定到 Servo 对象的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">ESP32PWM::allocateTimer(<span class="number">1</span>);                   <span class="comment">// 指定生成 PWM 信号所使用的定时器</span></span><br><span class="line">Servo_1.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 指定 PWM 信号的频率</span></span><br><span class="line">Servo_1.attach(Servo_1_Pin, Min_Us, Max_Us);  <span class="comment">// 将 Servo 对象绑定到指定的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">Servo_1.write(postion);                       <span class="comment">// 发出 PWM 信号，让舵机旋转 0° ~ 180° 度</span></span><br><span class="line"></span><br><span class="line">Servo_1.detach();                             <span class="comment">// 停止绑定 Servo 对象到 GPIO 引脚，并且释放对 LEDC 通道的占用</span></span><br></pre></td></tr></table></figure>
<p><strong>ESP32Servo</strong> 库的底层运用了<strong>定时器</strong>和
<strong>LEDC</strong> 来控制 PWM 信号的生成，其中
<strong>ESP32-C3</strong> 拥有 4 个<strong>定时器</strong>与 6 个独立的
<strong>PWM 通道</strong>，而 <strong>ESP32-S3</strong> 同样拥有 4
个<strong>定时器</strong>以及 8 个独立的 <strong>PWM
通道</strong>，具体可以参见下面的示意图：</p>
<p><img src="/Project/Arduino-ESP32/24.png"></p>
<p>舵机通常拥有 <code>PWM</code>、<code>VCC</code>、<code>GND</code>
三路外接引脚，其中 <code>VCC</code> 需要连接到一个独立的 <code>5V</code>
电源（确保工作电流稳定），而舵机的 <code>GND</code> 引脚需要与
<strong>UINIO-MCU-ESP32</strong> 的 <code>GND</code>
形成<strong>共地</strong>连接（作为 PWM 信号的电平基准），除此之外的
<code>PWM</code> 则是属于用来输入 PWM 控制信号的引脚：</p>
<p><img src="/Project/Arduino-ESP32/25.png"></p>
<p>例如 <strong>SG90</strong> 和 <strong>MG996R</strong>
型舵机的<strong>黄/橙色</strong>、<strong>红色</strong>、<strong>棕色</strong>杜邦线，就分别对应着舵机的
<code>PWM</code>、<code>VCC</code>、<code>GND</code> 引脚。接下来，通过
<strong>UINIO-MCU-ESP32</strong> 控制两个 <strong>SG90</strong>
微型舵机，分别将两个舵机的 <code>PWM</code> 信号线连接至
<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO9</code> 和
<code>GPIO10</code> 引脚：</p>
<p><img src="/Project/Arduino-ESP32/26.png"></p>
<p>下面的这份示例代码，可以使得两个 <strong>SG90</strong> 微型舵机分别从
<code>0°</code> 旋转到 <code>180°</code> 度，以及从 <code>180°</code>
旋转到 <code>0°</code> 度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明 Servo 对象 */</span></span><br><span class="line">Servo Servo_1;</span><br><span class="line">Servo Servo_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要绑定到 Servo 对象的 GPIO 引脚 */</span></span><br><span class="line"><span class="type">int</span> Servo_1_Pin = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> Servo_2_Pin = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;   <span class="comment">// 舵机 0° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;  <span class="comment">// 舵机 180° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Postion = <span class="number">-1</span>;   <span class="comment">// 声明舵机位置变量</span></span><br><span class="line"><span class="type">bool</span> UP = <span class="literal">true</span>;     <span class="comment">// 用于判断 Postion 变量是向上还是向下进行计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  ESP32PWM::allocateTimer(<span class="number">1</span>);                   <span class="comment">// 指定使用 1 号定时器生成 PWM 信号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置舵机 1 的 PWM 控制信号 */</span></span><br><span class="line">  Servo_1.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 设置 PWM 信号频率为 50 Hz</span></span><br><span class="line">  Servo_1.attach(Servo_1_Pin, Min_Us, Max_Us);  <span class="comment">// 把 Servo 对象绑定至指定 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置舵机 2 的 PWM 控制信号 */</span></span><br><span class="line">  Servo_2.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 设置 PWM 信号频率为 50 Hz</span></span><br><span class="line">  Servo_2.attach(Servo_2_Pin, Min_Us, Max_Us);  <span class="comment">// 把 Servo 对象绑定至指定 GPIO 引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 基于当前位置判断 Postion 变量是向上还是向下计数 */</span></span><br><span class="line">  <span class="keyword">if</span> (Postion == <span class="number">181</span>) &#123;</span><br><span class="line">    UP = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Postion == <span class="number">-1</span>) &#123;</span><br><span class="line">    UP = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据 UP 变量的计数方向，对 Postion 变量进行加减 1 */</span></span><br><span class="line">  <span class="keyword">if</span> (UP) &#123;</span><br><span class="line">    Postion++;  <span class="comment">// 如果 Postion 变量是向上计数，那么每次执行角度就加 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Postion--;  <span class="comment">// 如果 Postion 变量是向下计数，那么每次执行角度就减 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Servo_1.write(Postion);        <span class="comment">// 让舵机 1 从 0° 旋转到 180° 度</span></span><br><span class="line">  Servo_2.write(<span class="number">180</span> - Postion);  <span class="comment">// 让舵机 2 从 180° 旋转到 0° 度</span></span><br><span class="line"></span><br><span class="line">  delay(<span class="number">15</span>);  <span class="comment">// 每间隔 15 毫秒执行一次 loop 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：由于 <strong>UINIO-MCU-ESP32C3</strong>
采用了两线制 SPI 的 <strong>DIO</strong>
模式，因而在运行上述示例程序的时候，需要将 <strong>Arduino IDE</strong>
的 【Flash Mode】设置为 <code>DIO</code>
模式，否则会导致舵机程序无法正常工作。除此之外，因为
<strong>UINIO-MCU-ESP32C3</strong> 的第
<code>GPIO11</code>、<code>GPIO12</code>、<code>GPIO13</code>
引脚已经被用作 Flash 的 SPI 电源和信号引脚，所以无法用于控制舵机。</p>
</blockquote>
<h1 id="由多份源文件组成的草图工程">由多份源文件组成的草图工程</h1>
<p>本节内容将会综合运用之前介绍过的 <strong>SG90</strong> 舵机和
<strong>HC-SR04</strong> 超声波模组，基于
<strong>UINIO-MCU-ESP32S3</strong> 实现一个能够自动打开盒盖的
<code>UINIO-Auto-Box</code>
智能收纳盒子项目，这里假设盒盖关闭时候舵机的角度为 <code>0°</code>
度，而盒盖打开时候舵机的角度为 <code>90°</code>
度。当用手遮挡住超声波探头的时候，舵机旋转 <code>90°</code>
度打开盒盖。而当手离开之后，舵机就会回到 <code>0°</code>
度位置，表示已经自动关闭盒盖。</p>
<p><img src="/Project/Arduino-ESP32/27.png"></p>
<ul>
<li>把 <strong>SG90</strong> 舵机的 <code>VCC</code> 引脚连接到
<strong>UINIO-MCU-ESP32S3</strong> 的 <code>5V</code> 引脚，而
<code>PWM</code> 引脚连接到 <code>GPIO7</code> 引脚，除此之外两者的
<code>GND</code> 相互连接形成共地关系。</li>
<li>把 <strong>HC-SR04</strong> 舵机的 <code>VCC</code> 引脚连接到
<strong>UINIO-MCU-ESP32S3</strong> 的 <code>3V3</code> 引脚，而
<code>Trig</code> 引脚连接至 <code>GPIO6</code>，<code>Echo</code>
引脚连接至 <code>GPIO5</code>，同样 <code>GND</code>
相互连接形成共地关系。</li>
</ul>
<p>打开 <strong>Arduino IDE</strong> 新建一个名为
<code>UINIO-Auto-Box</code> 的草图工程，其主程序会被自动命名为
<code>UINIO-Auto-Box.ino</code>，然后手动添加<strong>超声波传感器</strong>相关的
<code>Sonar.h</code> 与 <code>Sonar.cpp</code>
源文件，<strong>盒盖</strong>控制相关的 <code>Cover.h</code> 与
<code>Cover.cpp</code> 源文件，以及<strong>舵机</strong>控制相关的
<code>Servo.h</code> 与 <code>Servo.cpp</code>
源文件，最后生成的工程结构如下面所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspace\UINIO-Auto-Box</span><br><span class="line">λ <span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 1458  7月 25 17:37 Cover.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  394  7月 25 17:37 Cover.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  492  7月 25 17:37 Servo.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  183  7月 25 17:37 Servo.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 2446  7月 25 17:37 Sonar.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  275  7月 25 17:37 Sonar.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 1459  7月 25 17:37 UINIO-Auto-Box.ino</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>C/C++</strong> 的全局变量可以定义在 <code>.cpp</code>
源文件当中，然后在对应的 <code>.h</code> 头文件当中将其声明为
<code>extern</code> 外部变量。</li>
<li><strong>Arduino IDE</strong> 会自动为 <code>.ino</code>
草图文件添加依赖的头文件，而在 <code>.h</code> 和 <code>.cpp</code>
源文件当中使用<strong>信号量</strong>相关的方法时，就需要手动包含源文件
<code>#include &lt;freertos/FreeRTOS.h&gt;</code> 和
<code>#include &lt;freertos/semphr.h&gt;</code>，并且
<code>#include &lt;freertos/FreeRTOS.h&gt;</code> 必须放置在
<code>&lt;freertos/semphr.h&gt;</code>
之前。而在使用<strong>定时器</strong>相关的方法时，则需要手动包含源文件
<code>#include &lt;esp32-hal-timer.h&gt;</code>。</li>
<li>必须将 <strong>Arduino IDE</strong> 的【工具】设置为
<code>Events Run On: "Core 0"</code> 和
<code>Arduino Runs On: "Core 1"</code>，才能够正确的运行本节的示例程序。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：由于 <strong>UINIO-MCU-ESP32C3</strong> 属于
RISC-V
架构的<strong>单核</strong>微控制器，所以无法正常运行本节的示例程序。如果强行上传示例程序，串口会打印出错误信息：<code>Guru Meditation Error: Core 0 panic'ed (Load access fault). Exception was unhandled.</code>。</p>
</blockquote>
<h2 id="uinio-auto-box.ino">UINIO-Auto-Box.ino</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== 主程序 ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sonar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cover.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义全局自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开盒盖的函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openCover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> send = <span class="literal">false</span>;     <span class="comment">// 用于判断本次是否向舵机发送命令</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="comment">/* 如果 OpenTime 等于 0 表示盒盖没有打开 */</span></span><br><span class="line">  <span class="keyword">if</span> (OpenTime == <span class="number">0</span>) &#123;</span><br><span class="line">    send = <span class="literal">true</span>;         <span class="comment">// 可以向舵机发送打开盒盖的命令</span></span><br><span class="line">  &#125;</span><br><span class="line">  OpenTime = <span class="built_in">micros</span>();   <span class="comment">// 更新当前盒盖打开的时间</span></span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断当前是否需要向舵机发送命令 */</span></span><br><span class="line">  <span class="keyword">if</span> (send) &#123;</span><br><span class="line">    MyServo.<span class="built_in">write</span>(<span class="number">90</span>);  <span class="comment">// 向舵机发送打开盒盖的信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭盒盖的函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closeCover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyServo.<span class="built_in">write</span>(<span class="number">0</span>);      <span class="comment">// 向舵机发送关闭盒盖的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Servo_Init</span>();             <span class="comment">// 初始化舵机</span></span><br><span class="line">  <span class="built_in">Sonar_Init</span>(&amp;mux);         <span class="comment">// 初始化超声波模组</span></span><br><span class="line">  <span class="built_in">Cover_Detect_Init</span>(&amp;mux);  <span class="comment">// 初始化盒盖关闭</span></span><br><span class="line">  <span class="built_in">closeCover</span>();             <span class="comment">// 盒盖初始状态为关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 循环检测打开盒盖的信号 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(Open_Semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开盒盖&quot;</span>);</span><br><span class="line">    <span class="built_in">openCover</span>();           <span class="comment">// 打开盒盖</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环检测关闭盒盖的信号 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(Close_Semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;关闭盒盖&quot;</span>);</span><br><span class="line">    <span class="built_in">closeCover</span>();          <span class="comment">// 关闭盒盖</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cover.h-与-cover.cpp">Cover.h 与 Cover.cpp</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Cover.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/semphr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;esp32-hal-timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头文件中使用 extern 关键字将全局变量声明为可供 UINIO-Auto-Box.ino 主程序调用的外部变量 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> OpenTime;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> SemaphoreHandle_t Close_Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover_Detect_Init</span><span class="params">(portMUX_TYPE* mux)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Cover.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cover.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">hw_timer_t</span>* CoverTimer = <span class="literal">NULL</span>;               <span class="comment">// 关闭盒盖的定时器</span></span><br><span class="line"><span class="type">static</span> portMUX_TYPE* _mux = <span class="literal">NULL</span>;            <span class="comment">// 用于接收全局自旋锁的变量</span></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t Close_Semaphore;  <span class="comment">// 关闭盒盖的信号量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> OpenTime = <span class="number">0</span>;         <span class="comment">// 打开盒盖的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 盒盖关闭检测 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">detectCoverClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(_mux);</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">micros</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果前当时间 now 减去打开盒盖的时间大于或等于 4 秒（即障碍物离开超声波传感器已经 4 秒以上），</span></span><br><span class="line"><span class="comment">     并且 OpenTime 不等于 0（即盒盖处于开启状态）*/</span></span><br><span class="line">  <span class="keyword">if</span> (OpenTime != <span class="number">0</span> &amp;&amp; (now - OpenTime) &gt;= <span class="number">4000000</span>) &#123;</span><br><span class="line">    OpenTime = <span class="number">0</span>;                                  <span class="comment">// 让 OpenTime 变量重新归零</span></span><br><span class="line">    <span class="built_in">xSemaphoreGiveFromISR</span>(Close_Semaphore, <span class="literal">NULL</span>);  <span class="comment">// 发送关闭盒盖的信号</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(_mux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 盒盖开关检测的初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover_Detect_Init</span><span class="params">(portMUX_TYPE* mux)</span> </span>&#123;</span><br><span class="line">  _mux = mux;                                  <span class="comment">// 接收全局自旋锁变量，同步临界区资源访问</span></span><br><span class="line">  Close_Semaphore = <span class="built_in">xSemaphoreCreateBinary</span>();  <span class="comment">// 定义二值信号量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定义硬件定时器，每 500 毫秒执行 1 次盒盖关闭检测程序 */</span></span><br><span class="line">  CoverTimer = <span class="built_in">timerBegin</span>(<span class="number">2</span>, <span class="number">80</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAttachInterrupt</span>(CoverTimer, detectCoverClose, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmWrite</span>(CoverTimer, <span class="number">500000</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmEnable</span>(CoverTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="servo.h-与-servo.cpp">Servo.h 与 Servo.cpp</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Servo.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Servo MyServo;  <span class="comment">// 声明舵机对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Servo_Init</span><span class="params">()</span></span>;     <span class="comment">// 将舵机初始化函数声明为外部变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Servo.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//舵机部分</span></span><br><span class="line">Servo MyServo;</span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;    <span class="comment">// 单位为微秒</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;   <span class="comment">// 单位为微秒</span></span><br><span class="line"><span class="type">int</span> Servo_Pin = <span class="number">7</span>;  <span class="comment">// 声明需要绑定到 Servo 对象的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舵机初始化函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Servo_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ESP32PWM::<span class="built_in">allocateTimer</span>(<span class="number">1</span>);                 <span class="comment">// 指定生成 PWM 信号所使用的定时器</span></span><br><span class="line">  MyServo.<span class="built_in">setPeriodHertz</span>(<span class="number">50</span>);                 <span class="comment">// 指定 PWM 信号的频率为 50Hz</span></span><br><span class="line">  MyServo.<span class="built_in">attach</span>(Servo_Pin, Min_Us, Max_Us);  <span class="comment">// 将 MyServo 对象绑定到指定的 GPIO 引脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sonar.h-与-sonar.cpp">Sonar.h 与 Sonar.cpp</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Sonar.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;esp32-hal-timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/semphr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/FreeRTOS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> SemaphoreHandle_t Open_Semaphore;  <span class="comment">// 将打开盒盖的信号量声明为外部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sonar_Init</span><span class="params">(portMUX_TYPE* mux)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Sonar.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sonar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t Open_Semaphore;  <span class="comment">// 声明打开盒盖的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">5</span>;  <span class="comment">// 指定 Echo 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">6</span>;  <span class="comment">// 指定 Trig 引脚</span></span><br><span class="line"><span class="type">int</span> Distance = <span class="number">0</span>;        <span class="comment">// 距离变量（厘米）</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> portMUX_TYPE* _mux = <span class="literal">NULL</span>;      <span class="comment">// 用于接收全局自旋锁的变量</span></span><br><span class="line"><span class="type">hw_timer_t</span>* SonarTimer = <span class="literal">NULL</span>;         <span class="comment">// 硬件定时器指针变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> StartTime = <span class="number">0</span>;  <span class="comment">// 发出超声波的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> EndTime = <span class="number">0</span>;    <span class="comment">// 接收到超声波的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬件定时器中断服务程序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">Ping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(Trig_Pin, HIGH);</span><br><span class="line">  <span class="built_in">delayMicroseconds</span>(<span class="number">15</span>);               <span class="comment">// 通过延时 15 微秒产生脉冲信号</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Trig_Pin, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo 引脚的中断服务程序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">changeISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">micros</span>();  <span class="comment">//当前时间</span></span><br><span class="line">  <span class="keyword">auto</span> state = <span class="built_in">digitalRead</span>(Echo_Pin);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(_mux);</span><br><span class="line">  <span class="comment">/* 如果 state 变量为低电平，表示刚刚发送出超声波 */</span></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    StartTime = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EndTime = now;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 state 变量为低电平，表示已经收到超声波响应 */</span></span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    <span class="keyword">auto</span> time = EndTime - StartTime;                <span class="comment">// 计算出脉冲宽度时间</span></span><br><span class="line">    <span class="keyword">auto</span> distance = time * <span class="number">0.01715</span>;                 <span class="comment">// 计算出实际距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当检测到的距离小于 10cm 的时候 */</span></span><br><span class="line">    <span class="keyword">if</span> (distance &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="built_in">xSemaphoreGiveFromISR</span>(Open_Semaphore, <span class="literal">NULL</span>);  <span class="comment">// 向主程序发送打开盒盖的信号</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(_mux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化超声波测距模块 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sonar_Init</span><span class="params">(portMUX_TYPE* mux)</span> </span>&#123;</span><br><span class="line">  _mux = mux;                                 <span class="comment">// 接收全局自旋锁变量，同步临界区资源访问</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Trig_Pin, OUTPUT);                  <span class="comment">// 配置 Trig 引脚的工作模式</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Echo_Pin, INPUT);                   <span class="comment">// 配置 Echo 引脚的工作模式</span></span><br><span class="line">  Open_Semaphore = <span class="built_in">xSemaphoreCreateBinary</span>();  <span class="comment">// 创建打开盒盖的信号量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 测距定时器，每 200 毫秒检测一次距离 */</span></span><br><span class="line">  SonarTimer = <span class="built_in">timerBegin</span>(<span class="number">0</span>, <span class="number">80</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAttachInterrupt</span>(SonarTimer, Ping, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmWrite</span>(SonarTimer, <span class="number">200000</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(Echo_Pin), changeISR, CHANGE);  <span class="comment">// 添加 Echo 引脚的中断服务程序</span></span><br><span class="line">  <span class="built_in">timerAlarmEnable</span>(SonarTimer);                                         <span class="comment">// 开始反复进行周期性的检测</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spi-总线主从通信">SPI 总线主从通信</h1>
<h2 id="spi-总线协议原理">SPI 总线协议原理</h2>
<p><strong>串行外设接口</strong>（<strong>SPI</strong>，Serial
Peripheral
Interface）是一种高速、全双工、同步通信总线，其优点在于支持全双工通信（可以同时进行数据的接收与发送），数据传输速率相对
I²C
总线更加迅速，不过其缺点在于没有应答机制（无法判断数据是否准确收发）。</p>
<p>SPI
总线通信协议只允许<strong>一个主设备</strong>，但是可以存在<strong>多个从设备</strong>，其一共拥有着四条物理信号线：</p>
<ul>
<li><strong>SCLK</strong> (Serial
Clock)：用于主设备向从设备传输时钟信号，也被称作 <code>SCK</code>；</li>
<li><strong>MOSI</strong> (Master Output Slave
Input)：<code>主设备</code><strong>输出</strong>，<code>从设备</code><strong>输入</strong>，也称为
<strong>SDO</strong> (Slave Device Output)；</li>
<li><strong>MISO</strong> (Master Input Slave
Output)：<code>主设备</code><strong>输入</strong>，<code>从设备</code><strong>输出</strong>，也称为
<strong>SDI</strong> (Slave Device Input)；</li>
<li><strong>CS</strong> (Chip
Select)：片选信号线，由主设备控制（<strong>低电平</strong>有效），用于选择当前需要通信的从设备，也被称作
<strong>SS</strong> (Slave Select)；</li>
</ul>
<p>除了 <strong>CS/SS</strong> 片选信号线需要每一台 <code>从设备</code>
都与 <code>主设备</code> 进行单独连接之外，其它的
<strong>SCLK/SCK</strong>、<strong>MOSI/SDO</strong>、<strong>MISO/SDI</strong>
三条信号线都分别各自连接到一起：</p>
<p><img src="/Project/Arduino-ESP32/28.png"></p>
<p>SPI
总线上的主设备与从设备都分别内置有<strong>串行移位寄存器</strong>，主设备向该寄存器写入
<code>1</code> 个字节数据，就会进行一次数据传输：</p>
<p><img src="/Project/Arduino-ESP32/29.png"></p>
<ol type="1">
<li>将指定<strong>从设备</strong>的 <code>CS</code>
片选信号线拉低，开始与其进行通信。</li>
<li><strong>主设备</strong>发出 <code>SCLK</code>
时钟信号，开始准备对<strong>从设备</strong>进行读写操作（时钟信号是<code>高电平</code>还是<code>低电平</code>有效，称为<strong>时钟极性</strong>）。</li>
<li><strong>主设备</strong>把待发送的数据写入到<strong>发送缓冲区</strong>，然后通过过<code>串行移位寄存器</code>，将数据从
<code>MOSI</code>
信号线逐位发送给<strong>从设备</strong>；同时<strong>主设备</strong>也可以把
<code>MISO</code>
信号线上待接收的<strong>从设备</strong>数据，同样通过<code>串行移位寄存器</code>逐位移动到<strong>接收缓冲区</strong>。</li>
<li><strong>从设备</strong>也会把自己<code>串行移位寄存器</code>里的内容，通过
<code>MISO</code>
信号线返回给<strong>主设备</strong>；并且同样也可以通过
<code>MOSI</code>
信号线接收<strong>主设备</strong>发送过来的数据（数据是在时钟信号的上升沿还是下降沿处理，称为<strong>时钟相位</strong>）。</li>
<li>每经过 1 个 <code>SCLK</code> 时钟脉冲，SPI 总线上就可以接收或者发送
<code>1bit</code> 数据。</li>
</ol>
<p>在上述 SPI
通信过程当中，<strong>时钟极性</strong>和<strong>时钟相位</strong>是非常重要的两个概念：</p>
<ul>
<li><strong>时钟极性 CPOL</strong>（<strong>C</strong>lock
<strong>Pol</strong>arity）：表示 SPI 总线空闲时，时钟线
<code>SCLK</code> 处于高电平还是低电平；如果
<code>CPOL = 0</code>，那么时钟信号在总线空闲时处于<strong>低电平</strong>；如果
<code>CPOL = 1</code>，那么时钟信号在总线空闲时则处于<strong>高电平</strong>；</li>
<li><strong>时钟相位 CPHA</strong>（<strong>C</strong>lock
<strong>Pha</strong>se）：表示处理 SPI 总线数据采样的时间点，如果
<code>CPHA = 0</code>，那么在时钟信号 <code>SCLK</code> 的第 1
个跳变沿<strong>采样</strong>，第 2
个跳变沿<strong>被改变</strong>；如果
<code>CPHA = 0</code>，那么在时钟信号 SCLK 的第 1
个跳变沿<strong>被改变</strong>，第 2
个跳变沿<strong>采样</strong>；</li>
</ul>
<p><img src="/Project/Arduino-ESP32/30.png"></p>
<blockquote>
<p><strong>注意</strong>：上图当中的<strong>红色竖线</strong>代表<strong>数据采样</strong>（Sampled）的位置，而蓝色代表<strong>数据被改变</strong>（Launched）的位置。</p>
</blockquote>
<p>根据 SPI
总线的<strong>时钟极性</strong>与<strong>时钟相位</strong>，可以划分出四种不同的
SPI
总线通信工作模式，它们分别定义了在时钟信号的哪个边沿<strong>采样信号</strong>，哪个边沿<strong>改变信号</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">模式</th>
<th style="text-align: center;">时钟极性与相位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Mode 0</strong></td>
<td style="text-align: center;"><code>CPOL = 0</code>，<code>CPHA = 0</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mode 1</strong></td>
<td style="text-align: center;"><code>CPOL = 0</code>，<code>CPHA = 1</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mode 2</strong></td>
<td style="text-align: center;"><code>CPOL = 1</code>，<code>CPHA = 0</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mode 3</strong></td>
<td style="text-align: center;"><code>CPOL = 1</code>，<code>CPHA = 1</code></td>
</tr>
</tbody>
</table>
<p><img src="/Project/Arduino-ESP32/31.png"></p>
<p><img src="/Project/Arduino-ESP32/32.png"></p>
<p>除此之外，在 SPI
串行通信过程当中，当前是<strong>最高有效位</strong>（<strong>MSB</strong>，Most
Significant
Bit）优先传输，还是<strong>最低有效位</strong>（<strong>LSB</strong>，Least
Significant
Bit）优先传输是非常重要的两个关键因素，收发双方必须保持传输时序的一致：</p>
<ul>
<li><strong>最低有效位 (LSB) 优先</strong>
：传输一个字节的时候从<strong>低位</strong>先进行传输；</li>
<li><strong>最高有效位 (MSB)
优先</strong>：传输一个字节的时候从<strong>高位</strong>先进行传输；</li>
</ul>
<blockquote>
<p><strong>注意</strong>：SPI 通信涉及的所有 API
函数都不能放置到中断服务程序当中，否则将会导致程序报错。</p>
</blockquote>
<h2 id="esp32c3-esp32s3-的-spi-外设">ESP32C3 &amp; ESP32S3 的 SPI
外设</h2>
<p>由于乐鑫早期的 <strong>ESP32</strong> 芯片（例如
<code>ESP32-D0WD-V3</code>、<code>ESP32-D2WD</code>、<code>ESP32-S0WD</code>、<code>ESP32-U4WDH</code>），分别使用了
<strong>HSPI</strong> 和 <strong>VSPI</strong> 来指代 <code>SPI2</code>
和 <code>SPI3</code> 外设：</p>
<p><img src="/Project/Arduino-ESP32/33.png"></p>
<p>官方的 <strong>Arduino-ESP32</strong>
库出于兼容性考虑延续了这种叫法，它们默认的 GPIO
引脚编号，如下面的表格所示：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%">
<col style="width: 29%">
<col style="width: 29%">
<col style="width: 16%">
<col style="width: 13%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">分类</th>
<th style="text-align: center;">主机输入从机输出引脚</th>
<th style="text-align: center;">主机输出从机输入引脚</th>
<th style="text-align: center;">时钟引脚</th>
<th style="text-align: center;">片选引脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>VSPI</strong></td>
<td style="text-align: center;"><code>MISO = 19</code></td>
<td style="text-align: center;"><code>MOSI = 23</code></td>
<td style="text-align: center;"><code>SCLK = 18</code></td>
<td style="text-align: center;"><code>CS = 5</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>HSPI</strong></td>
<td style="text-align: center;"><code>MISO = 12</code></td>
<td style="text-align: center;"><code>MOSI = 13</code></td>
<td style="text-align: center;"><code>SCLK = 14</code></td>
<td style="text-align: center;"><code>CS = 15</code></td>
</tr>
</tbody>
</table>
<p><strong>ESP32-C3</strong> 芯片集成有
<code>SPI0</code>、<code>SPI1</code>、<code>SPI2</code> 三个 SPI
总线控制器，因为 <code>SPI0</code> 和 <code>SPI1</code> 主要用于访问外部
Flash 以及 PSRAM，所以仅有 <code>SPI2</code> 可以供用户配置使用（即
<strong>GP-SPI2</strong>）。</p>
<p><img src="/Project/Arduino-ESP32/34.png"></p>
<p>而 <strong>ESP32-S3</strong> 芯片集成有
<code>SPI0</code>、<code>SPI1</code>、<code>SPI2</code>、<code>SPI3</code>
四个 SPI 总线控制器，同样因为 <code>SPI0</code> 和 <code>SPI1</code>
被用于访问外部 Flash 以及 PSRAM，所以仅有
<code>SPI2</code>、<code>SPI3</code> 可以供用户配置使用（即
<strong>GP-SPI2</strong> 和 <strong>GP-SPI3</strong>）。</p>
<p><img src="/Project/Arduino-ESP32/35.png"></p>
<p>观察上述 <strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 的
SPI 系统框图可以发现，两者都将 <code>GP-SPI2</code> 称为
<strong>FSPI</strong>（Fast SPI），因而在随后的主设备 SPI
官方库示例代码当中，宏定义里才会出现 <code>#define VSPI FSPI</code>
这样的语句。</p>
<blockquote>
<p><strong>注意</strong>：<strong>ESP32-C3</strong> 与
<strong>ESP32-S3</strong>
工作在<strong>主设备模式下</strong>的时钟频率都可以达到
<code>80 MHz</code>，而工作在<strong>从设备模式</strong>下的时钟频率也可以达到
<code>60 MHz</code>。</p>
</blockquote>
<h2 id="主设备-spi-官方库">主设备 SPI 官方库</h2>
<p><strong>Arduino-ESP32</strong> 封装的 SPI
库已经提供了<strong>主设备</strong> SPI 总线通信的支持，使用时只需要包含
<code>&lt;SPI.h&gt;</code> 头文件即可，相关的方法都已经被封装至
<code>SPIClass</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPIClass *vspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);</span><br><span class="line">SPIClass *hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);</span><br></pre></td></tr></table></figure>
<p><strong>Arduino-ESP32</strong> 内部已经定义有一个
<code>SPIClass SPI = new SPIClass(VSPI)</code>，可以在代码当中直接使用
<code>SPI</code> 对象控制总线通信，下面的伪代码展示了 SPI
主设备通信的基本过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SPIClass *SPI = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);  <span class="comment">// 创建 SPI 对象</span></span><br><span class="line">SPI-&gt;<span class="built_in">begin</span>();                        <span class="comment">// 使用默认引脚初始化 SPI 总线</span></span><br><span class="line"><span class="built_in">pinMode</span>(SPI-&gt;<span class="built_in">pinSS</span>()，OUTPUT);       <span class="comment">// 把片选引脚设置为数字输出模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 SPI 总线工作参数，时钟频率、高低位优先、时钟的极性与相位，然后开始 SPI 数据传输 */</span></span><br><span class="line">SPI-&gt;<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(spiClk，MSBFIRST，SPI_MODE0));</span><br><span class="line"><span class="built_in">digitalWrite</span>(SPI-&gt;<span class="built_in">pinSS</span>(), LOW);     <span class="comment">// 拉低片选信号</span></span><br><span class="line">SPI-&gt;<span class="built_in">transfer</span>(data);                 <span class="comment">// 开始传输数据</span></span><br><span class="line"><span class="built_in">digitalwrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), HIGH);    <span class="comment">// 拉高片选信号</span></span><br><span class="line"><span class="comment">/* 结束 SPI 数据传输 */</span></span><br><span class="line">SPI-&gt;<span class="built_in">endTransaction</span>();</span><br><span class="line"></span><br><span class="line">SPI-&gt;<span class="built_in">end</span>(); <span class="comment">// 释放当前 SPI 总线的资源占用</span></span><br></pre></td></tr></table></figure>
<p>下面的代码详细展示了 <strong>UINIO-MCU-ESP32S3</strong> 使用
<strong>Arduino-ESP32</strong> 库进行 SPI 主设备通信的整个步骤，由于
<strong>UINIO-MCU-ESP32C3</strong> 只存在一个 <code>HSPI</code>
可以供用户配置使用，运行下面代码会导致
<code>'VSPI' was not declared in this scope</code> 错误的出现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALTERNATE_PINS  <span class="comment">// 预处理命令，用于判断是否启用自定义引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果预定义有 ALTERNATE_PINS，就使用自定义引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALTERNATE_PINS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MISO 2</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MOSI 4</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SCLK 0</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SS   33</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MISO 26</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MOSI 27</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SCLK 25</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SS   32</span></span><br><span class="line"><span class="comment">/* 否则就使用 VSPI 和 HSPI 对应的默认引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MISO MISO</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MOSI MOSI</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SCLK SCK</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SS   SS</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MISO 12</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MOSI 13</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SCLK 14</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SS   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自动判断 IDF 编译的目标芯片是 ESP32-S2 还是 ESP32-S3 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI FSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> spiClk = <span class="number">1000000</span>;  <span class="comment">// 定义 SPI 总线的时钟频率为 1 MHz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明 SPIClass 类型的初始化指针 */</span></span><br><span class="line">SPIClass *vspi = <span class="literal">NULL</span>;</span><br><span class="line">SPIClass *hspi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 分别使用 HSPI 和 VSPI 初始化 SPIClass 实例 */</span></span><br><span class="line">  vspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);</span><br><span class="line">  hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALTERNATE_PINS</span></span><br><span class="line">  vspi-&gt;<span class="built_in">begin</span>();  <span class="comment">// 初始化 VSPI，默认引脚 SCLK = 18, MISO = 19, MOSI = 23, SS = 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  vspi-&gt;<span class="built_in">begin</span>(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS);  <span class="comment">// 使用自定义引脚初始化 VSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALTERNATE_PINS</span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>();  <span class="comment">// 初始化 HSPI，默认引脚 SCLK = 14, MISO = 12, MOSI = 13, SS = 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS);  <span class="comment">// 使用自定义引脚初始化 HSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 VSPI 和 HSPI 的片选引脚为数字输出 */</span></span><br><span class="line">  <span class="built_in">pinMode</span>(vspi-&gt;<span class="built_in">pinSS</span>(), OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(hspi-&gt;<span class="built_in">pinSS</span>(), OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 通过 VSPI 和 HSPI 发送测试数据 */</span></span><br><span class="line">  <span class="built_in">spiCommand</span>(vspi, <span class="number">0b01010101</span>);</span><br><span class="line">  <span class="built_in">spiCommand</span>(hspi, <span class="number">0b11001100</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spiCommand</span><span class="params">(SPIClass *spi, byte data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//use it as you would the regular arduino SPI API</span></span><br><span class="line">  spi-&gt;<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(spiClk, MSBFIRST, SPI_MODE0));</span><br><span class="line">  <span class="built_in">digitalWrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), LOW);   <span class="comment">// 拉低片选引脚，准备传输数据</span></span><br><span class="line">  spi-&gt;<span class="built_in">transfer</span>(data);               <span class="comment">// 进行数据传输</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), HIGH);  <span class="comment">// 拉高片选引脚，结束数据传输</span></span><br><span class="line">  spi-&gt;<span class="built_in">endTransaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍一下 <strong>Arduino-ESP32</strong> 当中 SPI
内置的相关方法，首先 <code>SPISettings</code> 类用于配置 SPI
总线通信端口的相关参数（默认的<strong>时钟频率</strong>
<code>clock</code> 为 <code>1MHz</code>、<strong>传输顺序</strong>
<code>bitOrder</code> 为
<code>高位优先</code>、<strong>时钟的极性与相位</strong>模式
<code>dataMode</code> 为 <code>MODE0</code>）：</p>
<table>
<colgroup>
<col style="width: 42%">
<col style="width: 57%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPISettings 构造函数</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)</code></td>
<td style="text-align: left;">SPI
总线配置参数的载体，三个参数的默认值分别为
<code>1000000</code>、<code>SPI_MSBFIRST</code>、<code>SPI_MODE0</code>。</td>
</tr>
</tbody>
</table>
<p>除此之外，<strong>Arduino-ESP32</strong> 库还通过
<code>SPIClass</code> 类，提供了丰富的 SPI
通信相关的工具函数，具体如下面的表格所示：</p>
<table>
<colgroup>
<col style="width: 58%">
<col style="width: 41%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPIClass 中的主要 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void begin(int8_t sck=-1, int8_t miso=-1, int8_t mosi=-1, int8_t ss=-1)</code></td>
<td style="text-align: left;">初始化 SPI 总线。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void end()</code></td>
<td style="text-align: left;">结束 SPI 总线的资源占用。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void beginTransaction(SPISettings settings)</code></td>
<td style="text-align: left;">使用 <code>SPISettings</code>
作为参数，开始进行 SPI 总线通信。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void endTransaction(void)</code></td>
<td style="text-align: left;">结束 SPI 总线通信。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int8_t pinSS()</code></td>
<td style="text-align: left;">返回 SPI 片选引脚。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 44%">
<col style="width: 55%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPIClass 中的 Transfer API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void transfer(void * data, uint32_t size)</code></td>
<td style="text-align: left;">发送 <code>size</code> 个字节的
<code>data</code> 数据，但是并不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t transfer(uint8_t data)</code></td>
<td style="text-align: left;">发送 1 个字节的 <code>data</code>
数据，同时接收 1 个字节的数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint16_t transfer16(uint16_t data)</code></td>
<td style="text-align: left;">发送 2 个字节的 <code>data</code>
数据，同时接收 2 个字节的数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t transfer32(uint32_t data)</code></td>
<td style="text-align: left;">发送 4 个字节的 <code>data</code>
数据，同时接收 4 个字节的数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void transferBytes(const uint8_t * data, uint8_t * out, uint32_t size)</code></td>
<td style="text-align: left;">接收 <code>size</code>
个字节到<strong>读取缓冲区</strong> <code>data</code>，或者发送
<code>size</code> 个字节到<strong>输出缓冲区</strong>
<code>out</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void transferBits(uint32_t data, uint32_t * out, uint8_t bits)</code></td>
<td style="text-align: left;">接收 <code>size</code>
位数据到<strong>读取缓冲区</strong> <code>data</code>，或者发送
<code>size</code> 位数据到<strong>输出缓冲区</strong>
<code>out</code>。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPIClass 中的 Write API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void write(uint8_t data)</code></td>
<td style="text-align: left;">发送 1 个字节的 <code>data</code>
数据，但是不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void write16(uint16_t data)</code></td>
<td style="text-align: left;">发送 2 个字节的 <code>data</code>
数据，但是不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void write32(uint32_t data)</code></td>
<td style="text-align: left;">发送 4 个字节的 <code>data</code>
数据，但是不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void writeBytes(const uint8_t * data, uint32_t size)</code></td>
<td style="text-align: left;">发送 <code>size</code> 个字节的
<code>data</code> 数据，但是不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void writePattern(const uint8_t * data, uint8_t size, uint32_t repeat)</code></td>
<td style="text-align: left;">循环发送 <code>size</code> 个字节的
<code>data</code> 数据 <code>repeat</code> 次，但是不会接收数据。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void writePixels(const void * data, uint32_t size)</code></td>
<td style="text-align: left;">请参考用户目录
<code>USER\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.9\libraries\SPI\src</code>
下面的源码。</td>
</tr>
</tbody>
</table>
<h2 id="从设备-spi-第三方库">从设备 SPI 第三方库</h2>
<p>由于 <strong>Arduino-ESP32</strong> 官方库只支持把
<strong>ESP32</strong> 芯片作为 <strong>SPI
主设备</strong>来使用，并未提供 <strong>SPI 从设备</strong>通信相关的
API，需要在 <strong>Arduino IDE</strong> 当中安装第三方库 <a target="_blank" rel="noopener" href="https://github.com/hideakitai/ESP32SPISlave"><strong>ESP32SPISlave</strong></a>。由于该库目前仅支持诸如
<code>ESP32-D0WD-V3</code>、<code>ESP32-D2WD</code>、<code>ESP32-S0WD</code>、<code>ESP32-U4WDH</code>
等较老型号的 <strong>ESP32</strong> 系列，暂不支持相对较新的
<strong>ESP32-C3</strong> 与 <strong>ESP32-S3</strong> 芯片。如果在
<strong>Arduino IDE</strong>
当中选择以这两款芯片作为主控的开发板，那么就会导致编译错误的出现。所以在接下来的示例当中，都会以乐鑫官方采用
<strong>ESP32-D0WD</strong> 主控的 <strong>ESP32-DevKitC</strong>
开发板作为 SPI 总线从设备：</p>
<p><img src="/Project/Arduino-ESP32/36.png"></p>
<p><strong>ESP32SPISlave</strong> 库可以支持以阻塞式等待的方式访问 SPI
传输事务队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">       HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">       VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 阻塞等待，直至接收到主设备的传输事务 */</span></span><br><span class="line">  slave.<span class="built_in">wait</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果主设备的传输事务已经结束，那么从设备 available() 就会返回传输的结果数量，并且自动更新 spi_slave_rx_buf 接收缓冲区 */</span></span><br><span class="line">  <span class="keyword">while</span> (slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应的，也能够支持以<strong>轮询</strong>的方式访问 SPI
传输事务队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">    HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">    VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(VSPI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 如果当前队列当中没有剩余的传输事务 */</span></span><br><span class="line">  <span class="keyword">if</span> (slave.<span class="built_in">remained</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    slave.<span class="built_in">queue</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);  <span class="comment">// 那么就向队列新添加 1 个事务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果主设备的传输事务已经结束，那么从设备 available() 就会返回传输的结果数量，并且自动更新 spi_slave_rx_buf 接收缓冲区 */</span></span><br><span class="line">  <span class="keyword">while</span> (slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是以<strong>任务</strong>的方式访问 SPI 传输事务队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> CORE_TASK_SPI_SLAVE&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> CORE_TASK_PROCESS_BUFFER&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskHandle_t task_handle_wait_spi = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> TaskHandle_t task_handle_process_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_wait_spi</span><span class="params">(<span class="type">void</span>* pvParameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">ulTaskNotifyTake</span>(pdTRUE, portMAX_DELAY);</span><br><span class="line">    slave.<span class="built_in">wait</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);  <span class="comment">// 阻塞等待，直至接收到主设备的传输事务</span></span><br><span class="line">    <span class="built_in">xTaskNotifyGive</span>(task_handle_process_buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_process_buffer</span><span class="params">(<span class="type">void</span>* pvParameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">ulTaskNotifyTake</span>(pdTRUE, portMAX_DELAY);</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">    <span class="built_in">xTaskNotifyGive</span>(task_handle_wait_spi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">    HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">    VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(task_wait_spi, <span class="string">&quot;task_wait_spi&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_handle_wait_spi, CORE_TASK_SPI_SLAVE);</span><br><span class="line">  <span class="built_in">xTaskNotifyGive</span>(task_handle_wait_spi);</span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(task_process_buffer, <span class="string">&quot;task_process_buffer&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_handle_process_buffer, CORE_TASK_PROCESS_BUFFER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的一系列表格当中，展示了 <strong>ESP32SPISlave</strong>
库当中提供的一系列 API 函数：</p>
<table>
<colgroup>
<col style="width: 70%">
<col style="width: 29%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPI 总线配置 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool begin(const uint8_t spi_bus = HSPI)</code></td>
<td style="text-align: left;">使用默认的 <code>HSPI</code> 或者
<code>VSPI</code> 作为 SPI 通信引脚。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool begin(const uint8_t spi_bus, const int8_t sck,</code><br><code>const int8_t miso, const int8_t mosi, const int8_t ss)</code></td>
<td style="text-align: left;">自定义 SPI 通信引脚。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setDataMode(const uint8_t m)</code></td>
<td style="text-align: left;">设置 SPI 数据模式（SPI
时钟的极性与相位）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setSpiMode(const uint8_t m)</code></td>
<td style="text-align: left;">设置 SPI 工作模式。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setSlaveFlags(const uint32_t flags)</code></td>
<td style="text-align: left;">设置从设备标记。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void setQueueSize(const int n)</code></td>
<td style="text-align: left;">设置队列大小。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool end()</code></td>
<td style="text-align: left;">结束 SPI 传输。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 49%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPI 传输事务 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool wait(uint8_t* rx_buf, const size_t size)</code></td>
<td style="text-align: left;">阻塞式等待传输事务，<strong>只接收不发送</strong>，成功返回
<code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool wait(uint8_t* rx_buf, const uint8_t* tx_buf, const size_t size)</code></td>
<td style="text-align: left;">阻塞式等待传输事务，<strong>即接收也发送</strong>，成功返回
<code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool queue(uint8_t* rx_buf, const size_t size)</code></td>
<td style="text-align: left;">添加传输事务，只接收不发送，成功返回
<code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool queue(uint8_t* rx_buf, const uint8_t* tx_buf, const size_t size)</code></td>
<td style="text-align: left;">添加传输事务，即接收也发送，成功返回
<code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void yield()</code></td>
<td style="text-align: left;">等待主设备处理完毕所有传输事务，如果
<code>yield</code> 完成，则更新全部缓冲区。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 82%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SPI 传输结果信息 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>size_t available() const</code></td>
<td style="text-align: left;">如果主设备的传输事务已经结束，那么从设备的
<code>available()</code> 就会返回传输的结果数量，并且自动更新
<code>spi_slave_rx_buf</code> 接收缓冲区。</td>
</tr>
<tr>
<td style="text-align: left;"><code>size_t remained() const</code></td>
<td style="text-align: left;">判断传输队列当中剩余的事务数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t size() const</code></td>
<td style="text-align: left;">从传输队列当中接收到的字节数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void pop()</code></td>
<td style="text-align: left;">获取从设备接收缓冲区当中的数据。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：SPI 传输涉及的 API
中都以<strong>传输事务</strong>作为基础，当主设备拉低片选线，并且时钟线上发出脉冲信号时，就开始了
1 次全双工的 SPI 传输事务。每一个时钟脉冲都意味着主设备通过
<code>MOSI</code> 线发送 <code>1</code>
个数据位到从设备，并且同时从设备通过 <code>MISO</code> 线返回
<code>1</code>
个数据位。当传输事务结束之后，主设备就会拉高片选线。每一次 SPI
总线传输事务，主设备与从设备所能传输的最大数据量为 <code>64</code>
字节，如果需要传输更大的数据，则必须借助 <strong>DMA</strong>
方式进行。</p>
</blockquote>
<h2 id="主-从设备-spi-通信实例">主 &amp; 从设备 SPI 通信实例</h2>
<p>本小节将会基于 SPI 总线实现
<strong>UINIO-MCU-ESP32S3</strong>（主设备）与
<strong>ESP32-DevKitC</strong>（从设备）之间的相互通信，把两块核心板的
<strong>HSPI</strong>/<strong>SPI2</strong> 按照下图关系相互连接，即
<strong>UINIO-MCU-ESP32S3</strong> 的
<code>SCLK = 21</code>、<code>MISO = 20</code>、<code>MOSI = 19</code>、<code>SS = 18</code>
与 <strong>ESP32-DevKitC</strong> 的
<code>SCLK = 14</code>，<code>MISO = 12</code>，<code>MOSI = 13</code>，<code>SS = 15</code>
一一对应连接。同时两者的 <code>GND</code>
也要连接到一起，从而形成共地连接关系：</p>
<p><img src="/Project/Arduino-ESP32/37.png"></p>
<p>让主设备每间隔 <code>1</code>
秒钟，向从设备发送小写英文字符串，从设备接收之后将其转换为大写形式再返还给主设备，主设备将接收到的大写字符串打印至
<strong>Arduino IDE</strong> 的【串口监视器】。接下来，分别在
<strong>Arduino IDE</strong> 当中新建 3 份草图源文件，它们分别是用于 SPI
主设备的 <code>SPIMaster.ino</code>、从设备（采用阻塞等待处理方式）的
<code>SPISlaveWait.ino</code>、从设备（采用队列处理方式）的
<code>SPISlaveQueue.ino</code>：</p>
<h3 id="spimaster.ino">SPIMaster.ino</h3>
<p>采用 <strong>UINIO-MCU-ESP32S3</strong> 作为 SPI 主设备，基于
<strong>Arduino-ESP32</strong> 官方库提供的 SPI 通信 API
与从设备进行数据交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPIMaster.ino（主设备） ==========*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK 5000000      <span class="comment">// 时钟信号频率，从设备时钟频率最高只能达到 10MHz</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Hspi = <span class="built_in">SPIClass</span>(HSPI);  <span class="comment">// 定义 SPIClass 对象</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> txBuffer[<span class="number">64</span>];        <span class="comment">// 声明发送缓冲区，非 DMA 方式最大传输 64 字节</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer[<span class="number">64</span>];        <span class="comment">// 声明接收缓冲区，非 DMA 方式最大传输 64 字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Hspi.<span class="built_in">begin</span>(<span class="number">21</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>);     <span class="comment">// 使用 GPIO21、GPIO20、GPIO19、GPIO18 初始化 HSPI 控制器</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Hspi.<span class="built_in">pinSS</span>(), OUTPUT);  <span class="comment">// 将 HSPI 的片选信号线设置为数字输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每 1 次循环就是 1 次 SPI 传输事务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> temporary = <span class="number">97</span> + count++ % <span class="number">26</span>;   <span class="comment">// 定义一个字符串，ASCII 码 97 代表小写字母 a（每次都会依次从 a 循环发送至 z）</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(temporary);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(txBuffer, temporary, <span class="number">56</span>);      <span class="comment">// 写入 56 个小写字母到从设备的发送缓冲区</span></span><br><span class="line">  txBuffer[<span class="number">56</span>] = <span class="string">&#x27;~&#x27;</span>;                   <span class="comment">// 在 56 个小写字母的最后再加上 1 条波浪线</span></span><br><span class="line">  <span class="built_in">memset</span>(rxBuffer, <span class="number">0</span>, <span class="number">64</span>);              <span class="comment">// 把接收缓冲区清零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 开始传输事务 */</span></span><br><span class="line">  Hspi.<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(SPI_CLK, MSBFIRST, SPI_MODE0));  <span class="comment">// 配置 SPI 总线参数</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Hspi.<span class="built_in">pinSS</span>(), LOW);                                   <span class="comment">// 拉低片选信号线</span></span><br><span class="line">  Hspi.<span class="built_in">transferBytes</span>(txBuffer, rxBuffer, <span class="number">57</span>);                        <span class="comment">// 主设备向从设备发送 57 字节的数据</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Hspi.<span class="built_in">pinSS</span>(), HIGH);                                  <span class="comment">// 拉高片选信号线</span></span><br><span class="line">  Hspi.<span class="built_in">endTransaction</span>();</span><br><span class="line">  <span class="comment">/* 结束传输事务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 发送数据的同时，也在接收从设备发回的数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">57</span>; i++) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>((<span class="type">char</span>)rxBuffer[i]);  <span class="comment">// 向串口打印接收到的从设备字符数据</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                        <span class="comment">// 延时 1 秒钟之后再重复上述过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spislavewait.ino">SPISlaveWait.ino</h3>
<p>采用 <strong>ESP32-DevKitC</strong> 作为 SPI 从设备，基于
<strong>ESP32SPISlave</strong> 库提供的 <code>wait()</code>
方法，以阻塞等待的方式与主设备进行通信：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPISlaveWait.ino（） ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave Slave;  <span class="comment">// 声明从设备对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义接收与发送的缓冲区最大空间为 64 字节 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">64</span> &#125;;</span><br><span class="line"><span class="type">uint8_t</span> txBuffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> rxBuffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式（时钟极性与相位）</span></span><br><span class="line">  Slave.<span class="built_in">begin</span>(HSPI);             <span class="comment">// 初始化 SPI 总线资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Slave.<span class="built_in">wait</span>(rxBuffer, txBuffer, BUFFER_SIZE);  <span class="comment">// 以阻塞等待的方式处理 SPI 数据</span></span><br><span class="line">  <span class="type">char</span> temporary = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断传输结果数量 */</span></span><br><span class="line">  <span class="keyword">while</span> (Slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> length = Slave.<span class="built_in">size</span>();       <span class="comment">// 获取主设备发送过来的数据长度</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      temporary = rxBuffer[i];</span><br><span class="line">      txBuffer[i] = temporary - <span class="number">32</span>;  <span class="comment">// 把字符的 ASIIC 编码减去 32，从而将其变为大写形式</span></span><br><span class="line">      Serial.<span class="built_in">print</span>(temporary);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">    Slave.<span class="built_in">pop</span>();                     <span class="comment">// 处理完缓冲区数据之后，必须将本次 SPI 传输事务弹出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">starWait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spislavequeue.ino">SPISlaveQueue.ino</h3>
<p>采用 <strong>ESP32-DevKitC</strong> 作为 SPI 从设备，基于
<strong>ESP32SPISlave</strong> 库提供的 <code>queue()</code>
方法与主设备进行通信，由于队列方式只能同时处理 <strong>3</strong> 个 SPI
传输任务。所以从设备需要初始化出 3
个传输任务，然后逐一用于处理数据的收发。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPISlaveQueue.ino ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave Slave;  <span class="comment">// 定义从设备对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ESP32SPISlave 的队列方式只能同时处理 3 个 SPI 传输任务 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">64</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 1 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer0[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer0[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 2 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer1[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer1[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 3 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer2[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer2[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Slave.<span class="built_in">setDataMode</span>(SPI_MODE0);</span><br><span class="line">  Slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 同时启动 3 个 SPI 总线传输任务 */</span></span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer0, txBuffer0, BUFFER_SIZE);</span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer1, txBuffer1, BUFFER_SIZE);</span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer2, txBuffer2, BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理接收缓冲区的数据，然后写入到发送缓冲区 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleBuffer</span><span class="params">(<span class="type">uint8_t</span>* rx_buffer, <span class="type">uint8_t</span>* tx_buffer, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> temporary = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环将接收缓冲区当中的 ASCII 字符编码减去 32 转换为大写，然后再写入至发送缓冲区 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    temporary = rx_buffer[i];</span><br><span class="line">    tx_buffer[i] = temporary - <span class="number">32</span>;</span><br><span class="line">    Serial.<span class="built_in">print</span>(temporary);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> index = <span class="number">0</span>;  <span class="comment">// 处理 SPI 传输任务的缓冲区序号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断当前是否存在传输数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (Slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> length = Slave.<span class="built_in">size</span>();  <span class="comment">// 获取主设备发送过来的数据长度</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断缓冲区队列顺序 */</span></span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">      <span class="comment">/* 处理第 1 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer0, txBuffer0, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer0, txBuffer0, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/* 处理第 2 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer1, txBuffer1, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer1, txBuffer1, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/* 处理第 3 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer2, txBuffer2, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer2, txBuffer2, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = (index + <span class="number">1</span>) % <span class="number">3</span>;  <span class="comment">// 采用取余的方式让 index 从 0 到 2 不断循环</span></span><br><span class="line">    Slave.<span class="built_in">pop</span>();              <span class="comment">// 把本次的 SPI 传输任务弹出处理队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">starQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于-spi-操作-sd-存储卡">基于 SPI 操作 SD 存储卡</h1>
<p>本节内容介绍的这款 <strong>SD 存储卡模组</strong>，可以使得
<strong>UINIO-MCU-ESP32</strong> 通过 SPI 接口以及文件系统读写 SD
存储卡（同时支持普通 <strong>Micro SD</strong> 和高速 <strong>Micro
SDHC</strong> 存储卡）。该款模组还板载有电平转换芯片，可以同时兼容
<code>5V</code> 和 <code>3.3V</code> 规格的电平信号。而自带的
<strong>3.3V 线性稳压器</strong>，也可以使其分别工作于 <code>5V</code>
和 <code>3.3V</code> 电源下。</p>
<p><img src="/Project/Arduino-ESP32/38.png"></p>
<p>这款 <strong>SD 存储卡模组</strong> 一共拥有六个外接引脚，它们分别是
<code>GND</code>，<code>VCC</code>，<code>MISO</code>，<code>MOSI</code>，<code>SCK</code>，<code>CS</code>，具体的引脚排列顺序可以参考下图：</p>
<p><img src="/Project/Arduino-ESP32/39.png"></p>
<h2 id="arduino-esp32-提供的-sd-库">Arduino-ESP32 提供的 SD 库</h2>
<p>笔者目前使用 <strong>Arduino-ESP32</strong> 库的 <code>2.0.11</code>
版本，已经基于 SPI 总线通信，提供了对于 SD
卡操作的支持（可以支持中文文件名，以及 <strong>UTF-8</strong>
编码的文件内容），使用时只需要在 Arduino 草图源文件当中包含
<code>SPI.h</code> 和 <code>SD.h</code> 头文件即可。由于截止到 2023 年 8
月为止，该库依然还处于开发状态，官方并未提供详尽的 API
文档说明，只是提供了一份比较典型的 SD
卡读写示例代码。接下来就基于这份代码，以自定义 SPI
通信引脚的方式，读写一颗文件系统为 <strong>FAT32</strong>，存储容量为
<code>32GB</code> 的 TF 存储卡：</p>
<p><img src="/Project/Arduino-ESP32/40.png"></p>
<p>首先把 <strong>UINIO-MCU-ESP32</strong> 的引脚
<code>SS = GPIO0</code>、<code>SCLK = GPIO1</code>、<code>MOSI = GPIO2</code>、<code>MISO = GPIO3</code>
分别与读卡器模块的
<code>CS</code>、<code>SCK</code>、<code>MOSI</code>、<code>MISO</code>
引脚相互连接，然后再将读卡器模组的 <code>VCC</code> 和 <code>GND</code>
分别接入至 <strong>UINIO-MCU-ESP32</strong> 的 <code>5V</code> 和
<code>GND</code> 电源，最后就可以下载并且运行这份参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SD.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 列出目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *dirname, <span class="type">uint8_t</span> levels)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;列出目录: %s\n&quot;</span>, dirname);</span><br><span class="line"></span><br><span class="line">  File root = fs.<span class="built_in">open</span>(dirname);</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开目录发生错误！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!root.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;这不是一个目录！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  File file = root.<span class="built_in">openNextFile</span>();</span><br><span class="line">  <span class="keyword">while</span> (file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  目录 : &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(file.<span class="built_in">name</span>());</span><br><span class="line">      <span class="keyword">if</span> (levels) &#123;</span><br><span class="line">        <span class="built_in">listDir</span>(fs, file.<span class="built_in">path</span>(), levels - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  文件: &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(file.<span class="built_in">name</span>());</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  尺寸: &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(file.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    file = root.<span class="built_in">openNextFile</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 建立目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;新建目录: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">mkdir</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录建立成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录建立错误！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 移除目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;移除目录: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">rmdir</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录移除成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录移除错误！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 读取目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在读取文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件读取失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;读取到的文件内容: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (file.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(file.<span class="built_in">read</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 写入目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;写入文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path, FILE_WRITE);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件写入失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (file.<span class="built_in">print</span>(message)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件写入失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 向文件末尾追加内容 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">appendFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;追加到文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path, FILE_APPEND);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件追加失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (file.<span class="built_in">print</span>(message)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;内容追加成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;内容追加失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 重命名文件 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">renameFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;重新命名文件 %s 为 %s\n&quot;</span>, path1, path2);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">rename</span>(path1, path2)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件重命名成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件重命名失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 删除文件 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;删除文件: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">remove</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件删除成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件删除失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 测试文件输入输出 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFileIO</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path);</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> buf[<span class="number">512</span>];</span><br><span class="line">  <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> start = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="type">uint32_t</span> end = start;</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    len = file.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> flen = len;</span><br><span class="line">    start = <span class="built_in">millis</span>();</span><br><span class="line">    <span class="keyword">while</span> (len) &#123;</span><br><span class="line">      <span class="type">size_t</span> toRead = len;</span><br><span class="line">      <span class="keyword">if</span> (toRead &gt; <span class="number">512</span>) &#123;</span><br><span class="line">        toRead = <span class="number">512</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      file.<span class="built_in">read</span>(buf, toRead);</span><br><span class="line">      len -= toRead;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">millis</span>() - start;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;读取 %u 字节花费了 %u 毫秒\n&quot;</span>, flen, end);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件读取失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  file = fs.<span class="built_in">open</span>(path, FILE_WRITE);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件写入失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  start = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++) &#123;</span><br><span class="line">    file.<span class="built_in">write</span>(buf, <span class="number">512</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">millis</span>() - start;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;写入 %u 字节花费了 %u 毫秒\n&quot;</span>, <span class="number">2048</span> * <span class="number">512</span>, end);</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  SPIClass *hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);  <span class="comment">// 初始化 HSPI 总线</span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);              <span class="comment">// 指定 SPI 通信引脚（SCLK, MISO, MOSI, SS）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SD.begin(指定 GPIO0 为片选引脚，使用 HSPI 控制器，频率为 4 MHz，SD 卡挂载点，最大文件数量，如果为空是否进行格式化) */</span></span><br><span class="line">  <span class="keyword">if</span> (!SD.<span class="built_in">begin</span>(<span class="number">0</span>, *hspi, <span class="number">4000000</span>, <span class="string">&quot;/SD&quot;</span>, <span class="number">5</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;存储卡挂载失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint8_t</span> cardType = SD.<span class="built_in">cardType</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cardType == CARD_NONE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;未检测到 SD 卡！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;SD 卡类型: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cardType == CARD_MMC) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;MMC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardType == CARD_SD) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;SDSC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardType == CARD_SDHC) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;SDHC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;未知类型卡&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> cardSize = SD.<span class="built_in">cardSize</span>() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;SD 卡容量: %lluMB\n&quot;</span>, cardSize);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">createDir</span>(SD, <span class="string">&quot;/成都&quot;</span>);</span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">removeDir</span>(SD, <span class="string">&quot;/成都&quot;</span>);</span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">writeFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;您好，&quot;</span>);</span><br><span class="line">  <span class="built_in">appendFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;电子技术博客 UinIO.com！\n&quot;</span>);</span><br><span class="line">  <span class="built_in">readFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">deleteFile</span>(SD, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">renameFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">readFile</span>(SD, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">testFileIO</span>(SD, <span class="string">&quot;/成都.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;全部容量: %lluMB\n&quot;</span>, SD.<span class="built_in">totalBytes</span>() / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;已经使用的容量: %lluMB\n&quot;</span>, SD.<span class="built_in">usedBytes</span>() / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码下载执行之后，测试用的 SD 卡上面会生成一个内容为
<code>您好，电子技术博客 UinIO.com！</code> 的文件
<code>UinIO.txt</code>，以及通过文件输入输出写入了内容为空的
<code>成都.txt</code> 文件，同时会以 <code>115200</code>
波特率向串口打印如下一系列执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SD 卡类型: SDHC 存储卡</span><br><span class="line">SD 卡容量: 29822MB</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line">新建目录: /成都</span><br><span class="line">目录建立成功！</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line">  目录 : 成都</span><br><span class="line">移除目录: /成都</span><br><span class="line">目录移除成功！</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">列出目录: /System Volume Information</span><br><span class="line">  文件: IndexerVolumeGuid  尺寸: 76</span><br><span class="line">  文件: WPSettings.dat  尺寸: 12</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line"></span><br><span class="line">写入文件: /网站.txt</span><br><span class="line">文件写入成功！</span><br><span class="line">追加到文件: /网站.txt</span><br><span class="line">内容追加成功！</span><br><span class="line">正在读取文件: /网站.txt</span><br><span class="line">读取到的文件内容: 您好，电子技术博客 UinIO.com！</span><br><span class="line">删除文件: /UinIO.txt</span><br><span class="line">文件删除成功！</span><br><span class="line">重新命名文件 /网站.txt 为 /UinIO.txt</span><br><span class="line">文件重命名成功！</span><br><span class="line">正在读取文件: /UinIO.txt</span><br><span class="line">读取到的文件内容: 您好，电子技术博客 UinIO.com！</span><br><span class="line">读取 1048576 字节花费了 2383 毫秒</span><br><span class="line">写入 1048576 字节花费了 2515 毫秒</span><br><span class="line">全部容量: 29802MB</span><br><span class="line">已经使用的容量: 1MB</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：如果串口打印出的调试内容提示
<code>存储卡挂载失败！</code>，那么可以将这片 SD
卡拔出之后重新插入，然后按下 <strong>UINIO-MCU-ESP32</strong>
核心板上面的 <strong>RESET</strong> 按钮，重新执行上述程序。</p>
</blockquote>
<h2 id="第三方提供的-sdfat-库">第三方提供的 SdFat 库</h2>
<p>因为 <strong>ESP32-Arduino</strong> 官方库的 SD 卡相关 API
暂时还不够完善，所以本节内容将会介绍功能更加丰富的 <a target="_blank" rel="noopener" href="https://github.com/greiman/SdFat">SdFat</a> 库，可以同时支持
<strong>SD</strong>、<strong>SDHC</strong>、<strong>SDXC</strong>
类型的存储卡，以及
<strong>FAT16</strong>、<strong>FAT32</strong>、<strong>exFAT</strong>
文件系统。该库的 API 文档可以访问 <a target="_blank" rel="noopener" href="https://github.com/greiman/SdFat/releases">SdFat 源文件</a> 的
<code>\doc</code> 目录下，压缩文件 <code>html.zip</code> 当中的
<code>index.html</code>。总体上来看，<strong>SdFat</strong> 库是通过
<code>SdFat32</code>、<code>SdExFat</code>、<code>SdFs</code>
三个类来分别代表不同的存储卡文件系统：</p>
<ol type="1">
<li><code>SdFs</code> 类：用于支持 <strong>FAT16</strong> 和
<strong>FAT32</strong> 以及 <strong>exFAT</strong>
文件系统，对应的文件类为 <code>FsFile</code>；</li>
<li><code>SdFat32</code> 类：用于支持 <strong>FAT16</strong> 和
<strong>FAT32</strong> 文件系统，对应的文件类为
<code>File32</code>；</li>
<li><code>SdExFat</code> 类：用于支持 <strong>exFAT</strong>
文件系统，对应的文件类为 <code>ExFile</code>；</li>
</ol>
<p>该库可以方便的通过 <strong>Arduino IDE</strong>
的【库管理器】进行安装，安装之后需要修改 Arduino 项目文件夹
<code>libraries\SdFat\src</code> 下的 <code>SdFatConfig.h</code>
头文件，将宏定义 <code>#define USE_UTF8_LONG_NAMES</code> 的值修改为
<code>1</code>，即采用 <strong>UTF-8</strong>
格式编码所有字符串，从而能够自由的使用中文字符。除此之外，通过修改
<code>SdFatConfig.h</code> 头文件中 <code>SPI_DRIVER_SELECT</code>
宏定义的值，还可以选择当前是使用 <strong>SPI 硬件总线</strong>（使用 SPI
控制器默认的引脚）还是 <strong>SPI 软件总线</strong>（自定义 SPI
通信引脚）：</p>
<ul>
<li><code>0</code>：如果存在优化的自定义 SPI
驱动程序，则使用它，否则使用标准库驱动程序。</li>
<li><code>1</code>：总是使用标准库驱动程序。</li>
<li><code>2</code>：总是使用 SoftSpiDriver 模板类的外部 SPI
驱动程序。</li>
<li><code>3</code>：总是使用从 SdSpiBaseClass 类派生的外部 SPI
驱动程序。</li>
</ul>
<p>接下来，我们把 <code>SdFatConfig.h</code> 头文件里的
<code>SPI_DRIVER_SELECT</code> 配置为 <code>2</code>，而
<code>#define USE_UTF8_LONG_NAMES</code> 的值配置为
<code>1</code>，同时依然将 <strong>UINIO-MCU-ESP32</strong> 的
<code>SS = GPIO0</code>、<code>SCLK = GPIO1</code>、<code>MOSI = GPIO2</code>、<code>MISO = GPIO3</code>
与读卡器模块的
<code>CS</code>、<code>SCK</code>、<code>MOSI</code>、<code>MISO</code>
引脚连接，而读卡器模块的 <code>VCC</code> 和 <code>GND</code> 则分别接入
<strong>UINIO-MCU-ESP32</strong> 的 <code>5V</code> 和 <code>GND</code>
进行供电，最后就可以编写并且执行如下的参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SdFat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_FAT_TYPE 0  <span class="comment">// 0 表示遵循 SdFatConfig.h 里的配置、1 表示 FAT16/FAT32、2 表示 exFAT、3 表示 FAT16/FAT32 和 exFAT</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 SPI 通信引脚的编号为常量 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_SS   = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_SCLK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_MOSI = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_MISO = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">SoftSpiDriver&lt;SOFT_MISO, SOFT_MOSI, SOFT_SCLK&gt; softSpi;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件 SPI 总线，可以忽略 Speed 参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_DEDICATED_SPI</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> SD_CONFIG SdSpiConfig(SOFT_SS, DEDICATED_SPI, SD_SCK_MHZ(0), &amp;softSpi)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> SD_CONFIG SdSpiConfig(SOFT_SS, SHARED_SPI, SD_SCK_MHZ(0), &amp;softSpi)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_FAT_TYPE == 0</span></span><br><span class="line">  SdFat sd;</span><br><span class="line">  File file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 1</span></span><br><span class="line">  SdFat32 sd;</span><br><span class="line">  File32 file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 2</span></span><br><span class="line">  SdExFat sd;</span><br><span class="line">  ExFile file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 3</span></span><br><span class="line">  SdFs sd;</span><br><span class="line">  FsFile file;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> Invalid SD_FAT_TYPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待 USB 串行接口就绪 */</span></span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;请输入任意字符开始测试：&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待控制台输入 */</span></span><br><span class="line">  <span class="keyword">while</span> (!Serial.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用上面的宏定义 SD_CONFIG 配置 SPI 总线 */</span></span><br><span class="line">  <span class="keyword">if</span> (!sd.<span class="built_in">begin</span>(SD_CONFIG)) &#123;</span><br><span class="line">    sd.<span class="built_in">initErrorHalt</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在 SD 存储卡上面创建并且打开一个 电子技术博客.txt 文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!file.<span class="built_in">open</span>(<span class="string">&quot;电子技术博客.txt&quot;</span>, O_RDWR | O_CREAT)) &#123;</span><br><span class="line">    sd.<span class="built_in">errorHalt</span>(<span class="built_in">F</span>(<span class="string">&quot;文件创建或者打开失败！&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">println</span>(<span class="built_in">F</span>(<span class="string">&quot;欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。&quot;</span>));  <span class="comment">// 向上面创建的 .txt 文件写入内容</span></span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">rewind</span>();                <span class="comment">// 将文件当前的操作位置初始为零</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (file.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(file.<span class="built_in">read</span>());  <span class="comment">// 读取并且打印 .txt 当中的内容到串口</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="built_in">F</span>(<span class="string">&quot;SD 存储卡写入完成！&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UINIO-MCU-ESP32</strong>
开始运行上述代码之后，可以打开一个第三方的串口上位机程序（例如
<strong>VOFA+</strong> 或者
<strong>COMTransmit</strong>），首先将其波特率设置为
<code>115200</code>，然后手动向串口上位机的【发送窗口】输入
<code>test</code> 并且按下发送，此时 <strong>UINIO-MCU-ESP32</strong>
就会自动向 SD
存储卡写入内容：<code>欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。</code>，同时串口上位机的【接收窗口】会打印出如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ESP-ROM:esp32s3-20210327</span><br><span class="line">Build:Mar 27 2021</span><br><span class="line">rst:0x1 (POWERON),boot:0x8 (SPI_FAST_FLASH_BOOT)</span><br><span class="line">SPIWP:0xee</span><br><span class="line">mode:DIO, clock div:1</span><br><span class="line">load:0x3fce3808,len:0x44c</span><br><span class="line">load:0x403c9700,len:0xbe4</span><br><span class="line">load:0x403cc700,len:0x2a68</span><br><span class="line">entry 0x403c98d4</span><br><span class="line"></span><br><span class="line">请输入任意字符开始测试：</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。</span><br><span class="line">SD 存储卡写入完成！</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<strong>DSPI</strong>（<strong>Dual
SPI</strong>）常用于 SPI 总线通信的 Flash 存储器，由于 Flash
存储器无需使用全双工通信，所以 <strong>DSPI</strong> 将
<code>MOSI</code> 和 <code>MISO</code>
都作为并行数据传输线，从而工作在半双工模式下，可以达到在单个时钟周期内，双倍提升数据传输速率的目的。</p>
</blockquote>
<h1 id="借用-freertos-的多任务与互斥量">借用 FreeRTOS
的多任务与互斥量</h1>
<p><strong>FreeRTOS</strong>
是一款适用于微控制器和小型微处理器的嵌入式实时操作系统（<strong>RTOS</strong>，Real-time
Operating
System），其提供了<code>任务</code>与<code>通知</code>、<code>队列</code>、<code>流缓冲区</code>、<code>消息缓冲区</code>、<code>信号量</code>/<code>互斥锁</code>、<code>软件定时器</code>、<code>事件组</code>等丰富特性，可以协助开发人员在资源受限的嵌入式场景下，实现稳定可靠的实时任务调度与协作。当
<strong>Arduino IDE</strong> 成功安装 <strong>Arduino-ESP32</strong>
之后，就会在如下目录里发现 <strong>ESP32-C3</strong> 和
<strong>ESP32-S3</strong> 源码实现都内嵌有
<strong>FreeRTOS</strong>。</p>
<ul>
<li><strong>ESP32C3 内嵌的
FreeRTOS</strong>：<code>C:\Users\Hank\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32c3\include\freertos</code>；</li>
<li><strong>ESP32S3 内嵌的
FreeRTOS</strong>：<code>C:\Users\Hank\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32s3\include\freertos</code>；</li>
</ul>
<p>相应的，<strong>Arduino-ESP32</strong> 当中所使用的
<strong>FreeRTOS</strong> 都会通过头文件 <code>FreeRTOSConfig.h</code>
来进行配置，其位置位于 <strong>Arduino-ESP32</strong>
用户安装目录的如下路径：</p>
<ul>
<li><strong>ESP32C3 的
<code>FreeRTOSConfig.h</code></strong>：<code>Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32c3\include\freertos\include\esp_additions\freertos\FreeRTOSConfig.h</code>；</li>
<li><strong>ESP32S3 的
<code>FreeRTOSConfig.h</code></strong>：<code>Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32s3\include\freertos\include\esp_additions\freertos\FreeRTOSConfig.h</code>；</li>
</ul>
<p>例如 <strong>Arduino-ESP32</strong> 当中的 <code>loop()</code>
函数，就是通过在 <strong>FreeRTOS</strong> 当中创建一个优先级为
<code>1</code> 的任务来进行执行的。也正是因为如此，我们同样可以在
Arduino 草图代码当中引入 FreeRTOS 相关的头文件来使用其相关的特性。</p>
<blockquote>
<p><strong>注意</strong>：当前本文使用的 <strong>Arduino-ESP32</strong>
版本为 <code>2.0.11</code>，其内嵌的 <strong>FreeRTOS</strong> 版本为
<code>V10.4.x</code>。</p>
</blockquote>
<h2 id="多任务处理">多任务处理</h2>
<p>当 <strong>Arduino IDE</strong> 安装了 <strong>Arduino-ESP32</strong>
之后，菜单栏的上【工具】下就会出现一系列配置选项。对于
<strong>UINIO-MCU-ESP32S3</strong>
这样的多核微控制器，就可以发现如下两条配置项：</p>
<ul>
<li><strong>Arduino Runs On</strong>：指定用于运行 <strong>Arduino
核心</strong>的微控制器内核；</li>
<li><strong>Events Run On</strong>：指定用于运行 <strong>Arduino
事件</strong>的微控制器内核；</li>
</ul>
<p>上述两个配置项的<strong>值</strong>可以分别被指定为
<code>Core 0</code> 和 <code>Core 1</code>，除此之外，由于
<strong>Arduino-ESP32</strong> 库在底层实现上，使用了嵌入式实时操作系统
<strong>FreeRTOS</strong>，所以在 Arduino
草图代码也可以通过包含如下两个头文件，以使用其提供的多任务处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Arduino-ESP32</strong> 当中可以通过
<code>xTaskCreatePinnedToCore()</code>
函数创建一个任务，如果任务创建成功，则会返回
<code>pdPASS</code>，否则表示创建失败：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskFunction_t pvTaskCode,     <span class="comment">// 指向任务入口函数的指针，该函数会不断运行，其原型为 void task( void* param )</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,     <span class="comment">// 任务的描述性名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">short</span> usStackDepth,   <span class="comment">// 分配用于任务堆栈的字数(非字节)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *pvParameters,            <span class="comment">// 传递给创建任务的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxPriority,        <span class="comment">// 创建任务执行的优先级 0 ~ 24，空闲任务的优先级为 0，而 loop 函数的优先级为 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t *pvCreatedTask,   <span class="comment">// 用于传递创建任务的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BaseType_t xCoreID       <span class="comment">// 值 0 或者 1 表示任务运行的微控制器内核编号，值 tskNO_AFFINITY 表示可以运行于任意的内核</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure>
<p>任务创建之后，就可以通过 <code>vTaskDelete()</code>
函数结束并且删除掉一个任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskDelete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t pxTask <span class="comment">// 需要删除的任务句柄，直接传递 NULL 会导致当前调用任务被删除</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以利用 <code>uxTaskPriorityGet()</code> 返回参数任务
<code>XTask</code> 的优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t xTask  <span class="comment">// 需要查询的任务句柄，直接传递 NULL 会返回调用任务的优先级</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure>
<p>以及使用 <code>XPortGetCoreID()</code>
返回当前任务运行于哪一个微控制器内核：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t IRAM ATTR <span class="title">XPortGetCoreID</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在接下来的示例代码当中，通过直接包含 FreeRTOS 配置文件
<code>FreeRTOSConfig.h</code> 的方式（也可以采用分别包含
<code>FreeRTOS.h</code> 和 <code>task.h</code>
两个头文件的方式），展示了如何基于采用 <strong>ESP32-S3</strong>
多核微控制器的 <strong>UINIO-MCU-ESP32S3</strong> 进行多任务的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task1</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> value = *((<span class="type">int</span>*)parameter); <span class="comment">// 获取整型指针参数的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务运行在：Core %d\n&quot;</span>, core);     <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务接收到的参数为: %d\n&quot;</span>, value);  <span class="comment">// 打印当前任务接收到的参数</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task2</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-2 任务运行在：Core %d\n&quot;</span>, core); <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 1，运行在 ESP32-S3 的 Core 0，优先级为 15 */</span></span><br><span class="line">  TaskHandle_t handle1;  <span class="comment">// 任务句柄</span></span><br><span class="line">  <span class="type">int</span> parameter = <span class="number">2023</span>;  <span class="comment">// 任务参数</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task1, <span class="string">&quot;Task-1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;parameter, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 2，运行在 ESP32-S3 的 Core 1，优先级为 15 */</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task2, <span class="string">&quot;Task-2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();  <span class="comment">// 获取运行的微控制器内核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务运行在：Core %d\n&quot;</span>, core);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = <span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务的优先级为: %d\n&quot;</span>, priority);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>); <span class="comment">// 一个任务里的 delay() 函数不会影响到其它任务的运行，即虽然该任务延时 2 秒，但是其它任务依然按照正常速度执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述代码下载到 <strong>UINIO-MCU-ESP32S3</strong>
上面，核心板就会每间隔 2 秒，以 <code>115200</code> 波特率向
<strong>Arduino IDE</strong> 的串口监视器打印如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task-1 任务运行在：Core 0</span><br><span class="line">Task-1 任务接收到的参数为: 2023</span><br><span class="line">Task-2 任务运行在：Core 1</span><br><span class="line">loop 函数任务运行在：Core 1</span><br><span class="line">loop 函数任务的优先级为: 1</span><br></pre></td></tr></table></figure>
<h2 id="互斥锁机制">互斥锁机制</h2>
<p><strong>FreeRTOS</strong> 提供的<a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/Real-time-embedded-RTOS-mutexes.html"><strong>互斥锁</strong></a>机制是一种包含有优先级继承机制的二进制信号量，之前介绍过的<strong>二进制信号量</strong>可以用于实现任务与任务，以及任务与中断之间的同步。而<strong>互斥锁</strong>则有助于更好的实现资源的互斥访问，它就像是保护互斥资源的一个令牌，当任务需要访问资源时，必须首先获取这个令牌；而在使用完资源之后，则必须返回这个令牌，从而使得其它任务能够继续访问该资源。</p>
<p><strong>Arduino-ESP32</strong> 可以通过
<code>xSemaphoreCreateMutex()</code>
函数创建一个互斥锁，执行之后就会返回这个互斥锁的句柄：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在创建信号量之后，接下来就可以通过 <code>xSemaphoreTake()</code>
函数获取互斥锁信号量，如果获取成功就返回
<code>pdTRUE</code>，如果获取失败则返回 <code>pdFALSE</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreTake</span>(</span><br><span class="line">    SemaphoreHandle_t xSemaphore,  <span class="comment">// 获取到的信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait        <span class="comment">// 等待信号量可用的节拍时间，指定为 portMAX_DELAY 会导致任务无限期阻塞（即没有超时）</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>除此之外，互斥锁信号量可以通过 <code>xSemaphoreGive()</code>
函数进行释放，信号量释放成功就返回
<code>pdTRUE</code>，如果发生错误则返回 <code>pdFALSE</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreGive</span>(</span><br><span class="line">    SemaphoreHandle_t xSemaphore   <span class="comment">// 待释放的信号量句柄</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>下面的伪代码，简单明了的展示了互斥锁信号量的典型使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">xSemaphoreTake</span>(xSemaphore, xTicksToWait) ) &#123;</span><br><span class="line">  <span class="comment">// ... ... ...</span></span><br><span class="line">  <span class="comment">// 开始处理临界资源</span></span><br><span class="line">  <span class="comment">// ... ... ...</span></span><br><span class="line">  <span class="built_in">xSemaphoreGive</span>(xSemaphore); <span class="comment">// 释放互斥锁信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的示例代码当中，通过使用互斥信号量确保了 <code>Task-1</code> 和
<code>Task-2</code> 两个任务，对于互斥资源变量 <code>number</code>
的同步访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">xSemaphoreHandle xSemaphore;  <span class="comment">// 声明互斥锁信号量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;               <span class="comment">// 定义互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2，用于打印互斥资源 number 的值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task1</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> value = *((<span class="type">int</span>*)parameter);  <span class="comment">// 获取整型指针参数的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务运行在：Core %d\n&quot;</span>, core);     <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务接收到的参数为: %d\n&quot;</span>, value);  <span class="comment">// 打印当前任务接收到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaphore, portMAX_DELAY)) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;互斥资源 number 的值为: %d\n&quot;</span>, number);  <span class="comment">// 打印互斥资源 number</span></span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2，用于对互斥资源 number 进行自增 1 操作 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task2</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-2 任务运行在：Core %d\n&quot;</span>, core);  <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaphore, portMAX_DELAY)) &#123;</span><br><span class="line">      number++;                <span class="comment">// 互斥资源 number 自增 1</span></span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaphore);  <span class="comment">// 释放互斥资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  xSemaphore = <span class="built_in">xSemaphoreCreateMutex</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 1，运行在 ESP32-S3 的 Core 0，优先级为 15 */</span></span><br><span class="line">  TaskHandle_t handle1;  <span class="comment">// 任务句柄</span></span><br><span class="line">  <span class="type">int</span> parameter = <span class="number">2023</span>;  <span class="comment">// 任务参数</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task1, <span class="string">&quot;Task-1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;parameter, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 2，运行在 ESP32-S3 的 Core 1，优先级为 15 */</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task2, <span class="string">&quot;Task-2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();  <span class="comment">// 获取运行的微控制器内核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务运行在：Core %d\n&quot;</span>, core);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = <span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务的优先级为: %d\n&quot;</span>, priority);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);  <span class="comment">// 一个任务里的 delay() 函数不会影响到其它任务的运行，即虽然该任务延时 2 秒，但是其它任务依然按照正常速度执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：不能在<strong>中断服务程序</strong>当中使用
FreeRTOS 的互斥锁信号量。</p>
</blockquote>
<h1 id="基于-wifi-传输数据">基于 WIFI 传输数据</h1>
<p><strong>Arduino-ESP32</strong> 提供了一系列 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html">WIFI
相关的 API</a>，支持 802.11b/g/n 无线局域网标准，可以用于<strong>扫描
WIFI 接入点</strong>，也支持
<strong>WPA2</strong>、<strong>WPA3</strong> 等 WIFI
安全模式，除此之外还提供了 WIFI 的 <strong>STA</strong> 和
<strong>AP</strong> 两种工作模式：</p>
<p><img src="/Project/Arduino-ESP32/41.png"></p>
<p><strong>Wi-Fi 客户端</strong>模式，也被称为 <strong>STA</strong>
模式（Station mode），这种模式支持把 ESP32 连接到一个 WIFI 接入点。</p>
<p><img src="/Project/Arduino-ESP32/42.png"></p>
<p><strong>Wi-Fi 接入点</strong>模式，也被称为 <strong>AP</strong>
模式（Access Point mode），这种模式下 ESP32
被配置为一个接入点，可以通过提供 Wi-Fi 局域网接收其它设备的连接。</p>
<h2 id="wifi-相关-api-函数概览">WIFI 相关 API 函数概览</h2>
<table>
<colgroup>
<col style="width: 62%">
<col style="width: 37%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">通用 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>wifi_event_id_t onEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX)</code></td>
<td style="text-align: left;">注册一个 WIFI 事件回调函数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void removeEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX)</code></td>
<td style="text-align: left;">移除一个 WIFI 事件回调函数。</td>
</tr>
<tr>
<td style="text-align: left;"><code>setHostname(const char *hostname)</code></td>
<td style="text-align: left;">设置 DHCP 客户端标识。</td>
</tr>
<tr>
<td style="text-align: left;"><code>const char *getHostname()</code></td>
<td style="text-align: left;">获取 DHCP 客户端标识。</td>
</tr>
<tr>
<td style="text-align: left;"><code>static void useStaticBuffers(bool bufferMode)</code></td>
<td style="text-align: left;">设置 Wi-Fi
缓冲区的内存分配方式，<code>true</code> 为静态，而 <code>false</code>
为动态。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool setDualAntennaConfig(uint8_t gpio_ant1, uint8_t gpio_ant2, wifi_rx_ant_t rx_mode, wifi_tx_ant_t tx_mode)</code></td>
<td style="text-align: left;">配置双天线功能，仅支持带有 RF 开关的 ESP32
使用。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 82%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">AP 模式 WIFI 相关 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>WiFi.softAP(ssid, password)</code></td>
<td style="text-align: left;">启动 Wi-Fi 作为接入点。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool softAP(const char* ssid, const char* passphrase = NULL, int channel = 1, int ssid_hidden = 0, int max_connection = 4, bool ftm_responder = false)</code></td>
<td style="text-align: left;">配置 Wi-Fi 的 AP 特性</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet)</code></td>
<td style="text-align: left;">用于配置静态 IP、网关、子网。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool softAPdisconnect(bool wifioff = false)</code></td>
<td style="text-align: left;">强制断开 AP 连接。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t softAPgetStationNum()</code></td>
<td style="text-align: left;">返回当前连接到 AP 的客户端数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPAddress softAPIP()</code></td>
<td style="text-align: left;">获取 AP 的 IPv4 地址。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPAddress softAPBroadcastIP()</code></td>
<td style="text-align: left;">获取 AP 的 IPv4 广播地址。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPAddress softAPNetworkID()</code></td>
<td style="text-align: left;">获取 AP 网络的 ID。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t softAPSubnetCIDR()</code></td>
<td style="text-align: left;">获取 AP 网络的子网 CIDR。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPAddress softAPSubnetMask()</code></td>
<td style="text-align: left;">获取 AP 网络的子网掩码。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool softAPenableIpV6()</code></td>
<td style="text-align: left;">启用 IPv6 支持。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPv6Address softAPIPv6()</code></td>
<td style="text-align: left;">获取 IPv6 地址。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool softAPsetHostname(const char * hostname)</code></td>
<td style="text-align: left;">设置 AP 的主机名称。</td>
</tr>
<tr>
<td style="text-align: left;"><code>const char * softAPgetHostname()</code></td>
<td style="text-align: left;">获取 AP 的主机名称。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t* softAPmacAddress(uint8_t* mac)</code></td>
<td style="text-align: left;">设置或者获取 AP 的 MAC 地址。</td>
</tr>
<tr>
<td style="text-align: left;"><code>String softAPSSID(void) const</code></td>
<td style="text-align: left;">获取 AP 网络的 SSID。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 72%">
<col style="width: 27%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">STA 模式 WIFI 相关 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>wl_status_t begin(const char* ssid, const char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);</code></td>
<td style="text-align: left;">启动 Wi-Fi 连接。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = (uint32_t)0x00000000, IPAddress dns2 = (uint32_t)0x00000000)</code></td>
<td style="text-align: left;">配置 IP 地址、网关、子网、DNS 信息。</td>
</tr>
<tr>
<td style="text-align: left;"><code>IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)</code></td>
<td style="text-align: left;"><code>IPAddress</code> 格式由 4
个字节进行定义。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool reconnect()</code></td>
<td style="text-align: left;">重新连接 Wi-Fi。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool disconnect(bool wifioff = false, bool eraseap = false)</code></td>
<td style="text-align: left;">强制断开 Wi-Fi 连接。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool isConnected();</code></td>
<td style="text-align: left;">获取 Wi-Fi 连接状态。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool setAutoReconnect(bool autoReconnect)</code></td>
<td style="text-align: left;">设置连接丢失时，是否开启自动重新连接。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool getAutoReconnect()</code></td>
<td style="text-align: left;">获取连接丢失时，自动重连的设置状态。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool setMinSecurity(wifi_auth_mode_t minSecurity)</code></td>
<td style="text-align: left;">设置 AP 连接的最低安全性，默认为
<code>WIFI_AUTH_WPA2_PSK</code>。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 75%">
<col style="width: 24%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">WiFiMulti 相关 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>bool addAP(const char* ssid, const char *passphrase = NULL)</code></td>
<td style="text-align: left;">添加多个 AP 接入点。</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint8_t run(uint32_t connectTimeout=5000)</code></td>
<td style="text-align: left;">开始运行 WiFiMulti。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 81%">
<col style="width: 18%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">WiFiScan 相关 API</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>int16_t scanNetworks(bool async = false, bool show_hidden = false, bool passive = false, uint32_t max_ms_per_chan = 300, uint8_t channel = 0)</code></td>
<td style="text-align: left;">开始扫描可用的 WiFi 网络。</td>
</tr>
<tr>
<td style="text-align: left;"><code>int16_t scanComplete()</code></td>
<td style="text-align: left;">采用异步模式获取扫描状态。</td>
</tr>
<tr>
<td style="text-align: left;"><code>void scanDelete()</code></td>
<td style="text-align: left;">删除 RAM 当中的最后一次扫描结果。</td>
</tr>
<tr>
<td style="text-align: left;"><code>bool getNetworkInfo(uint8_t networkItem, String &amp;ssid, uint8_t &amp;encryptionType, int32_t &amp;RSSI, uint8_t* &amp;BSSID, int32_t &amp;channel)</code></td>
<td style="text-align: left;">获取扫描到的 WIFI 网络信息。</td>
</tr>
</tbody>
</table>
<p>提供了 WIFI 接入点，并且运行了一个 Web
服务器，<code>http://192.168.4.1/H</code> 去打开 LED on or
<code>http://192.168.4.1/L</code></p>
<h2 id="使用-httpclient-发起-get-请求">使用 HttpClient 发起 GET
请求</h2>
<p><strong>ESP32-Arduino</strong> 内嵌有一个开源的 <a target="_blank" rel="noopener" href="http://github.com/amcewen/HttpClient">HttpClient</a>
库，可以方便的与 Web 服务器进行交互。下面的示例代码会通过 WIFI
局域网，不断的向 <code>http://www.uinio.com</code> 地址发起一个
<strong>HTTP GET</strong> 请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiMulti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">WiFiMulti wifiMulti;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;===== 开始 [SETUP] 配置 =====&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 延时等待 5 秒 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> t = <span class="number">5</span>; t &gt; <span class="number">0</span>; t--) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在运行 [SETUP]，请等待 %d... 秒\n&quot;</span>, t);</span><br><span class="line">    Serial.flush();</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;SSID&quot;</span>, <span class="string">&quot;Password&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 等待 WIFI 连接成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((wifiMulti.run() == WL_CONNECTED))</span><br><span class="line">    HTTPClient http;</span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;准备 [HTTP] 请求...\n&quot;</span>);</span><br><span class="line">    http.begin(<span class="string">&quot;http://www.uinio.com&quot;</span>);  <span class="comment">// 准备向 UinIO.com 发起 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;开始 [HTTP] GET 请求...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> HttpCode = http.GET();  <span class="comment">// 开始连接，发送 HTTP 协议头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当 HTTP 状态码为负值时表示出现错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] GET 请求成功，响应状态码为: %d\n&quot;</span>, HttpCode);  <span class="comment">// 打印 HTTP 请求响应状态码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 GET 请求获取到的内容 */</span></span><br><span class="line">      <span class="keyword">if</span> (HttpCode == HTTP_CODE_OK) &#123;</span><br><span class="line">        String payload = http.getString();</span><br><span class="line">        Serial.println(payload);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] GET 请求失败，错误信息为: %s\n&quot;</span>, http.errorToString(HttpCode).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    http.end();  <span class="comment">// 结束 HTTPClient 服务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">6000</span>);   <span class="comment">// 延时 6 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配合-arduinojson-发起-post-请求">配合 ArduinoJson 发起 POST
请求</h2>
<p>除此之外，配合第三方 JSON 解析库 <a target="_blank" rel="noopener" href="https://arduinojson.org/">ArduinoJson</a> 使用，还可以方便的以
<strong>POST</strong> 方式传输 JSON
格式的数据。下面的示例代码，将会携带一个包含有 <code>data</code> 属性的
JSON 对象参数，向远程服务器的 <code>http://192.168.1.1:8080/test</code>
接口发起一个 <strong>HTTP POST</strong>
请求，并且将响应的结果打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiMulti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HTTPClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ArduinoJson.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">WiFiMulti wifiMulti;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;===== 开始 [SETUP] 配置 =====&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 延时等待 5 秒 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> t = <span class="number">5</span>; t &gt; <span class="number">0</span>; t--) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在运行 [SETUP]，请等待 %d... 秒\n&quot;</span>, t);</span><br><span class="line">    Serial.flush();</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;SSID&quot;</span>, <span class="string">&quot;Password&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 等待 WIFI 连接成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((wifiMulti.run() == WL_CONNECTED)) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;准备 [HTTP] 请求...\n&quot;</span>);</span><br><span class="line">    http.begin(<span class="string">&quot;http://192.168.1.1:8080/test&quot;</span>);  <span class="comment">// 准备向 UinIO.com 发起 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;开始 [HTTP] POST 请求...\n&quot;</span>);</span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String serializeResult;</span><br><span class="line">    DynamicJsonDocument <span class="title function_">JsonParameter</span><span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">    JsonParameter[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;电子技术博客 UinIO.com&quot;</span>;</span><br><span class="line">    serializeJson(JsonParameter, serializeResult);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> HttpCode = http.POST((<span class="type">uint8_t</span>*)serializeResult.c_str(), serializeResult.length());  <span class="comment">// 开始连接，发送 HTTP 协议头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当 HTTP 状态码为负值时表示出现错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] POST 请求成功，响应状态码为: %d\n&quot;</span>, HttpCode);  <span class="comment">// 打印 HTTP 请求响应状态码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 GET 请求获取到的内容 */</span></span><br><span class="line">      <span class="keyword">if</span> (HttpCode == HTTP_CODE_OK) &#123;</span><br><span class="line">        String payload = http.getString();</span><br><span class="line">        Serial.println(payload);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] POST 请求失败，错误信息为: %s\n&quot;</span>, http.errorToString(HttpCode).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    http.end();  <span class="comment">// 结束 HTTPClient 服务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">6000</span>);   <span class="comment">// 延时 6 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程</p><p><a href="http://www.uinio.com/Project/Arduino-ESP32/">http://www.uinio.com/Project/Arduino-ESP32/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-05-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-01-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Arduino/">Arduino</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Web/Solidity/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Electronics/LDO/"><span class="level-item">常见 LDO 线性稳压芯片的对比选型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#arduino-ide-2-开发环境"><span class="level-left"><span class="level-item">1</span><span class="level-item">Arduino IDE 2 开发环境</span></span></a></li><li><a class="level is-mobile" href="#arduino-esp32-库概览"><span class="level-left"><span class="level-item">2</span><span class="level-item">Arduino-ESP32 库概览</span></span></a></li><li><a class="level is-mobile" href="#led-定时闪烁阻塞-非阻塞"><span class="level-left"><span class="level-item">3</span><span class="level-item">LED 定时闪烁（阻塞 &amp; 非阻塞）</span></span></a></li><li><a class="level is-mobile" href="#按键控制-与-rbd_button-库"><span class="level-left"><span class="level-item">4</span><span class="level-item">按键控制 与 RBD_BUTTON 库</span></span></a></li><li><a class="level is-mobile" href="#基于-pwm-的-ledc"><span class="level-left"><span class="level-item">5</span><span class="level-item">基于 PWM 的 LEDC</span></span></a></li><li><a class="level is-mobile" href="#软件定时器-与-asynctimer-库"><span class="level-left"><span class="level-item">6</span><span class="level-item">软件定时器 与 AsyncTimer 库</span></span></a></li><li><a class="level is-mobile" href="#adc-模数转换"><span class="level-left"><span class="level-item">7</span><span class="level-item">ADC 模数转换</span></span></a></li><li><a class="level is-mobile" href="#i²c-总线主从通信"><span class="level-left"><span class="level-item">8</span><span class="level-item">I²C 总线主从通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#i²c-主设备模式"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">I²C 主设备模式</span></span></a></li><li><a class="level is-mobile" href="#i²c-从设备模式"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">I²C 从设备模式</span></span></a></li><li><a class="level is-mobile" href="#主从设备通信实例"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">主从设备通信实例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#pcf8574-驱动-1602-液晶屏"><span class="level-left"><span class="level-item">9</span><span class="level-item">PCF8574 驱动 1602 液晶屏</span></span></a></li><li><a class="level is-mobile" href="#外部中断-自旋锁"><span class="level-left"><span class="level-item">10</span><span class="level-item">外部中断 &amp; 自旋锁</span></span></a></li><li><a class="level is-mobile" href="#测量-pwm-的频率-占空比"><span class="level-left"><span class="level-item">11</span><span class="level-item">测量 PWM 的频率 &amp; 占空比</span></span></a></li><li><a class="level is-mobile" href="#定时器-timer-信号量-semaphore"><span class="level-left"><span class="level-item">12</span><span class="level-item">定时器 Timer &amp; 信号量
Semaphore</span></span></a></li><li><a class="level is-mobile" href="#hc-sr04-超声波模组"><span class="level-left"><span class="level-item">13</span><span class="level-item">HC-SR04 超声波模组</span></span></a></li><li><a class="level is-mobile" href="#伺服舵机-esp32servo-库"><span class="level-left"><span class="level-item">14</span><span class="level-item">伺服舵机 &amp; ESP32Servo 库</span></span></a></li><li><a class="level is-mobile" href="#由多份源文件组成的草图工程"><span class="level-left"><span class="level-item">15</span><span class="level-item">由多份源文件组成的草图工程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#uinio-auto-box.ino"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">UINIO-Auto-Box.ino</span></span></a></li><li><a class="level is-mobile" href="#cover.h-与-cover.cpp"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">Cover.h 与 Cover.cpp</span></span></a></li><li><a class="level is-mobile" href="#servo.h-与-servo.cpp"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">Servo.h 与 Servo.cpp</span></span></a></li><li><a class="level is-mobile" href="#sonar.h-与-sonar.cpp"><span class="level-left"><span class="level-item">15.4</span><span class="level-item">Sonar.h 与 Sonar.cpp</span></span></a></li></ul></li><li><a class="level is-mobile" href="#spi-总线主从通信"><span class="level-left"><span class="level-item">16</span><span class="level-item">SPI 总线主从通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#spi-总线协议原理"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">SPI 总线协议原理</span></span></a></li><li><a class="level is-mobile" href="#esp32c3-esp32s3-的-spi-外设"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">ESP32C3 &amp; ESP32S3 的 SPI
外设</span></span></a></li><li><a class="level is-mobile" href="#主设备-spi-官方库"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">主设备 SPI 官方库</span></span></a></li><li><a class="level is-mobile" href="#从设备-spi-第三方库"><span class="level-left"><span class="level-item">16.4</span><span class="level-item">从设备 SPI 第三方库</span></span></a></li><li><a class="level is-mobile" href="#主-从设备-spi-通信实例"><span class="level-left"><span class="level-item">16.5</span><span class="level-item">主 &amp; 从设备 SPI 通信实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#spimaster.ino"><span class="level-left"><span class="level-item">16.5.1</span><span class="level-item">SPIMaster.ino</span></span></a></li><li><a class="level is-mobile" href="#spislavewait.ino"><span class="level-left"><span class="level-item">16.5.2</span><span class="level-item">SPISlaveWait.ino</span></span></a></li><li><a class="level is-mobile" href="#spislavequeue.ino"><span class="level-left"><span class="level-item">16.5.3</span><span class="level-item">SPISlaveQueue.ino</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#基于-spi-操作-sd-存储卡"><span class="level-left"><span class="level-item">17</span><span class="level-item">基于 SPI 操作 SD 存储卡</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#arduino-esp32-提供的-sd-库"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">Arduino-ESP32 提供的 SD 库</span></span></a></li><li><a class="level is-mobile" href="#第三方提供的-sdfat-库"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">第三方提供的 SdFat 库</span></span></a></li></ul></li><li><a class="level is-mobile" href="#借用-freertos-的多任务与互斥量"><span class="level-left"><span class="level-item">18</span><span class="level-item">借用 FreeRTOS
的多任务与互斥量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多任务处理"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">多任务处理</span></span></a></li><li><a class="level is-mobile" href="#互斥锁机制"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">互斥锁机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基于-wifi-传输数据"><span class="level-left"><span class="level-item">19</span><span class="level-item">基于 WIFI 传输数据</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#wifi-相关-api-函数概览"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">WIFI 相关 API 函数概览</span></span></a></li><li><a class="level is-mobile" href="#使用-httpclient-发起-get-请求"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">使用 HttpClient 发起 GET
请求</span></span></a></li><li><a class="level is-mobile" href="#配合-arduinojson-发起-post-请求"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">配合 ArduinoJson 发起 POST
请求</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Motor-PWM/"><img src="/Electronics/Motor-PWM/logo.png" alt="直流无刷电机的 PWM 驱动控制原理简述"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-06T16:00:00.000Z">2024-11-07</time></p><p class="title"><a href="/Electronics/Motor-PWM/">直流无刷电机的 PWM 驱动控制原理简述</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/E-Series/"><img src="/Electronics/E-Series/logo.png" alt="美国电子工业联盟 E 系列标准参数值速查手册"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-05T16:00:00.000Z">2024-11-06</time></p><p class="title"><a href="/Electronics/E-Series/">美国电子工业联盟 E 系列标准参数值速查手册</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/TVS/"><img src="/Electronics/TVS/logo.png" alt="瞬态电压抑制二极管 TVS 选型简述"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-05T16:00:00.000Z">2024-09-06</time></p><p class="title"><a href="/Electronics/TVS/">瞬态电压抑制二极管 TVS 选型简述</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Battery/"><img src="/Electronics/Battery/logo.png" alt="锂离子电池技术参数简明选型指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-08-28T16:00:00.000Z">2024-08-29</time></p><p class="title"><a href="/Electronics/Battery/">锂离子电池技术参数简明选型指南</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/LTspice/"><img src="/Electronics/LTspice/logo.png" alt="如何使用新版本的 LTspice 进行模拟电路仿真"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-05-21T16:00:00.000Z">2024-05-22</time></p><p class="title"><a href="/Electronics/LTspice/">如何使用新版本的 LTspice 进行模拟电路仿真</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>