<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UinIO.com 电子技术实验室</title>
  
  <subtitle>UinIO.com 电子技术实验室</subtitle>
  <link href="http://www.uinio.com/atom.xml" rel="self"/>
  
  <link href="http://www.uinio.com/"/>
  <updated>2024-09-03T18:02:49.596Z</updated>
  <id>http://www.uinio.com/</id>
  
  <author>
    <name>Hank</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于锂离子电池选型里的一些重要细节</title>
    <link href="http://www.uinio.com/Electronics/Battery/"/>
    <id>http://www.uinio.com/Electronics/Battery/</id>
    <published>2024-08-28T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:49.596Z</updated>
    
    <content type="html"><![CDATA[<p><strong>锂离子电池</strong>是一种采用锂金属化合物作为正负极材料，中间再填充电解质溶液的化学电池，属于一种可反复充放电的<strong>二次电池</strong>。内部主要依靠<strong>锂离子</strong>在正极与负极之间的移动来进行充放电。在充放电过程中，锂离子在两个电极之间不断的往返，嵌入正负极材料或者从正负极材料当中脱嵌。例如在充电时，锂离子就会从正极材料脱嵌，穿过电解质溶液之后再嵌入负极材料，使得负极逐渐呈现出富锂状态，而在放电的时候这个化学过程正好相反。</p><p><img src="/Electronics/Battery/logo.png"></p><p>长期以来，围绕锂离子电池安全性的话题层出不穷，大量的行业规范与政策法规，伴随着锂离子电池的大规模市场化应用而被不断推出。自从2024 年 8 月 1 日起，我国已经对锂离子电池实施 <strong>3C</strong>强制认证管理，未获得 <strong>3C</strong> 认证并且标注<strong>3C</strong>认证标识的锂电池产品，将不得出厂进行销售和进行其它经营活动。本文总结了各类锂离子电池材料的特性，以及选型过程当中的一些重要事项，希冀能够对于广大电子工程师的物料选型工作有所裨益。</p><span id="more"></span><p>锂离子电池主要是由<strong>正极</strong>（锂化合物）和<strong>负极</strong>（石墨）材料，以及两极之间填充的<strong>电解液</strong>和<strong>隔膜</strong>构成。下面的示意图展示了在充放电的时刻，电池内部锂离子的运动方向，以及外电路当中电流的运动方向：</p><p><img src="/Electronics/Battery/Basic-Theory.png"></p><p>锂离子电池（后续直接简称为<strong>锂电池</strong>）通常会使用循环次数和日历寿命两指标来表示电池的寿命：</p><ul><li><strong>循环次数</strong>：将电池从 <code>0％</code> 充电至<code>100％</code>，再从 <code>100％</code> 放电到 <code>0％</code>作为一个循环，能够反复进行充放电的次数。</li><li><strong>日历寿命</strong>：表示电池在规定的充电状态下即使静置也能够使用的时间，即从生产之日起至电池寿命结束的时间长度。</li></ul><p>在接下来的表格里，展示了三种常用电池（铅蓄电池、镍氢电池、锂离子电池）的循环次数和日历寿命：</p><table><thead><tr class="header"><th style="text-align: left;">电池类型</th><th style="text-align: left;">循环次数</th><th style="text-align: left;">日历寿命</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>铅蓄电池</strong></td><td style="text-align: left;"><code>3150 次</code></td><td style="text-align: left;"><code>17 年</code></td></tr><tr class="even"><td style="text-align: left;"><strong>镍氢电池</strong></td><td style="text-align: left;"><code>2000 次</code></td><td style="text-align: left;"><code>5~7 年</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>锂离子电池</strong></td><td style="text-align: left;"><code>3500 次</code></td><td style="text-align: left;"><code>6~10 年</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：虽然铅蓄电池的寿命长于锂离子电池，但是其能量密度相较于锂离子电池要差上许多。综合循环次数与日历寿命两个指标，</p></blockquote><h2 id="材料分类">材料分类</h2><p>根据<strong>正极</strong>材料所采用锂化合物的不同，可以将锂离子电池划分为如下几个种类：</p><ol type="1"><li><strong>钴酸锂</strong>电池：钴酸锂比较容易合成，但是钴是稀有金属，价格比较昂贵，并且化学性质非常活泼，需要限制充放电电流，避免出现热失控。</li><li><strong>锰酸锂</strong>电池：放电电压与钴酸锂电池相类似，但是制造成本更加低廉，但是充放电过程当中，锰可能会溶入电解质，缩短电池寿命。</li><li><strong>三元锂</strong>电池：即<strong>镍钴锰酸锂</strong>，优点在于安全性相对高，而且以铁作为原材料，生成成本相比锰酸锂更低，缺点在于放电电压非常低。</li><li><strong>磷酸铁锂</strong>电池：为了减少钴的用量，同时使用了钴、镍、锰三种材料，其中镍的比例较高，虽然放电电压相比钴酸锂、锰酸锂略低，但是能够降低生产成本，并且容量较高。但是缺点在于材料化学属性较为活泼，高温性能不稳定。</li><li><strong>钛酸锂</strong>电池：负极材料采用钛酸锂，正极材料采用上述其它几种锂离子材料，稳定性和安全性更好，循环寿命更长。但是价格昂贵，且能量密度过低，不太适合作为动力电池。</li></ol><p><img src="/Electronics/Battery/Li.png"></p><table><colgroup><col style="width: 13%"><col style="width: 8%"><col style="width: 13%"><col style="width: 10%"><col style="width: 10%"><col style="width: 14%"><col style="width: 8%"><col style="width: 21%"></colgroup><thead><tr class="header"><th style="text-align: left;">锂离子电池类型</th><th style="text-align: left;">标称电压</th><th style="text-align: left;">典型工作电压范围</th><th style="text-align: left;">充电截止电压</th><th style="text-align: left;">放电截止电压</th><th style="text-align: left;">循环寿命</th><th style="text-align: left;">热失控温度</th><th style="text-align: left;">容量（能量密度法，Wh/Kg）</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>钴酸锂</strong>电池</td><td style="text-align: left;"><code>3.6V</code></td><td style="text-align: left;"><code>3.0V ~ 4.2V</code></td><td style="text-align: left;"><code>4.2V</code></td><td style="text-align: left;"><code>2.5V</code></td><td style="text-align: left;"><code>500 ～ 1000</code> 次</td><td style="text-align: left;"><code>150°C</code></td><td style="text-align: left;"><code>150 ~ 200 Wh/Kg</code></td></tr><tr class="even"><td style="text-align: left;"><strong>锰酸锂</strong>电池</td><td style="text-align: left;"><code>3.7/3.8V</code></td><td style="text-align: left;"><code>3.0V ~ 4.2V</code></td><td style="text-align: left;"><code>4.2V</code></td><td style="text-align: left;"><code>2.5V</code></td><td style="text-align: left;"><code>300 ～ 700</code> 次</td><td style="text-align: left;"><code>250°C</code></td><td style="text-align: left;"><code>100 ~ 150 Wh/Kg</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>三元锂</strong>电池</td><td style="text-align: left;"><code>3.6/3.7V</code></td><td style="text-align: left;"><code>3.0V ~ 4.2V</code></td><td style="text-align: left;"><code>4.2V</code></td><td style="text-align: left;"><code>2.5V</code></td><td style="text-align: left;"><code>1000 ～ 2000</code> 次</td><td style="text-align: left;"><code>210°C</code></td><td style="text-align: left;"><code>150 ~ 220 Wh/Kg</code></td></tr><tr class="even"><td style="text-align: left;"><strong>磷酸铁锂</strong>电池</td><td style="text-align: left;"><code>3.2/3.3V</code></td><td style="text-align: left;"><code>2.5V ~ 3.65V</code></td><td style="text-align: left;"><code>3.65V</code></td><td style="text-align: left;"><code>2.5V</code></td><td style="text-align: left;"><code>1000 ～ 2000</code> 次</td><td style="text-align: left;"><code>270°C</code></td><td style="text-align: left;"><code>90 ~ 120 Wh/Kg</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>钛酸锂</strong>电池</td><td style="text-align: left;"><code>2.4V</code></td><td style="text-align: left;"><code>1.8V ~ 2.85V</code></td><td style="text-align: left;"><code>2.85V</code></td><td style="text-align: left;"><code>1.8V</code></td><td style="text-align: left;"><code>3000 ～ 7000</code> 次</td><td style="text-align: left;"><code>500°C</code></td><td style="text-align: left;"><code>50 ~ 80 Wh/Kg</code></td></tr></tbody></table><h2 id="封装规格">封装规格</h2><p>根据封装形式的不同，大体上可以将锂离子电池划分为<strong>软包</strong>（下图左，尺寸形状可定制）和<strong>金属壳</strong>（下图右，尺寸形状固定）两种类型，</p><p><img src="/Electronics/Battery/18650.png"></p><p>其中在 <a href="https://webstore.iec.ch/en/publication/27451"><strong>国际电工技术委员会IEC61960 规范</strong></a>当中，对于<strong>圆柱形金属壳</strong>锂离子电池的命名形式进行了定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正极材料代码 + 负极材料代码 + 直径 + 高度</span><br></pre></td></tr></table></figure><p>其中，<strong>正极</strong>材料包括有<code>C/U</code>（钴酸锂）、<code>M</code>（锰酸锂）、<code>NB</code>（氧化铌）、<code>V</code>（氧化钒）、<code>T</code>（钛酸锂），而<strong>负极</strong>材料包括有<code>C</code>（碳）、<code>L</code>（铝酸锂）、<code>S</code>（硅酸锂）、<code>T/TL</code>（钛酸锂）。除此之外，直径和高度的单位均为<code>mm</code><strong>毫米</strong>。为了书写方便，通常会省去前面的正负极材料代码，而直接使用外形尺寸来描述不同的电池规格。例如在下面的表格里，就展示了常用<strong>圆柱形金属壳</strong>锂离子电池的型号与规格：</p><table><thead><tr class="header"><th style="text-align: left;">型号</th><th style="text-align: left;">直径（mm）</th><th style="text-align: left;">高度（mm）</th><th style="text-align: left;">容量（时间乘积法，mAh）</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>14500</strong> 型</td><td style="text-align: left;"><code>14 毫米</code></td><td style="text-align: left;"><code>50 毫米</code></td><td style="text-align: left;"><code>800  ~ 1000 毫安时</code></td></tr><tr class="even"><td style="text-align: left;"><strong>18650</strong> 型</td><td style="text-align: left;"><code>18 毫米</code></td><td style="text-align: left;"><code>65 毫米</code></td><td style="text-align: left;"><code>2000 ~ 3500 毫安时</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>18500</strong> 型</td><td style="text-align: left;"><code>18 毫米</code></td><td style="text-align: left;"><code>50 毫米</code></td><td style="text-align: left;"><code>1000 ~ 2000 毫安时</code></td></tr><tr class="even"><td style="text-align: left;"><strong>26650</strong> 型</td><td style="text-align: left;"><code>26 毫米</code></td><td style="text-align: left;"><code>65 毫米</code></td><td style="text-align: left;"><code>3200 ~ 3500 毫安时</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>21700</strong> 型</td><td style="text-align: left;"><code>21 毫米</code></td><td style="text-align: left;"><code>70 毫米</code></td><td style="text-align: left;"><code>3000 ~ 4800 毫安时</code></td></tr><tr class="even"><td style="text-align: left;"><strong>32650</strong> 型</td><td style="text-align: left;"><code>32 毫米</code></td><td style="text-align: left;"><code>65 毫米</code></td><td style="text-align: left;"><code>4500 ~ 6500 毫安时</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>32700</strong> 型</td><td style="text-align: left;"><code>32 毫米</code></td><td style="text-align: left;"><code>70 毫米</code></td><td style="text-align: left;"><code>4500 ~ 6500 毫安时</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：上述表格当中，电池型号末尾的 <code>0</code>代表其为<strong>圆柱形</strong>锂电池。</p></blockquote><h2 id="串并联关系">串并联关系</h2><p>概而言之，电阻器是<strong>串联分压，并联分流</strong>，而锂电池则是<strong>串联增压，并联增流增容</strong>，它们各自的连接方式分别如下图所示：</p><p><img src="/Electronics/Battery/Series-Parallel.png"></p><ul><li><strong>串联</strong>（上图左）：将锂电池单体首尾相连，此时负载<code>Load</code> 两端的输出电压，等于各个单体的端电压之和<code>36V</code>。</li><li><strong>并联</strong>（上图右）：将锂电池单体的正极分别相互连接到一起，此时负载<code>Load</code> 两端的输出电压不变，输出电流等于各个单体的输出电流之和<code>3A</code>，并且最终构成的电池包总容量也会相应的提升至三个单体容量之和。</li></ul><blockquote><p><strong>注意</strong>：由单体<strong>锂电芯</strong>组成的<strong>锂电池包</strong>，其串并联关系的选型，要依据电源电路所需要的<strong>工作电压范围</strong>、后级负载的<strong>持续运行时间</strong>以及其所<strong>消耗的电流</strong>来综合进行判断。特别需要注意满足在后级负载<strong>上电启动</strong>的一瞬间，所产生的<strong>瞬时峰值电流</strong>需求。最好先将后级负载连接至<strong>可编程电源</strong>，观察一下该峰值电流的大小，并以该电流值作为锂电池包输出电流的<strong>上限值</strong>来进行选型，并且尽量保留一定的性能冗余。</p></blockquote><h2 id="电池容量">电池容量</h2><p>锂电池容量的计算方法，根据表达意义所侧重的不同，可以进一步划分为<strong>能量密度法</strong>和<strong>时间乘积法</strong>两种方式：</p><ul><li><strong>能量密度法</strong>：即电池容量与电池质量的比值，通常以<strong>瓦时/千克</strong>（<code>Wh/kg</code>）作为单位进行表示。</li><li><strong>时间乘积法</strong>：通常以<strong>安时</strong>（<code>Ah</code>，Ampere-hour）作为单位，表示在一定放电条件下（环境温度<code>25°C</code>左右），其所能够提供的电流和持续时间的乘积。例如，如果一节锂电池能够以 1安培的电流持续放电 1 小时，那么其容量就等于 <code>1Ah</code> 安时。</li></ul><blockquote><p><strong>注意</strong>：这两种表达方式都已经体现到了前述内容的表格当中。</p></blockquote><h2 id="充放电倍率">充放电倍率</h2><p><strong>充放电倍率</strong> <code>C</code>用于表示锂电池在单位时间内，完全放电所输出的电流大小。例如一节标称为<code>3300mAh</code> 容量的 18650 型三元锂电池，其放电倍率为<code>3C</code>，则其以 1 小时单位时间内进行放电，输出的电流应当为<code>9.9A</code> 安培，具体计算公式如下所示：</p><p><span class="math display">\[I_{输出电流} = C_{充放电倍率} \times P_{锂电池额定容量}\]</span></p><p>根据放电倍率的不同，还可以将锂电池划分为<strong>功率/动力型</strong>（放电倍率大于<code>10C</code>）和<strong>容量型</strong>（放电倍率<code>1C ~ 3C</code>）两种类型。下图是某国产 18650型锂电池的规格书，注意其中关于锂电池充放电倍率的描述：</p><p><img src="/Electronics/Battery/Datasheet.png"></p><h2 id="锂电池内阻">锂电池内阻</h2><p>锂电池的内阻是指电池在工作时，电流经过电池内部所受到的阻力（不是常量，会随时间和温度变化）。主要由<strong>欧姆内阻</strong>（电解液、电极材料、隔膜的体电阻或者接触电阻）和<strong>极化内阻</strong>（正负极发生电化学反应时极化所产生的阻抗）两个部分组成。</p><p>较低的锂电池内阻可以减少充放电过程当中的能量损失，也有助于降低锂电池在大电流充放电时候所产生的热量，从而降低热失控的风险。除此之外，锂电池内阻的增高通常与锂电池内部材料的老化过程相关，因而监测内阻的变化对于预测电池的健康状态也具有重要意义。锂电阻的内阻测量方法主要包括直流和交流两种：</p><ul><li><strong>直流测量法</strong>：通过在锂电池两端施加恒定电压并测量通过锂电池的电流来计算内阻。</li><li><strong>交流测量法</strong>：通过在锂电池两端施加小幅的交流电压，并测量其电流响应来计算内阻。</li></ul><h2 id="充电过程">充电过程</h2><p>为了确保锂电池充电过程的安全，需要采用特定的电流与电压（即<strong>限压恒流</strong>）进行充电，整个充电过程主要划分为<strong>涓流充电</strong>、<strong>恒流充电</strong>、<strong>恒压充电</strong>三个阶段，下面以三元锂电池的充电过程为例进行说明：</p><p><img src="/Electronics/Battery/Charge.png"></p><ul><li><strong>涓流充电</strong>：当电池电压低于 <code>3V</code>时进行低压预充，充电电流为恒流充电倍率的 <code>0.1C</code>。</li><li><strong>恒流充电</strong>：当电池电压上升至涓流充电电压的阈值之上时，就可以提高充电电流至<code>0.2C ~ 1C</code> 进行恒流充电，当电池电压上升至 <code>4.2V</code>时，恒流充电结束。</li><li><strong>恒压充电</strong>：保持充电电压为<code>4.2V</code>，伴随着电池电量的逐渐饱和，当充电电流逐渐减小至<code>0.01C</code> 的时候，就可以终止充电。</li></ul><h2 id="bms-充放电参数">BMS 充放电参数</h2><p>接下来的内容，展示了锂离子<strong>电池管理系统</strong>（BMS，BatteryManagement System）固件开发过程当中，一些常用的头文件配置参数：</p><ol type="1"><li><strong>单体过压保护电压</strong>：单节锂电池的过压保护值，充电时不得超过该上限电压（厂家数据手册）。</li><li><strong>单体过压恢复电压</strong>：低于该参数的时候，就可以认为单节锂电池已经处于不饱和状态（可自定义）。</li><li><strong>单体欠压保护电压</strong>：单节锂电池低于该电压的时候，就会停止继续放电，避免损坏电池（厂家数据手册）。</li><li><strong>单体欠压恢复电压</strong>：单节锂电池高于该电压的时候，可以认为其已经退出欠压保护状态（可自定义）。</li><li><strong>自动关机电压</strong>：低于该电压，就会关闭硬件系统（可自定义）。</li><li><strong>均衡起始电压</strong>：高于该参数时，就会启动电池均衡过程（可自定义）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 三元锂（Trihydride Lithium）电池 BMS 参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Over_Voltage_Protect   4.20 <span class="comment">// 单体过压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Over_Voltage_Rcovery   4.18 <span class="comment">// 单体过压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Under_Voltage_Protect  2.65 <span class="comment">// 单体欠压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Under_Voltage_Rcovery  2.70 <span class="comment">// 单体欠压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Shutdown_Voltage       3.00 <span class="comment">// 自动关机电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Balance_Voltage        3.30 <span class="comment">// 均衡起始电压</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 磷酸铁锂（Lithium Iron Phosphate）电池 BMS 参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Over_Voltage_Protect   3.60 <span class="comment">// 单体过压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Over_Voltage_Rcovery   3.55 <span class="comment">// 单体过压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Under_Voltage_Protect  2.60 <span class="comment">// 单体欠压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Under_Voltage_Rcovery  2.65 <span class="comment">// 单体欠压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Shutdown_Voltage       2.50 <span class="comment">// 自动关机电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TL_Balance_Voltage        3.00 <span class="comment">// 均衡起始电压</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 钛酸锂（Lithium Titanate）电池 BMS 参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Over_Voltage_Protect   2.70 <span class="comment">// 单体过压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Over_Voltage_Rcovery   2.65 <span class="comment">// 单体过压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Under_Voltage_Protect  1.80 <span class="comment">// 单体欠压保护电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Under_Voltage_Rcovery  1.85 <span class="comment">// 单体欠压恢复电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Shutdown_Voltage       1.70 <span class="comment">// 自动关机电压</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT_Balance_Voltage        2.30 <span class="comment">// 均衡起始电压</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;锂离子电池&lt;/strong&gt;是一种采用锂金属化合物作为正负极材料，中间再填充电解质溶液的化学电池，属于一种可反复充放电的&lt;strong&gt;二次电池&lt;/strong&gt;。内部主要依靠&lt;strong&gt;锂离子&lt;/strong&gt;在正极与负极之间的移动来进行充放电。在充放电过程中，锂离子在两个电极之间不断的往返，嵌入正负极材料或者从正负极材料当中脱嵌。例如在充电时，锂离子就会从正极材料脱嵌，穿过电解质溶液之后再嵌入负极材料，使得负极逐渐呈现出富锂状态，而在放电的时候这个化学过程正好相反。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/Battery/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;长期以来，围绕锂离子电池安全性的话题层出不穷，大量的行业规范与政策法规，伴随着锂离子电池的大规模市场化应用而被不断推出。自从
2024 年 8 月 1 日起，我国已经对锂离子电池实施 &lt;strong&gt;3C&lt;/strong&gt;
强制认证管理，未获得 &lt;strong&gt;3C&lt;/strong&gt; 认证并且标注
&lt;strong&gt;3C&lt;/strong&gt;
认证标识的锂电池产品，将不得出厂进行销售和进行其它经营活动。本文总结了各类锂离子电池材料的特性，以及选型过程当中的一些重要事项，希冀能够对于广大电子工程师的物料选型工作有所裨益。&lt;/p&gt;</summary>
    
    
    
    <category term="电子硬件" scheme="http://www.uinio.com/categories/%E7%94%B5%E5%AD%90%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="电池" scheme="http://www.uinio.com/tags/%E7%94%B5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何使用新版本的 LTspice 进行模拟电路仿真</title>
    <link href="http://www.uinio.com/Electronics/LTspice/"/>
    <id>http://www.uinio.com/Electronics/LTspice/</id>
    <published>2024-05-21T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:49.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>集成电路仿真程序</strong>（<strong>SPICE</strong>，SimulationProgram with Integrated CircuitsEmphasis）是一款以<strong>文本</strong>进行描述，可以通过<strong>数学</strong>方法来预测电路行为的仿真工具，也是电子自动化设计与现代半导体工业的基石。其被广泛应用于<strong>模拟电路</strong>（例如运放算放大器、稳压电源，模数与数模转换等），<strong>混合信号电路</strong>（锁相环、存储器、高速GPIO），<strong>精密数字电路</strong>（延时、时序、功耗、漏电流等）等场景的模拟与仿真（大型电子元器件生产企业通常都提供了元件配套的<a href="https://www.ni.com/zh-cn/shop/electronic-test-instrumentation/application-software-for-electronic-test-and-instrumentation-category/what-is-multisim/spice-simulation-fundamentals/spice-simulation-models.html">SPICE模型</a>）。</p><p><img src="/Electronics/LTspice/logo.png"></p><p><a href="https://www.analog.com/cn/index.html"><strong>亚德诺半导体公司</strong></a>（AnalogDevices）推出的 <strong>LTspice</strong>是一款界面简洁，但是功能强大的免费 <strong>SPICE</strong>电路仿真工具，其可以基于原理图快速准确的生成仿真结果，并且将这些结果通过内置的波形查看器进行展示，除此之外还内置有丰富的SPICE 模型（包含有基本的<strong>无源元件</strong>以及 ADI公司的<code>电源管理</code>和<code>信号链</code>产品），可以预先为模拟电路的设计以及元器件的选型提供重要的实验数据参考，从而降低电路设计过程当中产生的各种试错成本，有效的提高设计工作效率。</p><span id="more"></span><h2 id="基础操作">基础操作</h2><p><strong>LTspice</strong> 自带有一系列后缀名称为 <code>.asc</code>的<strong>仿真原理图示例文件</strong>，它们都位于 Windows 操作系统的<code>C:\Users\hank\AppData\Local\LTspice\examples</code>目录下面，主要包含有如下两个目录：</p><ul><li><strong>Educational目录</strong>：提供有一些基础的参考示例电路。</li><li><strong>Applications目录</strong>：亚德诺半导体公司产品相关的仿真原理图。</li></ul><p>在 <strong>LTspice</strong> 的主界面，鼠标依次点击菜单栏上的【File-&gt; Open Examples...】，就可以打开 <code>examples</code>目录，从而可以查看选中的 <code>.asc</code> 仿真原理图文件：</p><p><img src="/Electronics/LTspice/1-Basic/1.png"></p><p>这里打开 <code>Educational</code> 目录下的 <code>colpits.asc</code>振荡电路示例文件，然后按下键盘上的【<strong>空格</strong>】键，就可以将仿真原理图缩放至一个适配当前屏幕的显示尺寸：</p><p><img src="/Electronics/LTspice/1-Basic/2.png"></p><blockquote><p><strong>注意</strong>：鼠标滚轮向前是<strong>缩小</strong>操作，鼠标滚轮向后是<strong>放大</strong>操作。</p></blockquote><p>鼠标点击 <strong>LTspice</strong>顶部菜单栏上的【<strong>Run/Pause</strong>】按钮，或者按下快捷键【<strong>Alt+ R</strong>】，此时就会在 <code>Educational</code> 目录下自动生成一个<code>colpits.raw</code><strong>波形数据文件</strong>，同时也会在主界面打开一个可以单独进行<code>拖动</code>、<code>关闭</code>、<code>最大化</code>、<code>最小化</code>的波形数据预览窗口：</p><p><img src="/Electronics/LTspice/1-Basic/3.png"></p><p>鼠标点击 <strong>LTspice</strong> 顶部菜单栏上的【<strong>Window-&gt; TileHorizontally/Vertically</strong>】按钮，可以设置主界面当中窗口的平铺方向（<code>垂直</code>或者<code>水平</code>）：</p><p><img src="/Electronics/LTspice/1-Basic/4.png"></p><p>此时，把鼠标移动到主界面右侧的 <code>colpits.asc</code>仿真原理图上面，就可以使用下图所示的<strong>电压探头</strong>或者<strong>电流探头</strong>（会有<strong>箭头</strong>标识出电流的方向），查看该<strong>点</strong>所对应的电压或者电流信号的情况：</p><p><img src="/Electronics/LTspice/1-Basic/5.png"></p><p>电压与电流信号的相关波形，将会自动展示到主界面当中的<code>colpits.raw</code> 波形数据文件预览窗口：</p><p><img src="/Electronics/LTspice/1-Basic/6.png"></p><blockquote><p><strong>注意</strong>：除此之外，按下键盘上的【<strong>ALT</strong>】键不放，将鼠标移动到仿真电路当中的元器件上面，此时鼠标会显示为一个<strong>温度计符号</strong>，按下鼠标左键就可以在<strong>波形显示窗口</strong>查看到该元器件所消耗的功率情况。</p></blockquote><p>使用鼠标框选 <code>colpits.raw</code>波形数据文件预览窗口当中的波形，就可以放大该区域的波形细节（此时如果按下【<strong>空格键</strong>】或者在波形上展开鼠标右键菜单点击【<strong>Zoomto Fit</strong>】可以恢复波形预览到初始状态）：</p><p><img src="/Electronics/LTspice/1-Basic/7.png"></p><p><img src="/Electronics/LTspice/1-Basic/8.png"></p><blockquote><p><strong>注意</strong>：当使用 <strong>LTspice</strong>绘制仿真原理图的时候，必须手动为<strong>电源负极</strong>添加一个<code>GND</code> 符号。</p></blockquote><h2 id="常用快捷键">常用快捷键</h2><p>在下面的表格里，展示了 <strong>LTspice</strong>当中使用频率非常高的一些快捷键（这些快捷键也可以通过展开菜单栏上的【<strong>Edit</strong>】进行查看或者使用）：</p><table><colgroup><col style="width: 42%"><col style="width: 33%"><col style="width: 23%"></colgroup><thead><tr class="header"><th style="text-align: left;">快捷键</th><th style="text-align: left;">英文</th><th style="text-align: left;">中文</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">【<strong>Ctrl + Z</strong>】</td><td style="text-align: left;">Undo</td><td style="text-align: left;">撤消</td></tr><tr class="even"><td style="text-align: left;">【<strong>Ctrl + Shift + Z</strong>】</td><td style="text-align: left;">Redo</td><td style="text-align: left;">重做</td></tr><tr class="odd"><td style="text-align: left;">【<strong>T</strong>】</td><td style="text-align: left;">Text</td><td style="text-align: left;">文本</td></tr><tr class="even"><td style="text-align: left;">【 <strong>.</strong> 】</td><td style="text-align: left;">SPICE Directive</td><td style="text-align: left;">输入 SPICE 点命令</td></tr><tr class="odd"><td style="text-align: left;">【<strong>A</strong>】</td><td style="text-align: left;">Configure SPICE Analysis</td><td style="text-align: left;">SPICE 分析配置</td></tr><tr class="even"><td style="text-align: left;">【<strong>R</strong>】</td><td style="text-align: left;">Resistor</td><td style="text-align: left;">电阻</td></tr><tr class="odd"><td style="text-align: left;">【<strong>C</strong>】</td><td style="text-align: left;">Capacitor</td><td style="text-align: left;">电容</td></tr><tr class="even"><td style="text-align: left;">【<strong>L</strong>】</td><td style="text-align: left;">Inductor</td><td style="text-align: left;">电感</td></tr><tr class="odd"><td style="text-align: left;">【<strong>D</strong>】</td><td style="text-align: left;">Diode</td><td style="text-align: left;">二极管</td></tr><tr class="even"><td style="text-align: left;">【<strong>P</strong>】</td><td style="text-align: left;">Component</td><td style="text-align: left;">放置元件</td></tr><tr class="odd"><td style="text-align: left;">【<strong>Ctrl + R</strong>】</td><td style="text-align: left;">Rotate</td><td style="text-align: left;">旋转</td></tr><tr class="even"><td style="text-align: left;">【<strong>Ctrl + E</strong>】</td><td style="text-align: left;">Mirror</td><td style="text-align: left;">镜像</td></tr><tr class="odd"><td style="text-align: left;">【<strong>W</strong>】</td><td style="text-align: left;">Draw Wire</td><td style="text-align: left;">绘制连线</td></tr><tr class="even"><td style="text-align: left;">【<strong>N</strong>】</td><td style="text-align: left;">Label Net</td><td style="text-align: left;">网络标号</td></tr><tr class="odd"><td style="text-align: left;">【<strong>G</strong>】</td><td style="text-align: left;">Place GND</td><td style="text-align: left;">放置 GND 标签</td></tr><tr class="even"><td style="text-align: left;">【<strong>B</strong>】</td><td style="text-align: left;">Place BUS tap</td><td style="text-align: left;">放置总线抽头</td></tr><tr class="odd"><td style="text-align: left;">【<strong>M</strong>】</td><td style="text-align: left;">Move</td><td style="text-align: left;">移动</td></tr><tr class="even"><td style="text-align: left;">【<strong>S</strong>】</td><td style="text-align: left;">Stretch</td><td style="text-align: left;">伸缩</td></tr><tr class="odd"><td style="text-align: left;">【<strong>Backspace</strong>】或【<strong>Del</strong>】</td><td style="text-align: left;">Delete</td><td style="text-align: left;">删除</td></tr><tr class="even"><td style="text-align: left;">【<strong>Ctrl + C</strong>】</td><td style="text-align: left;">Duplicate</td><td style="text-align: left;">复制</td></tr><tr class="odd"><td style="text-align: left;">【<strong>Ctrl + V</strong>】</td><td style="text-align: left;">Paste</td><td style="text-align: left;">粘贴</td></tr></tbody></table><h2 id="快捷键设置">快捷键设置</h2><p>鼠标依次点击 <strong>LTspice</strong> 菜单栏上的【<strong>Simulate-&gt;Settings</strong>】打开设置对话框，选中该对话框里的【<strong>Schematic</strong>】选项卡，按下该界面上的【<strong>KeyboardShortcuts[*]</strong>】按钮：</p><p><img src="/Electronics/LTspice/2-Shortkey/1.png"></p><p>这样就可以查看和修改 <strong>LTspice</strong>全部的快捷键设置，其最新的 <code>24.0.0</code>版本与早期其它版本的默认快捷键设置有所不同，具体请参考如下界面当中的默认设置：</p><p><img src="/Electronics/LTspice/2-Shortkey/2.png"></p><h2 id="常量符号">常量符号</h2><table><colgroup><col style="width: 23%"><col style="width: 17%"><col style="width: 23%"><col style="width: 34%"></colgroup><thead><tr class="header"><th style="text-align: center;">LTspice 常量符号</th><th>释义</th><th style="text-align: center;">LTspice 常量符号</th><th>释义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>e</code></td><td>欧拉数</td><td style="text-align: center;"><code>true</code></td><td><span class="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>pi</code></td><td>圆周率 <span class="math inline">\(\pi\)</span></td><td style="text-align: center;"><code>false</code></td><td><span class="math inline">\(0\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>k</code></td><td>波尔兹曼常数</td><td style="text-align: center;"><code>mil</code></td><td><span class="math inline">\(25.4 \times 10^{-6} m\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>q</code></td><td>电荷常数</td><td style="text-align: center;">-</td><td>-</td></tr></tbody></table><h2 id="单位符号">单位符号</h2><table><thead><tr class="header"><th style="text-align: center;">单位名称</th><th style="text-align: center;">LTspice 单位符号</th><th style="text-align: center;">英文释义</th><th style="text-align: center;">数量级</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>太</strong></td><td style="text-align: center;"><code>T</code> 或者 <code>t</code></td><td style="text-align: center;">Tera</td><td style="text-align: center;"><span class="math inline">\(10^{12}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>吉</strong></td><td style="text-align: center;"><code>G</code> 或者 <code>g</code></td><td style="text-align: center;">Giga</td><td style="text-align: center;"><span class="math inline">\(10^{9}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>兆</strong></td><td style="text-align: center;"><code>meg</code></td><td style="text-align: center;">Mega</td><td style="text-align: center;"><span class="math inline">\(10^{6}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>千</strong></td><td style="text-align: center;"><code>K</code> 或者 <code>k</code></td><td style="text-align: center;">Kilo</td><td style="text-align: center;"><span class="math inline">\(10^{3}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>毫</strong></td><td style="text-align: center;"><code>M</code> 或者 <code>m</code></td><td style="text-align: center;">Milli</td><td style="text-align: center;"><span class="math inline">\(10^{-3}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>微</strong></td><td style="text-align: center;"><code>U</code> 或者 <code>u</code></td><td style="text-align: center;">Micro</td><td style="text-align: center;"><span class="math inline">\(10^{-6}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>纳</strong></td><td style="text-align: center;"><code>N</code> 或者 <code>n</code></td><td style="text-align: center;">Nano</td><td style="text-align: center;"><span class="math inline">\(10^{-9}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>皮</strong></td><td style="text-align: center;"><code>P</code> 或者 <code>p</code></td><td style="text-align: center;">Pico</td><td style="text-align: center;"><span class="math inline">\(10^{-12}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>飞</strong></td><td style="text-align: center;"><code>F</code> 或者 <code>f</code></td><td style="text-align: center;">Femto</td><td style="text-align: center;"><span class="math inline">\(10^{-15}\)</span></td></tr></tbody></table><blockquote><p><strong>注意</strong>：表达 <span class="math inline">\(10^6\)</span>数量级要使用 <code>MEG</code> 或者 <code>meg</code>，而不是使用<code>M</code> 或者 <code>m</code>；电容器的参数设置里输入<code>1</code> 表示的是 <code>1</code> 法拉第，而不能使用<code>1F</code> 或者 <code>1f</code>。</p></blockquote><h2 id="spice-点命令">SPICE 点命令</h2><p><strong>LTspice</strong> 当中运行的 SPICE 命令总是以一个点<code>.</code>作为前缀，因而也被称作<strong>点命令</strong>，常用的点命令如下面的表格所示：</p><table><colgroup><col style="width: 8%"><col style="width: 60%"><col style="width: 30%"></colgroup><thead><tr class="header"><th>点命令</th><th>英文描述</th><th>中文描述</th></tr></thead><tbody><tr class="odd"><td><code>.AC</code></td><td>Perform an Small Signal AC Analysis Linearized About the DCOperating Point</td><td>进行关于直流工作点的线性小信号交流分析</td></tr><tr class="even"><td><code>.BACKANNO</code></td><td>Annotate the Subcircuit Pin Names on Port Currents</td><td>在端口电流上面标注子电路的引脚名称</td></tr><tr class="odd"><td><code>.DC</code></td><td>Perform a DC Source Sweep Analysis</td><td>执行直流源扫描分析</td></tr><tr class="even"><td><code>.END</code></td><td>End of Netlist</td><td>标识网表的结束</td></tr><tr class="odd"><td><code>.ENDS</code></td><td>End of Subcircuit Definition</td><td>标识子电路定义的结束</td></tr><tr class="even"><td><code>.FERRET</code></td><td>Download a File Given the URL</td><td>从指定的 URL 地址下载文件</td></tr><tr class="odd"><td><code>.FOUR</code></td><td>Compute a Fourier Component</td><td>计算傅里叶分量</td></tr><tr class="even"><td><code>.FRA</code></td><td>Perfom a Time-Domain Frequency Response Analysis</td><td>执行时域频率响应分析</td></tr><tr class="odd"><td><code>.FUNC</code></td><td>User Defined Functions</td><td>用户定义的功能</td></tr><tr class="even"><td><code>.GLOBAL</code></td><td>Declare Global Nodes</td><td>声明全局节点</td></tr><tr class="odd"><td><code>.IC</code></td><td>Set Initial Conditions</td><td>设置初始条件</td></tr><tr class="even"><td><code>.INCLUDE</code></td><td>Include Another File</td><td>包含另一个文件</td></tr><tr class="odd"><td><code>.LIB</code></td><td>Include a Library</td><td>包含一个库</td></tr><tr class="even"><td><code>.LOADBIAS</code></td><td>Load a Previously Solved DC Solution</td><td>加载已经解析过的直流解决方案</td></tr><tr class="odd"><td><code>.MACHINE</code></td><td>Arbitrary State Machine</td><td>任意状态机</td></tr><tr class="even"><td><code>.MEASURE</code></td><td>Evaluate User-Defined Electrical Quantities</td><td>求解用户自定义的工程量</td></tr><tr class="odd"><td><code>.MODEL</code></td><td>Define a SPICE Model</td><td>定义一个 SPICE 模型</td></tr><tr class="even"><td><code>.NET</code></td><td>Compute Network Parameters in a .AC Analysis</td><td>在一个交流分析当中，计算电路网络的参数</td></tr><tr class="odd"><td><code>.NODESET</code></td><td>Supply Hints for Initial DC Solution</td><td>为初始的直流解决方案提供提示</td></tr><tr class="even"><td><code>.NOISE</code></td><td>Perform a Noise Analysis</td><td>进行噪音分析</td></tr><tr class="odd"><td><code>.OP</code></td><td>Find the DC Operating Point</td><td>查询直流工作点</td></tr><tr class="even"><td><code>.OPTIONS</code></td><td>Set Simulator Options</td><td>设置仿真工具的选项</td></tr><tr class="odd"><td><code>.PARAM</code></td><td>User-Defined Parameters</td><td>用户定义的参数</td></tr><tr class="even"><td><code>.SAVE</code></td><td>Limit the Quantity of Saved Data</td><td>限制保存数据的数量</td></tr><tr class="odd"><td><code>.SAVEBIAS</code></td><td>Save Operating Point to Disk</td><td>保存工作点到磁盘</td></tr><tr class="even"><td><code>.STEP</code></td><td>Parameter Sweeps</td><td>参数扫描</td></tr><tr class="odd"><td><code>.SUBCKT</code></td><td>Define a Subcircuit</td><td>定义一个子电路</td></tr><tr class="even"><td><code>.TEMP</code></td><td>Temperature Sweeps</td><td>温度扫描</td></tr><tr class="odd"><td><code>.TEXT</code></td><td>User-Defined Strings</td><td>用户定义的字符串</td></tr><tr class="even"><td><code>.TF</code></td><td>Find the DC Small-Signal Transfer Function</td><td>查找直流小信号传递函数</td></tr><tr class="odd"><td><code>.TRAN</code></td><td>Do a Nonlinear Transient Analysis</td><td>执行非线性瞬态分析</td></tr><tr class="even"><td><code>.WAVE</code></td><td>Write Selected Nodes to a .Wav File</td><td>将选定的节点写入 <code>.wav</code> 文件</td></tr></tbody></table><blockquote><p><strong>注意</strong>：在 <code>.asc</code>源文件当中，<strong>点命令</strong>以 <code>!</code>符号作为开始，而<strong>注释</strong>则是以 <code>;</code>作为开始。</p></blockquote><h2 id="spice-分析类型">SPICE 分析类型</h2><p>鼠标点击 <strong>LTspice</strong>主界面顶部菜单栏上的【<strong>Simulate -&gt; ConfigureAnalysis</strong>】或者直接按下快捷键【<strong>A</strong>】，就可以进入如下的 SPICE仿真命令配置对话框：</p><p><img src="/Electronics/LTspice/3-SPICE/1.png"></p><h3 id="瞬态分析-transient">瞬态分析 Transient</h3><p>瞬态分析指令 <code>.tran</code>用于描述电路当中，各个节点的<strong>电压</strong>与通过元件的<strong>电流</strong>跟随时间的变化关系，即仿真电路在<strong>时域</strong>下的行为：</p><p><img src="/Electronics/LTspice/3-SPICE/2.png"></p><p>瞬态分析指令 <code>.tran</code> 主要拥有如下几个参数：</p><ul><li><code>StopTime</code>：停止时间，该参数用于以<strong>秒</strong>为单位设定仿真的持续时间。</li><li><code>Time to Start Saving Data</code>：仿真数据保存至<code>.raw</code> 波形文件的开始时间。</li><li><code>Maximum Timestep</code>：最大时间间隔，也就是时间的步进长度（缺省表示无限大）。</li></ul><p>瞬态分析指令 <code>.tran</code> 主要拥有如下几个修饰符：</p><ul><li><code>Start external DC supply voltages at 0V</code>：让直流电源从<code>0V</code> 开始上升，并于 <code>20</code>微秒之后达到设定的电压值。</li><li><code>Stop simulating if steady state is detected</code>：如果检测到稳定状态就会停止仿真（只会保存最后10 组重复数据）。</li><li><code>Don't reset = 0 when steady state is detected</code>：如果检测到稳定状态就会停止仿真（将会保存全部数据）。</li><li><code>Step the load current source</code>：使用电流源作为负载时，可以使得负载的电流值逐步变化（即每达到一个稳定状态之后，就会向下变换为另外一个电流值）。</li><li><code>Skip initial operating point solution</code>：启用元器件的初始状态值。</li></ul><h3 id="交流分析-ac-analysis">交流分析 AC Analysis</h3><p>交流分析指令 <code>.ac</code>可以用于分析小信号的交流频率特性，即仿真电路在<strong>频域</strong>下的行为（由于目标分析频率处于<code>0.1Hz ~ 100MHz</code>之间较为宽广的范围，所以频率轴通常被表达为<strong>对数刻度</strong>，计算基准可以设置为每间隔<code>2</code> 倍或者 <code>10</code> 倍）：</p><p><img src="/Electronics/LTspice/3-SPICE/3.png"></p><ul><li><code>Type of sweep</code>：扫描类型，每两倍（<code>Octave</code>）、每十倍（<code>Decade</code>）、线性（<code>Linear</code>）、列表（<code>List</code>）。</li><li><code>Number of points per X</code>：这里的 <code>X</code>是上面设置的扫描类型，通常在 <code>Octave</code> 情况下配置为<code>20 ~ 40</code> 点，而在 <code>Decade</code> 情况下配置为<code>30 ~ 100</code>点。虽然点的数量越多就越精确，但是会花费掉额外的计算时间，所以需要具体情况具体分析。</li><li><code>Start fequency</code>：计算开始频率，单位为<code>Hz</code>。</li><li><code>Stop fequency</code>：计算截止频率，单位为<code>Hz</code>。</li></ul><h3 id="直流扫描分析-dc-sweep">直流扫描分析 DC Sweep</h3><p>直流扫描分析指令 <code>.dc</code>可以动态变换直流源的输出值（最大可以设置 3组扫描变量），可以用于分析<strong>二极管</strong>的伏安特性，<strong>晶体管</strong>的静态特性（将基极电流作为参数，观察集电极电流的变化情况），以及<strong>放大器</strong>的输入输出关系：</p><p><img src="/Electronics/LTspice/3-SPICE/4.png"></p><ul><li><code>Name of 1st/2nd/3rd Source to Sweep</code>：输入用于扫描的电压源、电流源的元件名名称，例如<code>V1</code> 或者 <code>I2</code>。</li><li><code>Type of Sweep</code>：每两倍（<code>Octave</code>）、每十倍（<code>Decade</code>）、线性（<code>Linear</code>）、列表（<code>List</code>）。</li><li><code>Start Value</code>：扫描起始的电压或者电流。</li><li><code>Stop Value</code>：扫描结束的电压或者电流。</li><li><code>Increment</code>：扫描增量，即间隔的幅度值。</li></ul><h3 id="噪声分析-noise">噪声分析 Noise</h3><p>噪声分析指令 <code>.noise</code>用于仿真电路当中<strong>输入</strong>与<strong>输出</strong>相关的频率噪声特性，也就是在<strong>频域</strong>下进行噪声分析（<strong>横轴</strong>是<code>频率</code>，<strong>纵轴</strong>是<code>噪声密度</code>）。其中噪声的单位为<span class="math inline">\(\frac{nV}{\sqrt{Hz}}\)</span>（如果想分析某个<strong>频带</strong>的噪声，只需要将该频带振幅的<strong>频率</strong>进行平方之后，再乘以噪声的<strong>电压密度</strong>即可推算出来）。</p><p><img src="/Electronics/LTspice/3-SPICE/5.png"></p><ul><li><code>Input</code>：输入噪声的结点网络标签。</li><li><code>Qutput</code>：输出噪声的结点网络标签。</li><li><strong>其它参数</strong>：与交流分析（ACAnalysis）相关的参数相同。</li></ul><blockquote><p><strong>注意</strong>：在该模式下按住键盘上的【<strong>CTRL</strong>】键，然后鼠标左键点击波形预览窗口上的<span class="math inline">\(V(onoise)\)</span>标签，就可以查看<strong>总电压噪声</strong>的均方根值（<strong>RMS</strong>，RootMean Square）。</p></blockquote><h3 id="直流传递分析-dc-transfer">直流传递分析 DC Transfer</h3><p>直流传输分析命令 <code>.tf</code>通过将偏置点附近的微小变化视为直线，从而计算出小信号的<strong>输入输出的传递函数值</strong>，以及<strong>输入阻抗</strong>和<strong>输出阻抗</strong>。</p><p><img src="/Electronics/LTspice/3-SPICE/6.png"></p><ul><li><code>Source</code>：电压源或者电流源的网络标签名称（不能使用<code>节点电压</code>、<code>元件电流</code>的名称）。</li><li><code>Output</code>：指定结点的电压，或者指定元件上面通过的电流。</li></ul><blockquote><p><strong>注意</strong>：<strong>传递函数</strong>用于描述一个电路网络的<strong>输出</strong>与<strong>输入</strong>的拉普拉斯变换之比。</p></blockquote><h3 id="直流工作点分析-dc-op-pnt">直流工作点分析 DC op pnt</h3><p>直流工作点分析指令 <code>.op</code>用于分析晶体管电路当中不含有交流成分的直流偏置信号，该指令通常不会单独使用，而是会与其它分析方式结合起来使用。这条指令没有扩展的修饰词，所以在点击下面界面当中的【<strong>OK</strong>】按钮之后，就可以将该指令放置在仿真原理图上的任意位置进行执行：</p><p><img src="/Electronics/LTspice/3-SPICE/7.png"></p><blockquote><p><strong>注意</strong>：当在仿真原理图上放置好 <code>.op</code>命令，并且运行完毕之后，就会自动弹出一个【OperatingPoint】工作点列表窗口界面。</p></blockquote><h3 id="瞬态频率响应分析-transient-frequency-response">瞬态频率响应分析Transient Frequency Response</h3><p>瞬态频率响应分析指令 <code>.fra</code>用于分析电路反馈回路的频率响应，使用时仿真原理图电路当中必须包含有一个以<code>@</code> 作为前缀的<strong>频率响应分析器</strong>（FRA，FrequencyResponse Analyzer），：</p><p><img src="/Electronics/LTspice/3-SPICE/8.png"></p><p>选择 <strong>LTspice</strong> 菜单栏上的【Edit -&gt;Component】或者直接按下快捷键【<strong>P</strong>】，然后在元件对话框的<strong>Search</strong> 里输入<code>fra</code>，就可以完成频率响应分析器的放置：</p><p><img src="/Electronics/LTspice/3-SPICE/9.png"></p><p>运用 <code>.fra</code>指令的时候，需要对<strong>频率响应分析器</strong>的相关分析参数进行详细配置，这些配置参数被划分为了<strong>分析类型</strong>、<strong>激励频率</strong>、<strong>激励幅值</strong>、<strong>通用</strong>四个部分：</p><p><img src="/Electronics/LTspice/3-SPICE/10.png"></p><h2 id="独立电压-电流源">独立电压 &amp; 电流源</h2><h3 id="独立电压源">独立电压源</h3><p>在 <strong>LTspice</strong>仿真原理图编辑界面，按下快捷键【<strong>P</strong>】，在弹出的元件选择窗口<strong>Search</strong> 里输入<code>voltage</code>，然后点击【确定】按钮，就可以向当前的仿真原理图上添加一个独立电压源：</p><p><img src="/Electronics/LTspice/4-Source/1.png"></p><p>在仿真原理图的电压源符号上点击【鼠标右键】，就会弹出一个电压源参数设置窗口，可以用于输入<code>电源的直流输出电压值</code>(单位为伏特<code>V</code>)，以及<code>电源的内阻</code>(单位为欧姆<code>Ω</code>)：</p><p><img src="/Electronics/LTspice/4-Source/2.png"></p><p>此时如果点击电压源参数设置窗口上的【<strong>Advanced</strong>】按钮，就可以设置更多关于独立电压源的参数：</p><p><img src="/Electronics/LTspice/4-Source/3.png"></p><h3 id="独立电流源">独立电流源</h3><p>在 <strong>LTspice</strong>仿真原理图编辑界面，按下快捷键【<strong>P</strong>】，在弹出的元件选择窗口<strong>Search</strong> 里输入<code>current</code>，然后点击【确定】按钮，就可以向当前的仿真原理图上添加一个独立电流源：</p><p><img src="/Electronics/LTspice/4-Source/4.png"></p><p>在仿真原理图的电流源符号上点击【鼠标右键】，就会弹出一个电流源参数设置窗口，该窗口只可以用于输入<code>电源的直流输出电流值</code>(单位为安培<code>A</code>)：</p><p><img src="/Electronics/LTspice/4-Source/5.png"></p><p>此时如果点击电流源参数设置窗口上的【<strong>Advanced</strong>】按钮，就可以设置更多关于独立电流源的参数：</p><p><img src="/Electronics/LTspice/4-Source/6.png"></p><h3 id="参考方向">参考方向</h3><p><strong>LTspice</strong>仿真原理图同样遵循电路原理当中<strong>关联参考方向</strong>的相关定义，即当<strong>独立电压源</strong>（由正极指向负极）与<strong>独立电流源</strong>的方向<strong>相反</strong>时（即<strong>非关联参考方向</strong>），电路网络当中的电压与电流为<strong>负数</strong>：</p><p><img src="/Electronics/LTspice/4-Source/7.png"></p><p>而当<strong>独立电压源</strong>（由正极指向负极）与<strong>独立电流源</strong>的方向<strong>相同</strong>时（即<strong>关联参考方向</strong>），则电路网络当中的电压与电流的仿真结果为<strong>正数</strong>：</p><p><img src="/Electronics/LTspice/4-Source/8.png"></p><h2 id="波形信号的产生">波形信号的产生</h2><p>打开 <strong>LTspice</strong> 主界面，选择菜单栏上的【<strong>VoltageSource</strong>】或者按下快捷键【<strong>V</strong>】放置一个电压源，然后在该电压源上面点击<strong>鼠标右键</strong>，打开电压源参数设置对话框：</p><p><img src="/Electronics/LTspice/5-Waveform/1.png"></p><h3 id="方波">方波</h3><p>鼠标点击上面电压源参数设置对话框当中的【<strong>Advanced</strong>】按钮，在弹出的独立电压源详细参数设置界面选择【<strong>PULSE</strong>】项，就可以配置脉冲波的相关参数：</p><p><img src="/Electronics/LTspice/5-Waveform/2.png"></p><p>这里我们将<strong>脉冲电压</strong>设置为<code>3.3V</code>，<strong>脉冲持续时间</strong>设置为 <code>1m</code>秒，<strong>周期</strong>设置为 <code>2m</code>秒，输出的<strong>周期数量</strong>设置为 <code>200</code>个，<strong>上升和下降沿时间</strong>分别设置为 <code>10n</code>秒：</p><p><img src="/Electronics/LTspice/5-Waveform/3.png"></p><p>然后按下快捷键【<strong>Alt +R</strong>】运行仿真原理图，就可以从下图左侧独立电压源的<code>OUT</code> 端口，查看到下图右侧所示的方波脉冲信号：</p><p><img src="/Electronics/LTspice/5-Waveform/4.png"></p><h3 id="正弦波">正弦波</h3><p>在弹出的参数设置对话框当中，选择【<strong>Advance</strong>】按钮，打开如下的独立电压源详细参数设置窗口，选择其中的【<strong>SINE</strong>】正弦信号，就可以进一步配置相关的参数：</p><p><img src="/Electronics/LTspice/5-Waveform/5.png"></p><p>这里我们将<strong>电压幅度</strong>设置为<code>220V</code>，<strong>频率</strong>设置为<code>50Hz</code>，从而就可以获得一个 <code>200V</code>民用交流市电的波形：</p><p><img src="/Electronics/LTspice/5-Waveform/6.png"></p><p>按下快捷键【<strong>Alt +R</strong>】运行仿真原理图，就能够从下图左侧独立电压源的<code>OUT</code> 端口，查看到下图右侧所示的正弦脉冲信号：</p><p><img src="/Electronics/LTspice/5-Waveform/7.png"></p><h2 id="四种受控源">四种受控源</h2><h3 id="电压控制电压源">电压控制电压源</h3><p><strong>电压控制电压源</strong>以 <code>E</code>作为网络标号的前缀，在仿真原理图界面按下元件放置快捷键【<strong>P</strong>】之后，在<code>Search</code> 栏输入 <code>e</code> 或者 <code>e2</code>就可以查找并且放置：</p><p><img src="/Electronics/LTspice/6-Controlled/1.png"></p><p>上述仿真原理图当中的<strong>电压源</strong> <code>V1</code>，输出一个<code>3.3V</code> 的直流电压，以此作为<strong>电压控制电压源</strong><code>E1</code> 的控制电压。将 <code>E1</code>的<strong>控制系数</strong>设置为<code>3</code>，那么其输出端就会得到一个 <code>9.9V</code>的直流电压。</p><blockquote><p><strong>注意</strong>：<strong>LTspice</strong> 默认元件库当中的<code>e</code> 和 <code>e2</code>两种电压控制电压源，主要区别在于输入端正负极的先后顺序，其中<code>e</code> 是上正下负，而 <code>e2</code> 则是上负下正。</p></blockquote><h3 id="电压控制电流源">电压控制电流源</h3><p><strong>电压控制电流源</strong>以 <code>G</code>作为网络标号的前缀，在仿真原理图界面按下元件放置快捷键【<strong>P</strong>】之后，在<code>Search</code> 栏输入 <code>g</code> 或者 <code>g2</code>就可以查找并且放置：</p><p><img src="/Electronics/LTspice/6-Controlled/2.png"></p><p>上述仿真原理图当中的<strong>电压源</strong><code>V1</code>，输出一个幅值为 <code>3.3V</code>，频率为<code>1KHz</code> 的正弦信号，以此作为<strong>电压控制电流源</strong><code>G1</code> 的控制电压。将 <code>G1</code>的<strong>控制系数</strong>设置为 <code>2</code>，那么电阻<code>R1</code> 上面就会通过一个变化幅值达到<code>6.6A</code>，变化频率同样为 <code>1KHz</code> 的电流信号。</p><blockquote><p><strong>注意</strong>：<strong>LTspice</strong> 默认元件库当中的<code>g</code> 和 <code>g2</code>两种电压控制电流源，主要区别在于输入端正负极的先后顺序，其中<code>g</code> 是上正下负，而 <code>g2</code> 则是上负下正。</p></blockquote><h3 id="电流控制电压源">电流控制电压源</h3><p><strong>电流控制电压源</strong>以 <code>H</code>作为网络标号的前缀，在仿真原理图界面按下元件放置快捷键【<strong>P</strong>】之后，在<code>Search</code> 栏输入 <code>h</code> 就可以查找并且放置：</p><p><img src="/Electronics/LTspice/6-Controlled/3.png"></p><p>上述仿真原理图当中的<strong>电压源</strong><code>V1</code>，输出一个幅值为 <code>5V</code>，频率为<code>1KHz</code> 的正弦信号，导致电阻 <code>R2</code>上通过的电流也呈正弦规律变化，以此作为<strong>电流控制电压源</strong><code>H1</code> 的控制电流。将 <code>H1</code>的<strong>控制系数</strong>设置为 <code>3</code>，那么电阻<code>R1</code> 上面就会通过一个变化幅值为<code>15V</code>，变化频率同样为 <code>1KHz</code> 的电压信号。</p><blockquote><p><strong>注意</strong>：电流控制电压源的 <code>Value</code>参数，需要采用 <code>电源网络标号 + 空格 + 控制系数</code>的格式进行定义。</p></blockquote><h3 id="电流控制电流源">电流控制电流源</h3><p><strong>电流控制电流源</strong>以 <code>F</code>作为网络标号的前缀，在仿真原理图界面按下元件放置快捷键【<strong>P</strong>】之后，在<code>Search</code> 栏输入 <code>f</code> 就可以查找并且放置：</p><p><img src="/Electronics/LTspice/6-Controlled/4.png"></p><p>上述仿真原理图当中的<strong>电压源</strong><code>V1</code>，输出一个幅值为 <code>5V</code>，频率为<code>1KHz</code> 的正弦信号，导致电阻 <code>R2</code>上通过的电流也呈正弦规律变化，以此作为<strong>电流控制电流源</strong><code>F1</code> 的控制电流。将 <code>F1</code>的<strong>控制系数</strong>设置为 <code>6</code>，那么电阻<code>R1</code> 上面就会通过一个变化幅值为<code>30A</code>，变化频率同样为 <code>1KHz</code> 的电流信号。</p><blockquote><p><strong>注意</strong>：电流控制电流源的 <code>Value</code>参数，需要采用 <code>电源网络标号 + 空格 + 控制系数</code>的格式进行定义。</p></blockquote><h2 id="无源元件-伏安特性">无源元件-伏安特性</h2><h3 id="电阻的伏安特性">电阻的伏安特性</h3><p><strong>欧姆定律</strong>是指一个电阻器两端的<strong>电压</strong><span class="math inline">\(V_R\)</span>，与通过该电阻器的<strong>电流</strong><span class="math inline">\(I_R\)</span>呈正比，而比例常数就是<strong>电阻值</strong> <span class="math inline">\(R\)</span>：</p><p><span class="math display">\[电压 V_R = 电流 I_R \times 电阻 R\]</span></p><p>仿真电阻的伏安特性需要使用 <strong>LTspice</strong>的<strong>直流扫描分析</strong>（DCSweep）功能，将扫描电源指定为仿真原理图里的<code>V1</code>，扫描方式采用 <code>Linear</code>线性，起始和截止扫描电压分别为<code>-10V ~ + 10V</code>，步进增长值则指定为<code>0.1V</code>，具体如下图所示：</p><p><img src="/Electronics/LTspice/7-RCL-VI/1.png"></p><p>将电压源 <code>V1</code> 的输出设置为 <code>5V</code>，而串联电阻<code>R1</code> 的阻值设置为<code>1Ω</code>。运行仿真任务之后，就可以看到电阻器的伏安特性曲线是一个以<strong>电压</strong>作为<code>X</code> 横轴，<strong>电流</strong>作为 <code>Y</code>纵轴，斜率为<strong>电阻值</strong> <span class="math inline">\(R\)</span>，并且经过<strong>原点</strong>的一条直线：</p><p><img src="/Electronics/LTspice/7-RCL-VI/2.png"></p><h3 id="电容的伏安特性">电容的伏安特性</h3><p>电容器两端的<strong>电压</strong> <span class="math inline">\(V_C\)</span>与所存储的<strong>电量</strong>（即通过电容器电流的时间<strong>积分</strong><span class="math inline">\(\int I_Cdt\)</span>）呈正比，与<strong>电容值</strong> <span class="math inline">\(C\)</span> 呈反比：</p><p><span class="math display">\[V_C = \frac{1}{C} \int I_C dt\]</span></p><p>对上面的公式两侧，按照时间进行进行<strong>微分</strong>，并且再分别乘以<strong>电容</strong><span class="math inline">\(C\)</span>，就可以得到如下通过电容器的<strong>电流</strong><span class="math inline">\(I_C\)</span>与电容器两端<strong>电压</strong> <span class="math inline">\(V_C\)</span> 的关系：</p><p><span class="math display">\[C \times \frac{dV_C}{dt} = I_C\]</span></p><p>仿真电容的伏安特性需要使用 <strong>LTspice</strong>的<strong>瞬态分析</strong>（Transient）功能，将停止时间设置为<code>2</code>秒，并且勾选<code>启用元器件的初始状态值</code>，具体如下图所示：</p><p><img src="/Electronics/LTspice/7-RCL-VI/3.png"></p><p>仿真原理图当中的<strong>电流源</strong> <code>I1</code>输出的是<strong>峰峰值</strong>为 <span class="math inline">\(\pm1mA\)</span> 的方波电流信号，相关的详细设置如下图所示：</p><p><img src="/Electronics/LTspice/7-RCL-VI/4.png"></p><p>仿真原理图上串联电容器 <code>C1</code> 的值设置为<code>1F</code>，并联等效电阻设置为<code>1TΩ</code>（以便于在电容器完成充电之后进行放电操作）：</p><p><img src="/Electronics/LTspice/7-RCL-VI/5.png"></p><p>当电容器上通过的<strong>电流</strong> <span class="math inline">\(I\)</span> 增大至 <code>1mA</code> 的时候，电容器<code>C1</code> 开始进入充电状态，两端的<strong>电压</strong> <span class="math inline">\(V_C\)</span>随之线性增大。而当通过电容器的<strong>电流</strong> <span class="math inline">\(I\)</span> 降低至 <code>0mA</code> 的时候，电容器<code>C1</code> 开始通过 <code>1TΩ</code>的并联等效电阻进行放电，此时两端的<strong>电压</strong> <span class="math inline">\(V_C\)</span> 也就随之线性下降：</p><p><img src="/Electronics/LTspice/7-RCL-VI/6.png"></p><h3 id="电感的伏安特性">电感的伏安特性</h3><p>电感器两端的<strong>电压</strong> <span class="math inline">\(V_L\)</span>和单位时间内通过电感器的<strong>电流</strong> <span class="math inline">\(I_L\)</span>的变化量呈<strong>正比</strong>，而与电感器的<strong>电感值</strong><span class="math inline">\(I\)</span>同样也呈<strong>正比</strong>：</p><p><span class="math display">\[V_L = L \times \frac{dI_L}{dt} \xrightarrow{逆关系} I_L = \frac{1}{L}\times \int V_L dt\]</span></p><p>当下面仿真原理图上的<strong>独立电流源</strong> <code>I1</code> 输出<code>5A</code> 直流电流的时候，<strong>电感</strong> <code>L1</code>可以近似为一条两端电压为 <code>5mV</code>的导线（<strong>LTspice</strong> 当中的电感器都会默认带有<code>1mΩ</code> 等效串联电阻）：</p><p><img src="/Electronics/LTspice/7-RCL-VI/7.png"></p><p>当仿真原理图上的<strong>独立电流源</strong> <code>I1</code> 输出的是<code>5A</code> 的正弦直流信号的时候，此时<strong>电感器</strong><code>L1</code> 两端电压 <span class="math inline">\(V_L\)</span>的相位，要超前于电流 <span class="math inline">\(I_L\)</span> 的相位<code>90</code> 度：</p><p><img src="/Electronics/LTspice/7-RCL-VI/8.png"></p><h2 id="无源元件-交流特性">无源元件-交流特性</h2><h3 id="电容的交流特性">电容的交流特性</h3><p>一个容值为 <span class="math inline">\(C\)</span>的电容器，对于<strong>频率</strong>为 <span class="math inline">\(f\)</span> 的信号所产生的<strong>电抗</strong><span class="math inline">\(X_C\)</span>，可以通过如下的公式进行计算得到：</p><p><span class="math display">\[X_C = \frac{1}{2 \pi fC}\]</span></p><p>利用电容器的这种频率依赖特性，可以和电阻一起构成可以只允许特定频率通过的RC滤波电路。根据电路的基本理论，可以知道当<strong>电阻器</strong>通过<strong>交流电流信号</strong><span class="math inline">\(I_C\)</span>时，其两端的<strong>电压</strong> <span class="math inline">\(V_C = R_C\timesI_C\)</span>。而当<strong>电容器</strong>通过<strong>交流电流信号</strong><span class="math inline">\(I_C\)</span>时，其两端的<strong>电压</strong> <span class="math inline">\(V_C = X_C\timesI_C\)</span>。接下来，分别对<strong>电阻器</strong>（<code>10KΩ</code>）和<strong>电容器</strong>（<code>0.001uF</code>、<code>0.01uF</code>、<code>0.1uF</code>）的频率依赖特性进行仿真实验：</p><p><img src="/Electronics/LTspice/7-RCL-VI/9.png"></p><p><img src="/Electronics/LTspice/7-RCL-VI/10.png"></p><p><span class="math display">\[N=a^{x}\ (a &gt; 0, a \neq 1)\impliesx = \log_{a} N\]</span></p><p><span class="math display">\[x = \log_{10} N\impliesx = \lg N\]</span></p><p><span class="math display">\[N_{dB} = 10 \times \lg \frac{P_{输入功率}}{P_{输出功率}}\]</span></p><h3 id="电感的交流特性">电感的交流特性</h3><h2 id="有源元件-伏安特性">有源元件-伏安特性</h2><h3 id="双极型晶体管的伏安特性">双极型晶体管的伏安特性</h3><h3 id="场效应管的伏安特性">场效应管的伏安特性</h3><h2 id="基本放大电路的仿真">基本放大电路的仿真</h2><h2 id="基本数字逻辑电路的仿真">基本数字逻辑电路的仿真</h2><h2 id="导入外部-spice-模型">导入外部 SPICE 模型</h2><h2 id="仿真实例">仿真实例</h2><h3 id="暂态仿真实例">暂态仿真实例</h3><p>模拟电路当中，电阻串联之后具备分压的功能，例如<strong>电压源</strong><span class="math inline">\(V\)</span> 两端的电压为<code>6V</code>，三枚阻值分别为<code>R1 = 1Ω</code>、<code>R2 = 2Ω</code>、<code>R3 = 3Ω</code>的电阻串联之后，每一枚电阻上通过的<strong>电流</strong> <span class="math inline">\(I\)</span> 与所分得的<strong>电压</strong> <span class="math inline">\(V\)</span> 如下面计算所示：</p><p><span class="math display">\[\begin{cases}I_1 = I_2 = I_3 = \frac{V}{R_1 + R_2 + R_3} = 1A; \\V_1 = V = 6V \\V_2 = V \times \frac{R_2 + R_3}{R_1 + R_2 + R_3} = 6V \times \frac{2Ω +3Ω}{1Ω + 2Ω + 3Ω} = 5V \\V_3 = V \times \frac{R_3}{R_1 + R_2 + R_3} = 6V \times \frac{3Ω}{1Ω + 2Ω+ 3Ω} = 3V \\V_{12} = V \times \frac{R_1}{R_1 + R_2 + R_3} = 6V \times \frac{1Ω}{1Ω +2Ω + 3Ω} = 1V \\V_{23} = V \times \frac{R_2}{R_1 + R_2 + R_3} = 6V \times \frac{2Ω}{1Ω +2Ω + 3Ω} = 2V \\V_{13} = V \times \frac{R_3}{R_1 + R_2 + R_3} = 6V \times \frac{3Ω}{1Ω +2Ω + 3Ω} = 3V \\\end{cases}\]</span></p><p>接下来绘制出这个电阻串联电路，打开 <strong>LTspice</strong>的主界面之后，按下键盘上的快捷键【<strong>Ctrl + N</strong>】，就可以在<code>C:\Users\hank\Documents\LTspice</code> 目录下面新建一个默认名称为<code>Draft1.asc</code> 的仿真原理图文件：</p><p><img src="/Electronics/LTspice/Example/1-Transient/1.png"></p><p>完成仿真原理图的绘制之后，鼠标点击 <strong>LTspice</strong>主界面顶部的【ConfigureAnalysis】按钮，或者直接按下快捷键【<strong>A</strong>】，选择暂态分析【<strong>Transient</strong>】选项卡，并将仿真的停止时间设置为<code>1</code> 秒：</p><p><img src="/Electronics/LTspice/Example/1-Transient/2.png"></p><p>在 <strong>LTspice</strong>的仿真原理图上面移动鼠标，就可以使用<strong>电流探头</strong>或者<strong>电压探头</strong>测量相应位置的参数（仔细观察可以发现，这些参数与上面手动计算的结果一致），并将这些参数显示到波形预览界面（同时会在仿真原理图文件<code>Draft1.asc</code> 所在的目录，自动生成出一个<code>Draft1.raw</code> 波形文件）：</p><p><img src="/Electronics/LTspice/Example/1-Transient/3.png"></p><blockquote><p><strong>注意</strong>：测量两点之间的相对电压，需要<strong>鼠标左键</strong>选定第<strong>1</strong>个点的位置之后（此时电压探头为红色），继续按住<strong>鼠标左键</strong>拖动至第2 个点的位置（此时电压探头为黑色）。</p></blockquote><h3 id="交流仿真实例">交流仿真实例</h3><p>在模拟电路当中，由一个<strong>电阻</strong> <code>R = 10kΩ</code>和一个<strong>电容</strong> <code>C = 0.1uF</code> 组成的 <strong>RC低通滤波器</strong>，其<strong>截止频率</strong> <span class="math inline">\(f_{C}\)</span> 的计算公式如下面所示：</p><p><span class="math display">\[f_{C} = \frac{1}{2 \pi RC} = \frac{1}{2 \pi \times 10000 \times0.0000001} \approx \frac{1}{0.00628} \approx 159.24 Hz\]</span></p><p>接下来绘制出这个 RC 低通滤波器电路，打开 <strong>LTspice</strong>的主界面之后，按下键盘上的快捷键【<strong>Ctrl + N</strong>】，就可以在<code>C:\Users\hank\Documents\LTspice</code> 目录下面新建一个默认名称为<code>Draft1.asc</code> 的仿真原理图文件：</p><p><img src="/Electronics/LTspice/Example/2-AC/1.png"></p><p>完成仿真原理图的绘制之后，鼠标点击 <strong>LTspice</strong>主界面顶部的【ConfigureAnalysis】按钮，或者直接按下快捷键【<strong>A</strong>】，选择【ACAnalysis】<strong>交流分析</strong>选项卡，配置相关的仿真分析参数：</p><p><img src="/Electronics/LTspice/Example/2-AC/2.png"></p><p>鼠标点击 <strong>LTspice</strong>主界面顶部的【Run/Pause】按钮，或者按下快捷键【<strong>Alt +R</strong>】开始运行仿真，紧接着将鼠标移动到 <code>OUT</code>端口查看<strong>输出电压</strong> <span class="math inline">\(V(out)\)</span> 的波形：</p><p><img src="/Electronics/LTspice/Example/2-AC/3.png"></p><p>RC 低通滤波器的<strong>截止频率</strong> <span class="math inline">\(f_C\)</span> 就是增益降低至 <code>-3dB</code>时候的频率，使用<strong>鼠标左键双击</strong>右侧波形预览窗口顶部的<span class="math inline">\(V(out)\)</span>，然后移动光标至<code>-3dB</code> 位置，就可以查看到该位置对应的频率为<code>159.78631Hz</code>，与前面计算的结果相类似：</p><p><img src="/Electronics/LTspice/Example/2-AC/4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;集成电路仿真程序&lt;/strong&gt;（&lt;strong&gt;SPICE&lt;/strong&gt;，Simulation
Program with Integrated Circuits
Emphasis）是一款以&lt;strong&gt;文本&lt;/strong&gt;进行描述，可以通过&lt;strong&gt;数学&lt;/strong&gt;方法来预测电路行为的仿真工具，也是电子自动化设计与现代半导体工业的基石。其被广泛应用于&lt;strong&gt;模拟电路&lt;/strong&gt;（例如运放算放大器、稳压电源，模数与数模转换等），&lt;strong&gt;混合信号电路&lt;/strong&gt;（锁相环、存储器、高速
GPIO），&lt;strong&gt;精密数字电路&lt;/strong&gt;（延时、时序、功耗、漏电流等）等场景的模拟与仿真（大型电子元器件生产企业通常都提供了元件配套的
&lt;a href=&quot;https://www.ni.com/zh-cn/shop/electronic-test-instrumentation/application-software-for-electronic-test-and-instrumentation-category/what-is-multisim/spice-simulation-fundamentals/spice-simulation-models.html&quot;&gt;SPICE
模型&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/LTspice/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.analog.com/cn/index.html&quot;&gt;&lt;strong&gt;亚德诺半导体公司&lt;/strong&gt;&lt;/a&gt;（Analog
Devices）推出的 &lt;strong&gt;LTspice&lt;/strong&gt;
是一款界面简洁，但是功能强大的免费 &lt;strong&gt;SPICE&lt;/strong&gt;
电路仿真工具，其可以基于原理图快速准确的生成仿真结果，并且将这些结果通过内置的波形查看器进行展示，除此之外还内置有丰富的
SPICE 模型（包含有基本的&lt;strong&gt;无源元件&lt;/strong&gt;以及 ADI
公司的&lt;code&gt;电源管理&lt;/code&gt;和&lt;code&gt;信号链&lt;/code&gt;产品），可以预先为模拟电路的设计以及元器件的选型提供重要的实验数据参考，从而降低电路设计过程当中产生的各种试错成本，有效的提高设计工作效率。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="Simulation" scheme="http://www.uinio.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>基于 Polar Si9000e 计算传输线特征阻抗的全攻略</title>
    <link href="http://www.uinio.com/Electronics/SI9000/"/>
    <id>http://www.uinio.com/Electronics/SI9000/</id>
    <published>2024-04-04T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.054Z</updated>
    
    <content type="html"><![CDATA[<p>伴随近几年集成电路制程工艺的进步，PCB传输线上信号的频率逐年提高，非常容易导致信号在传输过程当中，由于受到传输线的阻力而出现<strong>插损</strong>（插入损耗，单位为<strong>分贝</strong>），这种信号在传输过程中受到的阻力被称为<strong>特性阻抗</strong>或者<strong>特征阻抗</strong>。换而言之，如果信号在传输过程当中，传输路径上的<strong>特征阻抗</strong>发生了变化，信号就会在<code>阻抗不连续</code>的结点发生<strong>反射</strong>。因而PCB上的传输线仅仅只解决<strong>通</strong>和<strong>断</strong>的问题还远远不够，还需要进一步确保其传输链路上特性阻抗的匹配和连续。</p><p><img src="/Electronics/SI9000/logo.png"></p><p><strong>英国宝拉</strong> <a href="https://www.polarinstruments.com/index.html"><strong>POLAR</strong></a>公司推出的 <a href="https://www.polarinstruments.com/products/si/Si9000.html"><strong>Si9000e</strong></a>，正是一款这样可以预测PCB走线阻抗的计算工具，该工具已经成为高速电路设计当中，必不可少的辅助工具。该工具提取了100 余种 PCB传输线的典型结构，并且基于这些结构对指定频率下的传输线阻抗进行建模计算。<strong>Si9000e</strong>将影响 PCB传输线阻抗的主要因素：<code>板材厚度</code>、<code>顶层走线宽度</code>、<code>铜泊厚度</code>、<code>走线周围的包地间距</code>、<code>表面绿油的厚度</code>作为输入参数，就可以计算出<strong>表面单端/差分</strong>和<strong>共面单端/差分</strong>类型走线的阻抗。</p><span id="more"></span><h1 id="英文词汇准备">英文词汇准备</h1><p>由于 <strong>Si9000e 传输线场求解器</strong>（Si9000e TransmissionLine FieldSolver）采用的是全英文界面，因而在开始正式的内容之前，需要将软件界面高频出现的专业英文词汇，整理在下面的表格当中：</p><table><colgroup><col style="width: 53%"><col style="width: 46%"></colgroup><thead><tr class="header"><th style="text-align: left;">Si9000e 界面英文词汇</th><th style="text-align: left;">Si9000e 界面英文词汇</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>Stripline</strong> [ˈstrɪplaɪn]n.带状线，电介质条状线</td><td style="text-align: left;"><strong>Coplanar</strong> [kəʊˈpleɪnə(r)]adj.共面的</td></tr><tr class="even"><td style="text-align: left;"><strong>Microstrip</strong>[ˈmaɪkrəʊstrɪp] n.微带线，微波传输带</td><td style="text-align: left;"><strong>Coated</strong> [ˈkəʊtɪd] adj.覆盖有阻焊油墨的</td></tr><tr class="odd"><td style="text-align: left;"><strong>Waveguide</strong> [ˈweɪvˌɡaɪd]n.波导</td><td style="text-align: left;"><strong>Coarse</strong> [kɔːs] adj.粗略的</td></tr><tr class="even"><td style="text-align: left;"><strong>Substrate</strong> [ˈsʌbstreɪt]n.基层</td><td style="text-align: left;"><strong>Single-End</strong> [ˈsɪŋɡl end]adj.单端的</td></tr><tr class="odd"><td style="text-align: left;"><strong>Dielectric</strong>[ˌdaɪɪˈlektrɪk] n.电介质</td><td style="text-align: left;"><strong>Differential</strong>[ˌdɪfəˈrenʃ(ə)l] adj.差分的</td></tr><tr class="even"><td style="text-align: left;"><strong>Thickness</strong> [ˈθɪknəs]n.厚度</td><td style="text-align: left;"><strong>Separation</strong> [ˌsepəˈreɪʃn]n.隔离</td></tr><tr class="odd"><td style="text-align: left;"><strong>Cutout</strong> [ˈkʌtaʊt]n.分割</td><td style="text-align: left;"><strong>Lossless</strong> [ˈlɒsləs]adj.无损的</td></tr><tr class="even"><td style="text-align: left;"><strong>Tolerance</strong> [ˈtɒlərəns]n.公差</td><td style="text-align: left;"><strong>Trace</strong> [treɪs] n. PCB上的铜质走线</td></tr></tbody></table><blockquote><p><strong>注意</strong>：本文后续内容会将 <strong>Si9000e</strong>直接简写为 <strong>Si9000</strong>。</p></blockquote><h1 id="微带线-带状线">微带线 &amp; 带状线</h1><p>PCB 电路网络当中的信号走线，可以划分为<strong>微带线</strong>（Microstrip）和<strong>带状线</strong>（Stripline）两种主要类型：</p><p><img src="/Electronics/SI9000/Stripline-Microstrip.png"></p><ul><li><strong>微带线</strong>（Microstrip）：即 PCB表面的带状走线，由于一面裸露在空气中，可以向周围形成辐射或受到周围的辐射干扰，而另一面附着在PCB 绝缘电介质上，所以其形成的电场一部分分布在空气中，另一部分分布在 PCB的绝缘介质里，其信号传输速率高于<strong>带状线</strong>。</li><li><strong>带状线</strong>（Stripline）：即 PCB内层的带状走线，由于嵌在两层导体之间，所以其电场分布在两层导体所形成的平面之间，能量不会被辐射出去，也不会受到外部辐射的干扰。由于其周围分布的是介电常数大于<code>1</code>的电介质，所以信号传输速率要慢于<strong>微带线</strong>。</li></ul><p>无论是微带线还是带状线，在 PCB当中这些走线的单位通常会采用<strong>密尔</strong><code>mil</code>，其与公制<strong>毫米</strong> <code>mm</code>的换算关系如下面等式所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 密耳(mil) = <span class="number">0.0254</span> 毫米(mm)</span><br></pre></td></tr></table></figure><h1 id="共面单端-共面波导">共面单端 &amp; 共面波导</h1><p>传输线理论当中的<strong>共面波导</strong>（下图左）与<strong>共面单端</strong>（下图右）两种走线模型，是非常容易混淆的两个概念：</p><p><img src="/Electronics/SI9000/Waveguide-Single-Ended.png"></p><ul><li><strong>共面波导</strong>（CPW，CoplanarWaveguide）是指在介质平面上制作出中心导体带，并在紧邻中心导体带的两侧制作出<strong>导体平面</strong>，这样就构成了共面波导，其本质上属于一种<strong>共面微带传输线</strong>（上图左）。</li><li><strong>共面单端</strong>（CoplanarSingle-Ended）走线的概念类似于共面波导，不同之处在于其中心导体带两侧是<strong>指定宽度的接地走线</strong>，而非一个完整的地平面（上图右）。</li></ul><blockquote><p><strong>注意</strong>：当采用 <strong>Si9000</strong>计算阻抗的时候，由于<strong>共面单端</strong>需要输入的计算参数更多。因此，在没有特别严格要求的情况下，可以直接使用<strong>共面波导</strong>作为阻抗计算的模型，同样参数情况下两者的计算结果差异非常细微。</p></blockquote><h1 id="常用-pcb-叠层结构">常用 PCB 叠层结构</h1><p>实际的 PCB 设计工作当中，在完成元件的布局摆放之后，会首先对 PCB布线的瓶颈位置进行分析，根据敏感信号线的种类和数量来确定<strong>信号层</strong>的层数。然后再根据电源的性能参数要求，来确定<strong>内电层</strong>的层数。从而最终确定整个PCB 的<strong>叠层设计方案</strong>。下面的表格对比了 3 种常见<strong>四层 PCB 叠层方案</strong> 的优缺点（通常会优先选择第<code>2</code> 和第 <code>3</code> 号叠层方案）：</p><p><img src="/Electronics/SI9000/Level-4.png"></p><p>而在接下来的表格里，则是对比了 4 种常见 <strong>六层 PCB叠层方案</strong> 的优缺点（通常会优先选择第 <code>3</code> 和第<code>4</code> 号叠层方案）：</p><p><img src="/Electronics/SI9000/Level-6.png"></p><h1 id="si9000-主界面介绍">Si9000 主界面介绍</h1><p><strong>Si9000</strong>软件的主界面可以被划分为【功能选择标签】、【模型选择区域】、【参数输入与计算区域】、【单位切换区域】四个区域：</p><p><img src="/Electronics/SI9000/UI.png"></p><ol type="1"><li>【功能选择标签】：在计算 PCB特征阻抗的时候，需要将切换至<strong>无损计算</strong>（LosslessCalculation）标签。</li><li>【模型选择区域】主要用于选择 PCB典型层叠结构与走线方式的<strong>特征阻抗模型</strong>。</li><li>【单位切换区域】用于在<strong>米尔</strong>（<code>Mils</code>）、<strong>英寸</strong>（<code>Inches</code>）、<strong>微米</strong>（<code>Microns</code>）、<strong>毫米</strong>（<code>Millimetres</code>）计算单位之间进行切换。</li><li>【参数输入与计算区域】用于输入 PCB各种基材、铜层、阻焊油墨、走线的参数信息，并且利用这些信息计算出相应的特征阻抗。</li></ol><blockquote><p><strong>注意</strong>：勾选软件底部的【AutoCalc】可以开启自动计算功能，即当参数输入区域发生变化的时候，<strong>Si9000</strong>就会自动计算出对应的特征阻抗结果。</p></blockquote><h1 id="常见的阻抗模型">常见的阻抗模型</h1><p>现代传输线理论认为，信号在传输过程当中，特征阻抗的不连续会造成反射现象。而在信号完整性领域，<code>反射</code>、<code>串扰</code>、<code>参考平面分割</code>都会导致阻抗的不连续问题，因而传输线特征阻抗的匹配显得尤为重要。在下面的列表里，对高速电路设计当中存在的一些概念进行了解释：</p><ul><li><strong>时延</strong>：高速信号从电路网络的一端传送至另一端所需的时间。</li><li><strong>串扰</strong>：信号线之间的<strong>互感</strong>与<strong>互容</strong>所引发的噪声。</li><li><strong>反射</strong>：在传输线上阻抗不连续的位置，一部分信号会继续向前传输，另外一部分则会被反射形成回波。</li><li><strong>振铃</strong>：由于传输线的阻抗不匹配，导致信号被多次反射叠加之后，所出现的振荡波形。</li></ul><p>常见的阻抗计算模型可以划分为<strong>内层</strong>或者<strong>外层</strong>的<code>单端</code>、<code>差分</code>、<code>共面单端</code>、<code>共面波导</code>、<code>差分共面地</code>、<code>差分共面波导</code>一共 12 种模型：</p><table><colgroup><col style="width: 49%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>外层单端</strong></th><th style="text-align: center;"><strong>内层单端</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-1.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-7.png"></td></tr><tr class="even"><td style="text-align: center;"><strong>外层差分</strong></td><td style="text-align: center;"><strong>内层差分</strong></td></tr><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-2.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-8.png"></td></tr><tr class="even"><td style="text-align: center;"><strong>外层共面单端</strong></td><td style="text-align: center;"><strong>内层共面单端</strong></td></tr><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-3.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-9.png"></td></tr><tr class="even"><td style="text-align: center;"><strong>外层共面波导</strong></td><td style="text-align: center;"><strong>内层共面波导</strong></td></tr><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-4.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-10.png"></td></tr><tr class="even"><td style="text-align: center;"><strong>外层差分共面地</strong></td><td style="text-align: center;"><strong>内层差分共面地</strong></td></tr><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-5.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-11.png"></td></tr><tr class="even"><td style="text-align: center;"><strong>外层差分共面波导</strong></td><td style="text-align: center;"><strong>内层差分共面波导</strong></td></tr><tr class="odd"><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-6.png"></td><td style="text-align: center;"><img src="/Electronics/SI9000/Impedance-Model-12.png"></td></tr></tbody></table><p>影响上述模型当中<strong>特征阻抗</strong>的因素有<code>基材厚度</code>、<code>介电常数</code>、<code>铜层厚度</code>、<code>线宽</code>、<code>线距</code>、<code>阻焊油墨厚度</code>等，具体请参考下面的表格：</p><table><colgroup><col style="width: 8%"><col style="width: 30%"><col style="width: 61%"></colgroup><thead><tr class="header"><th style="text-align: center;">缩写</th><th style="text-align: left;">英文名称</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>H1</strong></td><td style="text-align: left;"><code>Substrate 1 Height</code></td><td style="text-align: left;">第 1层基材的<strong>厚度</strong>（不包含铜厚）；</td></tr><tr class="even"><td style="text-align: center;"><strong>H2</strong></td><td style="text-align: left;"><code>Substrate 2 Height</code></td><td style="text-align: left;">第 2层基材的<strong>厚度</strong>（不包含铜厚）；</td></tr><tr class="odd"><td style="text-align: center;"><strong>Er1</strong></td><td style="text-align: left;"><code>Substrate 1 Dielectric</code></td><td style="text-align: left;">第 1层基材的<strong>介电常数</strong>（多种基材压合时取平均值）；</td></tr><tr class="even"><td style="text-align: center;"><strong>Er2</strong></td><td style="text-align: left;"><code>Substrate 2 Dielectric</code></td><td style="text-align: left;">第 2层基材的<strong>介电常数</strong>（多种基材压合时取平均值）；</td></tr><tr class="odd"><td style="text-align: center;"><strong>W1</strong></td><td style="text-align: left;"><code>Lower Trace Width</code></td><td style="text-align: left;">阻抗走线的<strong>下线宽</strong>；</td></tr><tr class="even"><td style="text-align: center;"><strong>W2</strong></td><td style="text-align: left;"><code>Upper Trace Width</code></td><td style="text-align: left;">阻抗走线的<strong>上线宽</strong>；</td></tr><tr class="odd"><td style="text-align: center;"><strong>G1</strong></td><td style="text-align: left;"><code>Lower Ground Strip Width</code></td><td style="text-align: left;">接地走线的<strong>上线宽</strong>。</td></tr><tr class="even"><td style="text-align: center;"><strong>G2</strong></td><td style="text-align: left;"><code>Upper Ground Strip Width</code></td><td style="text-align: left;">接地走线的<strong>下线宽</strong>。</td></tr><tr class="odd"><td style="text-align: center;"><strong>D1</strong></td><td style="text-align: left;"><code>Ground Strip Separation</code></td><td style="text-align: left;">接地走线的<strong>间隔距离</strong>；</td></tr><tr class="even"><td style="text-align: center;"><strong>T1</strong></td><td style="text-align: left;"><code>Trace Thickness</code></td><td style="text-align: left;">走线的<strong>铜层厚度</strong>；</td></tr><tr class="odd"><td style="text-align: center;"><strong>C1</strong></td><td style="text-align: left;"><code>Coating Above Substrate</code></td><td style="text-align: left;">基材的<strong>阻焊油墨厚度</strong>；</td></tr><tr class="even"><td style="text-align: center;"><strong>C2</strong></td><td style="text-align: left;"><code>Coating Above Trace</code></td><td style="text-align: left;">铜皮或者走线的<strong>阻焊油墨厚度</strong>；</td></tr><tr class="odd"><td style="text-align: center;"><strong>C3</strong></td><td style="text-align: left;"><code>Coating Between Traces</code></td><td style="text-align: left;">铜层走线间隙的<strong>阻焊油墨厚度</strong>；</td></tr><tr class="even"><td style="text-align: center;"><strong>CEr</strong></td><td style="text-align: left;"><code>Coating Dielectric</code></td><td style="text-align: left;">阻焊油墨的<strong>介电常数</strong>；</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>残铜率</strong>是指板 PCB上面<code>覆铜面积</code>与<code>整板面积</code>之比，例如未经加工的覆铜芯板的残铜率为<code>100%</code>，而将表面铜层全部被蚀刻掉之后残铜率就变为<code>0%</code>。</p></blockquote><h1 id="导线的上下线宽换算关系">导线的上/下线宽换算关系</h1><p>目前的 PCB蚀刻制造工艺，会导致铜层走线出现<strong>上窄下宽</strong>的情况，形成类似下图这样的梯形截面走线：</p><p><img src="/Electronics/SI9000/Trapezoid.png"></p><p>接下来的表格展现了不同基础铜厚情况下，铜层走线的 <span class="math inline">\(W_{上/下线宽}\)</span> 以及 <span class="math inline">\(D_{线距}\)</span>，与 <span class="math inline">\(W_{设计线宽}\)</span> 和 <span class="math inline">\(D_{设计线距}\)</span>之间的换算关系（如果不需要精确的计算，那么可以默认 <span class="math inline">\(W_{上线宽}\)</span> 比 <span class="math inline">\(W_{下线宽}\)</span> 要窄约<code>1mil</code>，具体参数建议咨询 PCB 生产厂家）：</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th style="text-align: center;">基础铜厚</th><th style="text-align: center;">上线宽 <span class="math inline">\(W_{上线宽}\)</span></th><th style="text-align: center;">下线宽 <span class="math inline">\(W_{下线宽}\)</span></th><th style="text-align: center;">线距 <span class="math inline">\(D_{线距}\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>18μm</strong>（内层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.1 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>35μm</strong>（内层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.4 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>70μm</strong>（内层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 1.2 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>42μm</strong>（负片层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.4 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.4 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.4 mil\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>48μm</strong>（负片层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.5 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.5 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.5 mil\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>65μm</strong>（负片层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.8 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.8 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.8 mil\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>12μm</strong>（外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.6 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.6 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.6 mil\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>18μm</strong>（外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.6 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.7 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.7 mil\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>35μm</strong>（外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 0.9 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}+ 0.9 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}- 0.9 mil\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>12μm</strong>（镀金工艺外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 1.2 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>18μm</strong>（镀金工艺外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 1.2 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>35μm</strong>（镀金工艺外层）</td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}- 2.0 mil\)</span></td><td style="text-align: center;"><span class="math inline">\(W_{设计线宽}\)</span></td><td style="text-align: center;"><span class="math inline">\(D_{设计线距}\)</span></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>信号层</strong>主要用于走线，通常采用<strong>正片</strong>方式处理；而<strong>电源层</strong>和<strong>接地层</strong>通常采用<strong>负片</strong>方式处理，这样只需指定无需铺铜的位置即可，可以较大程度降低EDA 工具的数据处理量。</p></blockquote><h1 id="芯板与半固化片">芯板与半固化片</h1><p>多层 PCB 都是由 <code>FR-4</code> 材料的<strong>覆铜芯板</strong>（Core）与具有粘结功能的<strong>半固化片</strong>（PP，Prepreg [priːpreɡ]）热压合而成，当使用<strong>Si9000</strong> 计算带有叠层结构的 PCB特性阻抗时，纳入计算的板材厚度应当由两者共同叠加而成，下图清晰的展示了覆铜芯板与半固化片之间的这种叠加关系：</p><p><img src="/Electronics/SI9000/PCB-Structure.png"></p><h2 id="芯板的介电常数">芯板的介电常数</h2><p>普通 FR-4 材料的<strong>覆铜芯板</strong>（Core），主要有南亚、建滔、生益、宏瑞等板材生产厂家，下面两个表格展示了<strong>Tg≤ 170</strong> 型与 <strong>IT180A S1000-2</strong> 型的 <strong>生益FR-4 芯板</strong>，在各种厚度下所对应的<strong>介电常数</strong>：</p><table><colgroup><col style="width: 18%"><col style="width: 10%"><col style="width: 12%"><col style="width: 10%"><col style="width: 12%"><col style="width: 11%"><col style="width: 11%"><col style="width: 11%"></colgroup><thead><tr class="header"><th style="text-align: center;">生益 FR-4 芯板厚度</th><th style="text-align: center;">0.051mm/2mil</th><th style="text-align: center;">0.075mm/3.0mil</th><th style="text-align: center;">0.102mm/4mil</th><th style="text-align: center;">0.11mm/4.33mil</th><th style="text-align: center;">0.13mm/5.1mil</th><th style="text-align: center;">0.15mm/5.9mil</th><th style="text-align: center;">0.18mm/7.0mil</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Tg ≤ 170</strong> 型</td><td style="text-align: center;">3.6</td><td style="text-align: center;">3.65</td><td style="text-align: center;">3.95</td><td style="text-align: center;">无此规格</td><td style="text-align: center;">3.95</td><td style="text-align: center;">3.65</td><td style="text-align: center;">4.2</td></tr><tr class="even"><td style="text-align: center;"><strong>IT180A S1000-2</strong> 型</td><td style="text-align: center;">3.9</td><td style="text-align: center;">3.95</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4.5</td></tr></tbody></table><table><colgroup><col style="width: 21%"><col style="width: 14%"><col style="width: 12%"><col style="width: 14%"><col style="width: 12%"><col style="width: 12%"><col style="width: 15%"></colgroup><thead><tr class="header"><th style="text-align: center;">生益 FR-4 芯板厚度</th><th style="text-align: center;">0.21mm/8.27mil</th><th style="text-align: center;">0.25mm/10mil</th><th style="text-align: center;">0.36mm/14.5mil</th><th style="text-align: center;">0.51mm/20mil</th><th style="text-align: center;">0.71mm/28mil</th><th style="text-align: center;">≥0.8mm/≥31.5mil</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Tg ≤ 170</strong> 型</td><td style="text-align: center;">3.95</td><td style="text-align: center;">3.95</td><td style="text-align: center;">4.2</td><td style="text-align: center;">4.1</td><td style="text-align: center;">4.2</td><td style="text-align: center;">4.2</td></tr><tr class="even"><td style="text-align: center;"><strong>IT180A S1000-2</strong> 型</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4.5</td><td style="text-align: center;">4.4</td><td style="text-align: center;">4.5</td><td style="text-align: center;">4.5</td></tr></tbody></table><h2 id="半固化片的介电常数">半固化片的介电常数</h2><p><strong>半固化片</strong>（PP）比较有名的厂家是罗杰斯（Rogers），主要有<code>106</code>、<code>1080</code>、<code>3313</code>、<code>2116</code>、<code>7628</code>等规格，下面的这个表格展示了 <strong>Tg ≤ 170</strong> 型与<strong>IT180A S1000-2</strong>型半固化片，在各种规格下所对应的介电常数：</p><table style="width:100%;"><colgroup><col style="width: 45%"><col style="width: 9%"><col style="width: 11%"><col style="width: 11%"><col style="width: 11%"><col style="width: 11%"></colgroup><thead><tr class="header"><th style="text-align: center;">Tg≤170 半固化片规格</th><th style="text-align: center;">106</th><th style="text-align: center;">1080</th><th style="text-align: center;">3313</th><th style="text-align: center;">2116</th><th style="text-align: center;">7628</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">理论厚度 (mm)</td><td style="text-align: center;">0.0513</td><td style="text-align: center;">0.0773</td><td style="text-align: center;">0.1034</td><td style="text-align: center;">0.1185</td><td style="text-align: center;">0.1951</td></tr><tr class="even"><td style="text-align: center;">介电常数</td><td style="text-align: center;">3.6</td><td style="text-align: center;">3.65</td><td style="text-align: center;">3.85</td><td style="text-align: center;">3.95</td><td style="text-align: center;">4.2</td></tr><tr class="odd"><td style="text-align: center;"><strong>IT180A S1000-2B半固化片规格</strong></td><td style="text-align: center;"><strong>106</strong></td><td style="text-align: center;"><strong>1080</strong></td><td style="text-align: center;"><strong>3313</strong></td><td style="text-align: center;"><strong>2116</strong></td><td style="text-align: center;"><strong>7628</strong></td></tr><tr class="even"><td style="text-align: center;">理论厚度 (mm)</td><td style="text-align: center;">0.0511</td><td style="text-align: center;">0.07727</td><td style="text-align: center;">0.0987</td><td style="text-align: center;">0.1174</td><td style="text-align: center;">0.1933</td></tr><tr class="odd"><td style="text-align: center;">介电常数</td><td style="text-align: center;">3.9</td><td style="text-align: center;">3.95</td><td style="text-align: center;">4.15</td><td style="text-align: center;">4.25</td><td style="text-align: center;">4.5</td></tr></tbody></table><h1 id="si9000-阻抗计算实例">Si9000 阻抗计算实例</h1><p>在高速电路设计过程当中，通常情况下<strong>DDR</strong>、<strong>eMMC</strong>、<strong>SDIO</strong>等单端信号会要求 <code>50Ω</code> 阻抗（可以将其设置为 EDA工具走线的默认线宽）。而 <strong>HDMI</strong>、<strong>DDR</strong>时钟 等差分信号则会要求 <code>100Ω</code> 阻抗，除此之外<strong>USB</strong> 差分线则会要求 <code>90Ω</code> 阻抗。</p><p>为了匹配这些各不相同的特征阻抗需求，需要基于 <strong>Si9000</strong>对走线的各种参数进行计算，从而获得合理的走线<strong>宽度</strong>与<strong>距离</strong>。由于使用<strong>Si9000</strong>进行<strong>无损计算</strong>的时候，所采用的参数与 PCB生产厂家所使用的材料以及工艺密切相关，因而必须遵循厂家提供的相关参数，确保阻抗计算结果的准确性。这里的表格，展示的是某工厂最新使用的<strong>半固化片</strong>规格与其介电常数：</p><table><thead><tr class="header"><th style="text-align: center;">半固化片规格</th><th style="text-align: center;">7628</th><th style="text-align: center;">2216</th><th style="text-align: center;">3313</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>介电常数</strong></td><td style="text-align: center;"><code>4.4</code></td><td style="text-align: center;"><code>4.16</code></td><td style="text-align: center;"><code>4.1</code></td></tr></tbody></table><p>而接下来的表格，则展示了该工厂所使用<strong>阻焊油墨</strong>的厚度以及介电常数：</p><table><thead><tr class="header"><th style="text-align: center;">基材上的油墨厚度</th><th style="text-align: center;">导线上的油墨厚度</th><th style="text-align: center;">阻焊油墨介电常数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>0.8mil</code></td><td style="text-align: center;"><code>0.5mil</code></td><td style="text-align: center;"><code>3.8</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>盎司</strong> <code>oz</code>原本是一个用于表示重量的单位 <code>1oz = 28.350g</code>，在 PCB设计当中通常将其用于描述铜层的厚度，<code>1OZ</code> 铜层对应的厚度约为<code>0.035mm</code>。</p></blockquote><h2 id="四层层叠方案-jlc04161h-7628">四层层叠方案 JLC04161H-7628</h2><p>以某 PCB 生产厂家所提供的 <code>JLC04161H-7628</code> 型四层 PCB叠层方案为例（PCB 成品厚度 <code>1.59mm</code>，内层铜厚<code>0.5oz</code>，外层铜厚 <code>1oz</code>）：</p><p><img src="/Electronics/SI9000/JLC04161H-7628.png"></p><p>下图是使用 <strong>Si9000</strong> 计算 <code>50Ω</code>欧姆<strong>外层单端</strong>阻抗走线的结果（即上下线宽度分别为<code>14.1614/13.1614mil</code> 或者<code>0.35970/0.33430mm</code>）：</p><p><img src="/Electronics/SI9000/JLC04161H-7628-1.png"></p><h2 id="四层层叠方案-jlc04161h-3313">四层层叠方案 JLC04161H-3313</h2><p>以某 PCB 生产厂家所提供的 <code>JLC04161H-3313</code> 型四层 PCB叠层方案为例（PCB 成品厚度 <code>1.56mm</code>，内层铜厚<code>0.5oz</code>，外层铜厚 <code>1oz</code>）：</p><p><img src="/Electronics/SI9000/JLC04161H-3313.png"></p><p>下图是使用 <strong>Si9000</strong> 计算 <code>100Ω</code>欧姆<strong>外层差分共面</strong>阻抗走线的结果（即上下线宽度分别为<code>5.1623/4.1623mil</code> 或者<code>0.13112/0.10572mm</code>）：</p><p><img src="/Electronics/SI9000/JLC04161H-3313-1.png"></p><h2 id="六层层叠方案-jlc06161h-3313">六层层叠方案 JLC06161H-3313</h2><p>以某 PCB 生产厂家所提供的 <code>JLC06161H-3313</code> 型六层 PCB叠层方案为例（上下线宽度分别为 <code>1.6mm</code>，内层铜厚<code>0.5oz</code>，外层铜厚 <code>1oz</code>）：</p><p><img src="/Electronics/SI9000/JLC06161H-3313.png"></p><p>下图是使用 <strong>Si9000</strong> 计算 <code>90Ω</code>欧姆<strong>内层差分共面</strong>阻抗走线的结果（即上下线宽度分别为<code>4.9260/3.9260mil</code> 或者<code>0.12512/0.09972mm</code>）：</p><p><img src="/Electronics/SI9000/JLC06161H-3313-1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;伴随近几年集成电路制程工艺的进步，PCB
传输线上信号的频率逐年提高，非常容易导致信号在传输过程当中，由于受到传输线的阻力而出现&lt;strong&gt;插损&lt;/strong&gt;（插入损耗，单位为&lt;strong&gt;分贝&lt;/strong&gt;），这种信号在传输过程中受到的阻力被称为&lt;strong&gt;特性阻抗&lt;/strong&gt;或者&lt;strong&gt;特征阻抗&lt;/strong&gt;。换而言之，如果信号在传输过程当中，传输路径上的&lt;strong&gt;特征阻抗&lt;/strong&gt;发生了变化，信号就会在&lt;code&gt;阻抗不连续&lt;/code&gt;的结点发生&lt;strong&gt;反射&lt;/strong&gt;。因而
PCB
上的传输线仅仅只解决&lt;strong&gt;通&lt;/strong&gt;和&lt;strong&gt;断&lt;/strong&gt;的问题还远远不够，还需要进一步确保其传输链路上特性阻抗的匹配和连续。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/SI9000/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英国宝拉&lt;/strong&gt; &lt;a href=&quot;https://www.polarinstruments.com/index.html&quot;&gt;&lt;strong&gt;POLAR&lt;/strong&gt;&lt;/a&gt;
公司推出的 &lt;a href=&quot;https://www.polarinstruments.com/products/si/Si9000.html&quot;&gt;&lt;strong&gt;Si9000e&lt;/strong&gt;&lt;/a&gt;，正是一款这样可以预测
PCB
走线阻抗的计算工具，该工具已经成为高速电路设计当中，必不可少的辅助工具。该工具提取了
100 余种 PCB
传输线的典型结构，并且基于这些结构对指定频率下的传输线阻抗进行建模计算。&lt;strong&gt;Si9000e&lt;/strong&gt;
将影响 PCB
传输线阻抗的主要因素：&lt;code&gt;板材厚度&lt;/code&gt;、&lt;code&gt;顶层走线宽度&lt;/code&gt;、&lt;code&gt;铜泊厚度&lt;/code&gt;、&lt;code&gt;走线周围的包地间距&lt;/code&gt;、&lt;code&gt;表面绿油的厚度&lt;/code&gt;
作为输入参数，就可以计算出&lt;strong&gt;表面单端/差分&lt;/strong&gt;和&lt;strong&gt;共面单端/差分&lt;/strong&gt;类型走线的阻抗。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="EDA" scheme="http://www.uinio.com/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>硬件电路设计当中 の 常用分立元器件选型</title>
    <link href="http://www.uinio.com/Electronics/Component/"/>
    <id>http://www.uinio.com/Electronics/Component/</id>
    <published>2024-03-30T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:49.652Z</updated>
    
    <content type="html"><![CDATA[<p>自从 <strong>1883</strong>年电子管作为人类第一个电子元器件诞生以来，<strong>电子元器件</strong>的发展历程，见证了人类科技进步的辉煌成就。从最初的<code>电阻</code>、<code>电容</code>、<code>电感</code>等基础元器件，发展到<code>晶闸管</code>、<code>场效应管</code>、<code>IGBT</code>等半导体元器件，再进一步发展到现如今各种琳琅满目的<strong>微处理器</strong>、<strong>微控制器</strong>、<strong>传感器</strong>。电子元器件的功能越来越强大，体积越来越小，集成度越来越高。这些变化不仅极大地提升了电子产品的性能和可靠性，也为我们带来了更加便捷与智能的生活方式。</p><p><img src="/Electronics/Component/logo.png"></p><p>电子元器件如同电子设备的细胞，承载着实现各种复杂功能的基础任务，它们是电路设计和调试中不可或缺的元素。实际的电路设计过程当中，各类电子元器件的选择、连接、调试都至关重要，正确的选型能够确保设备的性能和稳定性，而合理的连接方式更是能够降低信号的损失与干扰。本文旨在以简单明了的方式介绍<code>电阻器</code>、<code>电容器</code>、<code>电感器</code>、<code>变压器</code>、<code>二极管</code>、<code>三极管</code>、<code>晶闸管</code>、<code>场效应管</code>、<code>IGBT</code>等常用分立式电子元器件的参数与选型注意事项。</p><span id="more"></span><h1 id="知识准备-basic">知识准备 Basic</h1><h2 id="电流">电流</h2><p><strong>电荷</strong>的定向移动形成<strong>电流</strong>，电流通常使用字母<code>I</code> 表示，其单位为 <code>A</code><strong>安培</strong>，更小的单位有<strong>毫安</strong>(<code>mA</code>)和<strong>微安</strong>(<code>μA</code>)，它们之间的换算关系为：</p><p><span class="math display">\[1A = 10^3mA = 10^6 \mu A\]</span></p><blockquote><p><strong>注意</strong>：习惯上约定将<strong>电荷</strong>（电子带有<strong>负电</strong>）运动的<strong>反方向</strong>作为电流的方向，即将<strong>正电荷</strong>在电路当中的移动方向规定为电流的方向，也就是从正极流向负极。</p></blockquote><h2 id="电阻">电阻</h2><p><strong>导体</strong>对电流的阻碍作用称为<strong>电阻</strong>，通常使用字母<code>R</code> 进行表示，其单位为 <code>Ω</code>欧姆，更大的单位有<strong>千欧</strong>(KΩ)、<strong>兆欧</strong>(MΩ)，它们之间的换算关系为：</p><p><span class="math display">\[1 MΩ = 10^3 KΩ = 10^6 Ω\]</span></p><p>一段导体的电阻主要是由导体的<strong>长度</strong> <span class="math inline">\(L\)</span>（单位<code>米</code>）、<strong>横截面积</strong><span class="math inline">\(S\)</span>（单位<code>平方米</code>）、<strong>电阻率</strong><span class="math inline">\(\rho\)</span>（单位<code>欧姆·米</code>）共同来决定，它们之间的数学关系如下所示：</p><p><span class="math display">\[R = \rho \frac{L}{S}\]</span></p><p>下面的表格，给出了一些常用导体的电阻率：</p><table><colgroup><col style="width: 9%"><col style="width: 40%"><col style="width: 9%"><col style="width: 40%"></colgroup><thead><tr class="header"><th style="text-align: center;">导体</th><th style="text-align: center;">电阻率</th><th style="text-align: center;">导体</th><th style="text-align: center;">电阻率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>银</strong></td><td style="text-align: center;"><span class="math inline">\(1.62 \times10^{-8}\)</span> Ω·m</td><td style="text-align: center;"><strong>锡</strong></td><td style="text-align: center;"><span class="math inline">\(11.4 \times10^{-8}\)</span> Ω·m</td></tr><tr class="even"><td style="text-align: center;"><strong>铜</strong></td><td style="text-align: center;"><span class="math inline">\(1.69 \times10^{-8}\)</span> Ω·m</td><td style="text-align: center;"><strong>铁</strong></td><td style="text-align: center;"><span class="math inline">\(10.0 \times10^{-8}\)</span> Ω·m</td></tr><tr class="odd"><td style="text-align: center;"><strong>铝</strong></td><td style="text-align: center;"><span class="math inline">\(2.83 \times10^{-8}\)</span> Ω·m</td><td style="text-align: center;"><strong>铅</strong></td><td style="text-align: center;"><span class="math inline">\(21.9 \times10^{-8}\)</span> Ω·m</td></tr><tr class="even"><td style="text-align: center;"><strong>金</strong></td><td style="text-align: center;"><span class="math inline">\(2.4 \times10^{-8}\)</span> Ω·m</td><td style="text-align: center;"><strong>汞</strong></td><td style="text-align: center;"><span class="math inline">\(95.8 \times10^{-8}\)</span> Ω·m</td></tr><tr class="odd"><td style="text-align: center;"><strong>钨</strong></td><td style="text-align: center;"><span class="math inline">\(5.51 \times10^{-8}\)</span> Ω·m</td><td style="text-align: center;"><strong>碳</strong></td><td style="text-align: center;"><span class="math inline">\(3500 \times10^{-8}\)</span> Ω·m</td></tr></tbody></table><h2 id="电压">电压</h2><p><strong>电位</strong>是衡量电荷在电路当中某点所具有能量的物理量，也称为<strong>电势</strong>。电位是相对的，电路中某点电位的大小，与参考点（即零电位点）的选择有关。</p><p><strong>电压</strong>则用于衡量单位电荷在静电场当中，由于电位不同而产生的能量差，也被称为<strong>电位差</strong>。电压的常用单位有<strong>伏</strong>(<code>V</code>)、<strong>毫伏</strong>(<code>mV</code>)、<strong>微伏</strong>(<code>μV</code>)：</p><p><span class="math display">\[1V = 10^3 mV = 10^6 \mu V\]</span></p><blockquote><p><strong>注意</strong>：电源消耗能量在两极之间，所建立的电位差称为<strong>电动势</strong>（电源的电动势方向是从电源<strong>负极</strong>指向<strong>正极</strong>）。</p></blockquote><h2 id="欧姆定律">欧姆定律</h2><p><strong>欧姆定律</strong>是指电路当中，流经导体的<strong>电流</strong><code>I</code> 与导体两端的<strong>电压</strong> <code>U</code>成正比，与这段导体的<strong>电阻</strong> <code>R</code> 成反比：</p><p><span class="math display">\[I = \frac{U}{R}  \implies R = \frac{U}{I} \implies U = R \cdot I\]</span></p><p>对于上述的欧姆定律换算公式，可以借助下面图形来帮助记忆：</p><p><img src="/Electronics/Component/1-Basic/0.png"></p><h2 id="电功">电功</h2><p><strong>电功</strong>是指电能所做的<strong>功</strong>，单位为<strong>焦耳</strong>(<code>J</code>)，其值与通过的<strong>电流</strong>(<code>A</code>)、<strong>电压</strong>(<code>V</code>)、以及<strong>通电时间</strong>(<code>s</code>)有关：</p><p><span class="math display">\[W = U \cdot I \cdot t\]</span></p><p>实际工作当中，经常使用到电功的另外一个单位<strong>千瓦时</strong>(<code>kW·h</code>)，也被称为<strong>度</strong>，即<code>1千瓦时 = 1 度</code>。千瓦时与焦耳的换算关系如下面所示：</p><p><span class="math display">\[1kW·h = (1 \times 10^3)W \times (60 \times 60)s = (3.6 \times 10^6) W·s= (3.6 \times 10^6) J\]</span></p><h2 id="电功率">电功率</h2><p><strong>电功率</strong>是指<strong>单位时间</strong>内<strong>电流</strong>通过用电设备所做的<strong>功</strong>，使用字母<code>P</code>表示，单位为<strong>瓦特</strong>(<code>W</code>)，其计算公式为：</p><p><span class="math display">\[P = U \cdot I\]</span></p><p>根据<strong>欧姆定律</strong>的公式 <span class="math inline">\(U = R\cdot I\)</span> 以及 <span class="math inline">\(I =\frac{U}{R}\)</span>，可以将上述电功率的计算公式，转换为下面两种形式：</p><p><span class="math display">\[\begin{align}P &amp;= I^2 \cdot R \\P &amp;= \frac{U^2}{R}\end{align}\]</span></p><h2 id="焦耳定律">焦耳定律</h2><p>电流通过导体时，导体发出的<strong>热量</strong><code>Q</code>(焦耳)与导体经过的<strong>电流</strong><code>I</code>(安培)、导体的<strong>电阻</strong><code>R</code>(欧姆)、通电的<strong>时间</strong> <code>t</code>(秒)有关：</p><p><span class="math display">\[Q = I^2 R t\]</span></p><blockquote><p><strong>注意</strong>：换而言之，电流经过导体产生的<strong>热量</strong><span class="math inline">\(Q\)</span> 与<strong>电流</strong> <span class="math inline">\(I\)</span> 的平方、导体的<strong>电阻</strong><span class="math inline">\(R\)</span>、通电的<strong>时间</strong><span class="math inline">\(t\)</span> 呈<strong>正比关系</strong>。</p></blockquote><h2 id="电阻的串并联">电阻的串并联</h2><h3 id="电阻的串联">电阻的串联</h3><p><strong>电阻的串联</strong>是指两个或者以上的电阻，在电路当中以<strong>首尾相接</strong>的方式进行连接：</p><p><img src="/Electronics/Component/1-Basic/1.png"></p><p>电阻的<strong>串联</strong>电路，主要具备有如下四个特点：</p><ol type="1"><li>流过每一个串联电阻的<strong>电流</strong>都相等，也就是都等于 <span class="math inline">\(I\)</span>；</li><li><strong>总电压</strong>等于各个串联电阻上面的电压之和，即 <span class="math inline">\(U = U_{R1} + U_{R2}\)</span>；</li><li>电阻串联之后的<strong>总电阻</strong>增大，总电阻等于各个串联电阻之和，即<span class="math inline">\(R = R_1 + R_2\)</span>；</li><li>串联电阻的<strong>阻值</strong>越大，电阻两端的<strong>电压</strong>就越高，即<span class="math inline">\(R_1 &lt; R_2 \implies U_{R1} &lt;U_{R2}\)</span>；</li></ol><h3 id="电阻的并联">电阻的并联</h3><p><strong>电阻的并联</strong>是指两个或者以上的电阻，在电路当中分别以<strong>首首相接</strong>和<strong>尾尾相连</strong>的方式进行连接：</p><p><img src="/Electronics/Component/1-Basic/2.png"></p><p>电阻的<strong>并联</strong>电路，主要具备有如下四个特点：</p><ol type="1"><li>每一个并联电阻两端的<strong>电压</strong>都相等，即 <span class="math inline">\(U_{R1} = U_{R2}\)</span>；</li><li><strong>总电流</strong>等于各个并联电阻上通过的电流之和，即 <span class="math inline">\(I = I_1 + I_2\)</span>；</li><li>电阻并联之后的<strong>总电阻</strong>减小，总电阻的倒数等于各个并联电阻的倒数之和，即<span class="math inline">\(\frac{1}{R} = \frac{1}{R_1} +\frac{1}{R_2}\)</span>；</li><li>并联电阻的<strong>阻值</strong>越小，通过电阻的<strong>电流</strong>就会越高，即<span class="math inline">\(R_1 &lt; R_2 \implies I_{R1} &gt;I_{R2}\)</span>；</li></ol><h2 id="直流电-交流电">直流电 &amp; 交流电</h2><h3 id="直流电">直流电</h3><p><strong>直流电</strong>是指<strong>方向</strong>始终固定不变的<strong>电压</strong>或者<strong>电流</strong>，<strong>直流电源</strong>通常使用如下的符号进行表示：</p><p><img src="/Electronics/Component/1-Basic/3.png"></p><blockquote><p><strong>注意</strong>：直流电的电流总是由电源的<strong>正极</strong>流出，再经由电路回流至电源的<strong>负极</strong>。</p></blockquote><p>直流电可以划分为<strong>稳定直流电</strong>（<code>方向</code>和<code>大小</code>都不发生变化）和<strong>脉动直流电</strong>（<code>方向</code>不变，<code>大小</code>随时间变化）两种类型：</p><p><img src="/Electronics/Component/1-Basic/4.png"></p><h3 id="交流电">交流电</h3><p><strong>交流电</strong>是指<strong>方向</strong>与<strong>大小</strong>都随时间进行<strong>周期性</strong>变化的<strong>电压</strong>或者<strong>电流</strong>，其中最为常见的是<strong>正弦交流信号</strong>，其符号与波形如下所示：</p><p><img src="/Electronics/Component/1-Basic/5.png"></p><p>正弦交流信号的<strong>周期</strong>、<strong>频率</strong>、<strong>瞬时值</strong>、<strong>有效值</strong>都是电子学当中非常重要的概念：</p><p><img src="/Electronics/Component/1-Basic/6.png"></p><ul><li><strong>周期</strong>是指交流信号重复变化一次所需的时间，通常使用字母<code>T</code>表示，单位是<strong>秒</strong>(<code>s</code>)；例如上图当中交流信号的周期<span class="math inline">\(T = 0.02s\)</span>，表示该交流信号每间隔<code>0.02</code> 秒就会重复变化一次。</li><li><strong>频率</strong>是指交流信号在每一秒钟之内重复变化的次数，使用字母<code>f</code>表示，单位为<strong>赫兹</strong>(<code>Hz</code>)，其值为周期的倒数<span class="math inline">\(f =\frac{1}{T}\)</span>；例如上图当中交流信号的频率 <span class="math inline">\(f = \frac{1}{0.02} = 50Hz\)</span>，表明该信号在 1秒钟之内会重复变化 50 次。</li><li><strong>瞬时值</strong>是指交流信号在某一个具体时刻的参数值；例如上图交流信号在<span class="math inline">\(t_1\)</span> 时刻的瞬时值为 <span class="math inline">\(（220 \times \sqrt{2})V \approx331V\)</span>，而在 <span class="math inline">\(t_2\)</span>时刻的瞬时值为 <span class="math inline">\(0V\)</span>。</li><li><strong>有效值</strong>用于计量交流电的大小，也称为<strong>均方根值</strong>，正弦交流电的<code>有效值</code>等于其<code>最大瞬时值</code>的<span class="math inline">\(\frac{1}{\sqrt{2}} \approx 0.707\)</span>倍。</li></ul><p>除此之外，正弦交流信号的<strong>相位</strong>与<strong>相位差</strong>，也属于电子学当中比较重要的概念：</p><p><img src="/Electronics/Component/1-Basic/7.png"></p><p><strong>相位</strong>是指交流信号在某一个具体时刻的<strong>角度</strong>，上图当中交流信号在<span class="math inline">\(t = 0.005s\)</span> 时刻的相位为 <span class="math inline">\(\frac{\pi}{2}\)</span> 或者 <code>90°</code>度，而在 <span class="math inline">\(t = 0.01s\)</span> 时刻的相位为<span class="math inline">\(\pi\)</span> 或者 <code>180°</code> 度。</p><ul><li><strong>初相位</strong>就是交流信号在 <code>0</code>时刻的角度。</li><li><strong>相位差</strong>是指两个相同频率正弦交流信号的相位之差。</li><li>同一个坐标系上面，位置偏<strong>左</strong>的相位称为<strong>超前</strong>，位置偏<strong>右</strong>的相位称为<strong>滞后</strong>。</li></ul><h2 id="电路网络图论">电路网络图论</h2><p>分析只包含有一个电源的<strong>简单电路</strong>，只需要运用<code>欧姆定律</code>和<code>电阻的串并联关系</code>即可，而对于拥有着多个电源的<strong>复杂电路</strong>，则需要进一步借助<code>基尔霍夫定律</code>、<code>叠加定理</code>、<code>戴维南定理</code>等。在进行更深入的讨论之前，需要引入电路网络图论的相关内容：</p><p><img src="/Electronics/Component/1-Basic/8.png"></p><ul><li><strong>支路</strong>：由一个或多个元器件首尾相接构成的一段电路（无其它分支），相同支路内通过所有元器件的电流都相等。上图电路当中拥有<code>BAFE</code>、<code>BE</code>、<code>BCDE</code>一共三条支路，其中包含有电源的称为<strong>有源支路</strong>，没有电源的称为<strong>无源支路</strong>。</li><li><strong>结点</strong>：三条或者以上支路的共同连接点，例如上面电路当中的<code>B</code> 点和 <code>E</code> 点。</li><li><strong>回路</strong>：即电路当中任意的闭合路径，例如上图所示电路当中的<code>ABEFA</code>、<code>BCDEB</code>、<code>ABCDEFA</code>。</li><li><strong>网孔</strong>：即内部不再包含有任何支路的回路，例如上图所示电路当中的<code>ABEFA</code>、<code>BCDEB</code>，而 <code>ABCDEFA</code>由于包含有支路 <code>BE</code>，因而不属于网孔。</li></ul><h2 id="基尔霍夫定律">基尔霍夫定律</h2><p><strong>基尔霍夫定律</strong>可以分为<strong>基尔霍夫第一定律</strong>（也称为<strong>基尔霍夫电流定律</strong>）和<strong>基尔霍夫第二定律</strong>（又称<strong>基尔霍夫电压定律</strong>）。</p><h3 id="基尔霍夫电流定律">基尔霍夫电流定律</h3><p>基尔霍夫电流定律：<strong>流入任意一个结点的电流之和，等于流出该结点的电流之和</strong>，即<span class="math inline">\(\Sigma I_{流入结点} = \SigmaI_{流出结点}\)</span>：</p><p><img src="/Electronics/Component/1-Basic/9.png"></p><p>上图所示的电路当中，流入 <strong>A</strong> 点的电流有 <span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span>、<span class="math inline">\(I_3\)</span> 三个，而流出 <strong>A</strong>点的电流有 <span class="math inline">\(I_4\)</span> 和 <span class="math inline">\(I_5\)</span>两个，根据基尔霍夫电流定律可以得出如下的关系：</p><p><span class="math display">\[I_1 + I_2 + I_3 = I_4 + I_5\]</span></p><blockquote><p><strong>注意</strong>：基尔霍夫电流定律不仅适用于电路当中的<strong>节点</strong>，同样也适用于一个<strong>封闭平面</strong>。</p></blockquote><h3 id="基尔霍夫电压定律">基尔霍夫电压定律</h3><p>基尔霍夫电压定律：<strong>任意一个回路内，所有支路的电压代数和为零</strong>（需要先确定参考方向），即<span class="math inline">\(\Sigma U = 0V\)</span>：</p><p><img src="/Electronics/Component/1-Basic/10.png"></p><p>指定上图电路当中 <code>BCDFB</code>回路的参考方向，经过<strong>电阻</strong> <span class="math inline">\(R_2\)</span> 的<strong>电流</strong> <span class="math inline">\(I_2\)</span>，与经过<strong>电阻</strong> <span class="math inline">\(R_3\)</span> 的<strong>电流</strong> <span class="math inline">\(I_3\)</span> 的绕行方向一致，所以 <span class="math inline">\(I_2 \times R_2 = U_2\)</span> 和 <span class="math inline">\(I_3 \times R_3 = U_3\)</span>两者都取<strong>正</strong>。由于电源的电动势方向是从<strong>负极</strong>到<strong>正极</strong>，所以<strong>电源</strong><span class="math inline">\(E_2\)</span>的电动势方向与参考方向相反取<strong>负</strong>，根据基尔霍夫电压定律可以得出如下关系：</p><p><span class="math display">\[E_2 = (I_2 \times R_2) + (I_3 \times R_3)\]</span></p><p>接下来，再指定上面电路当中 <code>ABFHA</code>回路的参考方向，流过<strong>电阻</strong> <span class="math inline">\(R_1\)</span> 的<strong>电流</strong> <span class="math inline">\(I_1\)</span> 方向与参考方向相同，所以 <span class="math inline">\(I_1 \times R_1 = U_1\)</span>取<strong>正</strong>；而流过<strong>电阻</strong> <span class="math inline">\(R_2\)</span> 的<strong>电流</strong> <span class="math inline">\(I_2\)</span> 方向与参考方向相反，所以 <span class="math inline">\(I_2 \times R_2 = U_2\)</span>取<strong>负</strong>；同样由于电源的电动势方向是从<strong>负极</strong>到<strong>正极</strong>，所以<strong>电源</strong><span class="math inline">\(E_2\)</span>的电动势方向与参考方向相同取<strong>正</strong>，而<strong>电源</strong><span class="math inline">\(E_1\)</span>的电动势方向与参考方向相反取<strong>负</strong>，从而可以得出如下的关系：</p><p><span class="math display">\[E_2 - E_1 = (I_1 \times R_1) - (I_2 \times R_2)\]</span></p><h2 id="叠加定理">叠加定理</h2><p><strong>叠加定理</strong>是一个反映<strong>线性电路</strong>基本性质的重要定理，其是指<strong>在线性电路当中，任意一条支路上的电流或者电压等于每一个电源单独作用在该条支路，所产生的电流或者电压的代数和</strong>。接下来，以下图所示电路为例来说明叠加定理的应用。已知下面电路当中的<span class="math inline">\(E_1 = 14V\)</span>、<span class="math inline">\(R_1 = 0.5Ω\)</span>、<span class="math inline">\(E_2 = 12V\)</span>、<span class="math inline">\(R_2 = 0.2Ω\)</span>、<span class="math inline">\(R= 4Ω\)</span>，试求解支路电流 <span class="math inline">\(I\)</span>、<span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span> ？</p><p><img src="/Electronics/Component/1-Basic/11.png"></p><p>首先，标识出上述电路当中各条支路的<strong>电流</strong>方向，然后绘制出只存在一个<strong>电源</strong><span class="math inline">\(E_1\)</span>作用时的电路（将另外一个<strong>电源</strong> <span class="math inline">\(E_2\)</span>视为<strong>短路</strong>），并且标识出简化电路上各条支路的<strong>电流</strong>方向，再分别求解出各条支路上的电流大小：</p><p><img src="/Electronics/Component/1-Basic/12.png"></p><p>接下来，再绘制出只存在一个<strong>电源</strong> <span class="math inline">\(E_2\)</span>作用时的电路（再将另外一个<strong>电源</strong> <span class="math inline">\(E_1\)</span>视为<strong>短路</strong>），同样标识出简化电路上各条支路的<strong>电流</strong>方向，再分别求解出各条支路上的电流大小：</p><p><img src="/Electronics/Component/1-Basic/13.png"></p><p>最后，叠加每一条支路上的电流或者电压（凡是与上面电路标识出的参考方向一致就为<strong>正</strong>，反之就为<strong>负</strong>），从而就可以求解出各条支路上的<strong>电流</strong><span class="math inline">\(I\)</span>、<span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span>：</p><p><span class="math display">\[\begin{align}&amp; I_1 = I_1&#39; - I_1&#39;&#39; = (20.28 - 16.56) = 3.72A \\&amp; I_2 = I_2&#39;&#39; - I_2&#39; = (18.6 - 19.3) = -0.7A \\&amp; I = I&#39; + I&#39;&#39; = (0.98 + 2.04) = 3.02A \\\end{align}\]</span></p><blockquote><p><strong>注意</strong>：如果元器件两端的<strong>电压</strong>与流过的<strong>电流</strong>呈正比，那么这类元器件（例如电阻）就被称作<strong>线性元件</strong>，而由线性元件组成的电路相应的就被称为<strong>线性电路</strong>。</p></blockquote><h2 id="戴维南定理">戴维南定理</h2><p><strong>二端网络</strong>顾名思义就是具有两个出线端子的电路，而包含有<strong>电源</strong>的二端网络就称为<strong>有源二端网络</strong>，否则就称为<strong>无源二端网络</strong>。例如下图左侧的电路，就可以简化为右侧的二端口网络：</p><p><img src="/Electronics/Component/1-Basic/14.png"></p><p><strong>戴维南定理</strong>是指对于任何一个有源二端口网络，都可以用一个等效的电源<strong>电动势</strong><span class="math inline">\(E_0\)</span> 与<strong>内阻</strong> <span class="math inline">\(R_0\)</span>的串联组合来代替，根据该定理同样可以将下图左侧的电路简化为右侧的形式：</p><p><img src="/Electronics/Component/1-Basic/15.png"></p><p><strong>戴维南定理</strong>还规定了等效的<strong>电源电动势</strong><span class="math inline">\(E_0\)</span> 以及<strong>内阻</strong> <span class="math inline">\(R\)</span> 的计算方法：</p><ul><li><strong>电源电动势</strong> <span class="math inline">\(E_0\)</span>指的是该有源二端口网络<strong>开路</strong>时候的端口电压。</li><li><strong>内阻</strong> <span class="math inline">\(R\)</span>是指从两个端口看进去，将电源视为<strong>短路</strong>时候的等效电阻。</li></ul><p>接下来，以下图所示的电路为例来展示<strong>戴维南定理</strong>的应用，已知该电路当中的<span class="math inline">\(E_1 = 14V\)</span>、<span class="math inline">\(R_1 = 0.5Ω\)</span>、<span class="math inline">\(E_2 = 12V\)</span>、<span class="math inline">\(R_2 = 0.2Ω\)</span>、<span class="math inline">\(R= 4Ω\)</span>，试求解通过<strong>电阻</strong> <span class="math inline">\(R\)</span> 的<strong>电流</strong> <span class="math inline">\(I\)</span> 的大小？</p><p><img src="/Electronics/Component/1-Basic/16.png"></p><p>首先，将电路划分为<strong>待求支路</strong>和<strong>有源二端口网络</strong>两个部分（如上图所示），然后假设待求支路处于断开状态，并且求解出有源二端网络开路时候的<strong>端口电压</strong>，该电压就等效为电源的<strong>电动势</strong><span class="math inline">\(E_0\)</span>：</p><p><img src="/Electronics/Component/1-Basic/17.png"></p><p>然后，再假设有源二端口网络内部的所有<strong>电源短路</strong>，从而就可以获得其<strong>内部电阻</strong><span class="math inline">\(R_0\)</span> 的阻值：</p><p><img src="/Electronics/Component/1-Basic/18.png"></p><p>接下来，基于上述步骤获得的<strong>电源电动势</strong> <span class="math inline">\(E_0\)</span> 以及<strong>内阻</strong> <span class="math inline">\(R\)</span>，就可以绘制出如下图所示的<strong>戴维南等效电路</strong>，并且求解出<strong>支路电流</strong><span class="math inline">\(I\)</span> 的大小：</p><p><img src="/Electronics/Component/1-Basic/19.png"></p><blockquote><p><strong>注意</strong>：对于拥有多个电源的复杂电路，如果需要求解多条支路上的电流大小，可以运用<strong>基尔霍夫定律</strong>或者<strong>叠加定理</strong>。如果只需要求解一条支路上的电流大小，则使用<strong>戴维南定理</strong>更加方便。</p></blockquote><h2 id="最大功率传输定理">最大功率传输定理</h2><p>最大功率传输定理是指负载要从电源获得最大功率的条件是：<strong>负载的内阻或者阻抗与电源的内阻相等</strong>，也就是电路设计工作当中经常提到的<strong>阻抗匹配</strong>。例如下图所示的电路，其中的<strong>电阻</strong><span class="math inline">\(R\)</span> 是<strong>电源</strong> <span class="math inline">\(E\)</span> 的内阻，而 <span class="math inline">\(I\)</span> 和 <span class="math inline">\(U\)</span> 则是<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span>上通过的<strong>电压</strong>与<strong>电流</strong>：</p><p><img src="/Electronics/Component/1-Basic/20.png"></p><p><strong>负载电阻</strong> <span class="math inline">\(R_L\)</span>上获得的<strong>功率</strong> <span class="math inline">\(P =UI\)</span>，如果增大<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 的阻值，虽然<strong>电压</strong><span class="math inline">\(U\)</span>会随之增大，但是<strong>电流</strong> <span class="math inline">\(I\)</span>会减小。如果减小<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 的阻值，虽然<strong>电流</strong><span class="math inline">\(I\)</span>会随之增大，但是<strong>电压</strong> <span class="math inline">\(U\)</span>又会减小。根据最大功率传输定理，此时<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 要从<strong>电源</strong> <span class="math inline">\(E\)</span> 获得最大功率的条件是 <span class="math inline">\(R_L = R\)</span>，这样<strong>负载电阻</strong><span class="math inline">\(R_L\)</span>上获得的<strong>最大功率</strong> <span class="math inline">\(P\)</span>为：</p><p><span class="math display">\[P = \frac{E^2}{4 \cdot R_L}\]</span></p><p>对于下面这种拥有<strong>多个电源</strong>的复杂电路，则需要先使用<strong>戴维南定理</strong>求解出该电路的<strong>等效内阻</strong><span class="math inline">\(R_0\)</span> 和<strong>等效电动势</strong><span class="math inline">\(E_0\)</span>：</p><p><img src="/Electronics/Component/1-Basic/21.png"></p><p>然后同样只要<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 与电源的<strong>等效内阻</strong><span class="math inline">\(R_0\)</span>相等，那么<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 就可以获得到<strong>最大功率</strong><span class="math inline">\(P\)</span>：</p><p><span class="math display">\[P = \frac{E_0^2}{4 \cdot R_L}\]</span></p><h2 id="贴片元件封装规格">贴片元件封装规格</h2><p>下面的表格体现了电路设计当中，常用元件的贴片封装规格，以及对应的尺寸信息：</p><p><img src="/Electronics/Component/1-Basic/22.png"></p><h2 id="电磁兼容性-emc">电磁兼容性 EMC</h2><p><strong>EMC</strong>是电磁兼容性（<strong>E</strong>lectro<strong>m</strong>agnetic[ɪˌlektroʊmæɡˈnetɪk]<strong>C</strong>ompatibility）的英文缩写，其意思是<strong>不对其它设备产生电磁干扰，即使受到来自其它设备的电磁干扰，也仍然能够保持原始的性能</strong>。由于需要同时兼具<strong>不干扰其它设备</strong>，以及<strong>抗其它设备干扰</strong>两种性能指标，因而被称为<strong>电磁兼容性</strong>。</p><p><img src="/Electronics/Component/1-Basic/23.png"></p><ul><li><strong>EMI</strong>（Electromagnetic Interference[ˌɪntəˈfɪərəns]）是<strong>电磁干扰</strong>的英文缩写，表示因发射电磁波而对周围环境造成的干扰，即<strong>干扰其它设备</strong>。</li><li><strong>EMS</strong>（Electromagnetic Susceptibility[səˌseptəˈbɪləti]）是<strong>电磁敏感性</strong>的英文缩写，代表的是对于电磁波干扰的耐受度，即<strong>被其它设备干扰</strong>。</li></ul><blockquote><p><strong>注意</strong>：上图中的<strong>传导</strong>表示的是<strong>传输导线</strong>，而<strong>辐射</strong>代表的是<strong>电磁辐射</strong>。</p></blockquote><h1 id="电阻器-resistor">电阻器 Resistor</h1><p>电阻器可以具体划分为<strong>固定电阻器</strong>、<strong>电位器</strong>、<strong>敏感电阻器</strong>三种类型，其中<strong>固定电阻器</strong>的阻值固定不变，通常使用如下的电路符号来进行表示：</p><p><img src="/Electronics/Component/2-Resistance/1.png"></p><p>固定电阻器通常在电路中起到<strong>降压/限流</strong>、<strong>分流</strong>、<strong>分压</strong>的作用：</p><p><img src="/Electronics/Component/2-Resistance/2.png"></p><h2 id="标称阻值">标称阻值</h2><p><strong>标称阻值</strong>是标注在电阻器上的阻值，使用<strong>单位</strong>来代表<strong>小数点</strong>是一种经常被使用到的阻值表示方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>k2 = <span class="number">1.2</span>kΩ</span><br><span class="line"><span class="number">3</span>M3 = <span class="number">3.3</span>MΩ</span><br><span class="line"><span class="number">3</span>R3 = <span class="number">3.3</span>Ω</span><br><span class="line">R33 = <span class="number">0.33</span>Ω</span><br></pre></td></tr></table></figure><p>贴片电阻器通常采用<strong>数值标注法</strong>，其最后一位表示阻值当中<code>0</code> 的个数，而前面的三到四位才是真正的有效数值：</p><p><img src="/Electronics/Component/2-Resistance/3.png"></p><h2 id="误差">误差</h2><p>电阻器的<strong>误差</strong>是实际阻值与标称阻值的差距，例如 <span class="math inline">\(\pm 5\%\)</span>、<span class="math inline">\(\pm10\%\)</span>、<span class="math inline">\(\pm 20\%\)</span>。国家标准<strong>E-24</strong>、<strong>E-12</strong>、<strong>E-6</strong>分别对各个厂家所生产电阻器的标称阻值（必须为 <code>10</code>的正整数倍）与误差进行了规定：</p><table><colgroup><col style="width: 8%"><col style="width: 6%"><col style="width: 5%"><col style="width: 79%"></colgroup><thead><tr class="header"><th style="text-align: center;">标称阻值系列</th><th style="text-align: center;">允许误差</th><th style="text-align: center;">误差等级</th><th>标称阻值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>E-24</strong></td><td style="text-align: center;"><span class="math inline">\(\pm5\%\)</span></td><td style="text-align: center;"><strong>Ⅰ</strong></td><td>1.0、1.1、1.2、1.3、1.5、1.6、1.8、2.0、2.2、2.4、2.7、3.0、3.3、3.6、3.9、4.3、4.7、5.1、5.6、6.2、6.8、7.5、8.2、9.1</td></tr><tr class="even"><td style="text-align: center;"><strong>E-12</strong></td><td style="text-align: center;"><span class="math inline">\(\pm10\%\)</span></td><td style="text-align: center;"><strong>Ⅱ</strong></td><td>1.0、1.2、1.5、1.8、2.2、2.7、3.3、3.9、4.7、5.6、6.8、8.2</td></tr><tr class="odd"><td style="text-align: center;"><strong>E-6</strong></td><td style="text-align: center;"><span class="math inline">\(\pm20\%\)</span></td><td style="text-align: center;"><strong>Ⅲ</strong></td><td>1.0、1.5、2.2、3.3、4.7、6.8</td></tr></tbody></table><h2 id="额定功率">额定功率</h2><p>电阻器的<strong>额定功率</strong>是指一定条件下，长期使用所允许承受的最大功率。额定功率越大，允许流过电阻器的<strong>电流</strong>就越大。国家规定的固定电阻器额定功率有<code>1/8W</code>、<code>1/4W</code>、<code>1/2W</code>、<code>1W</code>、<code>2W</code>、<code>5W</code>、<code>10W</code>等，下面的表格体现了各种封装的贴片电阻与其额定功率的对应关系：</p><table><thead><tr class="header"><th style="text-align: center;">封装规格</th><th style="text-align: center;">额定功率</th><th style="text-align: center;">封装规格</th><th style="text-align: center;">额定功率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0402</strong> 封装</td><td style="text-align: center;"><code>1/16</code> W</td><td style="text-align: center;"><strong>1210</strong> 封装</td><td style="text-align: center;"><code>1/3</code> W</td></tr><tr class="even"><td style="text-align: center;"><strong>0603</strong> 封装</td><td style="text-align: center;"><code>1/10</code> W</td><td style="text-align: center;"><strong>1812</strong> 封装</td><td style="text-align: center;"><code>1/2</code> W</td></tr><tr class="odd"><td style="text-align: center;"><strong>0805</strong> 封装</td><td style="text-align: center;"><code>1/8</code> W</td><td style="text-align: center;"><strong>2010</strong> 封装</td><td style="text-align: center;"><code>3/4</code> W</td></tr><tr class="even"><td style="text-align: center;"><strong>1206</strong> 封装</td><td style="text-align: center;"><code>1/4</code> W</td><td style="text-align: center;"><strong>2512</strong> 封装</td><td style="text-align: center;"><code>1</code> W</td></tr></tbody></table><h2 id="电阻器的选型">电阻器的选型</h2><p>对电阻器进行选型时，会主要考虑其<strong>标称阻值</strong>、<strong>误差</strong>、<strong>额定功率</strong>、<strong>最大工作电压</strong>、<strong>温度系数</strong>，例如对于下面这个电路：</p><p><img src="/Electronics/Component/2-Resistance/4.png"></p><p>首先，在<strong>考虑到误差</strong>的前提下确定<strong>阻值</strong>，基于欧姆定律可以求解得到电阻器的取值：</p><p><span class="math display">\[R = \frac{U}{I} = \frac{220V}{0.01A} = 22000Ω = 22kΩ\]</span></p><p>然后，根据功率的计算公式获得该电阻器消耗的功率，基于下面的公式可以计算得到<code>2.2W</code>。由于选取的电阻器<strong>额定功率应当在实际功率的两倍以上</strong>，所以这里选择的电阻器额定功率应当为<code>5W</code>：</p><p><span class="math display">\[P = I^2R = (0.01A)^2 \times 22000Ω = 2.2W\]</span></p><p>最后，还需要关注该电阻器所能够承受的<strong>最大工作电压</strong>，避免低于电路当中两端的实际电压而导致烧毁。除此之外，电阻器选型过程当中，<strong>温度系数</strong>和 <strong>噪声</strong> 也是非常重要的两个选型参数：</p><ul><li><strong>温度系数</strong>也是一个十分需要关注的参数（例如<code>±100 ppm/℃</code>、<code>±200 ppm/℃</code>），其表示了温度每变化<code>1℃</code>所引发的阻值相对变化。通常情况下，<strong>温度系数越小越好</strong>。</li><li><strong>噪声</strong>是产生于电阻器当中的一种不规则电压起伏，主要是由于内部不规则的自由电子运动所导致，<strong>噪声越低越好</strong>。</li></ul><blockquote><p><strong>注意</strong>：元器件的参数值，伴随着温度的升高而增大就称为<strong>正温度系数</strong>，反之则称为<strong>负温度系数</strong>。</p></blockquote><h2 id="薄膜厚膜电阻器">薄膜/厚膜电阻器</h2><p><strong>薄膜电阻</strong>或者<strong>厚膜电阻</strong>通常用于标注<strong>贴片电阻器</strong>，这是因为贴片电阻器是将<code>金属粉</code>与<code>玻璃釉粉</code>混合之后，印刷在基板上制作而成，根据印刷厚度可以大致划分为<strong>薄膜电阻</strong>或者<strong>厚膜电阻</strong>两种类型：</p><p><img src="/Electronics/Component/2-Resistance/5.png"></p><blockquote><p><strong>注意</strong>：通常情况下，<strong>薄膜电阻的温度系数要优于厚膜电阻</strong>。</p></blockquote><h2 id="碳膜金属膜电阻器">碳膜/金属膜电阻器</h2><p>这类电阻器是将一层<strong>碳膜</strong>或者<strong>金属膜</strong>附着在陶瓷基底上面制作而成，材料膜的厚度决定了阻值的大小：</p><p><img src="/Electronics/Component/2-Resistance/6.png"></p><blockquote><p><strong>注意</strong>：<strong>金属膜电阻器</strong>精度更高，噪声更小，温度系数更低。而<strong>碳膜电阻器</strong>的优势则主要在于成本低廉。</p></blockquote><h2 id="采样电阻器">采样电阻器</h2><p><strong>采样电阻</strong>通常采用铜镍、锰铜等合金材料制作，具备<strong>低温度系数</strong>（通常为<code>±50ppm/℃</code>或者更低）和<strong>极低的电阻值</strong>（毫欧级别，通常不会超过<code>1Ω</code>），可以在极宽的温度范围内具有比较稳定的电阻值。主要用于在电路当中进行<code>电压</code>或者<code>电流</code>的采样（<strong>电流采样</strong>时<strong>串联</strong>一个较小阻值的采样电阻，<strong>电压采样</strong>时则需要<strong>并联</strong>一个较大阻值的采样电阻）。</p><p><img src="/Electronics/Component/2-Resistance/7.png"></p><blockquote><p><strong>注意</strong>：万用表当中经常使用的<strong>康铜丝电阻</strong>，实质上就采用了<strong>铜镍</strong>或者<strong>锰铜</strong>合金材料。</p></blockquote><h2 id="电位器">电位器</h2><p><strong>电位器</strong>是一种阻值可以变化调节的电阻器，也被称作<strong>可变电阻器</strong>，其电路符号如下图所示：</p><p><img src="/Electronics/Component/2-Resistance/8.png"></p><p>电位器的基本结构如下图所示，其拥有<code>A</code>、<code>C</code>、<code>B</code> 三个引脚，在<code>A</code> 与 <code>B</code> 引脚之间连接着一段阻值为 <span class="math inline">\(R_{AB}\)</span>的电阻材料，该阻值就是这个电位器的<strong>标称阻值</strong>:</p><p><img src="/Electronics/Component/2-Resistance/9.png"></p><p>上面电位器的引脚 <code>C</code> 连接着一个滑动片，此时 <code>A</code>与 <code>C</code> 引脚之间的阻值为 <span class="math inline">\(R_{AC}\)</span>，而 <code>B</code> 与<code>C</code> 引脚之间的阻值为 <span class="math inline">\(R_{BC}\)</span>，三个引脚之间的电阻值存在着如下关系：</p><p><span class="math display">\[R_{AB} = R_{AC} + R_{BC}\]</span></p><p>类似于固定电阻器，电位器同样具备<strong>降压/限流</strong>、<strong>分流</strong>、<strong>分压</strong>的作用，不过由于其阻值可调，因而随时可以通过改变上述三个引脚之间的电阻值来调整相关的参数。</p><p>除了<strong>标称阻值</strong>、<strong>额定功率</strong>等电阻器通用参数之外，电位器的另外一个重要参数是<strong>阻值变化特性</strong>，也就是<strong>电位器阻值</strong>与滑动片旋转角度之间的关系，根据阻值变化特性不同可以划分为如下三种类型：</p><p><img src="/Electronics/Component/2-Resistance/10.png"></p><ol type="1"><li><strong>直线式</strong>：阻值与旋转角度呈直线关系，当旋转滑动片时，电位器的阻值会匀速变化，即电位器的阻值变化与旋转角度大小呈<strong>正比</strong>。</li><li><strong>指数式</strong>：阻值与旋转角度呈指数关系，刚开始旋转滑动片时，阻值变化很<strong>慢</strong>，随着转动角度的增大，阻值变化<strong>增大</strong>。</li><li><strong>对数式</strong>：阻值与旋转角度呈对数关系，刚开始旋转滑动片时，阻值变化很<strong>快</strong>，随着转动角度的增大，阻值变化<strong>减小</strong>。</li></ol><p>电位器的类型比较多，可以被划分为<strong>普通电位器</strong>、<strong>微调电位器</strong>、<strong>带开关电位器</strong>、<strong>多联电位器</strong>等种类：</p><p><img src="/Electronics/Component/2-Resistance/11.png"></p><ul><li><strong>普通电位器</strong>一般是指带有调节手柄的电位器。</li><li><strong>微调电位器</strong>通常不带调节手柄，需要使用螺丝刀进行调节。</li><li><strong>带开关电位器</strong>结合了开关（引脚数量会多出 2个）与电位器的功能。</li><li><strong>多联电位器</strong>把多个电位器组合在一起，可以同时进行调节。</li></ul><h2 id="热敏电阻器">热敏电阻器</h2><p><strong>热敏电阻器</strong>是一种对于温度敏感的电阻器，当温度变化时其阻值也会随之变化，其电路符号如下图所示：</p><p><img src="/Electronics/Component/2-Resistance/12.png"></p><p>通常情况下，热敏电阻器可以被划分为<strong>负温度系数</strong>和<strong>正温度系数</strong>热敏电阻器两种类型：</p><p><img src="/Electronics/Component/2-Resistance/13.png"></p><ol type="1"><li><strong>负温度系数</strong>热敏电阻器（NTC）：<strong>阻值</strong>随着温度的<strong>升高</strong>而<strong>减小</strong>。</li><li><strong>正温度系数</strong>热敏电阻器（PTC）：<strong>阻值</strong>随着温度的<strong>升高</strong>而<strong>增大</strong>。</li></ol><p>除此之外，热敏电阻器还可以被划分为<strong>缓慢型</strong>和<strong>开关型</strong>两种：</p><ul><li><strong>缓慢型</strong>热敏电阻器：温度每变化<code>1℃</code>，其阻值就会随之发生 <code>0.5% ~ 8%</code>的线性变化。</li><li><strong>开关型</strong>热敏电阻器：具有一个转折温度，当低于或者高于该温度时，阻值就会急剧增大或者减小。</li></ul><blockquote><p><strong>注意</strong>：热敏电阻器的<strong>标称阻值</strong>，是指当处于<code>25℃</code> 室温情况下所测得的电阻值。</p></blockquote><h2 id="压敏电阻器">压敏电阻器</h2><p><strong>压敏电阻器</strong>是指当两端电压低于<strong>压敏电压</strong>时，其阻值接近于无穷大。当两端电压超过<strong>压敏电压</strong>时，阻值又会急剧变小，其电路符号如下图所示：</p><p><img src="/Electronics/Component/2-Resistance/14.png"></p><p>利用压敏电阻器<strong>过电压</strong>时阻值变小的特性，可以将其应用于一些<strong>过压保护</strong>或者<strong>浪涌保护</strong>电路：</p><p><img src="/Electronics/Component/2-Resistance/15.png"></p><p>在上图的电路当中，<code>220V</code> 交流电通过保险丝 <code>F</code>连接至家用电器，当发生雷击的时候，就会导致电压瞬间上升。如果该电压被施加到压敏电阻器两端，就会使得压敏电阻器的阻值迅速降低至<strong>零</strong>，此时流过保险丝和压敏电阻器的电流急剧增大，致使保险丝被瞬间熔断，从而防止雷击的电压触及家用电器。</p><p><img src="/Electronics/Component/2-Resistance/16.png"></p><blockquote><p><strong>注意</strong>：大多数情况下，<strong>压敏电压</strong>是指使用<code>1mA</code> 直流电流经过压敏电阻器时所测得的电压值。对于<code>220V</code>的交流市电保护电路，通常会选用<strong>压敏电压</strong>介于<code>480V ~ 560V</code> 范围的压敏电阻。</p></blockquote><h2 id="光敏电阻器">光敏电阻器</h2><p><strong>光敏电阻器</strong>是一种对光照敏感的电阻器，当照射的光线强弱发生变化时，其阻值也会随之变化（通常情况下<strong>光线越强阻值越小</strong>），其电路符号如下图所示：</p><p><img src="/Electronics/Component/2-Resistance/17.png"></p><p>下面分别展示了贴片式和直插式光敏电阻器的实物，在进行光敏电阻器的选型时，需要重点关注如下三个参数：</p><p><img src="/Electronics/Component/2-Resistance/18.png"></p><ol type="1"><li><strong>最高工作电压</strong>：光敏电阻器正常工作时，两端所允许的最大电压。</li><li><strong>暗电阻</strong>：关闭光线照射（<code>0 Lux</code>）之后，第10秒钟时刻的阻值，此时在其<code>最高工作电压</code>下通过的电流的称为<strong>暗电流</strong>。</li><li><strong>亮电阻</strong>：使用光线照射（<code>10 Lux</code>）之后，所测得的阻值，此时在其<code>最高工作电压</code>下通过的电流的称为<strong>亮电流</strong>。</li></ol><p>下图是光敏电阻器的两个典型应用电路，即分别将其<strong>串联</strong>或者<strong>并联</strong>在电路当中使用：</p><p><img src="/Electronics/Component/2-Resistance/19.png"></p><ul><li>上图左侧电路是将<strong>光敏电阻串联使用</strong>，如果光敏电阻器<span class="math inline">\(R_2\)</span>无光线照射，那么阻值增大，流经灯的电流较小，灯亮度较暗。如果 <span class="math inline">\(R_2\)</span>被光线照射，那么阻值降低，流经灯的电流增大，灯的亮度就会增强。</li><li>上图右侧电路是将<strong>光敏电阻并联使用</strong>，当光敏电阻器<span class="math inline">\(R_2\)</span>无光线照射，那么其阻值将会增大，并联分得的电流就会减少，此时灯的亮度就会增强。反之，如果<span class="math inline">\(R_2\)</span>被光线照射，那么阻值就会降低，并联分得的电流就会增多，流经灯的电流将会减小，导致其亮度降低。</li></ul><h1 id="电容器-capacitor">电容器 Capacitor</h1><p><strong>电容器</strong>是一种可以储存电荷的元器件，由相距很近且中间隔有绝缘介质的两块导电极板构成，按照有无极性可以划分为如下两种类型：</p><ol type="1"><li><strong>无极性电容</strong>：引脚没有正负极性之分，主要是<code>MLCC 多层陶瓷电容</code>、<code>瓷片电容</code>。</li><li><strong>有极性电容</strong>：需要区分引脚的正负极（正极连接高电位，负极连接低电位，反接会导致损毁），例如常见的<code>电解电容</code>、<code>钽电容</code>。</li></ol><p><img src="/Electronics/Component/3-Capacitor/1.png"></p><p>上图分别展示了<strong>有极性电容</strong>和<strong>无极性电容</strong>的电路符号，使用的时候要注意加以区分。</p><h2 id="主要参数">主要参数</h2><p>电容器选型主要关注的参数有<strong>容值</strong>、<strong>精度</strong>、<strong>额定电压</strong>、<strong>等效串联电阻</strong>（ESR）：</p><ul><li><strong>容值</strong>：电容器存储电荷的多少，单位有<strong>法拉</strong>(F)、<strong>毫法</strong>(mF)、<strong>微法</strong>(μF)、<strong>纳法</strong>(nF)、<strong>皮法</strong>(pF)，相互之间的换算关系为<span class="math inline">\(1F = 10^3mF= 10^6 \mu F = 10^9 nF =10^{12}pF\)</span>；</li><li><strong>精度</strong>：标称容量与实际容量之间所允许的最大误差值，常见的精度有<code>±10%</code> 或者 <code>±20%</code>，比较高精度的甚至可以达到<code>±5%</code>；</li><li><strong>额定电压</strong>：也称为<strong>耐压值</strong>，是指在正常工作情况下，电容器两端所允许承受的最大电压值。一旦超过额定电压，极板之间的绝缘介质就会被击穿。常见的耐压值有<code>10V</code>、<code>16V</code>、<code>25V</code>、<code>50V</code>等。</li><li><strong>等效串联电阻</strong>：由于制作电容的材料具有一定的电阻性，导致工作时电信号出现损耗，这个损耗在外部会体现为一个串联的电阻，因而称为等效串联电阻（ESR），通常使用的单位为<strong>毫欧</strong>(mΩ)。通常情况下ESR 越小越好，但是某些稳压电路反而会选择具备一定 ESR 的电容器。</li><li><strong>损耗角正切值</strong>：由于电容器介电质损耗的原因，导致电容器上电压与电流的<strong>相位角</strong>并非理想的90° 度，而是偏离了一个 <span class="math inline">\(\delta\)</span>度，这个 <span class="math inline">\(\delta\)</span>角就被称为电容器的<strong>损耗角</strong>，该参数用于衡量电容器内部的<strong>电能损耗程度</strong>，因而越小越好。</li><li><strong>漏电流</strong>：虽然电容器内部的电介质对于直流电流具有阻碍作用，但是依然会有少部分漏电流通过，此参数会伴随温度与电压的升高而增大。</li></ul><h2 id="充放电特性">充放电特性</h2><p><strong>充电</strong>（电容器上获得电荷的过程）与<strong>放电</strong>（电容器上电荷流失的过程）是电容器非常重要的性质，电容器极板上存储的电荷数量与两个极板之间的电压具有一定的关系，即<strong>容值C</strong>（法拉<code>F</code>）不变的情况下，电容器储存的<strong>电荷数量Q</strong>（库伦 <code>C</code>）与其两端的<strong>电压 U</strong>（伏特<code>V</code>）呈正比：</p><p><span class="math display">\[Q = C \cdot U\]</span></p><h2 id="隔直通交特性">隔直通交特性</h2><p>电容器的一个显著特征是具有<strong>隔离直流</strong>、<strong>通过交流</strong>的特性：</p><ul><li><strong>隔直</strong>：直流电可以对电容器充电，这个过程持续时间很短，充电结束之后，直流电就无法再通过电容器。</li><li><strong>通交</strong>：由于交流电极性不断变化，电容器的充放电过程反复交替进行，因而始终会有交流电流通过电容器。</li></ul><h2 id="容抗">容抗</h2><p>电容器虽然能够通过交流信号，但是对于交流信号也存在一定的阻碍，这种阻碍作用就被称为<strong>容抗</strong>，使用<span class="math inline">\(X_C\)</span>进行表示，单位为<strong>欧姆</strong>(Ω)。电容器的<strong>容抗</strong>与交流信号的<strong>频率</strong><span class="math inline">\(f\)</span>，乃至于电容器<strong>容值</strong><span class="math inline">\(C\)</span> 之间的关系如下面公式所示：</p><p><span class="math display">\[X_C = \frac{1}{2 \pi f C}\]</span></p><p>观察这个公式可以得出结论：<strong>交流信号的频率越高，电容器的容抗就越小；或者电容器的容值越大，电容器的容抗也会越小</strong>。</p><h2 id="容值的标注">容值的标注</h2><p><strong>铝电解电容</strong>体积较大，通常使用直标法，即直接在外壳上标识出<strong>容值</strong>、<strong>耐压值</strong>、<strong>误差</strong>三个指标：</p><p><img src="/Electronics/Component/3-Capacitor/2.png"></p><p><strong>直插式瓷片电容</strong>，由于容值较小（皮法 <code>pF</code>级别），则通常会采用更为简单明了的<strong>整数标注法</strong>：</p><p><img src="/Electronics/Component/3-Capacitor/3.png"></p><ul><li>如果标注的整数值末位为 <code>0</code>，例如 <code>330</code>就表示容值为 <span class="math inline">\(330\ pF\)</span>。</li><li>如果标注的整数值末位不为 <code>0</code>，例如 <code>103</code>就表示容值为 <span class="math inline">\(10 \times 10^3\pF\)</span>。</li><li>如果标注的整数值末位为 <code>9</code>，并不是表示 <span class="math inline">\(10^9\)</span>，而是表示 <span class="math inline">\(10^{-1}\)</span>，例如 <code>339</code> 表示容值为<span class="math inline">\(3.3\ pF\)</span>。</li></ul><blockquote><p><strong>注意</strong>：对于容量较大的无极性电容器，少数情况下会采用<strong>小数点标注法</strong>，即分别使用<span class="math inline">\(\mu\)</span>、<span class="math inline">\(n\)</span>、<span class="math inline">\(p\)</span>来表示小数点，例如 <code>p1</code> 表示<code>0.1pF</code>、<code>4n7</code> 表示<code>4.7nF</code>、<code>3u3</code> 表示 <code>3.3uF</code>。</p></blockquote><h2 id="电容器误差的标注">电容器误差的标注</h2><p>电容器的误差标注方法，除了直接进行标注以外，还有<strong>罗马数字</strong>和<strong>字母</strong>两种标注方法，其中前者就是使用罗马数字的<code>0</code>、<code>Ⅰ</code>、<code>Ⅱ</code>、<code>Ⅲ</code>来分别标识误差值：</p><table><thead><tr class="header"><th style="text-align: center;">罗马数字</th><th style="text-align: center;">对应误差</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><code>±2%</code></td></tr><tr class="even"><td style="text-align: center;"><strong>Ⅰ</strong></td><td style="text-align: center;"><code>±5%</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>Ⅱ</strong></td><td style="text-align: center;"><code>±10</code></td></tr><tr class="even"><td style="text-align: center;"><strong>Ⅲ</strong></td><td style="text-align: center;"><code>±20%</code></td></tr></tbody></table><p>相应的，字母表示法则是通过在电容器上标注字母<code>B</code>、<code>C</code>、<code>D</code>、<code>F</code>、<code>G</code>、<code>J</code>、<code>K</code>、<code>M</code>、<code>N</code>、<code>Q</code>、<code>S</code>、<code>Z</code>、<code>P</code>来表示误差的大小：</p><table><thead><tr class="header"><th style="text-align: center;">字母</th><th style="text-align: center;">对应误差</th><th style="text-align: center;">字母</th><th style="text-align: center;">对应误差</th><th style="text-align: center;">字母</th><th style="text-align: center;">对应误差</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>B</strong></td><td style="text-align: center;"><code>±0.1%</code></td><td style="text-align: center;"><strong>J</strong></td><td style="text-align: center;"><code>±5%</code></td><td style="text-align: center;"><strong>S</strong></td><td style="text-align: center;"><code>+50% ~ -20%</code></td></tr><tr class="even"><td style="text-align: center;"><strong>C</strong></td><td style="text-align: center;"><code>+0.25%</code></td><td style="text-align: center;"><strong>K</strong></td><td style="text-align: center;"><code>+10%</code></td><td style="text-align: center;"><strong>Z</strong></td><td style="text-align: center;"><code>+80% ~ -20%</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>D</strong></td><td style="text-align: center;"><code>+0.5%</code></td><td style="text-align: center;"><strong>M</strong></td><td style="text-align: center;"><code>+20%</code></td><td style="text-align: center;"><strong>P</strong></td><td style="text-align: center;"><code>+100% ~ 0%</code></td></tr><tr class="even"><td style="text-align: center;"><strong>F</strong></td><td style="text-align: center;"><code>±1%</code></td><td style="text-align: center;"><strong>N</strong></td><td style="text-align: center;"><code>+30%</code></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><strong>G</strong></td><td style="text-align: center;"><code>+2%</code></td><td style="text-align: center;"><strong>Q</strong></td><td style="text-align: center;"><code>+30% ~ -10%</code></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h2 id="陶瓷电容介质分类">陶瓷电容介质分类</h2><p><strong>多层陶瓷贴片电容器</strong>（MLCC）根据<strong>介质</strong>或者<strong>介电材料</strong>的不同，可以具体划分为<strong>NPO</strong>、<strong>COG</strong>、<strong>X7R</strong>、<strong>X5R</strong>、<strong>Y5V</strong>、<strong>Z5U</strong>六种材质，不同的介质类型会导致电容器的<code>电场响应速度</code>、<code>极化率</code>、<code>稳定性</code>、<code>介质损耗</code>、<code>容量</code>出现差异，这六种材质按照温度稳定性和容量变化率可以进一步被划分为<strong>Ⅰ</strong>、<strong>Ⅱ</strong>、<strong>Ⅲ</strong>三种类型：</p><table><colgroup><col style="width: 9%"><col style="width: 7%"><col style="width: 16%"><col style="width: 66%"></colgroup><thead><tr class="header"><th style="text-align: center;">介质类型</th><th style="text-align: left;">英文缩写名称</th><th style="text-align: left;">类型名称</th><th style="text-align: left;">温度与容量变化率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Ⅰ 类陶瓷电容</strong></td><td style="text-align: left;">NPO、COG</td><td style="text-align: left;">具有温度补偿特性的陶瓷电容器</td><td style="text-align: left;">温度从 <code>-55°C ~ +125°C</code>时容量变化为 <code>0±30ppm/°C</code>，电容量随频率的变化小于<code>±0.3ΔC</code>。</td></tr><tr class="even"><td style="text-align: center;"><strong>Ⅱ 类陶瓷电容</strong></td><td style="text-align: left;">X7R、X5R</td><td style="text-align: left;">温度稳定型陶瓷电容器</td><td style="text-align: left;"><strong>X7R</strong> 在<code>-55°C ~ +125°C</code> 时容值变化为<code>15%</code>，<strong>X5R</strong> 在 <code>-55°C ~ +85°C</code>时容量变化为 <code>15%</code>。</td></tr><tr class="odd"><td style="text-align: center;"><strong>Ⅲ 类陶瓷电容</strong></td><td style="text-align: left;">Y5V、Z5U</td><td style="text-align: left;">具有一定温度限制的陶瓷电容器</td><td style="text-align: left;"><strong>Y5V</strong> 在<code>-30°C ~ +85°C</code> 时容值变化为<code>+22% ~ -82%</code>；<strong>Z5U</strong> 在<code>-30°C ~ +85°C</code> 时容值变化为 <code>+10% ~ -85%</code>；</td></tr></tbody></table><h2 id="电容器的串联">电容器的串联</h2><p>电容器的<strong>串联</strong>是指两个或者以上的电容器，在电路当中首尾相连，例如下面的电路：</p><p><img src="/Electronics/Component/3-Capacitor/4.png"></p><p>电容器串联之后的总容值会降低（小于容值最小的电容器），串联之后<strong>总容值</strong>的倒数等于<strong>每一个电容器</strong>容值的倒数之和，所以上面的两个电路相互等效：</p><p><span class="math display">\[\frac{1}{C} = \frac{1}{C_1} + \frac{1}{C_2}\impliesC = \frac{C_1 \cdot C_2}{C_1 + C_2} = \frac{1000pF \times 100pF}{1000pF+ 100pF} \approx 91pF\]</span></p><blockquote><p><strong>注意</strong>：电容器串联之后，<strong>容值较大</strong>的电容器两端的<strong>电压较小</strong>，而<strong>容值较小</strong>的电容器两端的<strong>电压较大</strong>。所以进行电容器选型的时候，对于容值较小的串联电容器，应当选择耐压值更高的型号。</p></blockquote><h2 id="电容器的并联">电容器的并联</h2><p>电容器的<strong>并联</strong>是指两个或者以上的电容器，在电路当中分别首首相连和尾尾相连，例如下面的电路：</p><p><img src="/Electronics/Component/3-Capacitor/5.png"></p><p>电容器并联之后的总容值会增大，<strong>总容值</strong>等于全部并联电容器的容值之和，所以上述两个电路相互等效：</p><p><span class="math display">\[C = C_1 + C_2 + C_3 = 5\mu F + 5\mu F + 10\mu F = 20 \mu F\]</span></p><blockquote><p><strong>注意</strong>：电容器并联之后，每一个电容器两端的<strong>电压都相等</strong>。所以在电容器的选型时，最好为并联电容器选择耐压值都相同的型号。</p></blockquote><h2 id="常用电容器">常用电容器</h2><table><colgroup><col style="width: 8%"><col style="width: 12%"><col style="width: 1%"><col style="width: 77%"></colgroup><thead><tr class="header"><th>名称</th><th>实物</th><th>极性</th><th>优缺点</th></tr></thead><tbody><tr class="odd"><td><strong>多层陶瓷电容器</strong></td><td><img src="/Electronics/Component/3-Capacitor/6.png"></td><td>无</td><td>串联等效电阻 <strong>ESR</strong> 比较低，容值范围介于<code>0.1pF ~ 470uF</code>，耐压值介于<code>2.5V ~ 10kV</code>，可以进一步划分为 <strong>I</strong>类(温度系数相对较低)和 <strong>II</strong>类(温度系数相对较高)两种类型。</td></tr><tr class="even"><td><strong>铝电解电容器</strong></td><td><img src="/Electronics/Component/3-Capacitor/7.png"></td><td>有</td><td>铝壳顶部带有防爆纹，容值范围较宽<code>0.1uF ~ 2.2F</code>，耐压值介于<code>2.5V ~ 700V</code>，价格低廉，但是使用寿命较短，漏电流会随着温度和电压的升高而增大，过压和反接时会发生爆炸。</td></tr><tr class="odd"><td><strong>铝固态聚合物电容器</strong></td><td><img src="/Electronics/Component/3-Capacitor/8.png"></td><td>有</td><td>铝壳顶部通常没有防爆纹，<strong>ESR</strong>非常低（毫欧级别），容值范围 <code>2.2uF ~ 0.02F</code>，耐压值介于<code>2V ~ 250kV</code>，价格相对较贵（通常是电解电容的 5倍），在工作温度高于 <code>105℃</code>以上时，各项参数指标会迅速恶化。</td></tr><tr class="even"><td><strong>钽电容</strong></td><td><img src="/Electronics/Component/3-Capacitor/9.png"></td><td>有</td><td><strong>ESR</strong>相对较低（欧姆级别），体积小容值大（<code>22nF ~ 0.1F</code>），耐压性能差（<code>2V ~ 125V</code>），价格昂贵，工作范围宽，使用寿命长，反接和过压发生爆炸时会出现<strong>明火</strong>，使用时需要特别注意。</td></tr></tbody></table><h2 id="安规电容器">安规电容器</h2><p><strong>安规电容</strong>也被称为 <strong>EMI抑制电容器</strong>，顾名思义在电路里主要用于减少电磁干扰，通常用于电源电路当中，可以滤除雷电或者插拔插座带来的高频脉冲，这类电容必须通过如下一系列的安全规范测试认证：</p><p><img src="/Electronics/Component/3-Capacitor/10.png"></p><p><strong>X 电容</strong>通常使用的是聚酯材料，用于滤除<strong>差模干扰</strong>，使用时主要放置在<strong>零线</strong>与<strong>火线</strong>之间：</p><p><img src="/Electronics/Component/3-Capacitor/11.png"></p><p><strong>Y 电容</strong>通常使用的是陶瓷材料，用于滤除<strong>共模干扰</strong>，使用时分别放置在<strong>火线</strong>与<strong>地</strong>、<strong>零线</strong>与<strong>地</strong>之间：</p><p><img src="/Electronics/Component/3-Capacitor/12.png"></p><p>对于 <strong>X 电容</strong> 和 <strong>Y 电容</strong>的选型，主要关注的参数是其可以耐受的<strong>浪涌峰值电压</strong>（通常在千伏左右），两者通常配合起来使用，其典型的应用电路如下所示（图中的<code>L</code> 表示<strong>火线</strong>，<code>N</code>表示<strong>零线</strong>，<code>G/PE</code>表示<strong>地线</strong>）：</p><p><img src="/Electronics/Component/3-Capacitor/13.png"></p><blockquote><p><strong>注意</strong>：<strong>X2</strong>（浪涌峰值电压小于或等于<code>2.5KV</code>）和 <strong>Y2</strong>（浪涌峰值电压为<code>5KV</code>）<strong>子类</strong>是国内比较常用的安规电容。</p></blockquote><h1 id="电感器-inductor">电感器 Inductor</h1><p>将导线在<strong>绝缘支架</strong>上绕制出一定的匝数就可以构成一个<strong>电感器</strong>，其电路符号如下图所示：</p><p><img src="/Electronics/Component/4-Inductance/1.png"></p><p>根据绕制支架材料的不同，可以将其划分为：<strong>空心电感器</strong>(无支架)、<strong>磁芯电感器</strong>(磁性材料支架)、<strong>铁芯电感器</strong>(硅钢片支架)：</p><p><img src="/Electronics/Component/4-Inductance/2.png"></p><p>电感器在电路当中，主要具备如下几个用途：</p><ul><li><strong>功率电感</strong>：主要用于电压转换，例如 DC-DC电路都需要使用到功率电感。</li><li><strong>去耦电感</strong>：主要用于 EMC滤除电源线或者信号线上面的噪声，也就是所谓的<strong>扼流圈</strong>。</li><li><strong>高频电感</strong>：主要用于射频电路，实现偏置、匹配、滤波等功能。</li></ul><h2 id="电感量">电感量</h2><p>当电感器通过电流时就会产生<strong>磁场</strong>，电流越大产生的磁场就会越强，穿过电感器的磁通量也就会越大。磁场的<strong>磁感线方向</strong>与<strong>电流方向</strong>遵循<strong>右手螺旋定则</strong>，也称为<strong>安培定则</strong>：右手握住电感线圈，让大拇指指向<strong>磁场</strong>的方向（从<strong>N</strong> 极出发回到 <strong>S</strong>极），那么其余四指所指向的就是<strong>电流</strong>的方向：</p><p><img src="/Electronics/Component/4-Inductance/3.png"></p><p>穿过电感器的<strong>磁通量</strong> <span class="math inline">\(\varPhi\)</span>与通过电感器的<strong>电流</strong> <span class="math inline">\(I\)</span>的比值叫做<strong>自感系数</strong>，也被称为<strong>电感量</strong>，通常使用字母<strong>L</strong> 进行表示：</p><p><span class="math display">\[L = \frac{\varPhi}{I}\]</span></p><p>电感量的基本单位为<strong>亨利</strong>，简称<strong>亨</strong>(H)，常用的单位还有<strong>毫亨</strong>(mH)、<strong>微亨</strong>(uH)，它们之间的换算关系如下面所示：</p><p><span class="math display">\[1H = 10^3mH = 10^6 \mu H\]</span></p><p>电感器所具有的电感量大小，主要取决于线圈的匝数、绕制的方式，以及磁芯的材料：</p><ol type="1"><li>线圈<strong>匝数</strong>越多，绕制的线圈就会越密集，电感量也就会越大；</li><li><strong>有磁芯</strong>的电感器，相比<strong>无磁芯</strong>的电感器的电感量要更大:</li><li>电感器磁芯的<strong>磁导率</strong>越高，其电感量也就会越大。</li></ol><h2 id="感抗">感抗</h2><p>电感器对于直流信号的阻碍非常小，而对于交流信号的阻碍非常大，也就是所谓的<strong>通直隔交</strong>。导致这种现象出现的原因，是由于变化的电信号通过电感器时，会让电感器产生<strong>自感电动势</strong>来阻碍这个变化的电信号。</p><p>电感器对于交流信号的这种阻碍作用称为<strong>感抗</strong>，其单位为<strong>欧姆</strong><code>Ω</code>，电感器<strong>感抗</strong> <span class="math inline">\(X_L\)</span>(欧姆)的大小与其<strong>电感量</strong> <span class="math inline">\(L\)</span> (亨利)以及通过的<strong>频率</strong><span class="math inline">\(f\)</span> (赫兹)相关：</p><p><span class="math display">\[X_L = 2\pi fL\]</span></p><blockquote><p><strong>注意</strong>：通过的信号频率 <span class="math inline">\(f\)</span> 越高，电感器的感抗 <span class="math inline">\(X_L\)</span> 也就越大。电感器的电感量 <span class="math inline">\(L\)</span> 越大，其对交流信号的感抗 <span class="math inline">\(X_L\)</span> 也就会越大。</p></blockquote><h2 id="品质因数-q-值">品质因数 Q 值</h2><p><strong>品质因数</strong>当向电感器两端施加特定<strong>频率</strong><span class="math inline">\(f\)</span>的交流信号时，其<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 与<strong>直流电阻</strong> <span class="math inline">\(R\)</span>的比值被称为<strong>品质因数</strong>。该参数是衡量电感器品质的一个重要参数，通常也被称作<strong>Q 值</strong>：</p><p><span class="math display">\[Q = \frac{X_L}{R}\]</span></p><blockquote><p><strong>注意</strong>：品质因数通常用于表征储能元件（电感器、电容器）<strong>储存能量</strong>与<strong>损耗能量</strong>的比值，品质因数越<strong>大</strong>，表示吸收与储存能量的损耗就越小，转换效率就会越高。</p></blockquote><h2 id="电感器的选型">电感器的选型</h2><p>按照电感器在电路当中的用处，还可以将其大致划分为用于<strong>信号系统</strong>的<strong>高频电感器</strong>，以及用于<strong>电源系统</strong>的<strong>功率电感器</strong>：</p><p><img src="/Electronics/Component/4-Inductance/4.png"></p><p><strong>高频电感器</strong>主要运用在信号频率介于 <code>MHz</code>或者 <code>GHz</code> 的场景，对于 Q值的要求非常高，通常会采用空心结构，其主要用途如下表所示：</p><p><img src="/Electronics/Component/4-Inductance/5.png"></p><p><strong>功率电感器</strong>主要被运用在电源电路当中，有时候也被称作<strong>工字型电感</strong>，其主要用途如下面的表格所示：</p><p><img src="/Electronics/Component/4-Inductance/6.png"></p><p>电感器的选型，除了电感量这个参数之外，还需要重点关注如下几个参数：</p><ul><li><strong>温升额定电流</strong>：以电感器的发热量（温升为<code>40℃</code>）作为指标的额定电流。</li><li><strong>电感值变化率额定电流</strong>：由通电时<strong>磁饱和</strong>所导致的电感值下降（直流叠加特性）作为指标的额定电流。</li><li><strong>工作温度范围</strong>：电感器正常工作的时候，环境温度所允许的范围。</li><li><strong>直流阻抗</strong>：能够通过的直流信号阻抗值，直流阻抗越小，损耗也就越少。</li></ul><blockquote><p><strong>注意</strong>：电路当中经常使用到的<strong>扼流圈</strong>，本质也是一种可以扼制交流信号通过的电感线圈，它利用<strong>感抗</strong><span class="math inline">\(X_L\)</span> 与<strong>频率</strong> <span class="math inline">\(f\)</span>呈正比的关系，从而能够扼制特定频率的交流信号通过电感器。</p></blockquote><h2 id="共模-差模噪声">共模 &amp; 差模噪声</h2><p>导线上的<strong>传导噪声</strong>可以划分为<strong>差模噪声</strong>和<strong>共模噪声</strong>两种类型，在下面的示意图当中，把PCB 电路板安装在了一个外壳里面：</p><p><img src="/Electronics/Component/4-Inductance/7.png"></p><ul><li><strong>差模噪声</strong>：产生于电源线之间，由噪声信号串入电源线导致。噪声信号<strong>流入</strong>与<strong>流出</strong>两条电源线的方向<strong>相反</strong>，所以被称为<strong>差模</strong>（DifferentialMode）。</li><li><strong>共模噪声</strong>：由于噪声信号通过大地之后，再返回电源线所导致，噪声信号<strong>流入</strong>与<strong>流出</strong>两条电源线的方向<strong>相同</strong>，所以被称为<strong>共模</strong>（CommonMode）。</li></ul><h2 id="共模-差模电感">共模 &amp; 差模电感</h2><p><strong>共模电感</strong>是一种用于滤除共模干扰信号的专用元器件，通常被运用在开关电源当中，可以滤除EMI 电磁干扰，或者抑制高速信号传输时产生的电磁辐射。</p><p><img src="/Electronics/Component/4-Inductance/8.png"></p><p>共模电感的工作原理是基于其特殊的<strong>双绕组结构</strong>：两个线圈绕制在相同的铁芯上面（匝数和相位相同，但是绕制的方向相反），从而形成一个<strong>四端元件</strong>。因而拥有4个外接引脚（这是共模电感器的典型外观特征），共模电感在电路原理图当中使用如下符号进行表示：</p><p><img src="/Electronics/Component/4-Inductance/9.png"></p><ol type="1"><li>当<strong>差模干扰信号</strong>经过共模电感时，信号会在同相位绕制的电感线圈中产生<strong>反向</strong>的磁场而相互抵消，此时正常信号电流只会受到线圈自身电阻的影响。</li><li>当<strong>共模干扰信号</strong>流过共模电感时，由于共模信号的同向性，就会在线圈内产生<strong>相同方向</strong>的磁场，进而增大线圈的感抗，致使线圈表现为高阻抗，从而衰减共模信号达到滤除的目的。</li></ol><p>相应的，<strong>差模电感</strong>本质上就是就是普通的绕线电感（两个引脚），其主要用于滤除差模干扰信号，通常被运用在一些<strong>大电流</strong>的场合，结构较为简单（主要由铁芯上绕制的线圈构成）。经常在电源电路当中，与电容一起构成用于减小噪声的LC 滤波器。</p><h2 id="磁珠">磁珠</h2><p><strong>磁珠</strong>对于高频信号具有较大的阻碍作用（将其转换为<strong>热能</strong>），主要用于抑制<strong>信号线</strong>、<strong>电源线</strong>上面的高频噪声与尖峰干扰。磁珠的单位是按照其在某一频率（通常为<code>100MHz</code>）下产生的<strong>阻抗</strong>来进行标识的，所以其采用<strong>欧姆</strong><code>Ω</code> 作为单位（而非<strong>亨利</strong>）：</p><p><img src="/Electronics/Component/4-Inductance/10.png"></p><p>通常情况下，制作<strong>磁珠</strong>的材料是<strong>铁氧体</strong>，大部分<strong>磁珠</strong>都会被制作为贴片元器件，只有<strong>穿芯磁珠</strong>属于直插式元器件。</p><blockquote><p><strong>注意</strong>：磁珠在选型时要重点关注其<code>标称阻抗@测试频率</code>、<code>直流电阻</code>、<code>额定工作电流</code>三个参数。</p></blockquote><h1 id="变压器-transformer">变压器 Transformer</h1><p><strong>变压器</strong>基于 <code>电→磁</code> 和 <code>磁→电</code>的转换原理，主要用于调整交流电压与电流的大小，通常由绝缘铜质线圈绕制而成的<strong>绕组</strong>（漆包线）和具备导磁性能的<strong>铁/磁芯</strong>（E形、C形、环形）构成，其电路符号（下图左）和结构示意图（下图右）分别如下所示：</p><p><img src="/Electronics/Component/5-Transformer/1.png"></p><p>其中，连接到输入端的绕组称为<strong>一次绕组</strong>或者<strong>初级绕组</strong>（源边），而连接至输出端的绕组被称为<strong>二次绕组</strong>或者<strong>次级绕组</strong>（副边）。变压器按照用途，可以进一步被划分为<strong>电源变压器</strong>、<strong>隔离变压器</strong>、<strong>信号处理变压器</strong>、<strong>电流互感器</strong>等。</p><h2 id="工作原理">工作原理</h2><p>当<strong>交流电压</strong> <span class="math inline">\(U_1\)</span>传递到变压器的<strong>一次绕组</strong> <span class="math inline">\(L_1\)</span>（<strong>匝数</strong>为 <span class="math inline">\(N_1\)</span>）两端时，就会有交流电流 <span class="math inline">\(I_1\)</span> 通过 <span class="math inline">\(L_1\)</span>，导致 <span class="math inline">\(L_1\)</span>立刻产生磁场，磁场的磁感线沿着具备导磁能力的铁芯或者磁芯穿过<strong>二次绕组</strong><span class="math inline">\(L_2\)</span>（匝数为 <span class="math inline">\(N_2\)</span>），使得 <span class="math inline">\(L_2\)</span>绕组马上产生方向相反的<strong>感应电动势</strong>。</p><p><img src="/Electronics/Component/5-Transformer/2.png"></p><p>此时 <span class="math inline">\(L_2\)</span> 与<strong>电阻</strong><span class="math inline">\(R\)</span>形成闭合电路，开始输出<strong>交流电流</strong> <span class="math inline">\(I_2\)</span>，电阻 <span class="math inline">\(R\)</span> 两端的<strong>电压</strong>为 <span class="math inline">\(U_2\)</span>。概而言之，变压器的<strong>一次绕组</strong>进行的是<strong>电→ 磁</strong>转换，而<strong>二次绕组</strong>进行的则是<strong>磁 →电</strong>转换。</p><h2 id="交流电压的转换">交流电压的转换</h2><p>变压器可以改变<strong>交流电压</strong>，在忽略电能损耗的情况下，变压器的<strong>一次电压</strong><span class="math inline">\(U_1\)</span>、<strong>二次电压</strong><span class="math inline">\(U_2\)</span> 与<strong>一次绕组匝数</strong><span class="math inline">\(N_1\)</span>、<strong>二次绕组匝数</strong><span class="math inline">\(N_2\)</span> 的关系如下所示，其中的<code>n</code>被称为<strong>匝数比</strong>或者<strong>电压比</strong>：</p><p><span class="math display">\[\frac{U_1}{U_2} = \frac{N_1}{N_2} = n\]</span></p><ol type="1"><li>当一次绕组匝数 <span class="math inline">\(N_1\)</span><strong>少于</strong>二次绕组的匝数 <span class="math inline">\(N_2\)</span> 时，一次电压 <span class="math inline">\(U_1\)</span> 就会<strong>低于</strong>二次电压<span class="math inline">\(U_2\)</span>。换而言之，当 <span class="math inline">\(\frac{N_1}{N_2} = n &lt; 1\)</span>的时候，变压器可以提高交流电压（同时也降低了输出电流），即<strong>升压变压器</strong>。</li><li>当一次绕组匝数 <span class="math inline">\(N_1\)</span><strong>多于</strong>二次绕组的匝数 <span class="math inline">\(N_2\)</span> 时，一次电压 <span class="math inline">\(U_1\)</span> 就会<strong>高于</strong>二次电压<span class="math inline">\(U_2\)</span>。换而言之，当 <span class="math inline">\(\frac{N_1}{N_2} = n &gt; 1\)</span>的时候，变压器可以降低交流电压（同时也提高了输出电流），即<strong>降压变压器</strong>。</li><li>当一次绕组匝数 <span class="math inline">\(N_1\)</span><strong>等于</strong>二次绕组的匝数 <span class="math inline">\(N_2\)</span> 时，一次电压 <span class="math inline">\(U_1\)</span> 就会<strong>等于</strong>二次电压<span class="math inline">\(U_2\)</span>。换而言之，当 <span class="math inline">\(\frac{N_1}{N_2} = n = 1\)</span>的时候，虽然变压器不会改变交流电压的大小，但是依然能够起到电气隔离的作用，也就是所谓的<strong>隔离变压器</strong>。</li></ol><h2 id="交流电流的转换">交流电流的转换</h2><p>变压器在改变交流电压大小的同时，也会相应的改变交流电流的大小。假设变压器对于电能的损耗较小，根据<strong>功率守恒定律</strong>，可以将变压器的<strong>输入功率</strong><span class="math inline">\(P_1\)</span> 与<strong>输出功率</strong><span class="math inline">\(P_2\)</span>视为相等，从而可以得到如下的推导过程：</p><p><span class="math display">\[P_1 = P_2 \implies U_1 \cdot I_1 = U_2 \cdot I_2 \implies\frac{U_1}{U_2} = \frac{I_2}{I_1}\]</span></p><p>根据上述的推导过程，可以知道变压器的一二次电压 <span class="math inline">\(U_1\)</span> 和 <span class="math inline">\(U_2\)</span> 与一二次电流 <span class="math inline">\(I_1\)</span> 和 <span class="math inline">\(I_2\)</span>呈现出<strong>反比关系</strong>。换而言之，变压器的<strong>匝数</strong>越多，绕组两端的<strong>电压</strong>就会越高，通过的<strong>电流</strong>相应的也就会越小。</p><p><img src="/Electronics/Component/5-Transformer/3.png"></p><p>例如上面这个输入电压为 <code>220V</code>，输出电压为 <code>12V</code>的<strong>电源变压器</strong>，它的一次绕组与二次绕组的<strong>匝数比</strong><code>n</code>，可以基于如下的计算获得：</p><p><span class="math display">\[n = \frac{U_1}{U_2} = \frac{220V}{12V} = \frac{55}{3}\xrightarrow{电压与电流成反比关系} \frac{I_2}{I_1} = \frac{55}{3}\approx 18.33\]</span></p><p>根据上面的推导过程可以得出结论：该变压器二次绕组的<strong>输出电流</strong>是一次绕组<strong>输入电流</strong>的<code>18.33</code> 倍。</p><h2 id="符号与结构">符号与结构</h2><p>接下来的表格里，展示了各种常见的变压器符号，并对其结构进行了简要的说明：</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th>变压器符号</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td><img src="/Electronics/Component/5-Transformer/4.png"></td><td>该变压器拥有 2 组二次绕组，其中 <code>3 ~ 4</code> 为一组，而<code>5 ~ 6</code>为另一组。符号中的<strong>虚线</strong>表示一次和二次绕组之间存在着<strong>屏蔽层</strong>（接地，起到抗干扰作用），通常表示的是<strong>电源变压器</strong>。</td></tr><tr class="even"><td><img src="/Electronics/Component/5-Transformer/5.png"></td><td>一次和二次绕组的一端标记的<strong>黑点</strong>表示的是变压器的<strong>同名端</strong>，表示这两处的<strong>电压极性相同</strong>。</td></tr><tr class="odd"><td><img src="/Electronics/Component/5-Transformer/6.png"></td><td>该变压器的一次和二次绕组之间<strong>没有实线</strong>，即表示该变压器没有<strong>铁芯</strong>或者<strong>磁芯</strong>。</td></tr><tr class="even"><td><img src="/Electronics/Component/5-Transformer/7.png"></td><td>变压器的<strong>二次绕组</strong>上面存在着一个<strong>抽头</strong>，也就是二次绕组<code>3 ~ 5</code> 之间的 <code>4</code> 号引脚。</td></tr><tr class="odd"><td><img src="/Electronics/Component/5-Transformer/8.png"></td><td>变压器的<strong>一次绕组</strong>上面存在一个<strong>抽头</strong>（即<code>2</code> 号引脚），表示可以输入不同电压的交流电。</td></tr><tr class="even"><td><img src="/Electronics/Component/5-Transformer/9.png"></td><td>变压器只拥有<strong>一个绕组</strong>，其中的 <code>2</code>号引脚是其抽头，也被称作<strong>自耦变压器</strong>。如果将<code>2 ~ 3</code> 作为一次绕组，而 <code>1 ~ 3</code>作为二次绕组，就可以将其视为一个<strong>升压变压器</strong>；而如果把<code>1 ~ 3</code> 作为一次绕组，而 <code>2 ~ 3</code>作为二次绕组，则可以将其视为一个<strong>降压变压器</strong>。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：变压器的<strong>同名端</strong>（极性相同的端口，通常在电路图当中使用实心黑点进行标注）和<strong>异名端</strong>（极性相反的端口）描述的是<code>初级绕组</code>与<code>次级绕组</code>之间的<strong>缠绕方式</strong>和<strong>极性关系</strong>。</p></blockquote><h2 id="变压器选型指标">变压器选型指标</h2><p>实际工作当中进行变压器的选型时，除了<strong>变压比/匝数比</strong><code>n</code> 之外，还需要关注下面几个性能指标：</p><ul><li><strong>额定功率</strong>：在规定频率和电压之下，变压器长时间工作而不超过规定温升的最大输出功率，单位为<strong>伏安</strong>(<code>V·A</code>)。由于额定功率当中会存在一部分<strong>无功功率</strong>，所以这里不会使用<strong>瓦特</strong>(<code>W</code>)作为单位。</li><li><strong>绝缘电阻</strong>：实际的变压器，很难在绕组与铁/磁芯之间做到完全绝缘，因而变压器<strong>绝缘电阻</strong>指标的大小（等于<span class="math inline">\(\frac{典型测试电压}{变压器漏电流}\)</span>，通常在<strong>兆欧</strong><code>MΩ</code>级别），不仅关系到变压器本身的质量，还关系到用电安全，选型时需要额外注意。</li><li><strong>转换效率</strong>：表示变压器正常工作时，对于电能的损耗程度，其值等于<span class="math inline">\(\frac{输出功率}{输入功率}\)</span>的百分比。</li><li><strong>温升</strong>：变压器通电之后，其工作温度上升至稳定值时，比环境温度高出的数值（该参数越小越好）。</li></ul><h1 id="二极管-diode">二极管 Diode</h1><p><strong>半导体</strong>是导电性能介于导体与绝缘体之间的材料，根据掺杂元素的情况，可以具体划分为<code>本征半导体</code>、<code>N 型半导体</code>、<code>P 型半导体</code>三种类型：</p><ol type="1"><li><strong>本征半导体</strong>：纯净的半导体（原子核最外层有 4个电子的<code>硅</code>、<code>锗</code>、<code>硒</code>等），导电能力较弱（掺入杂质后可通过富余的空穴和电子提高导电能力）。</li><li><strong>N型半导体</strong>：向纯净半导体中掺入<strong>五价元素</strong>（原子核最外层只有5个电子的<code>磷</code>、<code>砷</code>、<code>锑</code>等），半导体中存在大量带有<strong>负电荷</strong>的<strong>电子</strong>。</li><li><strong>P型半导体</strong>：向纯净半导体中掺入<strong>三价杂质</strong>（原子核最外层只有3个电子的<code>硼</code>、<code>铝</code>、<code>镓</code>等），半导体中存在大量带有<strong>正电荷</strong>的<strong>空穴</strong>。</li></ol><p>当包含有空穴的 <strong>P 型半导体</strong>和包含有电子的 <strong>N型半导体</strong>结合在一起时，由于两边正负电荷的相互扩散，就会在 P 型和N 型半导体中间形成 <strong>PN 结</strong>：</p><p><img src="/Electronics/Component/6-Diode/1.png"></p><p>从包含有 PN 结的<strong>P 型半导体</strong>和 <strong>N型半导体</strong>两端，分别引出一个电极并且封装起来，就构成了<strong>二极管</strong>，其基本结构与电路符号如下面示意图所示：</p><p><img src="/Electronics/Component/6-Diode/2.png"></p><blockquote><p><strong>注意</strong>：<strong>P型</strong>半导体一侧的电极称为<strong>正极</strong>（Positive），<strong>N型</strong>半导体一侧的电极称为<strong>负极</strong>（Negative）。</p></blockquote><h2 id="单向导电性">单向导电性</h2><p>二极管具有<strong>正向导通、反向截止</strong>的特性，也就是所谓的二极管的<strong>单向导电性</strong>：</p><p><img src="/Electronics/Component/6-Diode/3.png"></p><ul><li><strong>正向导通</strong>：二极管的<strong>正极</strong>连接电源的<strong>正极</strong>，而<strong>负极</strong>连接电源的<strong>负极</strong>，此时二极管处于导通状态。</li><li><strong>反向截止</strong>：二极管的<strong>正极</strong>连接电源的<strong>负极</strong>，而<strong>负极</strong>连接电源的<strong>正极</strong>，此时二极管处于截止状态。</li></ul><h2 id="伏安特性曲线">伏安特性曲线</h2><p>二极管的<strong>伏安特性曲线</strong>用来说明施加到二极管两端的<strong>电压</strong><span class="math inline">\(U\)</span> 与通过的<strong>电流</strong><span class="math inline">\(I\)</span>之间的关系（第一象限的曲线描述的是二极管的<strong>正向特性</strong>，而第三象限的曲线描述的则是二极管的<strong>反向特性</strong>）：</p><p><img src="/Electronics/Component/6-Diode/4.png"></p><ul><li><strong>正向特性</strong>：即二极管被施加<strong>正向电压</strong>（二极管正极接高电位，负极接低电位）时的特性，向二极管施加正向电压时不一定能导通，只有正向电压达到<strong>正向导通电压</strong>时才能够导通。</li><li><strong>反向特性</strong>：即二极管被施加<strong>反向电压</strong>（二极管正极接低电位，负极接高电位）时的特性，向二极管施加反向电压时不会导通，当达到<strong>反向击穿电压</strong>的时候，二极管就会由于被反向击穿而失去单向导电性。</li></ul><blockquote><p><strong>注意</strong>：<strong>硅基二极管</strong>的正向导通电压通常为<code>0.7V</code>，而<strong>锗基二极管</strong>的正向导通电压一般为<code>0.3V</code>。</p></blockquote><h2 id="性能参数">性能参数</h2><p>阅读二极管数据手册进行选型工作的时候，需要重点关注下面表格当中列出的参数指标：</p><table><colgroup><col style="width: 13%"><col style="width: 6%"><col style="width: 79%"></colgroup><thead><tr class="header"><th style="text-align: left;">参数名称</th><th style="text-align: center;">符号</th><th style="text-align: left;">参数功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>最大直流反向电流</strong></td><td style="text-align: center;"><span class="math inline">\(I_R\)</span></td><td style="text-align: left;">二极管反向截止时，通过二极管的<strong>漏电流</strong>（通常在<strong>微安</strong><code>uA</code> 级别）。</td></tr><tr class="even"><td style="text-align: left;"><strong>最大正向平均电流</strong></td><td style="text-align: center;"><span class="math inline">\(I_F\)</span></td><td style="text-align: left;">二极管长时间正向导通时，在允许温升的条件下，所通过的最大平均电流值（该参数与PN 结的尺寸以及封装的散热能力有关）。</td></tr><tr class="odd"><td style="text-align: left;"><strong>最大正向电压</strong></td><td style="text-align: center;"><span class="math inline">\(V_F\)</span></td><td style="text-align: left;">二极管正向导通时，当 <span class="math inline">\(I_F\)</span> 为指定电流值（例如 <code>10mA</code>）的时候，所测得的导通电压。</td></tr><tr class="even"><td style="text-align: left;"><strong>最大反向峰值电压</strong></td><td style="text-align: center;"><span class="math inline">\(V_{RRM}\)</span></td><td style="text-align: left;">二极管反向截止时，二极管所允许承受的最大重复峰值电压。</td></tr><tr class="odd"><td style="text-align: left;"><strong>最大有效值电压</strong></td><td style="text-align: center;"><span class="math inline">\(V_{RMS}\)</span></td><td style="text-align: left;">二极管反向截止时，峰值电压乘以<code>0.707</code> 倍之后，所得到的电压真有效值。</td></tr><tr class="even"><td style="text-align: left;"><strong>正向峰值浪涌电流</strong></td><td style="text-align: center;"><span class="math inline">\(I_{FSM}\)</span></td><td style="text-align: left;">二极管正向导通时，在特定的短暂时间内（例如<code>8.3 ms</code>），最大所允许通过的瞬时电流，一旦超过将会导致损坏。</td></tr><tr class="odd"><td style="text-align: left;"><strong>PN 结工作温度</strong></td><td style="text-align: center;"><span class="math inline">\(T_J\)</span></td><td style="text-align: left;">PN 结长时间正常工作时的温度范围，例如<code>–55°C ~ +150°C</code>。</td></tr><tr class="even"><td style="text-align: left;"><strong>典型 PN 结电容</strong></td><td style="text-align: center;"><span class="math inline">\(C_J\)</span></td><td style="text-align: left;">二极管反向截止时，施加 <code>4.0V</code>的反向电压，在 <code>1MHz</code> 频率下测得的 PN 结电容值。</td></tr><tr class="odd"><td style="text-align: left;"><strong>反向恢复时间</strong></td><td style="text-align: center;"><span class="math inline">\(t_{rr}\)</span></td><td style="text-align: left;">二极管从正向导通状态，切换至反向截止状态所需要的时间。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：通常情况下，普通二极管带有<strong>划线标记</strong>的一端为<strong>负极</strong>，而另外一端则属于<strong>正极</strong>。</p></blockquote><h2 id="整流二极管">整流二极管</h2><p>利用二极管的单向导电特性，可以将交流电转换为直流电。因为只有在交流电的正半周，二极管才会导通，而在交流电的负半周，二极管不会导通，所以整流二极管只会保留交流电的<strong>正半周</strong>，这种方式称作<strong>半波段整流</strong>：</p><p><img src="/Electronics/Component/6-Diode/5.png"></p><p>要实现<strong>全波段整流</strong>的效果，提升转换效率，则必须使用<strong>整流桥</strong>，这是一种由多个二极管组合在一起构成的元器件（整流桥<strong>缺角</strong>的一端属于<strong>正极</strong>）：</p><p><img src="/Electronics/Component/6-Diode/6.png"></p><p>整流桥也称为<strong>桥式整流器</strong>，其通常带有四个引脚（其中标注有<code>~</code> 的两个引脚为<strong>交流输入端</strong>，而分别标注有<code>+</code> 和 <code>-</code>的则属于<strong>直流输出端</strong>），典型的应用电路如下图所示：：</p><p><img src="/Electronics/Component/6-Diode/7.png"></p><h2 id="开关二极管">开关二极管</h2><p><strong>开关二极管</strong>正是利用了二极管的<strong>正向导通、反向截止</strong>特性，实现了类似开关一样的功能，并且开关的速度极其迅速：</p><p><img src="/Electronics/Component/6-Diode/8.png"></p><p>这类二极管最大的特点在于其<strong>反向恢复时间</strong> <span class="math inline">\(t_{rr}\)</span>通常在<code>纳秒</code>级别，而普通二极管的 <span class="math inline">\(t_{rr}\)</span> 通常在<code>微秒</code>级别：</p><p><img src="/Electronics/Component/6-Diode/9.png"></p><p>向开关二极管施加<strong>正向电压</strong>时电流通过（表示打开），施加<strong>反向电压</strong>时电流停止（表示关闭），具体过程可以参考下面的示意图：</p><p><img src="/Electronics/Component/6-Diode/10.png"></p><h2 id="肖特基二极管">肖特基二极管</h2><p>肖特基二极管也称为<strong>肖特基势垒二极管</strong>（SBD，SchottkyBarrier Diode），利用的是<strong>金属</strong>与 <strong>N型半导体</strong>结合时，所产生的<strong>肖特基势垒</strong>原理：</p><p><img src="/Electronics/Component/6-Diode/11.png"></p><p>肖特基二极管的优点在于<strong>正向导通电压</strong> <span class="math inline">\(V_F\)</span>相比普通二极管更低，通过相同电流时所消耗的功率更少。同时<strong>反向恢复时间</strong><span class="math inline">\(t_{rr}\)</span>非常短，开关频率特别高。而缺点在于<strong>漏电流</strong> <span class="math inline">\(I_R\)</span>比较大，可能会因为持续的发热而损毁，使用时需要特别注意：</p><p><img src="/Electronics/Component/6-Diode/12.png"></p><h2 id="齐纳稳压二极管">齐纳稳压二极管</h2><p><strong>稳压二极管</strong>也称为<strong>齐纳二极管</strong>（ZenerDiode），通常在电路当中起到稳压的作用，其电路符号如下图所示：</p><p><img src="/Electronics/Component/6-Diode/13.png"></p><p>稳压二极管使用的时候，需要<strong>反接</strong>在电路当中（负极接高电位，正极接低电位），其<strong>正接</strong>时的性质与普通二极管相同：</p><p><img src="/Electronics/Component/6-Diode/14.png"></p><p>下面的电路是稳压二极管的典型接法，其中的 <span class="math inline">\(E\)</span> 代表<strong>电压源</strong>，而 <span class="math inline">\(U_{VZ}\)</span>代表的是<strong>稳压二极管</strong>（稳压值为<code>5V</code>）的输出电压：</p><p><img src="/Electronics/Component/6-Diode/15.png"></p><ol type="1"><li>当外加电压<strong>低于</strong>稳压二极管的<strong>稳压值</strong>时，稳压二极管<strong>无法导通</strong>，此时没有稳压功能（这种情况下，如果上述电路当中的<span class="math inline">\(E = 4V\)</span>，那么 <span class="math inline">\(U_{VZ} = 4V\)</span>）。</li><li>当外加电压<strong>高于</strong>稳压二极管的<strong>稳压值</strong>时，稳压二极管<strong>反向击穿</strong>导通，并且会保持两端电压不变，电压的大小等于稳压值（这种情况下，如果上述电路当中的<span class="math inline">\(E = 8V\)</span>，那么 <span class="math inline">\(U_{VZ} = 5V\)</span>）。</li></ol><p>进行稳压二极管选型的时候，需要特别关注如下表格当中的三个参数：</p><table><colgroup><col style="width: 10%"><col style="width: 7%"><col style="width: 82%"></colgroup><thead><tr class="header"><th style="text-align: left;">参数名称</th><th style="text-align: center;">符号</th><th style="text-align: left;">参数功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>稳压范围</strong></td><td style="text-align: center;"><span class="math inline">\(V_{ZT}\)</span></td><td style="text-align: left;">也称为<strong>齐纳电压范围</strong>，稳压二极管工作在反向击穿状态时，两端的电压范围。</td></tr><tr class="even"><td style="text-align: left;"><strong>反向电流</strong></td><td style="text-align: center;"><span class="math inline">\(I_R\)</span></td><td style="text-align: left;">稳压二极管正常工作时所允许通过的反向电流。</td></tr><tr class="odd"><td style="text-align: left;"><strong>耗散功率</strong></td><td style="text-align: center;"><span class="math inline">\(P_D\)</span></td><td style="text-align: left;">稳压二极管通过反向电流时允许消耗的最大功率，其值等于稳压值<span class="math inline">\(V_{ZT}\)</span> 与反向电流 <span class="math inline">\(I_R\)</span> 的乘积。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：为了确保稳压二极管能够可靠工作，使用的时候总是需要串联上一枚<strong>限流电阻</strong>。</p></blockquote><h2 id="瞬态电压抑制二极管">瞬态电压抑制二极管</h2><p><strong>瞬态电压抑制二极管</strong>（TVS，Transient VoltageSuppressors）是一种用于<strong>过电压保护</strong>和<strong>静电释放</strong>（ESD，Electro-staticDischarge）的元器件，当两极之间的电压超过一定值时，就能够以极快的速度导通，并且钳制电压到预定值范围。根据导通方向的不同，可以将其划分为<strong>单向型</strong>和<strong>双向型</strong>两种类型：</p><p><img src="/Electronics/Component/6-Diode/16.png"></p><p>瞬态电压抑制二极管通常会在<strong>接地</strong>之后，<strong>并联</strong>在电路当中使用。下面的电路将瞬态电压抑制二极管并联在电源与IC之间，当电路正常工作时，二极管处于<strong>截止状态</strong>，只会消耗一定的<strong>漏电流</strong>。而当电路上出现<strong>浪涌电压</strong>的时候，二极管就会转换为<strong>导通状态</strong>，此时耗散的则是<strong>脉冲电流</strong>，同时还会钳制通过的电压，进而保护后级IC 的正常稳定工作：</p><p><img src="/Electronics/Component/6-Diode/17.png"></p><p>瞬态电压抑制二极管的<strong>极性</strong>，主要用于标识其保护作用属于<strong>单向</strong>还是<strong>双向</strong>，通常情况下采用的都是双向瞬态电压抑制二极管，因为它可以同时钳制浪涌电压的<strong>正负脉冲</strong>：</p><p><img src="/Electronics/Component/6-Diode/18.png"></p><blockquote><p><strong>注意</strong>：<strong>整流二极管</strong>和<strong>肖特基势垒二极管</strong>利用的都是二极管的<strong>正向特性</strong>，而<strong>瞬态电压抑制二极管</strong>与<strong>齐纳稳压二极管</strong>利用的则是二极管的<strong>反向特性</strong>。</p></blockquote><h2 id="发光二极管">发光二极管</h2><p>发光二极管（LED，Light Emitting Diode）同样是由 N 型半导体和 P型半导体结合而成，当两端施加<strong>正向电压</strong>时，电子与空穴不断结合所释放的能量，就会转变为可见光，这个过程可以参考下面的示意图：</p><p><img src="/Electronics/Component/6-Diode/19.png"></p><p>发光二极管通常会与一枚<strong>限流电阻</strong>串联起来使用，该限流电阻的<strong>阻值</strong><span class="math inline">\(R\)</span> 可以通过公式 <span class="math inline">\(\frac{输入电压 V_{in} - 发光二极管正向电压V_F}{发光二极管正向电流 I_F}\)</span> 计算得到：</p><p><img src="/Electronics/Component/6-Diode/20.png"></p><p>接下来，以<a href="https://www.nationstar.com/"><strong>国星光电</strong></a>的贴片式发光二极管为例，其<code>0402</code>、<code>0603</code>、<code>0805</code>三种常用封装的<strong>正向电压</strong> <span class="math inline">\(V_F\)</span>、<strong>正向电流</strong> <span class="math inline">\(I_F\)</span>、<strong>耗散功率</strong> <span class="math inline">\(P_D\)</span>三个参数基本一致（仅<strong>发光强度</strong>上有所区别，大尺寸封装的LED 会更亮）：</p><table><thead><tr class="header"><th style="text-align: center;">LED 颜色</th><th style="text-align: center;">正向电压 <span class="math inline">\(V_F\)</span></th><th style="text-align: center;">正向电流 <span class="math inline">\(I_F\)</span></th><th style="text-align: center;">耗散功率 <span class="math inline">\(P_D\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>红色</strong></td><td style="text-align: center;"><code>1.6V ~ 2.6V</code></td><td style="text-align: center;"><code>20mA</code></td><td style="text-align: center;"><code>65mW</code></td></tr><tr class="even"><td style="text-align: center;"><strong>黄色</strong></td><td style="text-align: center;"><code>1.6V ~ 2.6V</code></td><td style="text-align: center;"><code>20mA</code></td><td style="text-align: center;"><code>65mW</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>橙色</strong></td><td style="text-align: center;"><code>1.6V ~ 2.6V</code></td><td style="text-align: center;"><code>20mA</code></td><td style="text-align: center;"><code>65mW</code></td></tr><tr class="even"><td style="text-align: center;"><strong>黄绿色</strong></td><td style="text-align: center;"><code>1.6V ~ 2.6V</code></td><td style="text-align: center;"><code>5mA</code></td><td style="text-align: center;"><code>65mW</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>白色</strong></td><td style="text-align: center;"><code>2.6V ~ 3.6V</code></td><td style="text-align: center;"><code>5mA</code></td><td style="text-align: center;"><code>72mW</code></td></tr><tr class="even"><td style="text-align: center;"><strong>蓝色</strong></td><td style="text-align: center;"><code>2.6V ~ 3.6V</code></td><td style="text-align: center;"><code>10mA</code></td><td style="text-align: center;"><code>72mW</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>翠绿色</strong></td><td style="text-align: center;"><code>2.6V ~ 3.6V</code></td><td style="text-align: center;"><code>10mA</code></td><td style="text-align: center;"><code>72mW</code></td></tr></tbody></table><h1 id="三极管-triode">三极管 Triode</h1><p><strong>三极管</strong>又称为晶体三极管，根据其结构和电气特性可以划分为<strong>NPN</strong> 和 <strong>PNP</strong>两种类型，它们的电路符号如下所示（<strong>箭头朝外 NPN，箭头朝内PNP</strong>）：</p><p><img src="/Electronics/Component/7-Triode/1.png"></p><h2 id="基本结构">基本结构</h2><p><strong>PNP 型三极管</strong>是由两个 <strong>P 型半导体</strong>和一个 <strong>N 型半导体</strong>共同构成（电流是从<strong>发射极</strong>进入）：</p><p><img src="/Electronics/Component/7-Triode/2.png"></p><p><strong>NPN 型三极管</strong>则是由两个 <strong>N 型半导体</strong>和一个 <strong>P 型半导体</strong>共同构成（电流是从<strong>集电极</strong>进入）：</p><p><img src="/Electronics/Component/7-Triode/3.png"></p><p>三极管的 3个电极分别被称为<strong>集电极</strong>（<strong>C</strong>ollector）、<strong>基极</strong>（<strong>B</strong>ase）、<strong>发射极</strong>（<strong>E</strong>mitter），这三个电极之间会形成2 个 PN 结：</p><ul><li><strong>发射结</strong>：基极和发射极之间的 PN 结。</li><li><strong>集电结</strong>：基极与集电极之间的 PN 结。</li></ul><p>正是这 2 个 PN 结又会将三极管内部，划分为如下的 3 个区域：</p><ul><li><strong>发射区</strong>：跟<strong>发射极</strong>相连的区域，发射区的本征半导体掺杂浓度较高，存在有大量电荷，可以发射电荷。</li><li><strong>集电区</strong>：跟<strong>集电极</strong>相连的区域，集电区本征半导体的面积非常大，从而便于收集发射区传递过来的电荷。</li><li><strong>基区</strong>：跟<strong>基极</strong>相连的区域，基区处于上述两者之间，掺杂浓度低并且面积较小。由于从发射区进入集电区的电荷都要经过基区，所以基区可以控制发射区流向集电区的电荷数量。</li></ul><h2 id="三种工作状态">三种工作状态</h2><p><strong>偏置电路</strong>用于向 NPN 和 PNP三极管的各个<strong>极</strong>，提供相应的工作电压，从而使其运行在不同的工作状态：</p><p><img src="/Electronics/Component/7-Triode/4.png"></p><ol type="1"><li><strong>放大状态</strong>：发射结正偏导通，集电结反偏。此时<strong>基极电流</strong><span class="math inline">\(I_B\)</span>流入，三极管内部导通，<strong>集电极电流</strong> <span class="math inline">\(I_C\)</span>进入到三极管内部，在与<strong>基极电流</strong> <span class="math inline">\(I_B\)</span>汇合之后，形成<strong>发射极电流</strong> <span class="math inline">\(I_E\)</span> 输出；</li><li><strong>饱和状态</strong>：发射结和集电结都正偏导通，此时<strong>基极电流</strong><span class="math inline">\(I_B\)</span>不断增大，<strong>集电极电流</strong> <span class="math inline">\(I_C\)</span>也会不断增大，当两者增大到一定程度时，<span class="math inline">\(I_C\)</span> 无法再伴随 <span class="math inline">\(I_B\)</span>进一步增大，两者的大小关系就会维持不变。换而言之，<strong>基极电流</strong><span class="math inline">\(I_B\)</span> 无法再控制<strong>集电极电流</strong> <span class="math inline">\(I_C\)</span>；</li><li><strong>截止状态</strong>：发射结电压小于<strong>开启电压</strong>(<code>0.7V</code>)，集电结反偏。此时<strong>基极电流</strong><span class="math inline">\(I_B\)</span>为零，三极管内部无法导通，<strong>集电极电流</strong> <span class="math inline">\(I_C\)</span>无法进入三极管，致使<strong>发射极电流</strong> <span class="math inline">\(I_E\)</span> 也为零；</li></ol><p>接下来以一系列<strong>共集电极放大电路</strong>为例，来说明上述的三种工作状态。下图<strong>NPN 三极管偏置电路</strong> 当中的 <span class="math inline">\(U_C = 4V\)</span>、<span class="math inline">\(U_B= 2.5V\)</span>、<span class="math inline">\(U_E = 1.8V\)</span>，此时<span class="math inline">\(U_B - U_E = 0.7V\)</span> 发射结正偏导通，而<span class="math inline">\(U_C &gt; U_B\)</span>集电结反偏，三极管处于<strong>放大状态</strong>：</p><p><img src="/Electronics/Component/7-Triode/5.png"></p><p>当偏置电路中的 NPN 与 PNP三极管工作在<strong>放大状态</strong>时，其三个引脚之间的<strong>电压</strong>与<strong>电流</strong>关系总是会遵循下面的规律（其中的<span class="math inline">\(\beta\)</span>是三极管的电流放大倍数）：</p><p><span class="math display">\[\begin{align}所有三极管&amp;   \implies I_E = I_B + I_C \\所有三极管&amp;   \implies I_C = \beta \cdot I_B \\NPN 型三极管&amp; \implies U_E &lt; U_B &lt; U_C  \\PNP 型三极管&amp; \implies U_E &gt; U_B &gt; U_C\end{align}\]</span></p><p>下图 <strong>NPN 三极管偏置电路</strong> 当中的 <span class="math inline">\(U_C = 4.7V\)</span>、<span class="math inline">\(U_B = 5V\)</span>、<span class="math inline">\(U_E= 4.3V\)</span>，此时 <span class="math inline">\(U_B - U_E =0.7V\)</span> 发射结正偏导通，而 <span class="math inline">\(U_B &gt;U_C\)</span> 集电结同样正偏，三极管处于<strong>饱和状态</strong>：</p><p><img src="/Electronics/Component/7-Triode/6.png"></p><p>下图 <strong>PNP 三极管偏置电路</strong> 当中的 <span class="math inline">\(U_C = 0V\)</span>、<span class="math inline">\(U_B= 6V\)</span>、<span class="math inline">\(U_E = 6V\)</span>，此时 <span class="math inline">\(U_B - U_E = 0V\)</span> 发射结零偏不导通，而 <span class="math inline">\(U_B &gt; U_C\)</span>集电结反偏，三极管处于<strong>截止状态</strong>：</p><p><img src="/Electronics/Component/7-Triode/7.png"></p><h2 id="基本放大电路的接法">基本放大电路的接法</h2><p>由单个三极管构成的放大电路称为<strong>基本放大电路</strong>，根据不同的偏置电路连接方法，可以划分为如下三种基本接法：</p><p><img src="/Electronics/Component/7-Triode/8.png"></p><ul><li><strong>共射极放大电路</strong>：既能放大<strong>电流</strong>又能放大<strong>电压</strong>，<strong>输入电阻</strong>居于三种接法的中位，<strong>输出电阻</strong>比较大，频带较窄，通常用于<strong>低频电压放大电路</strong>。</li><li><strong>共集极放大电路</strong>：只能放大<strong>电流</strong>不能放大<strong>电压</strong>，<strong>输入电阻</strong>在三种接法当中最大，<strong>输出电阻</strong>最小，并且具有<strong>电压跟随</strong>的特点，通常用于<strong>电压或功率放大电路</strong>。</li><li><strong>共基极放大电路</strong>：只能放大<strong>电压</strong>不能放大<strong>电流</strong>，<strong>输入电阻</strong>最小，<code>电压放大倍数</code>和<code>输出电阻</code>与共射极放大电路相当，且具有<strong>电流跟随</strong>的特点，在三种接法当中高频特性最好，通常用于<strong>宽频带放大电路</strong>。</li></ul><blockquote><p><strong>注意</strong>：基本放大电路的<strong>输入回路</strong>与<strong>输出回路</strong>的公共端（也就是<strong>地</strong>）在三极管的哪个极，就可以称其为<strong>共X 极放大电路</strong>。</p></blockquote><h2 id="数据手册参数">数据手册参数</h2><p>三极管的数据手册，通常会将重点参数划分为<strong>最大额定值</strong>（MaximumRatings）和<strong>电器特性</strong>（ElectricalCharacteristics）两个部分，具体可以参见下面的表格：</p><table><colgroup><col style="width: 26%"><col style="width: 31%"><col style="width: 41%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数（最大额定值）</th><th style="text-align: left;">参数名称（中文）</th><th style="text-align: left;">参数名称（英文）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(V_{CBO}\)</span></td><td style="text-align: left;"><strong>集电极-基极电压</strong></td><td style="text-align: left;">Collector-Base Voltage</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(V_{CEO}\)</span></td><td style="text-align: left;"><strong>集电极-发射极电压</strong></td><td style="text-align: left;">Collector-Emitter Voltage</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(V_{EBO}\)</span></td><td style="text-align: left;"><strong>发射极-基极电压</strong></td><td style="text-align: left;">Emitter-Base Voltage</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(I_{B}\)</span></td><td style="text-align: left;"><strong>基极电流</strong></td><td style="text-align: left;">Base Current-Continuous</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(I_{C}\)</span></td><td style="text-align: left;"><strong>集电极电流</strong></td><td style="text-align: left;">Collector Current-Continuous</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(I_{E}\)</span></td><td style="text-align: left;"><strong>发射极电流</strong></td><td style="text-align: left;">Emitter Current-Continuous</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(P_{C}\)</span></td><td style="text-align: left;"><strong>耗散功率</strong></td><td style="text-align: left;">Collector Power Dissipation</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(T_{j}\)</span></td><td style="text-align: left;"><strong>结温</strong></td><td style="text-align: left;">Junction Temperature</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_{stg}\)</span></td><td style="text-align: left;"><strong>储存温度</strong></td><td style="text-align: left;">Storage Temperature</td></tr></tbody></table><table><colgroup><col style="width: 20%"><col style="width: 32%"><col style="width: 46%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数（电器特性）</th><th style="text-align: left;">参数名称（中文）</th><th style="text-align: left;">参数名称（英文）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(V_{(BR)CBO}\)</span></td><td style="text-align: left;"><strong>集电极-基极击穿电压</strong></td><td style="text-align: left;">Collector-base Breakdown Voltage</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(V_{(BR)CEO}\)</span></td><td style="text-align: left;"><strong>集电极-发射极击穿电压</strong></td><td style="text-align: left;">Collector-emitter Breakdown Voltage</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(V_{(BR)EBO}\)</span></td><td style="text-align: left;"><strong>发射极-基极击穿电压</strong></td><td style="text-align: left;">Emitter-base Breakdown Voltage</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(I_{CBO}\)</span></td><td style="text-align: left;"><strong>集电极-基极截止电流</strong></td><td style="text-align: left;">Collector Cut-off Current</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(I_{CEO}\)</span></td><td style="text-align: left;"><strong>集电极-发射极截止电流</strong></td><td style="text-align: left;">Collector Cut-off Current</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(I_{EBO}\)</span></td><td style="text-align: left;"><strong>发射极-基极截止电流</strong></td><td style="text-align: left;">Emitter Cut-off Current</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(hFE\)</span></td><td style="text-align: left;"><strong>直流电流增益</strong></td><td style="text-align: left;">DC Current Gain</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(V_{CE}（sat）\)</span></td><td style="text-align: left;"><strong>集电极-发射极饱和压降</strong></td><td style="text-align: left;">Collector-emitter Saturation Voltage</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(V_{BE}（sat）\)</span></td><td style="text-align: left;"><strong>发射极-基极饱和压降</strong></td><td style="text-align: left;">Base-emitter Saturation Voltage</td></tr></tbody></table><blockquote><p><strong>注意</strong>：三极管之所以被称为<strong>电流控制元件</strong>，是因为其本质是通过控制一个较小的电流（基极电流<span class="math inline">\(I_B\)</span>）来影响或者控制一个较大的电流（集电极电流<span class="math inline">\(I_C\)</span>、发射极电流 <span class="math inline">\(I_E\)</span>）。</p></blockquote><h2 id="达林顿管">达林顿管</h2><p><strong>达林顿管</strong>包含有两个或者多个三极管，其中第 1个三极管的<strong>集电极</strong>直接连接至第 2个三极管的<strong>基极</strong>。这种连接方式会让其具有<strong>高电流放大倍数</strong>、<strong>大输入电阻</strong>、<strong>良好的温度稳定性</strong>等特点，被广泛应用于开关电路、放大电路、功率控制电路：</p><p><img src="/Electronics/Component/7-Triode/9.png"></p><ul><li><strong>第 1个三极管</strong>放大之后的<strong>电流</strong>，可以进一步被<strong>第2个三极管</strong>放大，从而实现了电流放大特性的成倍叠加，因而具有更高的电流<strong>放大倍数</strong><span class="math inline">\(\beta\)</span>。</li><li>增大了达林顿三极管的<strong>输入电阻</strong>，有助于降低输入电路对于信号源的影响，提高输出信号的稳定性。</li><li>改善温度稳定性，虽然内部各个三极管的工作参数会受到温度的影响而变化，但是各极之间的相互连接关系，往往能够部分抵消这些变化。</li></ul><p><img src="/Electronics/Component/7-Triode/10.png"></p><p>上图当中的 <strong>TIP122</strong>（NPN，上图右）以及<strong>TIP127</strong>（PNP，上图左）都属于比较常见的达林顿管，它们都具备高达<code>1000</code> 的电流放大倍数，且基极与发射极之间只需要维持 <span class="math inline">\(V_{EBO} = 5V\)</span>的电压，而<strong>基极电流</strong>仅为 <span class="math inline">\(I_B= 120mA\)</span>，通常外接至微控制器的 GPIO端口，对一些<strong>大电流</strong>的负载进行开关控制。</p><p><img src="/Electronics/Component/7-Triode/11.png"></p><p>而上图当中的 <strong>ULN2003A</strong>则属于高电压、大电流的达林顿管<strong>阵列</strong>，片上主要由 7对具备高压输出能力的 <strong>NPN</strong>型达林顿管组成，并且带有用于开关感性负载的<strong>共阴极钳位二极管</strong>。下图是使用其驱动电机、电位器、电磁阀等感性负载时的典型应用电路：</p><p><img src="/Electronics/Component/7-Triode/12.png"></p><blockquote><p><strong>注意</strong>：微控制器的外围电路经常会使用到<strong>ULN2003A</strong>去驱动一些高电压（<code>50V</code>）或者大电流（<code>500mA</code>）的外设。</p></blockquote><h2 id="光电耦合器">光电耦合器</h2><p><strong>光电耦合器</strong>（OC，OpticalCoupler）简称<strong>光耦</strong>，是一种以光作为媒介来传递电平信号的元器件。内部由一个<strong>发光元件</strong>（发光二极管）和一个<strong>光敏元件</strong>（光电三极管）共同组成，通过不断的执行<code>电 → 光 → 电</code>的转换过程，在传输信号的同时还可以起到保护隔离的作用，下面是经典的<strong>PC817A</strong> 型光耦的剖面示意图：</p><p><img src="/Electronics/Component/7-Triode/13.png"></p><p>对于一侧是低电压的微控制器电路，而另外一侧是高电压的功率控制端，这种情况下就可以选用光耦进行隔离控制。除此之外，由于光耦的输入端属于电流驱动的低阻元件，因而具备较强的<strong>共模抑制</strong>能力，可以应用在长距离信号传输当中提升信噪比（光耦封装上的<strong>小圆点</strong>标注的是第<code>1</code> 号引脚）。</p><p><img src="/Electronics/Component/7-Triode/14.png"></p><p>对光电耦合器进行选型时，需要分别关注其<strong>输入端</strong>（可视为<strong>发光二极管</strong>）和<strong>输出端</strong>（可视为<strong>光电三极管</strong>的<code>集电极</code>和<code>发射极</code>）的相关参数。下图左侧展示的是光耦典型应用电路，而右侧呈现的是光耦通信时的输入输出信号状态：</p><p><img src="/Electronics/Component/7-Triode/15.png"></p><p>除开二极管、三极管的各种通用参数之外，还需要额外关注输出脉冲信号的<strong>上升时间</strong><span class="math inline">\(t_r\)</span>（从输出脉冲的<code>10% → 90%</code> 所需的时间）和<strong>下降时间</strong> <span class="math inline">\(t_f\)</span>（从输出脉冲的 <code>90% → 10%</code>所需的时间），这两个参数通常在<strong>微秒</strong>级别，两者之和（不考虑信号的持续时间）即为光耦通信速率的上限。</p><h2 id="三端稳压器">三端稳压器</h2><p>三端稳压器是一款由许多三极管构成的串联型稳压芯片，比较常用的有<strong>正电压输出</strong>的<strong>78XX</strong> 系列，以及<strong>负电压输出</strong>的<strong>79XX</strong> 系列（最后的尾数 <code>XX</code>表示的是稳压值），它们通常会采用如下三个引脚的封装形式（这些引脚分别为<strong>输入</strong>、<strong>地</strong>、<strong>输出</strong>）：</p><p><img src="/Electronics/Component/7-Triode/16.png"></p><p><strong>三端稳压器</strong>的工作原理主要依赖于反馈控制，即当输入电压发生变化时，通过内部<code>基准电压源</code>、<code>比较放大器</code>、<code>误差放大器</code>的协同工作，以维持一个稳定的电压输出（下面是 <strong>78XX</strong>系列的内部原理图）：</p><p><img src="/Electronics/Component/7-Triode/17.png"></p><blockquote><p><strong>注意</strong>：在进行三端稳压器选型的时候，需要额外注意<strong>输入电压</strong> <span class="math inline">\(V_{in}\)</span>必须始终高于 <strong>输出电压</strong> <span class="math inline">\(V_{out}\)</span>，两者之间必须维持一个合理的压差。</p></blockquote><h1 id="可控硅-scr">可控硅 SCR</h1><p><strong>可控硅</strong>（SCR，Silicon ControlledRectifier）通常被称作<strong>晶闸管</strong>，是一种外形尺寸比较硕大的元器件（也存在尺寸相对小巧的贴片或者直插式封装），被广泛应用于<code>高电压</code>、<code>大电流</code>、<code>大功率</code>的工作场景：</p><p><img src="/Electronics/Component/8-SCR/0.png"></p><h2 id="单向可控硅">单向可控硅</h2><p><strong>单向晶闸管</strong>顾名思义只能单向导通，其拥有着<strong>阳极</strong>（A）、<strong>控制极</strong>（G）、<strong>阴极</strong>（K）三个引脚，对应的电路符号如下图所示：</p><p><img src="/Electronics/Component/8-SCR/1.png"></p><p>单向晶闸管的内部结构如下图左侧所示，我们可以将其等效为下图右侧的一个<strong>PNP</strong> 型三极管与一个 <strong>NPN</strong>型三极管的相互连接：</p><p><img src="/Electronics/Component/8-SCR/2.png"></p><p>下面是一个单向晶闸管的偏置电路，其中的<strong>电源</strong> <span class="math inline">\(E_2\)</span> 通过<strong>电阻</strong> <span class="math inline">\(R_2\)</span> 为单向晶闸管的 <strong>A 极</strong>与 <strong>K 极</strong> 提供<strong>正向电压</strong> <span class="math inline">\(U_{AK}\)</span>，而<strong>电源</strong> <span class="math inline">\(E_1\)</span> 经过<strong>电阻</strong> <span class="math inline">\(R_1\)</span> 和<strong>开关</strong> <span class="math inline">\(S\)</span> 为单向晶闸管的 <strong>G 极</strong> 与<strong>K 极</strong> 提供<strong>正向电压</strong> <span class="math inline">\(U_{GK}\)</span>：</p><p><img src="/Electronics/Component/8-SCR/3.png"></p><ul><li>当<strong>开关</strong> <span class="math inline">\(S\)</span>处于<strong>断开</strong>状态的时候，单向晶闸管内部的<strong>三极管</strong><span class="math inline">\(VT_1\)</span> 没有<strong>基极电流</strong><span class="math inline">\(I_{B1}\)</span> 通过无法导通，同样的 <span class="math inline">\(VT_2\)</span> 也无法导通（电流 <span class="math inline">\(I_2 =0A\)</span>），此时单向晶闸管处于<strong>截止状态</strong>。</li><li>当<strong>开关</strong> <span class="math inline">\(S\)</span>处于<strong>闭合</strong>状态的时候，<strong>电源</strong> <span class="math inline">\(E_1\)</span> 开始向<strong>三极管</strong> <span class="math inline">\(VT_1\)</span> 提供<strong>基极电流</strong> <span class="math inline">\(I_{B1}\)</span>，此时由于三极管 <span class="math inline">\(VT_2\)</span> 的<strong>基极电流</strong> <span class="math inline">\(I_{B2}\)</span> 会经过<strong>三极管</strong><span class="math inline">\(VT_1\)</span>的集电极和发射极，从而使得<strong>三极管</strong> <span class="math inline">\(VT_1\)</span> 和 <span class="math inline">\(VT_2\)</span>先后导通。此时<strong>三极管</strong> <span class="math inline">\(VT_2\)</span> 的<strong>集电极电流</strong> <span class="math inline">\(I_{C2}\)</span> 与<strong>电源</strong> <span class="math inline">\(E_1\)</span>提供的电流汇合，形成一股更大的<strong>电流</strong> <span class="math inline">\(I_{B1}\)</span> 进入<strong>三极管</strong> <span class="math inline">\(VT_1\)</span>的发射极，由于<strong>三极管</strong> <span class="math inline">\(VT_1\)</span>的导通程度越深，通过的<strong>集电极电流</strong> <span class="math inline">\(I_{C1}\)</span>就会越大，导致<strong>三极管</strong> <span class="math inline">\(VT_2\)</span> 的<strong>基极电流</strong> <span class="math inline">\(I_{B2}\)</span> 以及<strong>集电极电流</strong><span class="math inline">\(I_{C2}\)</span>也随之增大，从而形成<strong>正反馈</strong>。</li></ul><p><img src="/Electronics/Component/8-SCR/4.png"></p><ol type="1"><li><strong>正反馈</strong>会使得<strong>三极管</strong> <span class="math inline">\(VT_1\)</span> 和 <span class="math inline">\(VT_2\)</span>都进入饱和状态，<strong>基极电流</strong> <span class="math inline">\(I_{B2}\)</span> 以及<strong>集电极电流</strong><span class="math inline">\(I_{C2}\)</span>都来源于<strong>三极管</strong> <span class="math inline">\(VT_2\)</span>的<strong>发射极</strong>（即单向晶闸管的 <strong>A极</strong>），最后从<strong>三极管</strong> <span class="math inline">\(VT_1\)</span> 的<strong>发射极</strong>流出（即单向晶闸管的 <strong>K极</strong>），此时单向晶闸管<strong>导通</strong>。</li><li>单向晶闸管导通之后，即使<strong>开关</strong> <span class="math inline">\(S\)</span> 断开，<strong>三极管</strong> <span class="math inline">\(VT_2\)</span> 的 <strong>基极电流</strong> <span class="math inline">\(I_{B2}\)</span> 以及 <strong>集电极电流</strong><span class="math inline">\(I_{C2}\)</span>会继续存在，单向晶闸管<strong>持续导通</strong>。</li><li>如果此时调低<strong>电源</strong> <span class="math inline">\(E_2\)</span> 的电压，那么流入单向晶闸管 <strong>A极</strong>的电流也会随之减小，当 <span class="math inline">\(E_2\)</span> 的电压被调整至极低的时候（接近于<code>0V</code>），流入单向晶闸管 <strong>A极</strong>的电流也就会接近于<code>0A</code>，此时单向晶闸管就<strong>进入截止</strong>状态。</li></ol><p>综上所述，我们可以将单向晶闸管的主要特点，归结为如下这四个方面：</p><ol type="1"><li>无论 <strong>A 极</strong> 与 <strong>K 极</strong>之间施加<strong>任何电压</strong>，只要 <strong>G 极</strong> 与<strong>K 极</strong>之间未被施加<strong>正向电压</strong>，单向晶闸管都<strong>无法导通</strong>。</li><li>只有 <strong>A 极</strong> 与 <strong>K极</strong>之间施加<strong>正向电压</strong>，并且 <strong>G 极</strong>与 <strong>K 极</strong>之间也施加一定的<strong>正向电压</strong>，单向晶闸管才<strong>能够导通</strong>。</li><li>单向晶闸管导通之后，即使撤掉其 <strong>G 极</strong> 与 <strong>K极</strong>之间的<strong>正向电压</strong>，单向晶闸管仍然能够继续<strong>维持导通</strong>状态。</li><li>如果要让已经导通的单向晶闸管<strong>进入截止</strong>状态，要么让流入单向晶闸管<strong>A 极</strong>的电流减小至其<strong>维持电流</strong> <span class="math inline">\(I_H\)</span>，要么使其 <strong>A 极</strong> 与<strong>K 极</strong> 之间的<strong>正向电压</strong> <span class="math inline">\(U_{AK}\)</span> 减小至<code>0V</code>，或者直接施加一个<strong>反向电压</strong>（简而言之，只能控制开，无法控制关）。</li></ol><h2 id="重点选型参数">重点选型参数</h2><p><strong>单向晶闸管</strong>元器件进行选型时，需要重点关注下面表格当中的一系列参数：</p><table><colgroup><col style="width: 14%"><col style="width: 5%"><col style="width: 80%"></colgroup><thead><tr class="header"><th style="text-align: left;">参数名称</th><th style="text-align: left;">符号</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>正向断态重复峰值电压</strong></td><td style="text-align: left;"><span class="math inline">\(U_{DRM}\)</span></td><td style="text-align: left;">指在单向晶闸管关断，并且 <strong>G极</strong> 开路的情况下，允许重复施加到 <strong>A 极</strong> 与<strong>K 极</strong> 之间的最大正向峰值电压。</td></tr><tr class="even"><td style="text-align: left;"><strong>反向重复峰值电压</strong></td><td style="text-align: left;"><span class="math inline">\(U_{RRM}\)</span></td><td style="text-align: left;">是指在 G极开路的时候，允许施加到单向晶闸管 <strong>A 极</strong> 与 <strong>K极</strong> 之间的最大反向峰值电压（<span class="math inline">\(U_{DRM}\)</span> 与 <span class="math inline">\(U_{RRM}\)</span> 两个参数通常比较接近）。</td></tr><tr class="odd"><td style="text-align: left;"><strong>控制极 / G极触发电压</strong></td><td style="text-align: left;"><span class="math inline">\(U_{GT}\)</span></td><td style="text-align: left;">指室温条件下，当 <strong>A 极</strong> 与<strong>K 极</strong>之间施加指定电压的时候，能够使单向晶闸管从截止转变为导通，所需的最小<strong>G 极</strong>直流<strong>电压</strong>。</td></tr><tr class="even"><td style="text-align: left;"><strong>控制极 / G极触发电流</strong></td><td style="text-align: left;"><span class="math inline">\(I_{GT}\)</span></td><td style="text-align: left;">指室温条件下，当 <strong>A 极</strong> 与<strong>K 极</strong>之间施加指定电压的时候，能够使单向晶闸管从截止转变为导通，所需的最小<strong>G 极</strong>直流<strong>电流</strong>。</td></tr><tr class="odd"><td style="text-align: left;"><strong>通态平均电流</strong></td><td style="text-align: left;"><span class="math inline">\(I_T\)</span></td><td style="text-align: left;">指室温条件下，能够连续通过<code>50Hz</code> 正弦波的电流平均值。</td></tr><tr class="even"><td style="text-align: left;"><strong>维持电流</strong></td><td style="text-align: left;"><span class="math inline">\(I_H\)</span></td><td style="text-align: left;">指在 <strong>G极</strong>开路的条件下，能够维持单向晶闸管持续导通的最小正向电流。</td></tr></tbody></table><h2 id="双向可控硅">双向可控硅</h2><p><strong>双向晶闸管</strong>能够双向导通，其拥有<strong>主电极</strong><span class="math inline">\(T_1\)</span>、<strong>主电极</strong> <span class="math inline">\(T_2\)</span>、<strong>控制极</strong> <span class="math inline">\(G\)</span>三个引脚，对应的<strong>电路符号</strong>（下图左侧）和<strong>内部结构</strong>（下图右侧）如下所示：</p><p><img src="/Electronics/Component/8-SCR/5.png"></p><p>当向<strong>双向晶闸管</strong>的 <span class="math inline">\(T_1\)</span> 与 <span class="math inline">\(T_2\)</span>极之间施加<strong>正向电压</strong>（<span class="math inline">\(U_{T2}&gt; U_{T1}\)</span>）的时候，如果其 <strong>G极</strong>没有施加电压，那么 <span class="math inline">\(T_1\)</span>与 <span class="math inline">\(T_2\)</span> 极之间就不会导通。如果在<span class="math inline">\(G\)</span> 极与 <span class="math inline">\(T_1\)</span>极之间施加<strong>正向电压</strong>（<span class="math inline">\(U_{G}&gt; U_{T1}\)</span>），那么 <span class="math inline">\(T_1\)</span> 与<span class="math inline">\(T_2\)</span> 极之间将会马上导通，电流会由<span class="math inline">\(T_2\)</span> 极流入，并从 <span class="math inline">\(T_1\)</span> 极流出。此时即使移除 <strong>G极</strong>电压，双向晶闸管的 <span class="math inline">\(T_1\)</span>与 <span class="math inline">\(T_2\)</span>极之间仍然处于导通状态。换而言之，当 <span class="math inline">\(U_{T2}&gt; U_{G} &gt; U_{T1}\)</span> 的时候，双向晶闸管就会导通，电流会从<span class="math inline">\(T_2\)</span> 极流入 <span class="math inline">\(T_1\)</span> 极流出，此时即使移除 <strong>G极</strong>电压，晶闸管仍然能够保持导通：</p><p><img src="/Electronics/Component/8-SCR/6.png"></p><p>当向<strong>双向晶闸管</strong>的 <span class="math inline">\(T_1\)</span> 与 <span class="math inline">\(T_2\)</span>极之间施加<strong>反向电压</strong>（<span class="math inline">\(U_{T2}&lt; U_{T1}\)</span>）时，如果其 <strong>G 极</strong>没有施加电压，那么<span class="math inline">\(T_1\)</span> 与 <span class="math inline">\(T_2\)</span> 极之间就不会导通。如果在 <span class="math inline">\(G\)</span> 极与 <span class="math inline">\(T_1\)</span>极之间施加<strong>反向电压</strong>（<span class="math inline">\(U_{G}&lt; U_{T1}\)</span>），那么 <span class="math inline">\(T_1\)</span> 与<span class="math inline">\(T_2\)</span> 极之间将会立刻导通，电流会由<span class="math inline">\(T_1\)</span> 极流入，并从 <span class="math inline">\(T_2\)</span> 极流出。此时即使移除 <strong>G极</strong>电压，双向晶闸管的 <span class="math inline">\(T_1\)</span>与 <span class="math inline">\(T_2\)</span>极之间仍然处于导通状态。换而言之，当 <span class="math inline">\(U_{T1}&gt; U_{G} &gt; U_{T2}\)</span> 的时候，双向晶闸管就会导通，电流会从<span class="math inline">\(T_1\)</span> 极流入 <span class="math inline">\(T_2\)</span> 极流出，此时即使移除 <strong>G极</strong>电压，晶闸管仍然能够保持导通：</p><p><img src="/Electronics/Component/8-SCR/7.png"></p><p>当双向晶闸管导通之后，即使移除 <strong>G极</strong>电压其仍然能够保持导通状态。此时如果需要关断双向晶闸管，使其进入截止状态，那么可以采取如下任意一种措施：</p><ol type="1"><li>让流过<strong>主电极</strong> <span class="math inline">\(T_1\)</span> 和 <strong>主电极</strong> <span class="math inline">\(T_2\)</span>极的电流减小至<strong>维持电流</strong> <span class="math inline">\(I_H\)</span> 以下。</li><li>将<strong>主电极</strong> <span class="math inline">\(T_1\)</span>与 <strong>主电极</strong> <span class="math inline">\(T_2\)</span>极之间的电压置为<code>0V</code>，或者直接施加一个<strong>反向电压</strong>（依然是只能导通，无法关断(•ิ_•ิ) ）。</li></ol><h1 id="场效应管-fet">场效应管 FET</h1><p><strong>晶体管</strong>（Transistor）是一种以固态半导体作为制造原材料的元器件，通常都至少拥有三只引脚，可以划分为如下一系列类型：</p><p><img src="/Electronics/Component/9-FET/1.png"></p><ul><li><strong>双极型晶体管</strong>（<strong>BJT</strong>，BipolarJunctionTransistor）：即前面介绍的<strong>三极管</strong>，如前所述，可以划分为<strong>NPN</strong> 型和 <strong>PNP</strong> 型两种。</li><li><strong>单极型晶体管</strong>（<strong>FET</strong>，Field EffectTransistor）：即本节内容即将介绍的<strong>场效应管</strong>，根据材料还可以细分为<strong>JFET</strong>（结型）和<strong>MOSFET</strong>（金属氧化物型），两者还可以进一步被划分为<strong>N 沟道</strong>和 <strong>P 沟道</strong> 类型。</li></ul><blockquote><p><strong>注意</strong>：<strong>双极型晶体管</strong>的载流子包含<strong>电子</strong>和<strong>空穴</strong>两种，类似于拥有两个极性，所以称为<strong>双极型</strong>；而在<strong>单极型晶体管</strong>当中，只存在<strong>电子</strong>或者<strong>空穴</strong>两种载流子当中的一种，类似于只存在着一个极性，因而被称为<strong>单极型</strong>。</p></blockquote><p><img src="/Electronics/Component/9-FET/2.png"></p><p>虽然<strong>场效应管</strong>和之前讨论过的<strong>三极管</strong>在外形上都拥有着<strong>三只引脚</strong>，但是<strong>场效应管</strong>的核心原理是通过<strong>栅极</strong>与<strong>源极</strong>两端的电压，来控制<strong>漏极</strong>的电流，因而被称为<strong>压控型</strong>元器件。而<strong>三极管</strong>则是通过<strong>基极电流</strong><span class="math inline">\(I_B\)</span> 控制<strong>集电极电流</strong><span class="math inline">\(I_C\)</span>，所以被称为<strong>流控型</strong>元器件。</p><h2 id="结型场效应管-jfet">结型场效应管 JFET</h2><p>如前所述，<strong>结型场效应管</strong> JFET 可以划分为 <strong>P沟道</strong>和 <strong>N沟道</strong>两种类型，因其工作电流非常小（最大仅有<code>500mA</code>，大部分低于<code>100mA</code>），导致应用场合十分有限，仅有百余种型号，它们的电路符号如下图所示：</p><p><img src="/Electronics/Component/9-FET/3.png"></p><ul><li><strong>N 沟道结型场效应管</strong>（下图左侧）：内部两块 <strong>P型半导体</strong>通过导线连接（引出 <strong>G极</strong>），除此之外的部分均为 <strong>N 型半导体</strong>，在 P 型和N 型半导体的交界处会形成两个 <strong>PN结</strong>，它们中间的区域称为<strong>沟道</strong>（两端分别引出<strong>D 极</strong>与 <strong>S 极</strong>）。由于该沟道由 <strong>N型半导体</strong>构成，所以称为 <strong>N 沟道</strong>。</li><li><strong>P 沟道结型场效应管</strong>（下图右侧）：内部两块 <strong>N型半导体</strong>同样通过导线连接（引出 <strong>G极</strong>），中间的<strong>沟道</strong>由 <strong>P型半导体</strong>制成（分别引出 <strong>D 极</strong>与 <strong>S极</strong>），此时交界处会形成两个 <strong>PN结</strong>，中间的沟道也就称作 <strong>P 沟道</strong>。</li></ul><p><img src="/Electronics/Component/9-FET/4.png"></p><blockquote><p><strong>注意</strong>：上述示意图当中的<strong>栅极</strong>（<strong>G</strong>ate）也被称作<strong>G极</strong>，<strong>漏极</strong>（<strong>D</strong>rain）也称作<strong>D 极</strong>，而<strong>源极</strong>（<strong>S</strong>ource）被称为 <strong>S极</strong>。</p></blockquote><p>以下图虚线框中的 <strong>N 沟道结型场效应管</strong> 为例，当向<strong>D 极</strong>和 <strong>S极</strong>之间施加<strong>正向电压</strong> <span class="math inline">\(U_{DS}\)</span> 时，就会有电流从 <strong>D极</strong> 流向 <strong>S 极</strong>。此时如果再在 <strong>G极</strong> 和 <strong>S极</strong>之间施加一个<strong>反向电压</strong> <span class="math inline">\(U_{GS}\)</span>，就会导致内部的两个 PN结增厚（沟道变窄），由 <strong>D 极</strong>流向 <strong>S极</strong>的电流 <span class="math inline">\(I_D\)</span>就会随之减小：</p><p><img src="/Electronics/Component/9-FET/5.png"></p><p>由此可见，改变 <strong>G 极</strong>与 <strong>S极</strong>之间的电压 <span class="math inline">\(U_{GS}\)</span>，就能改变从 <strong>D 极</strong>流向 <strong>S 极</strong> 的电流 <span class="math inline">\(I_D\)</span>，并且<strong>电流</strong> <span class="math inline">\(I_D\)</span>的变化幅度要远大于<strong>电压</strong> <span class="math inline">\(U_{GS}\)</span>，这正是结型场效应管的放大原理所在。通常我们使用<strong>跨导</strong> <span class="math inline">\(g_m\)</span>来衡量<strong>结型场效应管</strong> JFET的放大能力（单位为<strong>西门子</strong> <code>S</code>）：</p><p><span class="math display">\[g_m = \frac{\Delta I_D}{\Delta U_{GS}}\]</span></p><p>如果向 <strong>N 沟道结型场效应管</strong>的 <strong>G 极</strong> 和<strong>S 极</strong> 之间施加<strong>正向电压</strong> <span class="math inline">\(U_G &gt; U_S\)</span>，其内部两个 PN结就会导通，此时无论如何增大 <strong>G 极</strong> 与 <strong>S极</strong> 之间的正向电压，沟道宽度都不会变化，<strong>电流</strong><span class="math inline">\(I_D\)</span> 也不会发生变化。换而言之，向<strong>G 极</strong> 与 <strong>S极</strong>之间施加<strong>正向电压</strong>的时候，无法控制<strong>电流</strong><span class="math inline">\(I_D\)</span> 的变化：</p><p><img src="/Electronics/Component/9-FET/6.png"></p><p>综上所述，向 <strong>N 沟道结型场效应管</strong>的 <strong>G极</strong> 与 <strong>S 极</strong> 之间施加<strong>反向电压</strong><span class="math inline">\(U_G &lt; U_S\)</span>，而 <strong>P沟道结型场效应管</strong>的 <strong>G 极</strong>与 <strong>S极</strong>之间施加<strong>正向电压</strong> <span class="math inline">\(U_G &gt;U_S\)</span>，就可以确保它们能够正常工作。无论是 N 沟道还是 P沟道的结型场效应管，它们都存在有如下几个重要参数：</p><ul><li><strong>跨导</strong> <span class="math inline">\(g_m\)</span>：当电压 <span class="math inline">\(U_{DS}\)</span> 为一个确定值的时候，该参数的值等于<strong>电流</strong> <span class="math inline">\(I_D\)</span>变化量与<strong>电压</strong> <span class="math inline">\(U_{GS}\)</span> 变化量的比值 <span class="math inline">\(g_m = \frac{\Delta I_D}{\DeltaU_{GS}}\)</span>，这个参数主要反映了 <strong>G 极</strong>和 <strong>S极</strong>之间的电压，对于 <strong>D 极</strong>电流的控制能力。</li><li><strong>夹断电压</strong> <span class="math inline">\(U_{P}\)</span>：当<strong>电压</strong> <span class="math inline">\(U_{DS}\)</span> 为一个确切的值，使得<strong>电流</strong> <span class="math inline">\(I_D\)</span>减小至近似为 <code>0A</code> 时候，<span class="math inline">\(U_{GS}\)</span> 的电压值。</li><li><strong>漏源极最大电压</strong> <span class="math inline">\(U_{DS}\)</span>：是指漏极与源极之间的最大击穿电压，即<strong>电流</strong><span class="math inline">\(I_D\)</span> 急剧增大时候的 <span class="math inline">\(U_{DS}\)</span> 值。</li><li><strong>饱和漏极电流</strong> <span class="math inline">\(I_{DSS}\)</span>：是指当 <span class="math inline">\(U_{GS} = 0V\)</span>，并且 <span class="math inline">\(U_{DS}\)</span> 大于<strong>夹断电压</strong><span class="math inline">\(U_P\)</span>时候的<strong>沟道电流</strong>。</li></ul><h2 id="金属氧化物场效应管-mosfet">金属氧化物场效应管 MOSFET</h2><p><strong>金属氧化物场效应管</strong>（MOSFET，Metal-Oxide-SemiconductorField-Effect Transistor）由于名称过于冗长，所以经常被简称为 <strong>MOS管</strong>，主要分为<strong>耗尽型</strong>和<strong>增强型</strong>两种，每种类型又可以进一步细分为<strong>P 沟道</strong> 和 <strong>N沟道</strong>，具体关系可以参考下面的示意图：</p><p><img src="/Electronics/Component/9-FET/7.png"></p><h3 id="增强型">增强型</h3><p>根据<strong>增强型 MOS管</strong>内部的<strong>导电沟道</strong>是形成在 <strong>N 型</strong>还是 <strong>P 型</strong> 半导体之间，可以将其细分为 <strong>N沟道</strong>和 <strong>P 沟道</strong> 两种类型，分别称作<strong>增强型NMOS 管</strong> 和 <strong>增强型 PMOS管</strong>，它们的电路符号分别如下图所示：</p><p><img src="/Electronics/Component/9-FET/8.png"></p><p>实际生产环境下，<strong>增强型 NMOS</strong>会更加常用，所以接下来就以 <strong>NMOS</strong>管为例来讨论其内部结构。首先，增强型 <strong>NMOS</strong> 管采用<strong>P 型</strong>半导体作为<strong>衬底</strong>，在上面制作出两个含有较多杂质的<strong>N 型</strong> 半导体，并覆盖上一层极薄的 <span class="math inline">\(SiO_2\)</span><strong>二氧化硅绝缘层</strong>。然后在两个 <strong>N 型</strong>半导体上分别引出<strong>漏极</strong>（<strong>D</strong>rain）和<strong>源极</strong>（<strong>S</strong>ource），再在两极中间的二氧化硅绝缘层上制作出一层<strong>金属导电层</strong>，并从该导电层上引出<strong>栅极</strong>（<strong>G</strong>ate）：</p><p><img src="/Electronics/Component/9-FET/9.png"></p><p>增强型 <strong>NMOS</strong>管需要施加相应的电压才能够正常工作，在下面的示例电路当中，<strong>电源</strong><span class="math inline">\(E_1\)</span> 通过<strong>电阻</strong> <span class="math inline">\(R_1\)</span> 连接到 <strong>NMOS</strong> 管的<strong>D 极</strong> 和 <strong>S 极</strong>，而<strong>电源</strong><span class="math inline">\(E_2\)</span> 通过<strong>开关</strong> <span class="math inline">\(S\)</span> 连接到 <strong>NMOS</strong> 管的<strong>G 极</strong> 和 <strong>S 极</strong>：</p><p><img src="/Electronics/Component/9-FET/10.png"></p><ol type="1"><li>当开关 <span class="math inline">\(S\)</span> 断开时，增强型<strong>NMOS</strong> 管的 <strong>G 极</strong>上没有电压，并且<strong>D 极</strong>和 <strong>S 极</strong>所连接的两个 N型半导体区域之间<strong>没有导电沟道</strong>，所以两个 N型半导体区域之间无法导通，通过的电流为 <code>0A</code>；</li><li>当开关 <span class="math inline">\(S\)</span> 闭合时，增强型<strong>NMOS</strong> 管的 <strong>G极</strong>获得<strong>正向电压</strong>（<span class="math inline">\(U_G &gt; U_S\)</span>），此时与 <strong>G极</strong>相连接的<strong>金属导电层</strong>上存在有<strong>电荷</strong>，产生的电场会穿过二氧化硅绝缘层，将P 型半导体衬底上的大量电子吸引到 <span class="math inline">\(SiO_2\)</span> 层一侧，进而在两个 N型半导体区域之间<strong>形成一条导电沟道</strong>，导通 <strong>D极</strong> 与 <strong>S 极</strong> 并且输出<strong>电流</strong> <span class="math inline">\(I_D\)</span>；</li><li>改变<strong>电源</strong> <span class="math inline">\(E_2\)</span>输出电压的大小，就会相应的改变 <strong>G 极</strong>与 <strong>S极</strong>之间的<strong>电压</strong> <span class="math inline">\(U_{GS}\)</span>，致使 <strong>G极</strong>所连接铝电极上的电场也随之变化，进而引发 <span class="math inline">\(SiO_2\)</span> 绝缘层下电子数量的变化，并使得两个N型半导体区域之间的<strong>沟道宽度发生改变</strong>，流过的<strong>电流</strong><span class="math inline">\(I_D\)</span> 也就相应的改变。</li></ol><p>综上所诉，就是依靠<strong>金属导电层上产生的电场，吸引半导体衬底上的电子，从而产生导电沟道与电流</strong>，基于此可以总结出增强型<strong>NMOS</strong> 管的如下特点：</p><ol type="1"><li>当没有向 <strong>G 极</strong> 与 <strong>S 极</strong>之间施加<strong>电压</strong>的时候（<span class="math inline">\(U_{GS}= 0V\)</span>），在 <strong>D 极</strong> 与 <strong>S极</strong>之间不会形成导电沟道，<strong>D极</strong>上的<strong>输出电流</strong> <span class="math inline">\(I_D= 0A\)</span>；</li><li>当 <strong>G 极</strong>与 <strong>S极</strong>之间施加上合适的电压时（<strong>开启电压</strong>，即刚形成导电沟道时的栅源极电压<span class="math inline">\(U_{GS(th)}\)</span>），就会在 <strong>D极</strong>与 <strong>S 极</strong>之间形成导电沟道，<strong>D极</strong>上开始输出电流 <span class="math inline">\(I_D\)</span>；</li><li>当<strong>G 极</strong>与 <strong>S极</strong>之间的<strong>电压</strong> <span class="math inline">\(U_{GS}\)</span>发生变化时，导电沟道的宽度也会随之变化，致使<strong>电流</strong> <span class="math inline">\(I_D\)</span> 也会发生变化；</li></ol><p>增强型 <strong>NMOS</strong> 管和 <strong>PMOS</strong>管形成导电沟道的条件，分别如下面所示：</p><ul><li><strong>增强型 NMOS 管</strong>：需要向 G 极与 S极之间施加<strong>正向电压</strong>（<span class="math inline">\(U_G&gt; U_S\)</span>），才会在 D 极与 S 极之间形成导电沟道；</li><li><strong>增强型 PMOS 管</strong>：需要向 G 极与 S极之间施加<strong>反向电压</strong>（<span class="math inline">\(U_G&lt; U_S\)</span>），才会在 D 极与 S 极之间形成导电沟道；</li></ul><blockquote><p><strong>注意</strong>：<strong>跨导</strong> <span class="math inline">\(g_m = \frac{\Delta I_D}{\Delta U_{GS}}\)</span>同样可以用于衡量<strong>金属氧化物场效应管</strong> MOSFET的放大能力（单位为<strong>西门子</strong> <code>S</code>）。</p></blockquote><h3 id="耗尽型">耗尽型</h3><p><strong>耗尽型 MOS管</strong>同样根据内部<strong>导电沟道</strong>是形成在 <strong>N型</strong> 还是 <strong>P 型</strong> 半导体之间，被细分为 <strong>N沟道</strong> 和 <strong>P 沟道</strong>两种类型，分别称作<strong>耗尽型 NMOS 管</strong> 和 <strong>耗尽型 PMOS管</strong>，它们的电路符号分别如下面所示：</p><p><img src="/Electronics/Component/9-FET/11.png"></p><blockquote><p><strong>注意</strong>：相比于<strong>增强型 MOS 管</strong>，耗尽型MOS 管的型号非常稀少（仅十余种），因而实际工作当中极少被使用。</p></blockquote><p><strong>耗尽型 NMOS 管</strong>的内部构造与<strong>增强型 NMOS管</strong>类似，不同之处在于 <span class="math inline">\(SiO_2\)</span><strong>绝缘层</strong>中掺有大量含有<strong>正电荷</strong>的杂质（而<strong>耗尽型PMOS管</strong>掺入的是带有<strong>负电荷</strong>的杂质），从而吸引衬底当中的大量电子，并在两个N 型半导体区域之间形成<strong>导电沟道</strong>：</p><p><img src="/Electronics/Component/9-FET/12.png"></p><p>相较于增强型 MOSFET，<strong>耗尽型 MOS 管</strong>由于向 <span class="math inline">\(SiO_2\)</span><strong>绝缘层</strong>掺入了大量带有<strong>正电荷</strong>的杂质，即使<strong>G 极</strong> 和 <strong>S 极</strong>之间没有施加电压（<span class="math inline">\(U_{GS}=0V\)</span>），在 <strong>D 极</strong> 和<strong>S极</strong>之间依然也会存在着导电沟道，此时<strong>电流</strong> <span class="math inline">\(I_D\)</span> 并不会等于 <code>0A</code>；当<strong>G 极</strong> 和 <strong>S极</strong>之间施加<strong>反向电压</strong> <span class="math inline">\(U_{GS}\)</span>的时候，才会影响到导电沟道的宽度，进而使得通过的<strong>电流</strong><span class="math inline">\(I_D\)</span>发生变化。换而言之，<strong>耗尽型 MOSFET的最大特点在于栅极电压为零或者比较小的时候就已经处于导通状态</strong>（因为导电沟道已经存在）。</p><ul><li><strong>耗尽型 NMOS 管</strong>：如果 G 极与 S极之间施加<strong>正向电压</strong>（<span class="math inline">\(U_G&gt; U_S\)</span>），那么 <strong>D 极</strong>与 <strong>S极</strong>之间的导电沟道变宽，<strong>漏极电流</strong> <span class="math inline">\(I_D\)</span>才会增大；反之如果施加<strong>反向电压</strong>（<span class="math inline">\(U_G &lt; U_S\)</span>），那么 <strong>D极</strong>与 <strong>S极</strong>之间的导电沟道变窄，<strong>漏极电流</strong> <span class="math inline">\(I_D\)</span> 就会减小。</li><li><strong>耗尽型 PMOS 管</strong>：如果 G 极与 S极之间施加<strong>反向电压</strong>（<span class="math inline">\(U_G&lt; U_S\)</span>），那么 <strong>D 极</strong>与 <strong>S极</strong>之间的导电沟道变宽，<strong>漏极电流</strong> <span class="math inline">\(I_D\)</span>才会增大；反之如果施加<strong>正向电压</strong>（<span class="math inline">\(U_G &gt; U_S\)</span>），那么 <strong>D极</strong>与 <strong>S极</strong>之间的导电沟道变窄，<strong>漏极电流</strong> <span class="math inline">\(I_D\)</span> 就会减小。</li></ul><p>综上所述，<strong>耗尽型 MOS 管</strong> 分别在 <span class="math inline">\(U_{GS} &gt; 0\)</span>、<span class="math inline">\(U_{GS} = 0\)</span>、<span class="math inline">\(U_{GS} &lt; 0\)</span>这三种情况下，都总是会形成导电沟道并且通过<strong>电流</strong> <span class="math inline">\(I_D\)</span>（但是通过的电流大小会有所区别），因而电路设计时可以将其作为<strong>常开开关</strong>来使用，选型的时候则需要注意如下表格当中的三个参数：</p><table><colgroup><col style="width: 11%"><col style="width: 5%"><col style="width: 82%"></colgroup><thead><tr class="header"><th style="text-align: left;">参数名称</th><th style="text-align: center;">符号</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>漏极到源极的击穿电压</strong></td><td style="text-align: center;"><span class="math inline">\(BV_{DSX}\)</span></td><td style="text-align: left;">选型时注意保留一定的安全裕量，以适应正常的电压波动，以及瞬态浪涌或者干扰引发的电压尖峰。</td></tr><tr class="even"><td style="text-align: left;"><strong>漏极到源极的最小饱和电流</strong></td><td style="text-align: center;"><span class="math inline">\(I_{DSS}\)</span></td><td style="text-align: left;">栅极与源极电压为零 <span class="math inline">\(U_{GS} = 0\)</span> 时，在特定漏极与源极电压 <span class="math inline">\(U_{DS}\)</span> 下面通过的漏极电流。</td></tr><tr class="odd"><td style="text-align: left;"><strong>栅极到源极的截止电压</strong></td><td style="text-align: center;"><span class="math inline">\(V_{GS(OFF)}\)</span></td><td style="text-align: left;">反向增加 <strong>耗尽型 NMOS 管</strong>的栅极与源极电压 <span class="math inline">\(U_{GS}\)</span>，或者正向增加 <strong>耗尽型 PMOS管</strong> 的栅极与源极电压 <span class="math inline">\(U_{GS}\)</span>的时候，漏极电流 <span class="math inline">\(I_D\)</span>都将会逐渐减小，直至 <span class="math inline">\(U_{GS} =V_{GS(OFF)}\)</span> 的时候就会停止导通。</td></tr></tbody></table><h1 id="绝缘栅双极晶体管-igbt">绝缘栅双极晶体管 IGBT</h1><p><strong>绝缘栅双极晶体管</strong>（IGBT，Insulated Gate BipolarTransistor）是一种由<strong>场效应管</strong>和<strong>三极管</strong>共同构成的复合型元器件，其兼具有三极管的<strong>大功率特性</strong>和场效应管的<strong>高速转换</strong>与<strong>电压驱动</strong>特点，被广泛运用于各种功率电路当中（耐压值达到<code>6500V</code>，单管芯电流可达到 <code>200A</code>，开关频率可以达到<code>300kHz</code>）。该元器件同样被划分为 <strong>N 沟道</strong>和<strong>P 沟道</strong>两种类型，它们的电路符号分别如下图所示：</p><p><img src="/Electronics/Component/10-IGBT/1.png"></p><p>观察上面的符号，可以看到 <strong>IGBT</strong> 拥有着<strong>集电极</strong>（<strong>C</strong>ollector）、<strong>栅极</strong>（<strong>G</strong>ate）、<strong>发射极</strong>（<strong>E</strong>mitter）三个引脚，接下来以目前<strong>比较主流的N 沟道型 IGBT</strong> 为例展开介绍。这里可以将内部结构为下图左侧的<strong>N 沟道型 IGBT</strong>，等效为下图右侧那样由 <strong>PNP型三极管</strong> 与 <strong>增强型 NMOS 管</strong>组合而成的电路：</p><p><img src="/Electronics/Component/10-IGBT/2.png"></p><p>在下面的 N 沟道型 IGBT 偏置电路里，<strong>电源</strong> <span class="math inline">\(E_2\)</span> 通过<strong>开关</strong> <span class="math inline">\(S\)</span> 为 <strong>IGBT</strong> 提供 <span class="math inline">\(U_{GE}\)</span> 电压，<strong>电源</strong> <span class="math inline">\(E_1\)</span> 经过 <span class="math inline">\(R_1\)</span> 为 <strong>IGBT</strong> 提供 <span class="math inline">\(U_{CE}\)</span> 电压：</p><p><img src="/Electronics/Component/10-IGBT/3.png"></p><ul><li>当<strong>开关</strong> <span class="math inline">\(S\)</span>闭合的时候，如果 <strong>IGBT</strong> 的 <strong>G 极</strong>与<strong>E 极</strong>之间的<strong>电压</strong> <span class="math inline">\(U_{GE}\)</span>大于<strong>开启电压</strong>，那么 <strong>IGBT</strong> 内部的<strong>NMOS</strong> 管就会形成<strong>导电沟道</strong>，使得<strong>NMOS</strong> 管的 <strong>D 极</strong>与 <strong>S极</strong>导通，从而为三极管的<strong>基极电流</strong> <span class="math inline">\(I_B\)</span>提供通路，进而导通三极管，<strong>电流</strong> <span class="math inline">\(I_C\)</span> 开始从 <strong>IGBT</strong> 的<strong>C 极</strong>流入，经过三极管的 <strong>E 极</strong>之后分为<span class="math inline">\(I_1\)</span>（通过 NMOS 管的 <strong>D极</strong>与 <strong>S 极</strong>）和 <span class="math inline">\(I_2\)</span>（从三极管的 <strong>C极</strong>流出）两路电流。这两路<strong>电流</strong> <span class="math inline">\(I_1\)</span> 和 <span class="math inline">\(I_2\)</span> 汇合之后形成 <span class="math inline">\(I_E\)</span>（从 <strong>IGBT</strong> 的<strong>E 极</strong>流出），此时 IGBT就处于<strong>导通状态</strong>。</li><li>当<strong>开关</strong> <span class="math inline">\(S\)</span>断开的时候，<strong>IGBT</strong> 的 <strong>G 极</strong>与 <strong>E极</strong>之间的<strong>电压</strong> <span class="math inline">\(U_{GE} = 0V\)</span>，此时 NMOS管的导电沟道<strong>夹断</strong>消失，<strong>电流</strong> <span class="math inline">\(I_1\)</span> 和 <span class="math inline">\(I_2\)</span> 都为<code>0A</code>，<strong>电流</strong> <span class="math inline">\(I_C\)</span> 和 <span class="math inline">\(I_E\)</span> 也等于 <code>0A</code>，此时<strong>IGBT</strong> 就会处于<strong>截止状态</strong>。</li><li>通过<strong>电源</strong> <span class="math inline">\(E_2\)</span>调节<strong>电压</strong> <span class="math inline">\(U_{GE}\)</span>的大小，就可以改变 <strong>IGBT</strong> 内部 <strong>NMOS</strong>管导电沟道的宽度，使得<strong>电流</strong> <span class="math inline">\(I_1\)</span> 发生变化。此时 <span class="math inline">\(I_1\)</span>（即三极管的<strong>基极电流</strong><span class="math inline">\(I_B\)</span>）的微小变化，就会引发 <span class="math inline">\(I_2\)</span>（即三极管的<strong>集电极电流</strong><span class="math inline">\(I_C\)</span>）的大幅度变化。例如当<strong>电压</strong><span class="math inline">\(U_{GE}\)</span>增大的时候，<strong>NMOS</strong>管的导电沟道将会变宽，<strong>电流</strong> <span class="math inline">\(I_1\)</span> 和 <span class="math inline">\(I_2\)</span> 都会增大，从 <strong>IGBT</strong> 的<strong>C 极</strong>流入 <strong>E极</strong>流出的电流也<strong>随之增大</strong>。</li></ul><p><img src="/Electronics/Component/10-IGBT/4.png"></p><blockquote><p><strong>注意</strong>：上图右侧的三款元器件被称作<strong>功率型 IGBT模块</strong>，通常运用在一些<strong>大电流高电压</strong>的场景，主要由IGBT 和续流二极管通过特定的电路<strong>桥接封装</strong>而成。</p></blockquote><h1 id="碳化硅功率器件-sic">碳化硅功率器件 SiC</h1><p><strong>碳化硅</strong>（SiC，Silicon Carbide）是由硅 <code>Si</code>和碳 <code>C</code>共同构成的化合物半导体材料，可以通过向碳化硅材料当中掺入<code>氮</code>或<code>磷</code>来形成N型半导体，或者向碳化硅材料当中掺入<code>铍</code>、<code>硼</code>、<code>铝</code>、<code>镓</code>来形成P 型半导体。其在 <code>禁带宽度</code>（3倍）、<code>击穿电场强度</code>（10倍以上）、<code>饱和电子漂移速率</code>、<code>热传导率</code>（3倍）方面远远优于传统硅基半导体材料。目前使用碳化硅材料生产的元器件主要有<strong>SBD</strong> 肖特基势垒二极管和 <strong>MOSFET</strong>金属氧化物场效应管。</p><p><img src="/Electronics/Component/11-SiC/1.png"></p><h2 id="碳化硅二极管-sic-sbd">碳化硅二极管 SiC-SBD</h2><p>由碳化硅材料制作的<strong>肖特基势垒二极管</strong>（SBD）不仅具备出色的高速开关性能，还实现了更高的<strong>耐压值</strong>，而与高耐压型的硅基<strong>快速恢复二极管</strong>相比，其<strong>反向恢复时间</strong>更快，可以实现更低的损耗与小型化：</p><p><img src="/Electronics/Component/11-SiC/2.png"></p><h2 id="碳化硅场效应管-sic-mosfet">碳化硅场效应管 SiC-MOSFET</h2><p>使用<strong>碳化硅</strong>作为衬底材料的<strong>金属氧化物场效应管</strong>（MOSFET）耐压值可以高达<code>1000V</code> 以上，相比传统 IGBT其<strong>工作频率</strong>更高，从而有效降低了开关损耗。而相对于同等<strong>耐压值</strong>的硅基MOSFET，其<strong>导通电阻</strong>更小，在同等导通电阻条件下可以有效减小元器件的体积，并且显著的降低恢复损耗：</p><p><img src="/Electronics/Component/11-SiC/3.png"></p><h1 id="半导体元器件总结">半导体元器件总结</h1><table><colgroup><col style="width: 9%"><col style="width: 4%"><col style="width: 85%"></colgroup><thead><tr class="header"><th>BJT 与 MOSFET 比较</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>三极管</strong></td><td><strong>BJT</strong></td><td>电流控制型元件，通过<strong>基极</strong>流向<strong>发射极</strong>的电流<span class="math inline">\(I_{BE}\)</span>来控制<strong>集电极</strong>与<strong>发射极</strong>之间通过<strong>电流</strong><span class="math inline">\(I_{CE}\)</span> 的大小。</td></tr><tr class="even"><td><strong>金属氧化物场效应管</strong></td><td><strong>MOSFET</strong></td><td>电压控制型元件，通过<strong>栅级</strong>与<strong>源极</strong>之间的<strong>电压</strong><span class="math inline">\(V_{GS}\)</span>来控制<strong>漏极</strong>与<strong>源极</strong>之间的<strong>电阻</strong><span class="math inline">\(R_{DS}\)</span>，从而实现对<strong>漏极</strong>与<strong>源极</strong>之间<strong>电压</strong><span class="math inline">\(V_{DS} = \frac{I_{DS}}{R_{DS}}\)</span>的控制。</td></tr></tbody></table><table><colgroup><col style="width: 17%"><col style="width: 7%"><col style="width: 75%"></colgroup><thead><tr class="header"><th>功率型半导体元器件比较</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><strong>金属氧化物场效应管</strong></td><td><strong>MOSFET</strong></td><td>大电流，低耐压，开关频率极高（可以高达数十<code>兆赫兹</code>），即有功率型器件，也有高频小信号器件。</td></tr><tr class="even"><td><strong>可控硅</strong></td><td><strong>SCR</strong></td><td>大功率器件，频率极低（仅数<code>千赫兹</code>），只能控制开，不能控制关，但是抗过载能力极强。</td></tr><tr class="odd"><td><strong>绝缘栅双极晶体管</strong></td><td><strong>IGBT</strong></td><td>大功率器件，频率较低（几十至几百<code>千赫兹</code>），可以控制开和关，成本比可控硅略高，逐渐在替代可控硅。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>三极管</strong>可以理解为使用<code>二极管</code>控制另外一个<code>二极管</code>，而<strong>场效应管</strong>可以理解为用<code>电容</code>控制<code>电阻</code>，<strong>IGBT</strong>则是使用<code>电容</code>控制<code>二极管</code>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从 &lt;strong&gt;1883&lt;/strong&gt;
年电子管作为人类第一个电子元器件诞生以来，&lt;strong&gt;电子元器件&lt;/strong&gt;的发展历程，见证了人类科技进步的辉煌成就。从最初的
&lt;code&gt;电阻&lt;/code&gt;、&lt;code&gt;电容&lt;/code&gt;、&lt;code&gt;电感&lt;/code&gt;
等基础元器件，发展到
&lt;code&gt;晶闸管&lt;/code&gt;、&lt;code&gt;场效应管&lt;/code&gt;、&lt;code&gt;IGBT&lt;/code&gt;
等半导体元器件，再进一步发展到现如今各种琳琅满目的&lt;strong&gt;微处理器&lt;/strong&gt;、&lt;strong&gt;微控制器&lt;/strong&gt;、&lt;strong&gt;传感器&lt;/strong&gt;。电子元器件的功能越来越强大，体积越来越小，集成度越来越高。这些变化不仅极大地提升了电子产品的性能和可靠性，也为我们带来了更加便捷与智能的生活方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/Component/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;电子元器件如同电子设备的细胞，承载着实现各种复杂功能的基础任务，它们是电路设计和调试中不可或缺的元素。实际的电路设计过程当中，各类电子元器件的选择、连接、调试都至关重要，正确的选型能够确保设备的性能和稳定性，而合理的连接方式更是能够降低信号的损失与干扰。本文旨在以简单明了的方式介绍
&lt;code&gt;电阻器&lt;/code&gt;、&lt;code&gt;电容器&lt;/code&gt;、&lt;code&gt;电感器&lt;/code&gt;、&lt;code&gt;变压器&lt;/code&gt;、&lt;code&gt;二极管&lt;/code&gt;、&lt;code&gt;三极管&lt;/code&gt;、&lt;code&gt;晶闸管&lt;/code&gt;、&lt;code&gt;场效应管&lt;/code&gt;、&lt;code&gt;IGBT&lt;/code&gt;
等常用分立式电子元器件的参数与选型注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="Component" scheme="http://www.uinio.com/tags/Component/"/>
    
  </entry>
  
  <entry>
    <title>兆易创新 UINIO-MCU-GD32F350 固件库开发指南</title>
    <link href="http://www.uinio.com/Project/UINIO-MCU-GD32/"/>
    <id>http://www.uinio.com/Project/UINIO-MCU-GD32/</id>
    <published>2024-03-17T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.393Z</updated>
    
    <content type="html"><![CDATA[<p>早在新冠疫情爆发前的 <strong>2019</strong> 年，就曾经撰写过一篇关于<strong>ARM</strong> 标准库的技术长文 <a href="http://uinio.com/Embedded/STM32F103/"><strong>《意法半导体STM32F103 标准库典型实例》</strong></a>，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于<a href="https://www.gigadevice.com.cn/product/mcu"><strong>兆易创新</strong></a>推出的国产 ARM 微控制器，设计和制作了 <a href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>这款开源核心板，同时撰写了本篇文章作为配套的资料教程，希冀为国产芯片的商业化普及尽自己一份绵薄之力。</p><p><img src="/Project/UINIO-MCU-GD32/logo.png"></p><p><a href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>是一款采用 LQFP64 封装的 <strong>GD32F350RBT6</strong>微控制器核心板，基于 <strong>ARM Cortex-M4</strong> 内核架构，主频高达<code>108MHz</code>，拥有 <code>128K</code> 容量 Flash，以及<code>16K</code> 的 SRAM。而 <a href="https://github.com/uinika/UINIO-MCU-GD32F103C"><strong>UINIO-MCU-GD32F103C</strong></a>采用 LQFP48 封装的 <strong>GD32F103Cxxx</strong> 系列微控制器（包括<code>GD32F103CBT6</code>、<code>GD32F103C8T6</code>、<code>GD32F103C6T6</code>、<code>GD32F103C4T6</code>），基于<strong>ARM Cortex-M3</strong> 内核架构，主频达到<code>108MHz</code>，拥有 <code>16K ~ 128K</code> 容量 Flash，以及<code>6K ~ 20K</code> 的 SRAM。</p><span id="more"></span><h1 id="准备-gd32-支持包-固件库">准备 GD32 支持包 &amp; 固件库</h1><p>这里以 <strong>UINIO-MCU-GD32F350RBT6</strong>核心板作为例子，首先需要前往兆易创新的 <a href="https://www.gd32mcu.com/cn/download/7?kw=GD32F3x0"><strong>GD32MCU 微控制器</strong></a>官方网站，把如下两个开发资源下载到本地计算机：</p><ol type="1"><li><strong>GD32F350RBT6</strong> 固件库<code>GD32F3x0_Firmware_Library_V2.2.1</code>。</li><li><strong>Keil uVision5</strong> 开发环境的支持包<code>GigaDevice.GD32F3x0_DFP.3.0.2.pack</code>。</li></ol><p>然后，启动 <strong>Keil uVision5</strong>开发环境，开始导入或者在线安装<code>GigaDevice.GD32F3x0_DFP.3.0.2.pack</code> 支持包：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/0.png"></p><p>接下来，解压 <code>GD32F3x0_Firmware_Library_V2.2.1</code>固件库，此时会得到如下一系列目录：</p><ul><li><strong>Docs</strong>：包含有官方评估板的<strong>原理图</strong>和固件库的<strong>使用指南</strong>。</li><li><strong>Examples</strong>：各种 <strong>GD32F350RBT6</strong>片上外设的官方示例源程序。</li><li><strong>Firmware</strong>：包含有<strong>内核库</strong><code>CMSIS</code>、<strong>标准外设库</strong><code>GD32F3x0_standard_peripheral</code>、<strong>USB文件系统库</strong> <code>GD32F3x0_usbfs_library</code>三个子目录。</li><li><strong>Template</strong>：集成开发环境 <strong>IAR</strong> 和<strong>Keil uVision4</strong> 的工程模板，包含有 LED 闪烁、USART打印、按键控制的简单示例程序。</li><li><strong>Utilities</strong>：一些第三方组件和 GD32配套的评估板测试文件。</li></ul><p>其中 <strong>Examples</strong>下面的每一个子目录，都对应着一种片上外设的示例程序，里面通常会包含有如下的源文件：</p><ul><li><code>main.c</code>：主程序源文件。</li><li><code>systick.h</code>：SysTick 精准延时头文件；</li><li><code>systick.c</code>：SysTick 精准延时源文件；</li><li><code>GD32f3x0.it.h</code>：中断处理程序头文件；</li><li><code>GD32f3x0_it.c</code>：中断处理程序源文件（未使用中断，所有函数体为空）；</li><li><code>GD32f3x0_libopt.h</code>：通过预处理语句 <code>#include</code>包含指定的外设库 <code>.h</code> 头文件（默认导入全部外设）；</li></ul><p>而 <strong>Firmware</strong> 目录下面包含有<strong>GD32F350RBT6</strong> 固件库的核心源文件：</p><ul><li><code>CMSIS</code> 子目录包含有 <strong>ARM Cortex-M4</strong>内核的支持文件、启动代码、库引导文件，以及 <code>GD32F3x0</code>的全局头文件和系统配置文件。</li><li><code>GD32F3x0_standard_peripheral</code> 子目录下的<code>Include</code> 包含了固件库所需要的头文件，而 <code>Source</code>则包含有固件库所需的源文件。</li></ul><h1 id="测试-uinio-mcu-gd32-核心板">测试 UINIO-MCU-GD32 核心板</h1><p>打开 <code>GD32F3x0_Firmware_Library_V2.2.1</code> 固件库下面的<code>Template</code> 目录，删掉除开 <code>Keil_project</code>目录之外的其它文件与目录，然后将 <code>Examples\GPIO\Running_led</code>内的全部源文件，拷贝至 <code>Template</code>目录当中，从而获得如下的文件目录结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Template</span><br><span class="line">├── Keil_project</span><br><span class="line">│   ├── Project.uvopt</span><br><span class="line">│   └── Project.uvproj</span><br><span class="line">├── gd32f3x0_it.c</span><br><span class="line">├── gd32f3x0_it.h</span><br><span class="line">├── gd32f3x0_libopt.h</span><br><span class="line">├── main.c</span><br><span class="line">├── readme.txt</span><br><span class="line">├── systick.c</span><br><span class="line">└── systick.h</span><br></pre></td></tr></table></figure><p>鼠标双击 <code>Template</code> 目录下面的工程描述文件<code>Project.uvproj</code>，启动 <strong>Keil uVision5</strong>。由于<code>GD32F3x0_Firmware_Library_V2.2.1</code> 当中的示例工程采用的是<strong>Keil uVision4</strong>建立和编译，因而此时会弹出下面的错误信息：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/1.png"></p><p>按下【确定】按钮忽略这些错误信息，依次选择顶部菜单栏上面的【Project-&gt; Manage -&gt; Migrate to Version 5 Format...】，把工程迁移成为<strong>Keil uVision5</strong> 兼容的格式：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/2.png"></p><p>此时会提示工程描述文件需要从 <strong>Keil uVision4</strong> 的<code>Project.uvproj</code> 保存为 <strong>Keil uVision5</strong> 的<code>Project.uvprojx</code>，直接按下【确定】按钮即可：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/3.png"></p><p>在开始接下来的操作之前，需要先将 <strong>Keil uVision5</strong>工程的编译目标切换为 <strong>UINIO-MCU-GD32F350RBT6</strong>核心板所使用的型号【GD32F350】：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/4.png"></p><p>点击顶部工具栏上的【Options forTarget...】按钮，指定<strong>目标选项对话框</strong>里的【ARMCompiler】版本为 <code>compiler version 5</code>：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/5.png"></p><blockquote><p><strong>注意</strong>：这里必须修改 <strong>Keil uVision5</strong>当中 ARM 编译器版本，否则会导致后续的编译操作出现错误，具体请参考 <a href="http://uinio.com/Project/UINIO-DAP-Link">《ARM 调试工具UINIO-DAP-Link 应用详解》</a> 一文的 <a href="http://uinio.com/Project/UINIO-DAP-Link/#%E6%B7%BB%E5%8A%A0-arm-compiler-version-5">添加ARM Compiler version 5</a> 小节内容。</p></blockquote><p>切换至对话框的【Output】选项卡，在勾选【Create HEXFile】的同时，把【Name of Executable】修改为<code>Project.hex</code>（务必添加 <code>.hex</code>后缀，否则默认烧录的是 <code>.axf</code> 文件）：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/6.png"></p><p>再切换至对话框当中的【Debug】选项卡，此时需要将 <a href="http://uinio.com/Project/UINIO-DAP-Link/"><strong>UINIO-DAP-Link</strong></a>插入至计算机的 USB 接口，然后在下拉选择【CMSIS-DAPDebugger】之后，再按下右侧的【Settings】按钮：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/7.png"></p><p>此时会弹出<strong>调试器设置对话框</strong>，这里我们选择【UINIO-CMSIS-DAP】，并且将【MaxClock】配置为 <code>10MHz</code>：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/8.png"></p><p>最后再切换至【Flash Download】选项卡，勾选【Reset andRun】，并且点击【Add】按钮添加片上 Flash 的编程算法：</p><p><img src="/Project/UINIO-MCU-GD32/1-Keil/9.png"></p><p>完成上述配置步骤之后点击【OK】，回到 <strong>Keil uVision5</strong>的主界面，此时按下快捷键【F7】或者顶部工具栏上的【Build】按钮编译示例工程，再按下快捷键【F8】或者【Download】按钮将编译后得到的<code>.hex</code> 程序下载至 <strong>UINIO-MCU-GD32F350RBT6</strong>核心板运行，此时整个工程的目录文件结构如下所示，其中的 <code>Out</code>目录保存着编译后产生的十六进制 <code>.hex</code> 文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Template</span><br><span class="line">├── Keil_project</span><br><span class="line">│   ├── Project.uvguix.hank</span><br><span class="line">│   ├── Project.uvopt</span><br><span class="line">│   ├── Project.uvoptx</span><br><span class="line">│   ├── Project.uvproj.saved_uv4</span><br><span class="line">│   ├── Project.uvprojx</span><br><span class="line">│   ├── RTE</span><br><span class="line">│   │   ├── _GD32F310</span><br><span class="line">│   │   │   └── RTE_Components.h</span><br><span class="line">│   │   ├── _GD32F330</span><br><span class="line">│   │   │   └── RTE_Components.h</span><br><span class="line">│   │   └── _GD32F350</span><br><span class="line">│   │       └── RTE_Components.h</span><br><span class="line">│   ├── list</span><br><span class="line">│   │   ├── Project.map</span><br><span class="line">│   │   └── startup_gd32f3x<span class="number">0.l</span>st</span><br><span class="line">│   └── output</span><br><span class="line">├── gd32f3x0_it.c</span><br><span class="line">├── gd32f3x0_it.h</span><br><span class="line">├── gd32f3x0_libopt.h</span><br><span class="line">├── main.c</span><br><span class="line">├── readme.txt</span><br><span class="line">├── systick.c</span><br><span class="line">└── systick.h</span><br></pre></td></tr></table></figure><p>该示例程序会每间隔 4 秒的时间，循环切换<strong>UINIO-MCU-GD32F350RBT6</strong> 的四个 GPIO 引脚<code>C2</code>、<code>C10</code>、<code>C11</code>、<code>C12</code>的高低电平状态，此时通过万用表就可以测量出运行结果，从而方便的判断出程序是否下载成功，以及核心板运行是否存在有故障。</p><blockquote><p><strong>注意</strong>：<strong>DAPLink</strong> 是 ARM系列微控制器开发过程当中，程序下载与调试不可少的工具，相关资料和设计资源可以参考笔者之前撰写的<a href="http://uinio.com/Project/UINIO-DAP-Link/">《ARM 调试工具UINIO-DAP-Link 应用详解》</a> 一文。</p></blockquote><h1 id="搭建-keil-uvision5-自定义工程">搭建 Keil uVision5自定义工程</h1><h2 id="新建目录与拷贝源文件">新建目录与拷贝源文件</h2><p>本节内容开始尝试自己动手搭建 <strong>Keil uVision5</strong>工程，首先新建一个名称为 <code>Keil-GD32F350RBT6</code> 的 <strong>KeiluVision5</strong>工程，并将其保存至同名的目录下面，然后再新建如下一系列子目录，并且将固件库里的源文件拷贝至对应的子目录：</p><ul><li><strong>Applications</strong>：保存应用层相关的源文件。</li><li><strong>Documents</strong>：用于存放 Markdown说明文档，可以预先放置一个 <code>README.md</code> 文件。</li><li><strong>Drivers</strong>：存放针对<strong>UINIO-MCU-GD32F350RBT6</strong> 定制的板级驱动程序。</li><li><strong>Firmware</strong>：用于放置<code>GD32F3x0_Firmware_Library_V2.2.1</code> 当中 <code>Firmware</code>目录下的全部内容（即<code>CMSIS</code>、<code>GD32F3x0_standard_peripheral</code>、<code>GD32F3x0_usbfs_library</code>三个子目录）。</li><li><strong>Sources</strong>：用于保存<code>GD32F3x0_Firmware_Library_V2.2.1</code> 下面的<code>Template</code> 目录当中，除<code>IAR_project</code>、<code>Keil_project</code>、<code>readme.txt</code>之外的文件（即<code>main.c/h</code>、<code>systick.c/h</code>、<code>gd32f3x0_it.c/h</code>、<code>gd32f3x0_libopt.h</code>七个源文件）。</li></ul><h2 id="创建分组与添加源文件">创建分组与添加源文件</h2><p>鼠标点击 <strong>Keil uVision5</strong> 顶部菜单栏上面的【FileExtensions, Books and Environment...】按钮：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/0.png"></p><p>在弹出的<strong>工程管理项</strong>对话框当中，分别将左侧的【ProjectTargets】命名为<code>Keil-GD32F350RBT6</code>，而中间的【Groups】则分别建立如下几个分组，并且通过右侧的<code>Files</code> 向指定分组添加相应的源文件：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/1.png"></p><ul><li><strong>CMSIS 分组</strong>：分别添加<code>Keil-GD32F350RBT6\Firmware\CMSIS\GD\GD32F3x0\Source</code>目录下的 <code>system_gd32f3x0.c</code> 外设接入层源文件，以及<code>Keil-GD32F350RBT6\Firmware\CMSIS\GD\GD32F3x0\Source\ARM</code>目录下的 <code>startup_gd32f3x0.s</code>启动文件（添加对话框的文件类型要修改为 <code>.s</code>）。</li><li><strong>Drivers 分组</strong>：暂时不需要添加任何源文件。</li><li><strong>Firmware 分组</strong>：按需添加<code>Keil-GD32F350RBT6\Firmware\GD32F3x0_standard_peripheral\Source</code>目录下的 <code>.c</code> 源文件（其中的 <code>gd32f3x0_rcu.c</code> 和<code>gd32f3x0_gpio.c</code> 属于必须添加）。</li><li><strong>Documents 分组</strong>：将<code>Keil-GD32F350RBT6\Documents</code> 目录下新建的<code>README.md</code> 文件添加进去。</li><li><strong>Applications</strong> 分组：添加<code>Keil-GD32F350RBT6\Sources</code> 目录下的<code>main.c</code>、<code>systick.c</code>、<code>gd32f3x0_it.c</code>三个源文件。</li><li><strong>Sources 分组</strong>：暂时不需要添加任何源文件。</li></ul><p>完成上述操作之后，在<strong>工程管理项</strong>对话框当中，各个分组下面的源文件情况如下图所示：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/2.png"></p><p>点击【OK】按钮关闭<strong>工程管理项</strong>对话框，此时<strong>Keil uVision5</strong> 左侧呈现的工程目录结构如下面所示：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/3.png"></p><h2 id="移除-source-目录下的冗余代码">移除 Source 目录下的冗余代码</h2><p>为了避免工程搭建过程当中，直接拷贝官方固件库 <code>Template</code>目录下的源文件，出现冗余代码导致编译错误的情况，接下来还需要对<code>Source</code> 目录进行一些清理工作。首先需要删除掉该目录下<code>main.c</code> 源文件里多余的内容，只需要保留如下所示的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* configure systick */</span></span><br><span class="line">    <span class="built_in">systick_config</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还需要再移除掉 <code>Source</code> 目录下<code>gd32f3x0_it.c</code> 源文件里面，如下所示的无效代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      this function handles SysTick exception</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">led_spark</span>();</span><br><span class="line">    <span class="built_in">delay_decrement</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置编译器路径与选项">配置编译器路径与选项</h2><p>点击 <strong>Keil uVision5</strong> 工具栏顶部的【Options fortarget】，在弹出的<strong>目标选项对话框</strong>当中，首先切换至【C/C++】选项卡，将【Define】输入框设置为<code>USE_STDPERIPH_DRIVER,GD32F3X0,GD32F350</code>：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/4.png"></p><p>然后再点击对话框当中【Include Paths】输入框右侧的按钮，配置 ARM编译器分别包含 <strong>Keil-GD32F350RBT6</strong>工程目录下的如下路径：</p><ul><li><code>.\Sources</code></li><li><code>.\Firmware\CMSIS</code></li><li><code>.\Firmware\CMSIS\GD\GD32F3x0\Include</code></li><li><code>.\Firmware\GD32F3x0_standard_peripheral\Include</code></li></ul><p><img src="/Project/UINIO-MCU-GD32/2-Project/5.png"></p><p>接下来切换至【Target】选项卡，选择 ARM 编译器的版本为<strong>5</strong>，并勾选界面上 <strong>Keil uVision5</strong>自带的用于串口重定向的【Use MicroLIB】工具库：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/6.png"></p><p>最后切换到【Output】选项卡，将【Name of Executable】输入框设置为<code>Keil-GD32F350RBT6.hex</code>，并且勾选 <strong>Create HEXFile</strong> 使得编译结果为十六进制 <code>.hex</code> 格式：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/7.png"></p><h2 id="测试工程的编译下载">测试工程的编译下载</h2><p>完成上述配置工作之后，关闭 <strong>Keil uVision5</strong>界面上的全部对话框，然后按下快捷键【F7】或者顶部工具栏上的【Build】按钮，将新建工程里的相关源文件编译为一个<code>Keil-GD32F350RBT6.hex</code> 文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Build started: Project: Keil-GD32F350RBT6</span><br><span class="line">*** Using Compiler &#x27;V5.<span class="number">06</span> update <span class="number">7</span> (build <span class="number">960</span>)&#x27;, folder: &#x27;D:\Software\Tech\Keil\ARM\ARMCC\Bin&#x27;</span><br><span class="line">Build target &#x27;Keil-GD32F350RBT6&#x27;</span><br><span class="line">assembling startup_gd32f3x0.s...</span><br><span class="line">compiling gd32f3x0_dma.c...</span><br><span class="line">compiling gd32f3x0_dbg.c...</span><br><span class="line">compiling gd32f3x0_crc.c...</span><br><span class="line">compiling gd32f3x0_ctc.c...</span><br><span class="line">compiling gd32f3x0_cec.c...</span><br><span class="line">compiling gd32f3x0_dac.c...</span><br><span class="line">compiling gd32f3x0_exti.c...</span><br><span class="line">compiling gd32f3x0_adc.c...</span><br><span class="line">compiling gd32f3x0_cmp.c...</span><br><span class="line">compiling system_gd32f3x0.c...</span><br><span class="line">compiling gd32f3x0_fmc.c...</span><br><span class="line">compiling gd32f3x0_fwdgt.c...</span><br><span class="line">compiling gd32f3x0_i2c.c...</span><br><span class="line">compiling gd32f3x0_misc.c...</span><br><span class="line">compiling gd32f3x0_gpio.c...</span><br><span class="line">compiling gd32f3x0_pmu.c...</span><br><span class="line">compiling gd32f3x0_spi.c...</span><br><span class="line">compiling gd32f3x0_syscfg.c...</span><br><span class="line">compiling gd32f3x0_rcu.c...</span><br><span class="line">compiling gd32f3x0_rtc.c...</span><br><span class="line">compiling gd32f3x0_tsi.c...</span><br><span class="line">compiling gd32f3x0_timer.c...</span><br><span class="line">compiling gd32f3x0_wwdgt.c...</span><br><span class="line">compiling gd32f3x0_usart.c...</span><br><span class="line">compiling gd32f3x0_it.c...</span><br><span class="line">compiling main.c...</span><br><span class="line">compiling systick.c...</span><br><span class="line">linking...</span><br><span class="line">Program Size: Code=<span class="number">1104</span> RO-data=<span class="number">368</span> RW-data=<span class="number">4</span> ZI-data=<span class="number">1028</span></span><br><span class="line"><span class="function">FromELF: <span class="title">creating</span> <span class="title">hex</span> <span class="title">file</span>...</span></span><br><span class="line"><span class="function">&quot;.\<span class="title">Objects</span>\<span class="title">Keil</span>-<span class="title">GD32F350RBT6.hex</span>&quot; - 0 <span class="title">Error</span>(<span class="title">s</span>), 0 <span class="title">Warning</span>(<span class="title">s</span>).</span></span><br><span class="line"><span class="function"><span class="title">Build</span> <span class="title">Time</span> <span class="title">Elapsed</span>:  00:00:03</span></span><br></pre></td></tr></table></figure><p>如果编译结果显示 <code>0 Error(s), 0 Warning(s)</code>，说明这个<strong>Keil uVision5</strong>工程已经搭建成功。接下来，就可以按下快捷键【F8】或者顶部工具栏上的【Download】按钮，把编译后得到的十六进制文件<code>Keil-GD32F350RBT6.hex</code>，通过 <strong>UINIO-DAP-Link</strong>下载至 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板上面运行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Load &quot;D:\\Workspace\\UINIO-MCU-GD32F350RBT6\\Keil-GD32F350RBT6\\Objects\\Keil-GD32F350RBT6.hex&quot;</span><br><span class="line"><span class="built_in">Erase</span> Done.</span><br><span class="line">Programming Done.</span><br><span class="line"><span class="built_in">Verify</span> OK.</span><br><span class="line">Flash Load finished <span class="built_in">at</span> <span class="number">18</span>:<span class="number">22</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：为了大家能够方便快速的搭建测试项目，该自定义工程已被保存到开源硬件项目<a href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>的 <code>Keil-GD32F350RBT6</code> 目录里面。</p></blockquote><h2 id="让-keil-uvision5-支持中文注释">让 Keil uVision5支持中文注释</h2><p>鼠标依次选择 <strong>Keil uVision5</strong> 菜单栏上的 【Edit -&gt;Configration... -&gt; 】，将弹出窗口【Editor】选项卡下的<code>Encoding</code> 选择为 <code>Chinese GB2312 (Simplified)</code>就可以支持中文注释：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/8.png"></p><blockquote><p><strong>注意</strong>：这种方式会导致 Keil uVision显示的源代码字体非常不美观，更佳的处理办法是利用<strong>Sublime</strong> 等文本编辑器提供的 <a href="https://github.com/seanliang/ConvertToUTF8">ConvertToUTF8</a>插件，将源代码文件全部转换为 <strong>UTF-8</strong> 格式的编码。</p></blockquote><h2 id="使用-astyle-格式化源代码">使用 AStyle 格式化源代码</h2><p><a href="https://astyle.sourceforge.net/">AStyle</a> 是一款用于对C/C++ 源代码进行格式化的开源插件，鼠标点击 <strong>KeiluVision5</strong> 菜单栏上的【Tools -&gt; Customize Tools Menu】：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/9.png"></p><p>在弹出的对话框当中进行如下的设置，其中的 <strong>Command</strong>就是 <code>astyle.exe</code> 可执行文件所在的路径：</p><ul><li><strong>Command</strong>:<code>D:\Software\Tech\AStyle\astyle.exe</code></li><li><strong>AStyleAll</strong>：<code>"$E*.c" "$E*.h" --style=google --indent=spaces=2</code>。</li><li><strong>AStyleFile</strong>：<code>!E --style=google --indent=spaces=2</code>。</li></ul><p>完成上述步骤之后，就可以在 <strong>Keil uVision5</strong>的菜单栏上发现【Tools -&gt; AStyle All】和【Tools -&gt; AStyleFile】两条自定义菜单项：</p><p><img src="/Project/UINIO-MCU-GD32/2-Project/10.png"></p><h1 id="mcu-微控制器系统结构概览">MCU 微控制器系统结构概览</h1><h2 id="芯片资源简介">芯片资源简介</h2><p><strong>GD32F350RBT6</strong> 是一款采用 Arm Cortex-M4 内核架构的 32位微控制器，工作频率为 <code>108MHz</code>，工作电压范围在<code>2.6V ~ 3.6V</code> 之间，工作温度介于 <code>-40°C ~ +85°C</code>范围。提供高达 <code>128KB</code> 的片上 <strong>Flash</strong> 闪存和<code>16KB</code> 的 <strong>SRAM</strong>内存，其它的片上资源情况可以参考下面表格：</p><table><thead><tr class="header"><th style="text-align: left;">资源名称</th><th style="text-align: left;">数量</th><th style="text-align: left;">资源名称</th><th style="text-align: left;">数量</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>12 位 ADC</strong></td><td style="text-align: left;">1 个</td><td style="text-align: left;"><strong>SPI</strong></td><td style="text-align: left;">2 个</td></tr><tr class="even"><td style="text-align: left;"><strong>12 位 DAC</strong></td><td style="text-align: left;">1 个</td><td style="text-align: left;"><strong>I2C</strong></td><td style="text-align: left;">2 个</td></tr><tr class="odd"><td style="text-align: left;"><strong>通用比较器 CMP</strong></td><td style="text-align: left;">2 个</td><td style="text-align: left;"><strong>USART</strong></td><td style="text-align: left;">2 个</td></tr><tr class="even"><td style="text-align: left;"><strong>通用 16 位定时器</strong></td><td style="text-align: left;">5 个</td><td style="text-align: left;"><strong>I2S</strong></td><td style="text-align: left;">1 个</td></tr><tr class="odd"><td style="text-align: left;"><strong>通用 32 位定时器</strong></td><td style="text-align: left;">1 个</td><td style="text-align: left;"><strong>HDMI-CEC</strong></td><td style="text-align: left;">1 个</td></tr><tr class="even"><td style="text-align: left;"><strong>基本定时器</strong></td><td style="text-align: left;">1 个</td><td style="text-align: left;"><strong>TSI</strong></td><td style="text-align: left;">1 个</td></tr><tr class="odd"><td style="text-align: left;"><strong>PWM 高级定时器</strong></td><td style="text-align: left;">1 个</td><td style="text-align: left;"><strong>USBFS 全速 USB</strong></td><td style="text-align: left;">1 个</td></tr></tbody></table><p><strong>UINIO-MCU-GD32F350RBT6</strong> 采用的<strong>GD32F350RBT6</strong> 微控制器使用的是 <code>LQFP64</code>封装形式，其具体 <strong>64</strong> 个引脚的功能分配可以参见下图：</p><p><img src="/Project/UINIO-MCU-GD32/3-ARM/0.png"></p><h2 id="arm-cortex-m4-内核架构">ARM Cortex-M4 内核架构</h2><p><strong>ARM Cortex-M4</strong> 系列微控制器基于<strong>ARMv7</strong> 架构，其内核主要由下面一系列的功能单元构成：</p><p><img src="/Project/UINIO-MCU-GD32/3-ARM/1.png"></p><ul><li><strong>嵌套式向量型中断控制器</strong>（<strong>NVIC</strong>，NestedVectored Interrupt Controller）。</li><li><strong>浮点运算单元</strong>（<strong>FPU</strong>，Floating PointUnit）。</li><li><strong>闪存地址重载及断点单元</strong>（<strong>FPB</strong>，FlashPatch Breakpoint）。</li><li><strong>串行线调试接口</strong>（<strong>SW-DP</strong>，Serial-WireDebug Port）。</li><li><strong>数据观测点及跟踪单元</strong>（<strong>DWT</strong>，DataWatchpoint And Trace）。</li><li><strong>指令跟踪宏单元</strong>（<strong>ITM</strong>，InstrumentationTrace Macrocell）。</li><li><strong>跟踪端口接口单元</strong>（<strong>TPIU</strong>，Trace PortInterface Unit）。</li><li><strong>内部总线矩阵</strong>（<strong>Bus Matrix</strong>，用于实现<strong>I-Code</strong> 指令总线、<strong>D-Code</strong>数据总线、<strong>System</strong> 系统总线、<strong>PPB</strong>专用总线、<strong>AHB-AP</strong> 调试专用总线的相互联接）。</li></ul><h2 id="gd32f350rbt6-外设架构">GD32F350RBT6 外设架构</h2><p><strong>GD32F350RBT6</strong>微控制器的整体系统架构如下面的框图所示，其中<strong>AHB</strong>（Advanced High performanceBus）高级高性能总线矩阵采用的是多层总线结构，支持多个主从设备之间实现并行通信，其中<strong>主设备</strong>包含有来自<strong>ARM Cortex-M4</strong> 内核架构的<code>I-Code 指令总线</code>、<code>D-Code 数据总线</code>、<code>System 系统总线</code>，以及来自于内核外部的<code>DMA 总线</code>：</p><ul><li><strong>I-Code 总线</strong>：即 Instruction Code，用于从<code>0x 0000 0000 ~ 0x 1FFF FFFF</code><strong>代码区域</strong>获取向量。</li><li><strong>D-Code 总线</strong>：即 DataCode，用于加载和存储数据，以及调试访问<strong>代码区域</strong>。</li><li><strong>System系统总线</strong>：用于获取指令和向量、加载与存储数据、调试访问<strong>系统区域</strong>（包括内部SRAM 和外设区域）。</li><li><strong>DMA总线</strong>：用于直接内存访问（<strong>DMA</strong>，Direct MemoryAccess）的传输总线。</li></ul><p><img src="/Project/UINIO-MCU-GD32/3-ARM/2.png"></p><p>除此之外，<strong>AHB总线矩阵</strong>的<strong>从设备</strong>包含有来自 Flash 存储控制器的<strong>IBUS</strong> 和 <strong>DBUS</strong> 总线、<strong>SRM控制器</strong>总线，以及 <strong>AHB1</strong> 和 <strong>AHB2</strong>总线：</p><ul><li><strong>AHB2</strong> 总线连接了<strong>A</strong>、<strong>B</strong>、<strong>C</strong>、<strong>D</strong>、<strong>F</strong>一共五组 GPIO 端口。</li><li><strong>AHB1</strong> 总线连接的是其它片上外设资源，其通过两组<strong>AHB-APB 总线桥</strong>（AHB to APB Bridge 1/2）分别提供了<strong>AHB1</strong>总线与<strong>高级外设总线</strong>（<strong>APB</strong>，AdvancedPeripheral Bus）之间的同步连接。</li></ul><h2 id="地址空间映射">地址空间映射</h2><p><strong>ARM Cortex M4</strong>内核采用了<strong>哈佛结构</strong>，使用相互独立的总线来读取<strong>指令</strong>和操作<strong>数据</strong>。这些指令和数据都存储在一个大小为<code>4GB</code> 的相同<strong>地址空间</strong>（因为 <strong>ARMCortex M4</strong> 的地址总线宽度为 <strong>32位</strong>，所以其对应的地址范围为 <code>2</code> 的 <code>32</code>次方等于<strong>4GB</strong>），但是处于不同的<strong>地址范围</strong>：</p><p><img src="/Project/UINIO-MCU-GD32/3-ARM/3.png"></p><p>观察上面的表格可以发现 <strong>GD32F350RBT6</strong> 的片上外设地址空间被划分为 <strong>AHB1</strong> 和<strong>AHB2</strong> 总线、<strong>APB1</strong> 和<strong>APB2</strong>总线共四个部分，这些总线的最低地址被称为<strong>总线基地址</strong>，也就是挂载在该总线上第1个外设的地址，而每个外设的最低地址则被称为<strong>外设基地址</strong>，每个外设的地址范围内都分布着该外设所对应的<strong>寄存器</strong>，通过<strong>操作这些寄存器就可以达到控制外设的目的</strong>。</p><h1 id="操作寄存器-运用固件库">操作寄存器 → 运用固件库</h1><h2 id="操作寄存器">操作寄存器</h2><p>如果需要将 <strong>AHB</strong> 总线上的 <strong>GPIOA</strong>外设对应的 16 个引脚全部置为<code>1</code>，那么就需要去配置<strong>端口输出控制寄存器</strong><code>GPIOx_OCTL</code>，通过查询用户手册可以知道其地址偏移量为<code>0x14</code>：</p><p><img src="/Project/UINIO-MCU-GD32/4-Register/1.png"></p><p>由于 <strong>GPIOA</strong> 的外设基地址为<code>0x4800 0000</code>，所以寄存器 <code>GPIOA_OCTL</code>的地址计算方式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x4800</span> <span class="number">0000</span> + <span class="number">0x0000</span> <span class="number">0014</span> = <span class="number">0x4800</span> <span class="number">0014</span></span><br></pre></td></tr></table></figure><p>换而言之，将寄存器 <code>OCTL(0~15)</code>相应的<strong>位</strong>设置为 <code>1</code>，就可以把对应的<code>GPIOA(0~15)</code> 控制为高电平。如果要让全部 16个引脚输出高电平，那么相应的 <code>GPIOA_OCTL</code> 寄存器的高 16位可以置为 <code>0</code> 而低 16 位置为 <code>1</code>，即<code>0000 0000 0000 0000 1111 1111 1111 1111</code>，转换为十六进制就是<code>0x0000FFFF</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x48000014</span>) = <span class="number">0x0000FFFF</span>;      <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure><p>像上面这样直接对寄存器地址进行操作会比较麻烦，下面可以通过宏定义<code>#define</code>，为每一个寄存器地址都分配一个名称：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL (unsigned int*)(0x48000014)  <span class="comment">// 将寄存器地址 0x48000014 定义为指针类型的 GPIOA_OCTL</span></span></span><br><span class="line">*GPIOA_OCTL = <span class="number">0x0000FFFF</span>;                       <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure><p>为了进一步简化代码，可以将指针类型 <code>*</code> 的声明合并到<code>GPIOA_OCTL</code> 的宏定义当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL *(unsigned int*)(0x48000014) <span class="comment">// 将寄存器地址 0x48000014 定义为 GPIOA_OCTL</span></span></span><br><span class="line">GPIOA_OCTL = <span class="number">0x0000FFFF</span>;                        <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure><h2 id="运用库函数">运用库函数</h2><p><strong>兆易创新</strong>官方固件库<code>GD32F3x0_Firmware_Library_V2.2.1</code>当中<strong>标准外设库</strong><code>Firmware\GD32F3x0_standard_peripheral</code> 目录下的<code>Include\gd32f3x0_gpio.h</code> 和<code>Source\gd32f3x0_gpio.c</code> 两个源文件，提供有一系列用于操作GPIO 的库函数：</p><p><img src="/Project/UINIO-MCU-GD32/4-Register/2.png"></p><p>其中的<code>void gpio_port_write(uint32_t gpio_periph, uint16_t data)</code>函数可以用于向特定的 GPIO 端口写入状态值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_port_write(GPIOB, <span class="number">0xFFFF</span>);</span><br></pre></td></tr></table></figure><p>该函数被定义在 <code>Source\gd32f3x0_gpio.c</code>源文件当中，可以看到其函数体内调用了 <code>GPIO_OCTL(gpio_periph)</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      write data to the specified GPIO port</span></span><br><span class="line"><span class="comment">    \param[in]  gpio_periph: GPIOx(x = A,B,C,D,F)</span></span><br><span class="line"><span class="comment">                only one parameter can be selected which is shown as below:</span></span><br><span class="line"><span class="comment">      \arg        GPIOx(x = A,B,C,D,F)</span></span><br><span class="line"><span class="comment">    \param[in]  data: specify the value to be written to the port output control register</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_port_write</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint16_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_OCTL(gpio_periph) = (<span class="type">uint32_t</span>)data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个 <code>GPIO_OCTL(gpio_periph)</code> 函数又被预定义在了<code>Include\gd32f3x0_gpio.h</code> 头文件里面，其最终调用的是<code>REG32(addr)</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OCTL(gpiox)           REG32((gpiox) + 0x00000014U)    <span class="comment">/*!&lt; GPIO port output control register */</span></span></span><br></pre></td></tr></table></figure><p><code>REG32(addr)</code> 函数的定义位于官方固件库<code>Firmware\CMSIS\GD\GD32F3x0\Include</code> 目录下的<code>gd32f3x0.h</code> 头文件当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG32(addr)                  (*(volatile uint32_t *)(uint32_t)(addr))</span></span><br></pre></td></tr></table></figure><p>把前面寄存器 <code>GPIOA_OCTL</code> 的地址计算式<code>0x4800 0000 + 0x0000 0014</code> 作为 <code>addr</code>参数代入之后，就会发现标准外设库底层也是在操作寄存器，只是在使用的时候更加直观简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG32(addr) (*(volatile uint32_t *)(uint32_t)(0x4800 0000 + 0x0000 0014))</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：通过<strong>寄存器</strong>直接控制外设，性能开销更少，运行更加迅速，适用于片上资源有限，且对于实时性要求较高的场景。而使用<strong>标准外设库</strong>来操控外设，其优势主要体现在提升代码的开发效率以及可读性与可维护性。</p></blockquote><h1 id="通过-gpio-寄存器控制-led">通过 GPIO 寄存器控制 LED</h1><p>使用 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板来控制 GPIO端口的输出，整体需要经历下面几个步骤：</p><ol type="1"><li>开启指定 GPIO 的<strong>端口时钟</strong>；</li><li>配置指定 GPIO 的<strong>工作模式</strong>；</li><li>配置指定 GPIO 的<strong>输出类型</strong>；</li></ol><p>开始编写代码之前，首先需要将一枚 <code>4.7K</code> 的电阻<code>R1</code> 与一枚 LED 发光二极管串联，然后再连接到<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOB8</code>引脚，当该引脚输出<strong>高电平</strong>的时候 LED发光二极管就会点亮，而输出<strong>低电平</strong>的时候 LED发光二极管就会熄灭，具体的电路连接关系请参考下面的示意图：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/0.png"></p><h2 id="开启-gpio-的端口时钟">开启 GPIO 的端口时钟</h2><p>由于 <strong>GD32F350RBT6</strong>的外设时钟资源默认情况下都是<strong>关闭</strong>的，所以在配置外设之前需要先<strong>开启其对应的时钟</strong>。</p><h3 id="ahb-总线使能寄存器-rcu_ahben">AHB 总线使能寄存器 RCU_AHBEN</h3><p><code>GPIOB</code> 引脚分组被挂载到了 <strong>GD32F350RBT6</strong>微控制器的 <strong>AHB</strong> 总线下面，在用户手册的<code>复位和时钟单元(RCU)</code> 章节里，描述了 <strong>AHB总线使能寄存器</strong> <code>RCU_AHBEN</code> 的地址偏移量为<code>0x14</code>、复位值为 <code>0x0000 0014</code>，可以按照 8位的<strong>字节</strong>、16 位的<strong>半字</strong>以及 32位的<strong>字</strong>进行访问：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/1.png"></p><p>而 <strong>AHB 总线使能寄存器</strong><code>RCU_AHBEN</code>位于<strong>复位和时钟单元 RCU</strong>外设的地址范围之内，由于 RCU 的外设基地址为<code>0x4002 1000</code>，所以 <code>RCU_AHB1EN</code>寄存器的实际地址计算过程如下面等式所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">RCU_AHBEN</span> = <span class="variable constant_">RCU</span> 的外设基地址 + <span class="variable constant_">AHB</span> 总线使能寄存器偏移量 = <span class="number">0x4002</span> <span class="number">1000</span> + <span class="number">0x14</span> = <span class="number">0x4002</span> <span class="number">1014</span></span><br></pre></td></tr></table></figure><p>根据用户手册当中接下来的内容，可以发现 <code>RCU_AHB1EN</code>寄存器的第 <code>18</code> 位 <code>PBEN</code> 就是 GPIOB时钟的<strong>使能位</strong>：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/2.png"></p><p>所以只需要往 <code>RCU_AHB1EN</code> 寄存器的第 18 位写入<code>1</code>，其它位保持不变，就可以实现对 <strong>GPIOB</strong>外设时钟的使能，这里我们可以通过一个<strong>或运算</strong>和<strong>移位运算</strong>来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCU_AHBEN |= (<span class="number">1</span> &lt;&lt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面等式要使能的是第几位，就向右移多少位。例如上面等式向第18 位写入 <code>1</code>，所以就右移 <code>18</code> 位。</p></blockquote><h2 id="配置-gpio-的工作模式">配置 GPIO 的工作模式</h2><p>接下来，着手配置 <strong>GD32F350RBT6</strong> 的 GPIO工作模式，这里具体可以划分为下面两个步骤：</p><ol type="1"><li>将<strong>端口控制寄存器</strong> <code>GPIOx_CTL</code>配置为<code>输入模式(默认)</code> / <code>输出模式</code> /<code>备用功能模式</code> / <code>模拟模式</code>；</li><li>将<strong>端口上下拉寄存器</strong> <code>GPIOx_PUD</code>配置为<code>上拉模式</code> / <code>下拉模式</code> /<code>悬空模式(默认)</code>；</li></ol><h3 id="配置端口控制寄存器-gpiob_ctl">配置端口控制寄存器 GPIOB_CTL</h3><p>已知 <strong>GPIOB</strong> 寄存器的基地址为<code>0x4800 0400</code>，而端口控制寄存器 <code>GPIOB_CTL</code>的地址偏移量为 <code>0x00</code>：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/3.png"></p><p>从而就可以计算出 <strong>GPIOB</strong> 端口控制寄存器<code>GPIOB_CTL</code> 的实际地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x00</span> = <span class="number">0x4800</span> <span class="number">0400</span></span><br></pre></td></tr></table></figure><p><img src="/Project/UINIO-MCU-GD32/5-LED/4.png"></p><p>该寄存器通过两个位来进行控制，例如这里需要操作的是 <code>Pin8</code>引脚，就是需要控制 <code>GPIOB_CTL</code> 寄存器的第 17 和 16位。通过将这两位配置为 <code>01</code>，就可以将 <strong>GPIOB8</strong>端口配置为输出模式。此时向 <code>GPIOB_CTL</code>寄存器写入的二进制数据为<code>0000 0000 0000 0001 0000 0000 0000 0000</code>，转换为十六进制就是<code>00010000</code>。为了确保其它位不会被修改，需要先将第 15 和第 14两位置零，然后再将其配置为 <code>0</code> 和 <code>1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL &amp;= <span class="number">0xFFFCFFFF</span>;  <span class="comment">// 把第 17 和 16 位置为 00</span></span><br><span class="line">GPIOB_CTL |= <span class="number">0x00004000</span>;  <span class="comment">// 配置第 17 和 16 位为 01</span></span><br></pre></td></tr></table></figure><p>除此之外，还可以采用下面的计算方式进行配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 把第 17 和 16 位置为 00</span></span><br><span class="line">GPIOB_CTL |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 配置第 17 和 16 位为 01</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面代码当中的数值 <code>8</code> 对应的是<code>GPIOB8</code>，反之如果是 <code>GPIOB5</code> 则可以将该值替换为<code>5</code>。</p></blockquote><h3 id="配置端口上下拉寄存器-gpiob_pud">配置端口上下拉寄存器GPIOB_PUD</h3><p>将 <strong>GPIOB8</strong>引脚配置为输出模式之后，还需要再进一步通过<strong>端口上下拉寄存器</strong><code>GPIOB_PUD</code>将其进一步配置为<strong>悬空模式</strong>(默认值，即没有上下拉电阻)：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/5.png"></p><p>同样已知 <strong>GPIOB</strong> 寄存器的基地址为<code>0x4800 0400</code>，而端口上下拉寄存器 <code>GPIOB_PUD</code>的地址偏移量为 <code>0x0C</code>，从而就可以计算出其实际地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_PUD = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x0C</span> = <span class="number">0x4800</span> <span class="number">040</span>C</span><br></pre></td></tr></table></figure><p>该寄存器同样通过 <code>GPIOB_PUD</code> 寄存器的第 17 和第 16两个位来进行控制：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/6.png"></p><p>使用时也依然需要先进行清零，然后再将其配置为 <code>00</code>所代表的<strong>悬空模式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_PUD &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 将第 17 和 16 位清零</span></span><br><span class="line">GPIOB_PUD |= (<span class="number">0x00</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 配置第 17 和 16 位为 00</span></span><br></pre></td></tr></table></figure><h2 id="配置-gpio-的输出类型">配置 GPIO 的输出类型</h2><p>配置 <strong>UINIO-MCU-GD32F350RBT6</strong> 的 GPIO输出类型也可以划分为如下两个步骤：</p><ol type="1"><li>配置端口输出模式寄存器<code>GPIOx_OMODE</code>，也就是选择<strong>推挽输出</strong>还是<strong>开漏输出</strong>；</li><li>配置端口速度寄存器 <code>GPIOx_OSPD</code>的输出速度等级，在这里我们选择 <code>50MHz</code> 的频率；</li></ol><h3 id="端口输出模式寄存器-gpiob_omode">端口输出模式寄存器GPIOB_OMODE</h3><p>GPIO的<strong>开漏输出</strong>模式需要外接上拉电阻，才能够输出高电平，不适用于当前的电路连接关系，在这里我们需要通过<strong>端口输出模式寄存器</strong><code>GPIOB_OMODE</code>，将其设置为<strong>推挽输出</strong>模式：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/7.png"></p><p>同样已知 <strong>GPIOB</strong> 的寄存器基地址为<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_OMODE</code>的地址偏移量为 <code>0x04</code>，那么 <code>GPIOB_OMODE</code>的准确寄存器地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OMODE = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x04</span> = <span class="number">0x4800</span> <span class="number">0404</span></span><br></pre></td></tr></table></figure><p><img src="/Project/UINIO-MCU-GD32/5-LED/8.png"></p><p>根据上图的描述可知，向 <code>GPIOB_OMODE</code> 寄存器的第 8 位写入<code>0</code>，就可以将其配置为<strong>推挽输出模式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OMODE &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>) <span class="comment">// 将 GPIOB_OMODE 的第 8 位置为 0</span></span><br></pre></td></tr></table></figure><h3 id="端口速度寄存器-gpiob_ospd">端口速度寄存器 GPIOB_OSPD</h3><p>接下来，需要再将<strong>端口速度寄存器</strong><code>GPIOx_OSPD</code> 的输出频率设置为 <code>50MHz</code>：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/9.png"></p><p>根据前面的计算方法，已知 <strong>GPIOB</strong> 的寄存器基地址为<code>0x4800 0400</code>，而端口速度寄存器 <code>GPIOB_OSPD</code>的地址偏移量为 <code>0x08</code>，则 <code>GPIOB_OSPD</code>的准确寄存器地址，可以按照如下方式进行计算得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x08</span> = <span class="number">0x4800</span> <span class="number">0408</span></span><br></pre></td></tr></table></figure><p><img src="/Project/UINIO-MCU-GD32/5-LED/10.png"></p><p>根据上图描述的信息，可以向 <code>GPIOB_OSPD</code> 寄存器的第 17 和第 16 位写入 <code>10</code>（复位值），就可以将其配置为<code>2MHz</code> 的输出速率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD |=  (<span class="number">0x02</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向第 17 和 16 位写入 10</span></span><br></pre></td></tr></table></figure><p>而向 <code>GPIOB_OSPD</code> 寄存器的第 17 和 第 16 位写入<code>01</code>，则可以将其配置为 <code>10MHz</code> 的输出速率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD |=  (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向第 17 和 16 位写入 10</span></span><br></pre></td></tr></table></figure><p>如果向 <code>GPIOB_OSPD</code> 寄存器的第 17 和 第 16 位写入的是<code>11</code>，则可以将其配置为 <code>50MHz</code>的输出速率，也就是当前需要为 <strong>UINIO-MCU-GD32F350RBT6</strong> 的<code>GPIOB</code> 配置的目标频率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD &amp;=  ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 向第 17 和 16 位写入 11</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：十六进制 <code>0x03</code> 的二进制形式为<code>0000 0011</code>，十六进制 <code>0x02</code> 的二进制形式为<code>0000 0010</code>，十六进制 <code>0x01</code> 的二进制形式为<code>0000 0001</code>。</p></blockquote><h2 id="控制-gpio-的输出状态">控制 GPIO 的输出状态</h2><p>配置好 <strong>GPIOB8</strong>对应的<code>端口时钟</code>、<code>工作模式</code>、<code>输出类型</code>之后，就可以通过使其输出<strong>高电平</strong>点亮LED 发光二极管，或者通过<strong>低电平</strong>熄灭 LED 发光二极管。</p><h3 id="端口输出控制寄存器-gpiob_octl">端口输出控制寄存器GPIOB_OCTL</h3><p>根据用户手册已知 <strong>GPIOB</strong> 的寄存器基地址为<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_OCTL</code>的地址偏移量为 <code>0x14</code>：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/11.png"></p><p>那么端口输出控制寄存器 <code>GPIOB_OCTL</code>的实际地址，就可以通过下面的等式计算得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OCTL = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x14</span> = <span class="number">0x4800</span> <span class="number">0414</span></span><br></pre></td></tr></table></figure><p>通过向上图当中 <code>GPIOB_OCTL</code> 寄存器的第 8 位<code>OCTL8</code> 位写入 <code>1</code> 或者<code>0</code>，就可以控制相应的 GPIO引脚输出<strong>高电平</strong>或者<strong>低电平</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OCTL &amp;= ~ (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>); <span class="comment">// 输出低电平</span></span><br><span class="line">GPIOB_OCTL |=  (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);  <span class="comment">// 输出高电平</span></span><br></pre></td></tr></table></figure><h3 id="端口位操作寄存器-gpiob_bop">端口位操作寄存器 GPIOB_BOP</h3><p>除此之外，我们还可以通过<strong>端口位操作寄存器</strong><code>GPIOB_BOP</code> 来操作 GPIO 端口的状态。根据用户手册已知<strong>GPIOB</strong> 的寄存器基地址为<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_BOP</code>的地址偏移量为 <code>0x18</code>：</p><p><img src="/Project/UINIO-MCU-GD32/5-LED/12.png"></p><p>那么端口输出控制寄存器 <code>GPIOB_BOP</code>的实际地址，就可以通过下面的计算过程获得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_BOP = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x18</span> = <span class="number">0x4800</span> <span class="number">0418</span></span><br></pre></td></tr></table></figure><p>观察可以发现 <code>GPIOB_BOP</code> 寄存器的高 16 位和低 16位的每一位，都分别对应着一个 GPIO 引脚。其中<strong>低十六位</strong><span class="math inline">\(CR_{0 \sim 15}\)</span> 是置 <code>1</code>位，而<strong>高十六位</strong> <span class="math inline">\(BOP_{0 \sim15}\)</span> 则属于清 <code>0</code> 位：</p><ul><li><code>GPIOB_BOP</code> 寄存器的高十六位 <span class="math inline">\(CR_{0 \sim 15}\)</span>：置为 <code>1</code>输出<strong>低电平</strong>，置 <code>0</code> 电平状态不改变；</li><li><code>GPIOB_BOP</code> 寄存器的低十六位 <span class="math inline">\(BOP_{0 \sim 15}\)</span>：置为 <code>1</code>输出<strong>高电平</strong>，置 <code>0</code> 电平状态不改变；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">8</span> + <span class="number">16</span>)); <span class="comment">// 输出低电平</span></span><br><span class="line">GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);        <span class="comment">// 输出高电平</span></span><br></pre></td></tr></table></figure><h2 id="完整-keil-µvision-工程代码">完整 Keil µVision 工程代码</h2><p>在 <strong>Keil-GD32F350RBT6</strong> 工程的 <code>Driver</code>目录下建立一个名为 <code>LED</code> 的子目录，然后分别新建<code>LED.h</code> 和 <code>LED.c</code> 两个源文件，并且在<code>main.c</code> 里包含 <code>LED.h</code>头文件，全部的示例代码内容如下面所示，即<strong>UINIO-MCU-GD32F350RBT6</strong> 工程 <code>Examples</code>目录下的 <code>1-LED-Register</code> 工程：</p><h3 id="driversled.h">Drivers/LED.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_Driver_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_Driver_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_RCU_BASE (unsigned int)0x40021000U                      <span class="comment">// RCU 寄存器的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_RCU_AHBEN *(unsigned int *)(UINIO_RCU_BASE + 0x14U)     <span class="comment">// AHB 使能寄存器地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_BASE (unsigned int)0x48000400U                    <span class="comment">// GPIOB 的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_CTL *(unsigned int *)(UINIO_GPIOB_BASE + 0x00U)   <span class="comment">// GPIOB 控制寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_PUD *(unsigned int *)(UINIO_GPIOB_BASE + 0x0CU)   <span class="comment">// GPIOB 的上下拉寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OMODE *(unsigned int *)(UINIO_GPIOB_BASE + 0x04U) <span class="comment">// GPIOB 的输出模式寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OSPD *(unsigned int *)(UINIO_GPIOB_BASE + 0x08U)  <span class="comment">// GPIOB 的速度寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OCTL *(unsigned int *)(UINIO_GPIOB_BASE + 0x14U)  <span class="comment">// GPIOB 的输出控制寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_BOP *(unsigned int *)(UINIO_GPIOB_BASE + 0x18U)   <span class="comment">// GPIOB 的位操作寄存器的地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// LED 相关的 GPIO 端口配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_Driver_LED_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driversled.c">Drivers/LED.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 相关的 GPIO 端口配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* AHB 总线使能寄存器 RCU_AHBEN */</span></span><br><span class="line">  UINIO_RCU_AHBEN |= (<span class="number">0x01</span> &lt;&lt; <span class="number">18</span>);         <span class="comment">// RCU_AHBEN 寄存器的第 18 位置为 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置端口控制寄存器 GPIOB_CTL */</span></span><br><span class="line">  UINIO_GPIOB_CTL &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span>*<span class="number">8</span>));     <span class="comment">// 把 GPIOB_CTL 的第 17 和 16 位置为 00</span></span><br><span class="line">  UINIO_GPIOB_CTL |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span>*<span class="number">8</span>));      <span class="comment">// 配置 GPIOB_CTL 的第 17 和 16 位为 01</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置端口上下拉寄存器 GPIOB_PUD */</span></span><br><span class="line">  UINIO_GPIOB_PUD &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));   <span class="comment">// 将 GPIOB_PUD 的第 17 和 16 位清零</span></span><br><span class="line">  UINIO_GPIOB_PUD |= (<span class="number">0x00</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));    <span class="comment">// 配置 GPIOB_PUD 的第 17 和 16 位为 00</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口输出模式寄存器 GPIOB_OMODE */</span></span><br><span class="line">  UINIO_GPIOB_OMODE &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);       <span class="comment">// 将 GPIOB_OMODE 的第 8 位置为 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口速度寄存器 GPIOB_OSPD */</span></span><br><span class="line">  UINIO_GPIOB_OSPD &amp;=  (<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向 GPIOB_OSPD 的第 17 和 16 位写入 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 配置系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 配置连接 LED 的 GPIO 端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口输出控制寄存器 GPIOB_OCTL 方式控制 LED */</span></span><br><span class="line">  UINIO_GPIOB_OCTL &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);      <span class="comment">// 输出低电平，LED 熄灭</span></span><br><span class="line">  UINIO_GPIOB_OCTL |=  (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);      <span class="comment">// 输出高电平，LED 点亮</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口位操作寄存器 GPIOB_BOP 方式控制 LED */</span></span><br><span class="line">  UINIO_GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">8</span> + <span class="number">16</span>)); <span class="comment">// 输出低电平，LED 熄灭</span></span><br><span class="line">  UINIO_GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);        <span class="comment">// 输出高电平，LED 点亮</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过-gpio-固件库控制-led">通过 GPIO 固件库控制 LED</h1><p>本节内容将采用<strong>兆易创新</strong>官方提供的标准外设固件库<code>GD32F3x0_Firmware_Library_V2.2.1</code> 来完成点亮 LED的实验，这通常需要经历如下四个步骤：</p><ol type="1"><li>调用 <code>rcu_periph_clock_enable()</code> 固件库函数使能 GPIO端口对应的<strong>外设时钟</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rcu_periph_clock_enable</span><span class="params">(rcu_periph_enum periph)</span>;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>通过 <code>gpio_mode_set()</code> 函数配置 GPIO端口的<strong>工作模式</strong>以及设置<strong>上下拉电阻状态</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_mode_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> mode, <span class="type">uint32_t</span> pull_up_down, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>通过 <code>gpio_output_options_set()</code> 函数配置指定 GPIO引脚的输出类型与速率：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">void</span> <span class="title function_">gpio_output_options_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint8_t</span> otype, <span class="type">uint32_t</span> speed, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>通过 <code>gpio_bit_set/write()</code> 指定 GPIO引脚的电平状态：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> gpio_bit_set/write(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span><br></pre></td></tr></table></figure><h2 id="使能-gpio-外设时钟">使能 GPIO 外设时钟</h2><p>官方固件库 <code>Firmware\GD32F3x0_standard_peripheral\Include</code>目录下的头文件 <code>gd32f3x0_rcu.h</code>里，定义了一个专门用于使能<strong>外设时钟</strong>的库函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rcu_periph_clock_enable</span><span class="params">(rcu_periph_enum periph)</span></span><br></pre></td></tr></table></figure><p>这个函数的 <code>periph</code> 参数是一个<code>rcu_periph_enum</code>枚举类型的变量，其具体的定义如下面所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* peripheral clock enable */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* AHB peripherals */</span></span><br><span class="line">    RCU_DMA     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">0U</span>),                  <span class="comment">/*!&lt; DMA clock */</span></span><br><span class="line">    RCU_CRC     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">6U</span>),                  <span class="comment">/*!&lt; CRC clock */</span></span><br><span class="line">    RCU_GPIOA   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">17U</span>),                 <span class="comment">/*!&lt; GPIOA clock */</span></span><br><span class="line">    RCU_GPIOB   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">18U</span>),                 <span class="comment">/*!&lt; GPIOB clock */</span></span><br><span class="line">    RCU_GPIOC   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">19U</span>),                 <span class="comment">/*!&lt; GPIOC clock */</span></span><br><span class="line">    RCU_GPIOD   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">20U</span>),                 <span class="comment">/*!&lt; GPIOD clock */</span></span><br><span class="line">    RCU_GPIOF   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">22U</span>),                 <span class="comment">/*!&lt; GPIOF clock */</span></span><br><span class="line">    RCU_TSI     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">24U</span>),                 <span class="comment">/*!&lt; TSI clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* APB2 peripherals */</span></span><br><span class="line">    RCU_CFGCMP  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">0U</span>),                 <span class="comment">/*!&lt; CFGCMP clock */</span></span><br><span class="line">    RCU_ADC     = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">9U</span>),                 <span class="comment">/*!&lt; ADC clock */</span></span><br><span class="line">    RCU_TIMER0  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">11U</span>),                <span class="comment">/*!&lt; TIMER0 clock */</span></span><br><span class="line">    RCU_SPI0    = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">12U</span>),                <span class="comment">/*!&lt; SPI0 clock */</span></span><br><span class="line">    RCU_USART0  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">14U</span>),                <span class="comment">/*!&lt; USART0 clock */</span></span><br><span class="line">    RCU_TIMER14 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">16U</span>),                <span class="comment">/*!&lt; TIMER14 clock */</span></span><br><span class="line">    RCU_TIMER15 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">17U</span>),                <span class="comment">/*!&lt; TIMER15 clock */</span></span><br><span class="line">    RCU_TIMER16 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">18U</span>),                <span class="comment">/*!&lt; TIMER16 clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* APB1 peripherals */</span></span><br><span class="line">    RCU_TIMER1  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">0U</span>),                 <span class="comment">/*!&lt; TIMER1 clock */</span></span><br><span class="line">    RCU_TIMER2  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">1U</span>),                 <span class="comment">/*!&lt; TIMER2 clock */</span></span><br><span class="line">    RCU_TIMER13 = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">8U</span>),                 <span class="comment">/*!&lt; TIMER13 clock */</span></span><br><span class="line">    RCU_WWDGT   = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">11U</span>),                <span class="comment">/*!&lt; WWDGT clock */</span></span><br><span class="line">    RCU_SPI1    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">14U</span>),                <span class="comment">/*!&lt; SPI1 clock */</span></span><br><span class="line">    RCU_USART1  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">17U</span>),                <span class="comment">/*!&lt; USART1 clock */</span></span><br><span class="line">    RCU_I2C0    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">21U</span>),                <span class="comment">/*!&lt; I2C0 clock */</span></span><br><span class="line">    RCU_I2C1    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">22U</span>),                <span class="comment">/*!&lt; I2C1 clock */</span></span><br><span class="line">    RCU_PMU     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">28U</span>),                <span class="comment">/*!&lt; PMU clock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(GD32F350)</span></span><br><span class="line">    RCU_DAC     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">29U</span>),                <span class="comment">/*!&lt; DAC clock */</span></span><br><span class="line">    RCU_CEC     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">30U</span>),                <span class="comment">/*!&lt; CEC clock */</span></span><br><span class="line">    RCU_TIMER5  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">4U</span>),                 <span class="comment">/*!&lt; TIMER5 clock */</span></span><br><span class="line">    RCU_USBFS   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">12U</span>),                 <span class="comment">/*!&lt; USBFS clock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* GD32F350 */</span></span></span><br><span class="line">    RCU_RTC     = RCU_REGIDX_BIT(IDX_BDCTL, <span class="number">15U</span>),                 <span class="comment">/*!&lt; RTC clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RCU_ADDAPB1EN */</span></span><br><span class="line">    RCU_CTC     = RCU_REGIDX_BIT(IDX_ADDAPB1EN, <span class="number">27U</span>)              <span class="comment">/*!&lt; CTC clock */</span></span><br><span class="line">&#125; rcu_periph_enum;</span><br></pre></td></tr></table></figure><p>观察可以发现，如果向 <code>rcu_periph_clock_enable()</code>函数传入上述枚举类型变量当中的<strong>枚举值</strong><code>RCU_GPIOB</code>，就可以使能 <strong>GPIOB</strong>对应的外设时钟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcu_periph_clock_enable(RCU_GPIOB);</span><br></pre></td></tr></table></figure><h2 id="配置-gpio-模式">配置 GPIO 模式</h2><p>类似的，固件库<code>Firmware\GD32F3x0_standard_peripheral\Include</code>目录下的头文件 <code>gd32f3x0_gpio.h</code> 里定义了一个用于设置<strong>GPIO 工作模式</strong>的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set GPIO mode */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_mode_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> mode, <span class="type">uint32_t</span> pull_up_down, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure><p>该函数的四个参数，分别用于<code>设置 GPIO 分组</code>、<code>配置工作模式</code>、<code>选择上下拉状态</code>、<code>指定 GPIO 引脚</code>，具体参数选项请参考下面的源代码片断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIOx(x=A,B,C,D,F) definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA                      (GPIO_BASE + 0x00000000U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB                      (GPIO_BASE + 0x00000400U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC                      (GPIO_BASE + 0x00000800U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD                      (GPIO_BASE + 0x00000C00U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF                      (GPIO_BASE + 0x00001400U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* output mode definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_INPUT            CTL_CLTR(0)           <span class="comment">/*!&lt; input mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_OUTPUT           CTL_CLTR(1)           <span class="comment">/*!&lt; output mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_AF               CTL_CLTR(2)           <span class="comment">/*!&lt; alternate function mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_ANALOG           CTL_CLTR(3)           <span class="comment">/*!&lt; analog mode */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pull-up/pull-down definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_PUPD(regval)           (BITS(0,1) &amp; ((uint32_t)(regval) &lt;&lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_NONE             PUD_PUPD(0)           <span class="comment">/*!&lt; floating mode, no pull-up and pull-down resistors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_PULLUP           PUD_PUPD(1)           <span class="comment">/*!&lt; with pull-up resistor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_PULLDOWN         PUD_PUPD(2)           <span class="comment">/*!&lt; with pull-down resistor */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO pin definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_0                 BIT(0)                <span class="comment">/*!&lt; GPIO pin 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_1                 BIT(1)                <span class="comment">/*!&lt; GPIO pin 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_2                 BIT(2)                <span class="comment">/*!&lt; GPIO pin 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_3                 BIT(3)                <span class="comment">/*!&lt; GPIO pin 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_4                 BIT(4)                <span class="comment">/*!&lt; GPIO pin 4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_5                 BIT(5)                <span class="comment">/*!&lt; GPIO pin 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_6                 BIT(6)                <span class="comment">/*!&lt; GPIO pin 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_7                 BIT(7)                <span class="comment">/*!&lt; GPIO pin 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_8                 BIT(8)                <span class="comment">/*!&lt; GPIO pin 8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_9                 BIT(9)                <span class="comment">/*!&lt; GPIO pin 9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_10                BIT(10)               <span class="comment">/*!&lt; GPIO pin 10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_11                BIT(11)               <span class="comment">/*!&lt; GPIO pin 11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_12                BIT(12)               <span class="comment">/*!&lt; GPIO pin 12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_13                BIT(13)               <span class="comment">/*!&lt; GPIO pin 13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_14                BIT(14)               <span class="comment">/*!&lt; GPIO pin 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_15                BIT(15)               <span class="comment">/*!&lt; GPIO pin 15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_ALL               BITS(0,15)            <span class="comment">/*!&lt; GPIO pin all */</span></span></span><br></pre></td></tr></table></figure><p>例如现在要配置 <strong>GPIOB8</strong>引脚为<strong>悬空输出模式</strong>，则只需要向<code>gpio_mode_set()</code> 函数传入相应的参数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_mode_set(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_8);</span><br></pre></td></tr></table></figure><h2 id="配置-gpio-输出类型与速度">配置 GPIO 输出类型与速度</h2><p>固件库 <code>Firmware\GD32F3x0_standard_peripheral\Include</code>目录下的 <code>gd32f3x0_gpio.h</code> 头文件里面，同样定义有一个用于设置<strong>GPIO 输出类型和速率</strong>的库函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_output_options_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint8_t</span> otype, <span class="type">uint32_t</span> speed, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的四个参数，则是分别用于<code>设置 GPIO 分组</code>、<code>配置输出类型</code>、<code>最大输出速率</code>，具体的参数选项同样请参考下面的源代码片断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO output type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OTYPE_PP              ((uint8_t)(0x00U))    <span class="comment">/*!&lt; push pull mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OTYPE_OD              ((uint8_t)(0x01U))    <span class="comment">/*!&lt; open drain mode */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO output max speed value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_2MHZ           OSPD_OSPD0(0)                     <span class="comment">/*!&lt; output max speed 2MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_10MHZ          OSPD_OSPD0(1)                     <span class="comment">/*!&lt; output max speed 10MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_50MHZ          OSPD_OSPD0(3)                     <span class="comment">/*!&lt; output max speed 50MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_MAX            ((uint32_t)0x0000FFFFU)           <span class="comment">/*!&lt; GPIO very high output speed, max speed more than 50MHz */</span></span></span><br></pre></td></tr></table></figure><p>例如当前要配置 <strong>GPIOB8</strong>引脚为<strong>推挽输出</strong>方式，其最大输出速率为<code>50MHz</code>，则只需要向 <code>gpio_output_options_set()</code>函数传入下面的参数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);</span><br></pre></td></tr></table></figure><h2 id="指定-gpio-引脚电平状态">指定 GPIO 引脚电平状态</h2><p>固件库的 <code>gd32f3x0_gpio.h</code>头文件里，存在着下面三个可以用于定义 <strong>GPIO引脚电平状态</strong>的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set GPIO pin bit */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_reset</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* write data to the specified GPIO pin */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_write</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin, bit_status bit_value)</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>gpio_bit_set()</code> 和 <code>gpio_bit_reset()</code>函数用于指定 GPIO 引脚为固定的高电平状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_bit_set(GPIOB, GPIO_PIN_8);    <span class="comment">// 指定 GPIOB8 引脚为高电平</span></span><br><span class="line">gpio_bit_reset(GPIOB, GPIO_PIN_8);  <span class="comment">// 指定 GPIOB8 引脚为低电平</span></span><br></pre></td></tr></table></figure><p>而 <code>gpio_bit_write()</code> 函数则可以用来灵活的设置 GPIO引脚为高电平或者低电平状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_bit_write(GPIOB, GPIO_PIN_8, <span class="number">0</span>);  <span class="comment">// 让 GPIOB8 引脚输出低电平</span></span><br><span class="line">gpio_bit_write(GPIOB, GPIO_PIN_8, <span class="number">1</span>);  <span class="comment">// 让 GPIOB8 引脚输出高电平</span></span><br></pre></td></tr></table></figure><h2 id="完整-keil-µvision-工程代码-1">完整 Keil µVision 工程代码</h2><p>接下来，将 <strong>Keil-GD32F350RBT6</strong> 示例工程里的<code>LED.h</code> 和 <code>LED.c</code> 以及 <code>main.c</code>替换为使用固件库的版本，全部的示例代码内容如下面所示，即<strong>UINIO-MCU-GD32F350RBT6</strong> 工程 <code>Examples</code>目录下的 <code>2-LED-Library</code> 工程：</p><h3 id="driversled.h-1">Drivers/LED.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== UINIO_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_RCU  RCU_GPIOB   <span class="comment">// 宏定义 LED 对应的 GPIO 端口时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_PORT GPIOB       <span class="comment">// 宏定义 LED 对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_PIN  GPIO_PIN_8  <span class="comment">// 宏定义 LED 对应的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// LED 关联 GPIO 引脚的配置函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_LED_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driversled.c-1">Drivers/LED.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== UINIO_LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 对应 GPIO 引脚的配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_LED_RCU);                                                   <span class="comment">// 使能 GIPO 外设对应的 RCU 复位和时钟单元</span></span><br><span class="line">  gpio_mode_set(UINIO_LED_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, UINIO_LED_PIN);           <span class="comment">// 配置 GPIO 为浮空输出模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_LED_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_LED_PIN); <span class="comment">// 设置 GPIO 的输出模式为推挽输出，速度为 50MHz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-1">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  gpio_bit_set(UINIO_LED_PORT, UINIO_LED_PIN);             <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">  gpio_bit_reset(UINIO_LED_PORT, UINIO_LED_PIN);           <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line"></span><br><span class="line">  gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">  gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="启动文件-startup_gd32f3x0.s-剖析">启动文件 startup_gd32f3x0.s剖析</h1><p>在开启进一步的标准固件库学习之前，首先需要了解<strong>Keil-GD32F350RBT6</strong> 工程的启动顺序，其中<code>Firmware\CMSIS\GD\GD32F3x0\Source\ARM</code> 目录下的<code>startup_gd32f3x0.s</code> 源文件是 <strong>GD32F350RBT6</strong>微控制器上电复位之后，执行的第一段程序（由汇编语言编写），该程序主要完成了如下几项工作：</p><ol type="1"><li>配置<strong>栈</strong>信息；</li><li>配置<strong>堆</strong>信息；</li><li>映射<strong>向量表</strong>；</li><li>设置<strong>复位处理程序</strong>；</li><li>定义<strong>异常/外部中断处理程序</strong>；</li><li>初始化<strong>用户堆栈</strong>；</li></ol><p>在接下来的内容当中，将会根据执行顺序依次探讨<code>startup_gd32f3x0.s</code> 当中各个代码块的功能与用途。</p><h2 id="配置栈信息">配置栈信息</h2><p><strong>栈</strong>主要用于存放<code>局部变量</code>、<code>函数调用</code>、<code>函数形式参数</code>，其<strong>由高向低生长</strong>，且容量不能超过片上SRAM 存储器的容量大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; &lt;h&gt; Stack Configuration</span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure><p>上面的汇编代码，开辟了一个大小为 <code>0X00000400</code> (1KB) 名称为<code>STACK</code> 的<strong>栈</strong>，其中 <code>NOINIT</code>表示不初始化，<code>READWRITE</code> 表示可读可写，<code>ALIGN=3</code>表示 <span class="math inline">\(2^3 = 8\)</span> 字节对齐。最后的<code>__initial_sp</code> 表示栈的结束地址，也就是栈顶地址。</p><h2 id="配置堆信息">配置堆信息</h2><p><strong>堆</strong>主要用于完成动态内存分配，其<strong>由低向高生长</strong>，例如<code>malloc()</code> 函数申请的内存就位于在堆上面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br></pre></td></tr></table></figure><p>上面的汇编代码，开辟了一个大小为 <code>0X00000400</code> (1KB) 名称为<code>HEAP</code> 的<strong>堆</strong>，同样的 <code>NOINIT</code>表示不初始化，<code>READWRITE</code> 表示可读可写，<code>ALIGN=3</code>表示 <span class="math inline">\(2^3 = 8\)</span> 字节对齐。</p><p>除此之外，<code>__heap_base</code> 表示堆的起始地址，而<code>__heap_limit</code> 表示堆的结束地址。后续的<code>PRESERVE8</code> 表示保留 8 字节对齐，而 <code>THUMB</code>表示兼容 <strong>THUMB</strong> 指令集。</p><h2 id="映射向量表">映射向量表</h2><p><strong>向量表</strong>是一个 32 位 <code>WORD</code><strong>字</strong>数组，其按照 4 字节进行边界对齐，从片上 Flash的零地址开始进行放置，这个数组保存着一系列程序的入口地址，当<strong>GD32F350RBT6</strong>微控制器处于不同的预定义状态时，就会通过查找向量表，进入执行对应地址的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">;               /* reset Vector Mapped to at Address 0 */</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                      ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                     ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                       ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler                 ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler                 ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler                  ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler                ; Usage Fault Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     SVC_Handler                       ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler                  ; Debug Monitor Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                    ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                   ; SysTick Handler</span><br><span class="line"></span><br><span class="line">;               /* external interrupts handler */</span><br><span class="line">                DCD     WWDGT_IRQHandler                  ; 16:Window Watchdog Timer</span><br><span class="line">                DCD     LVD_IRQHandler                    ; 17:LVD through EXTI Line detect</span><br><span class="line">                DCD     RTC_IRQHandler                    ; 18:RTC through EXTI Line</span><br><span class="line">                DCD     FMC_IRQHandler                    ; 19:FMC</span><br><span class="line">                DCD     RCU_CTC_IRQHandler                ; 20:RCU and CTC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler                ; 21:EXTI Line 0 and EXTI Line 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler                ; 22:EXTI Line 2 and EXTI Line 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler               ; 23:EXTI Line 4 to EXTI Line 15</span><br><span class="line">                DCD     TSI_IRQHandler                    ; 24:TSI</span><br><span class="line">                DCD     DMA_Channel0_IRQHandler           ; 25:DMA Channel 0</span><br><span class="line">                DCD     DMA_Channel1_2_IRQHandler         ; 26:DMA Channel 1 and DMA Channel 2</span><br><span class="line">                DCD     DMA_Channel3_4_IRQHandler         ; 27:DMA Channel 3 and DMA Channel 4</span><br><span class="line">                DCD     ADC_CMP_IRQHandler                ; 28:ADC and Comparator 0-1</span><br><span class="line">                DCD     TIMER0_BRK_UP_TRG_COM_IRQHandler  ; 29:TIMER0 Break,Update,Trigger and Commutation</span><br><span class="line">                DCD     TIMER0_Channel_IRQHandler         ; 30:TIMER0 Channel Capture Compare</span><br><span class="line">                DCD     TIMER1_IRQHandler                 ; 31:TIMER1</span><br><span class="line">                DCD     TIMER2_IRQHandler                 ; 32:TIMER2</span><br><span class="line">                DCD     TIMER5_DAC_IRQHandler             ; 33:TIMER5 and DAC</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     TIMER13_IRQHandler                ; 35:TIMER13</span><br><span class="line">                DCD     TIMER14_IRQHandler                ; 36:TIMER14</span><br><span class="line">                DCD     TIMER15_IRQHandler                ; 37:TIMER15</span><br><span class="line">                DCD     TIMER16_IRQHandler                ; 38:TIMER16</span><br><span class="line">                DCD     I2C0_EV_IRQHandler                ; 39:I2C0 Event</span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; 40:I2C1 Event</span><br><span class="line">                DCD     SPI0_IRQHandler                   ; 41:SPI0</span><br><span class="line">                DCD     SPI1_IRQHandler                   ; 42:SPI1</span><br><span class="line">                DCD     USART0_IRQHandler                 ; 43:USART0</span><br><span class="line">                DCD     USART1_IRQHandler                 ; 44:USART1</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     CEC_IRQHandler                    ; 46:CEC</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     I2C0_ER_IRQHandler                ; 48:I2C0 Error</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; 50:I2C1 Error</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     USBFS_WKUP_IRQHandler             ; 58:USBFS Wakeup</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     DMA_Channel5_6_IRQHandler         ; 64:DMA Channel5 and Channel6</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     USBFS_IRQHandler                  ; 83:USBFS</span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU     __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure><p>上述汇编代码中的 <code>__Vectors</code>表示向量表的<strong>起始地址</strong>，而 <code>__Vectors_End</code>表示向量表的<strong>结束地址</strong>。除此之外，其中的 <code>DCD</code>指令用于<strong>分配</strong>和<strong>初始化</strong>一个或者多个以<strong>字</strong><code>Word</code> 为单位的内存空间，并且以 4 字节进行对齐。</p><h2 id="设置复位处理程序">设置复位处理程序</h2><p>复位处理程序是 <strong>GD32F350RBT6</strong>上电之后首个要运行的程序，其首先会调用 <code>SystemInit</code>函数初始化系统时钟，然后再调用 C 库函数 <code>__main</code>进入用户定义的主函数 <code>main()</code>：</p><ol type="1"><li><code>SystemInit()</code> 是一个 ARM 标准库函数，定义在<strong>Keil-GD32F350RBT6</strong> 工程<code>Firmware\CMSIS\GD\GD32F3x0\Source</code> 目录下的<code>system_gd32f3x0.c</code> 当中（即 CMSIS Cortex-M4外设接入层源文件），主要用于初始化各种系统时钟。</li><li><code>__main</code> 是一个标准 C库函数，主要用于初始化用户堆栈，并且会在最后调用自定义的<code>main()</code> 函数，这也就是 <code>main()</code> 总是作为<strong>Keil uVision5</strong> 工程入口函数的原因所在。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">;/* reset Handler */</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler                     [WEAK]</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述源文件当中的第一句代码，用于定义一个名称为<code>.text</code> 的只读代码段区域。</p></blockquote><h2 id="定义异常外部中断处理程序">定义异常/外部中断处理程序</h2><p>接下来的代码片段，定义了一系列的<strong>异常处理程序</strong>和<strong>外部中断处理程序</strong>，而这些程序的完整实现则保存在外部的<code>.c</code>源文件当中。当出现相关异常或者发生指定外部中断的时候，程序的执行流程就会跳转至这里指定的各种服务程序当中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">;/* dummy Exception Handlers */</span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler                 [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler                 [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler                  [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler                  [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  PendSV_Handler                    [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  SysTick_Handler                   [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line">;               /* external interrupts handler */</span><br><span class="line">                EXPORT  WWDGT_IRQHandler                  [WEAK]</span><br><span class="line">                EXPORT  LVD_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  RTC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  FMC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  RCU_CTC_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI0_1_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI2_3_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI4_15_IRQHandler               [WEAK]</span><br><span class="line">                EXPORT  TSI_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel0_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel1_2_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel3_4_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  ADC_CMP_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER0_BRK_UP_TRG_COM_IRQHandler  [WEAK]</span><br><span class="line">                EXPORT  TIMER0_Channel_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIMER1_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  TIMER2_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  TIMER5_DAC_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  TIMER13_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER14_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER15_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER16_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C0_EV_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  SPI0_IRQHandler                   [WEAK]</span><br><span class="line">                EXPORT  SPI1_IRQHandler                   [WEAK]</span><br><span class="line">                EXPORT  USART0_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  USART1_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  CEC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  I2C0_ER_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  USBFS_WKUP_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel5_6_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  USBFS_IRQHandler                  [WEAK]</span><br><span class="line"></span><br><span class="line">;/* external interrupts handler */</span><br><span class="line">WWDGT_IRQHandler</span><br><span class="line">LVD_IRQHandler</span><br><span class="line">RTC_IRQHandler</span><br><span class="line">FMC_IRQHandler</span><br><span class="line">RCU_CTC_IRQHandler</span><br><span class="line">EXTI0_1_IRQHandler</span><br><span class="line">EXTI2_3_IRQHandler</span><br><span class="line">EXTI4_15_IRQHandler</span><br><span class="line">TSI_IRQHandler</span><br><span class="line">DMA_Channel0_IRQHandler</span><br><span class="line">DMA_Channel1_2_IRQHandler</span><br><span class="line">DMA_Channel3_4_IRQHandler</span><br><span class="line">ADC_CMP_IRQHandler</span><br><span class="line">TIMER0_BRK_UP_TRG_COM_IRQHandler</span><br><span class="line">TIMER0_Channel_IRQHandler</span><br><span class="line">TIMER1_IRQHandler</span><br><span class="line">TIMER2_IRQHandler</span><br><span class="line">TIMER5_DAC_IRQHandler</span><br><span class="line">TIMER13_IRQHandler</span><br><span class="line">TIMER14_IRQHandler</span><br><span class="line">TIMER15_IRQHandler</span><br><span class="line">TIMER16_IRQHandler</span><br><span class="line">I2C0_EV_IRQHandler</span><br><span class="line">I2C1_EV_IRQHandler</span><br><span class="line">SPI0_IRQHandler</span><br><span class="line">SPI1_IRQHandler</span><br><span class="line">USART0_IRQHandler</span><br><span class="line">USART1_IRQHandler</span><br><span class="line">CEC_IRQHandler</span><br><span class="line">I2C0_ER_IRQHandler</span><br><span class="line">I2C1_ER_IRQHandler</span><br><span class="line">USBFS_WKUP_IRQHandler</span><br><span class="line">DMA_Channel5_6_IRQHandler</span><br><span class="line">USBFS_IRQHandler</span><br><span class="line"></span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述汇编代码当中的 <code>B .</code>语句表示进入了一个<strong>无限循环</strong>，即通俗意义上的<strong>死循环</strong>。</p></blockquote><h2 id="初始化用户堆栈">初始化用户堆栈</h2><p>接着判断当前 <strong>Keil uVision5</strong> 工程是否启用有<code>__MICROLIB</code> 库，如果有启用就赋予栈顶地址<code>__initial_sp</code>、堆起始地址<code>__heap_base</code>、堆结束地址<code>__heap_limit</code>。如果没有启用，则会使用<strong>双段存储器模式</strong>，并且由用户来初始化堆栈空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">; user Initial Stack &amp; Heap</span><br><span class="line"></span><br><span class="line">                IF      :DEF:__MICROLIB</span><br><span class="line"></span><br><span class="line">                EXPORT  __initial_sp</span><br><span class="line">                EXPORT  __heap_base</span><br><span class="line">                EXPORT  __heap_limit</span><br><span class="line"></span><br><span class="line">                ELSE</span><br><span class="line"></span><br><span class="line">                IMPORT  __use_two_region_memory</span><br><span class="line">                EXPORT  __user_initial_stackheap</span><br><span class="line"></span><br><span class="line">__user_initial_stackheap PROC</span><br><span class="line">                LDR     R0, =  Heap_Mem</span><br><span class="line">                LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                LDR     R3, = Stack_Mem</span><br><span class="line">                BX      LR</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">                ENDIF</span><br><span class="line"></span><br><span class="line">                END</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述代码当中的 <code>END</code>是一个<strong>汇编程序结束标记</strong>。</p></blockquote><h1 id="时钟配置-system_gd32f3x0.c-解析">时钟配置 system_gd32f3x0.c解析</h1><p>前面已经介绍过，由汇编语言编写的<strong>系统启动文件</strong><code>startup_gd32f3x0.s</code> 调用了<strong>Keil-GD32F350RBT6</strong> 工程的<code>Firmware\CMSIS\GD\GD32F3x0\Source\system_gd32f3x0.c</code>源文件当中，由 C 语言编写的<strong>系统初始化函数</strong><code>SystemInit()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      setup the microcontroller system, initialize the system</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="comment">/* configure system clock */</span></span><br><span class="line">    system_clock_config();</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数最终调用的是同样定义在这个源文件里的<code>system_clock_config()</code> 方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure the system clock</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">system_clock_config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __SYSTEM_CLOCK_8M_HXTAL</span></span><br><span class="line">    system_clock_8m_hxtal();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__SYSTEM_CLOCK_108M_PLL_HXTAL)</span></span><br><span class="line">    system_clock_108m_hxtal();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    system_clock_8m_irc8m();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SYSTEM_CLOCK_8M_HXTAL */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在 <code>system_gd32f3x0.c</code>源文件的开头位置，存在着如下针对 <strong>GDF350</strong>系列微控制器的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (GD32F350)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSTEM_CLOCK_108M_PLL_HXTAL        (uint32_t)(108000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* GD32F350 */</span></span></span><br></pre></td></tr></table></figure><p>所以 <code>system_clock_config()</code>方法最终实际调用的是该源文件中的函数<code>system_clock_108m_hxtal()</code>，这个函数的具体定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__SYSTEM_CLOCK_108M_PLL_HXTAL)</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure the system clock to 84M by PLL which selects HXTAL as its clock source</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">system_clock_108m_hxtal</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> timeout = <span class="number">0U</span>;</span><br><span class="line">    <span class="type">uint32_t</span> stab_flag = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable HXTAL */</span></span><br><span class="line">    RCU_CTL0 |= RCU_CTL0_HXTALEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until HXTAL is stable or the startup time is longer than HXTAL_STARTUP_TIMEOUT */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">        stab_flag = (RCU_CTL0 &amp; RCU_CTL0_HXTALSTB);</span><br><span class="line">    &#125; <span class="keyword">while</span>((<span class="number">0U</span> == stab_flag) &amp;&amp; (HXTAL_STARTUP_TIMEOUT != timeout));</span><br><span class="line">    <span class="comment">/* if fail */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> == (RCU_CTL0 &amp; RCU_CTL0_HXTALSTB)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* HXTAL is stable */</span></span><br><span class="line">    <span class="comment">/* AHB = SYSCLK */</span></span><br><span class="line">    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;</span><br><span class="line">    <span class="comment">/* APB2 = AHB/2 */</span></span><br><span class="line">    RCU_CFG0 |= RCU_APB2_CKAHB_DIV2;</span><br><span class="line">    <span class="comment">/* APB1 = AHB/2 */</span></span><br><span class="line">    RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PLL = HXTAL/2 * 27 = 108 MHz */</span></span><br><span class="line">    RCU_CFG0 &amp;= ~(RCU_CFG0_PLLSEL | RCU_CFG0_PLLMF | RCU_CFG0_PLLMF4 | RCU_CFG0_PLLPREDV);</span><br><span class="line">    RCU_CFG1 &amp;= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PLLMF5 | RCU_CFG1_PREDV);</span><br><span class="line">    RCU_CFG0 |= (RCU_PLLSRC_HXTAL_IRC48M | (RCU_PLL_MUL27 &amp; (~RCU_CFG1_PLLMF5)));</span><br><span class="line">    RCU_CFG1 |= (RCU_PLLPRESEL_HXTAL | RCU_PLL_PREDV2);</span><br><span class="line">    RCU_CFG1 |= (RCU_PLL_MUL27 &amp; RCU_CFG1_PLLMF5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable PLL */</span></span><br><span class="line">    RCU_CTL0 |= RCU_CTL0_PLLEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until PLL is stable */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> == (RCU_CTL0 &amp; RCU_CTL0_PLLSTB)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* select PLL as system clock */</span></span><br><span class="line">    RCU_CFG0 &amp;= ~RCU_CFG0_SCS;</span><br><span class="line">    RCU_CFG0 |= RCU_CKSYSSRC_PLL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until PLL is selected as system clock */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> == (RCU_CFG0 &amp; RCU_SCSS_PLL)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁相环</strong>（PLL，Phase LockingLoop）是一种反馈控制电路，其工作过程当中，当输出信号频率与输入信号频率相同时，可以使输出电压与输入电压保持固定的相位差，就像输入/输出电压的相位被锁住了一样，所以这种电路被称为锁相环。<strong>GD32F350RBT6</strong>内部的 PLL 主要用于根据特定的外部晶振信号来生成其它频率的信号。</p><p><img src="/Project/UINIO-MCU-GD32/6-Clock/1.png"></p><p>观察可以发现，上述代码使能了 <strong>GD32F350RBT6</strong> 内部的 PLL锁相坏，由于当前 <strong>UINIO-MCU-GD32F350RBT6</strong>核心板的外部贴片晶振频率为<code>8MHz</code>，所以<strong>高速外部晶体振荡器时钟</strong><code>HXTAL = 8MHz</code>，这样锁相环的输出频率可以按照如下方式进行计算：</p><p><span class="math display">\[PLL = \frac{HXTAL}{2} \times 27 = \frac{8MHz}{2} \times 27 = 108 MHz\]</span></p><p>上述代码选择了锁相环的输出作为<strong>系统时钟</strong><code>SYSCLK</code>，并且将<strong>高级高性能总线</strong>（<strong>AHB</strong>，AdvancedHigh-performance Bus）时钟配置为了与系统时钟的频率相等：</p><p><span class="math display">\[AHB = SYSCLK = 108 MHz\]</span></p><p>而两条<strong>高级外设总线</strong>（<strong>APB</strong>，AdvancedPeripheral Bus）时钟频率分别为 AHB 总线时钟的二分之一：</p><p><span class="math display">\[\begin{cases}APB1 = \frac{AHB}{2} = \frac{108MHz}{2} = 54MHz \\APB2 = \frac{AHB}{2} = \frac{108MHz}{2} = 54MHz\end{cases}\]</span></p><h1 id="系统滴答定时器-systick">系统滴答定时器 SysTick</h1><p><strong>SysTick 定时器</strong>是一个拥有自动重装载能力的 24位<strong>向下计数器</strong>，所有 ARM Cortex-M4内核微控制器都具备该定时器，从而能够方便的在不同型号微控制器之间进行代码移植。当设定SysTick定时器的初始值并且使能之后，每经过一个系统时钟周期，定时器的计数值就会减去<code>1</code>，当减至 <code>0</code> 的时候，SysTick就会自动重新装载初始值，并且继续开始计数，同时置位内部的<code>COUNTFLAG</code>标志位，并且触发中断（如果使能有相应的定时器中断）。</p><p><img src="/Project/UINIO-MCU-GD32/7-SysTick/1.png"></p><p>观察 <strong>GD32F350RBT6</strong>微控制器<strong>时钟树</strong>可以发现，<code>108MHz</code> 频率的 AHB总线时钟 <code>CK_AHB</code>，在经过 8 分频之后，默认作为了 SysTick系统定时器的时钟源。</p><h2 id="使用-systick_config-配置寄存器">使用 SysTick_Config()配置寄存器</h2><p>标准固件库 <code>Firmware\CMSIS\core_cm4.h</code> 源文件中的<code>SysTick_Type</code> 结构体类型，定义了系统滴答定时器 SysTick相关的寄存器：</p><p><img src="/Project/UINIO-MCU-GD32/7-SysTick/2.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \brief  Structure type to access the System Timer (SysTick).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CTRL;                    <span class="comment">/*!&lt; Offset: 0x000 (R/W)  SysTick Control and Status Register */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> LOAD;                    <span class="comment">/*!&lt; Offset: 0x004 (R/W)  SysTick Reload Value Register       */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> VAL;                     <span class="comment">/*!&lt; Offset: 0x008 (R/W)  SysTick Current Value Register      */</span></span><br><span class="line">    __I  <span class="type">uint32_t</span> CALIB;                   <span class="comment">/*!&lt; Offset: 0x00C (R/ )  SysTick Calibration Register        */</span></span><br><span class="line">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure><p>该源文件中的 <code>SysTick_Config()</code> 函数，则是用于对上述SysTick相关的寄存器进行配置，在初始化和启动系统滴答定时器的同时，产生周期性的中断。概而言之，其主要完成了下面四个步骤的工作：</p><ol type="1"><li>设置 <code>LOAD</code> 重载寄存器的初始值；</li><li>设置 SysTick 定时器中断的优先级为<code>(1 &lt;&lt; 4) - 1 = 15</code>，即优先级为最低；</li><li>配置 <code>VAL</code> 寄存器，装载 SysTick 的计数值；</li><li>配置 <code>CTRL</code> 寄存器，使能 SysTick的时钟源、中断、以及外设本身；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \brief  System Tick Configuration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.</span></span><br><span class="line"><span class="comment">    Counter is in free running mode to generate periodic interrupts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \param [in]  ticks  Number of ticks between two interrupts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return          0  Function succeeded.</span></span><br><span class="line"><span class="comment">    \return          1  Function failed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \note     When the variable &lt;b&gt;__Vendor_SysTickConfig&lt;/b&gt; is set to 1, then the</span></span><br><span class="line"><span class="comment">    function &lt;b&gt;SysTick_Config&lt;/b&gt; is not included. In this case, the file &lt;b&gt;&lt;i&gt;device&lt;/i&gt;.h&lt;/b&gt;</span></span><br><span class="line"><span class="comment">    must contain a vendor-specific implementation of this function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((ticks - <span class="number">1</span>) &gt; SysTick_LOAD_RELOAD_Msk) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);    <span class="comment">/* Reload value impossible */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;LOAD  = ticks - <span class="number">1</span>;                                  <span class="comment">/* set reload register */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, (<span class="number">1</span> &lt;&lt; __NVIC_PRIO_BITS) - <span class="number">1</span>); <span class="comment">/* set Priority for SysTick Interrupt */</span></span><br><span class="line">    SysTick-&gt;VAL   = <span class="number">0</span>;                                          <span class="comment">/* Load the SysTick Counter Value */</span></span><br><span class="line">    SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk |</span><br><span class="line">                     SysTick_CTRL_TICKINT_Msk   |</span><br><span class="line">                     SysTick_CTRL_ENABLE_Msk;                    <span class="comment">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滴答定时器官方示例-systick.c">滴答定时器官方示例 systick.c</h2><p><strong>Keil-GD32F350RBT6</strong> 示例工程 <code>Sources</code>目录下提供的 <code>systick.c</code> 源文件，其中的<code>systick_config()</code> 方法就封装并且调用了上面的<code>SysTick_Config()</code> 函数，在使能 SysTick中断服务程序与定时器的同时，以系统时钟频率的千分之一<code>SystemCoreClock / 1000U</code> 作为 SysTick滴答定时器配置参数，也就是<strong>每 1 秒计数一千次，每一次 1毫秒</strong>（如果修改为 <code>SystemCoreClock / 1000000U</code>则可以实现微秒级的延时）。</p><p>而 <code>systick.c</code> 源文件当中提供的另一个函数<code>delay_1ms()</code>，则是以 <code>count</code>参数（单位为毫秒）进行定时计数，当 <code>volatile</code>关键字修饰的<strong>全局变量</strong> <code>delay</code>被自减至零的时候，就会自动退出该函数的执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the systick configuration file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">uint32_t</span> delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure systick</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      delay a time in milliseconds</span></span><br><span class="line"><span class="comment">    \param[in]  count: count in milliseconds</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span> &#123;</span><br><span class="line">    delay = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      delay decrement</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，上面 <code>systick.c</code> 代码中定义的<code>delay_decrement()</code> 函数，则会被<strong>Keil-GD32F350RBT6</strong> 工程下<code>Sources/gd32f3x0_it.h/c</code> 源文件内的 SysTick 中断服务程序<code>SysTick_Handler()</code> 调用，具体调用代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      this function handles SysTick exception</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    delay_decrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当每一次进入 SysTick系统滴答定时器中断的时候，上面这个函数就会被调用一次，从而就完成了一次对于<code>delay</code> 变量的自减。</p><h2 id="编写-main.c-测试代码">编写 main.c 测试代码</h2><p>接下来，将前面 <strong>LCD</strong> 示例工程当中的<code>main.c</code> 源文件修改为如下的代码，使得 LED发光二极管可以每间隔 1 秒钟循环进行闪烁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    gpio_bit_set(UINIO_LED_PORT, UINIO_LED_PIN);             <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_reset(UINIO_LED_PORT, UINIO_LED_PIN);           <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uinio_systick_delay_usms">UINIO_SysTick_Delay_us/ms()</h2><p>SysTick 系统滴答定时器的 <code>counter</code> 从 <code>reload</code>值往下递减到零的时候，<code>CTRL</code>寄存器相应的<strong>位</strong>就会被置为<code>1</code>，而读取该位的时候，其值又会自动被清零，所以利用这个特点就能够以非常简短的代码，实现类似于官方SysTic 示例的定时器延时功能：</p><h3 id="driverssystick.h">Drivers/SysTick.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SysTick.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_SysTick_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_SysTick_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_us</span><span class="params">(__IO <span class="type">uint32_t</span> us)</span>;  <span class="comment">// 微秒级延时，参数 us 的单位为微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_ms</span><span class="params">(__IO <span class="type">uint32_t</span> ms)</span>;  <span class="comment">// 毫秒级延时，参数 ms 的单位为毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_SysTick_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driverssystick.c">Drivers/SysTick.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SysTick.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 微秒级延时，参数 us 的单位为微秒 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_us</span> <span class="params">(__IO <span class="type">uint32_t</span> us)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> index;</span><br><span class="line">  SysTick_Config(SystemCoreClock/<span class="number">1000000U</span>);      <span class="comment">// 调用 core_cm4.h 头文件中定义的 SysTick_Config() 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; us; index++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( !((SysTick-&gt;CTRL) &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">16</span>)) );  <span class="comment">// 当计数值减小到 0 时，CRTL 寄存器相应的位会被置为 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;     <span class="comment">// 失能 SysTick 系统滴答定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毫秒级延时，参数 ms 的单位为毫秒 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_ms</span> <span class="params">(__IO <span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> index;</span><br><span class="line">  SysTick_Config(SystemCoreClock/<span class="number">1000U</span>);         <span class="comment">// 调用 core_cm4.h 头文件中定义的 SysTick_Config() 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; ms; index++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( !((SysTick-&gt;CTRL) &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">16</span>)) );  <span class="comment">// 当计数值减小到 0 时，CRTL 寄存器相应的位会被置为 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;     <span class="comment">// 失能 SysTick 系统滴答定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-main.c-测试代码">修改 main.c 测试代码</h2><p>这里可以修改前面的 <code>main.c</code> 源文件，通过自定义的<code>UINIO_SysTick_Delay_us()</code> 和<code>UINIO_SysTick_Delay_ms()</code> 函数来进行延时，从而实现相同的 LED间隔 1 秒循环闪烁的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_us(<span class="number">1000000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：本节内容涉及的全部源代码，已经保存在<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板工程 <code>Examples</code>目录下的 <code>3-Systick</code>。</p></blockquote><h2 id="库函数修改-systick-的时钟源">库函数修改 SysTick 的时钟源</h2><p><strong>Keil-GD32F350RBT6</strong> 示例工程在<code>Firmware\GD32F3x0_standard_peripheral\Source\gd32f3x0_misc.c</code>源文件内提供有一个名为 <code>systick_clksource_set()</code>的库函数，可以用于修改 SysTick的时钟源，其功能与参数说明如下面表格所示：</p><p><img src="/Project/UINIO-MCU-GD32/7-SysTick/3.png"></p><p>可以看到，该库函数可以用于选择 SysTick系统滴答定时器的时钟源，可以选择的参数有如下两个：</p><ul><li><code>SYSTICK_CLKSOURCE_HCLK</code>：系统滴答定时器时钟源来自 AHB时钟；</li><li><code>SYSTICK_CLKSOURCE_HCLK_DIV8</code>: 系统滴答定时器时钟源来自AHB 时钟 8 分频（默认）；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      set the systick clock source</span></span><br><span class="line"><span class="comment">    \param[in]  systick_clksource: the systick clock source needed to choose</span></span><br><span class="line"><span class="comment">                only one parameter can be selected which is shown as below:</span></span><br><span class="line"><span class="comment">      \arg        SYSTICK_CLKSOURCE_HCLK: systick clock source is from HCLK</span></span><br><span class="line"><span class="comment">      \arg        SYSTICK_CLKSOURCE_HCLK_DIV8: systick clock source is from HCLK/8</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_clksource_set</span><span class="params">(<span class="type">uint32_t</span> systick_clksource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(SYSTICK_CLKSOURCE_HCLK == systick_clksource) &#123;</span><br><span class="line">        <span class="comment">/* set the systick clock source from HCLK */</span></span><br><span class="line">        SysTick-&gt;CTRL |= SYSTICK_CLKSOURCE_HCLK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* set the systick clock source from HCLK/8 */</span></span><br><span class="line">        SysTick-&gt;CTRL &amp;= SYSTICK_CLKSOURCE_HCLK_DIV8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于位带-bit-band-执行位操作">基于位带 Bit Band 执行位操作</h1><p>嵌入式开发过程当中，经常需要进行<strong>位操作</strong>（即对一个比特位进行读写），早期的<strong>STC51</strong> 系列单片机可以通过关键字 <code>sbit</code>实现位操作，但是 <strong>ARM Cortex-M4</strong>架构的微控制器并不存在类似语法，而是通过提供<strong>位带别名区</strong>到<strong>位带区</strong>的映射来实现对<strong>比特位</strong>的操作。</p><h2 id="位带别名区-位带区">位带别名区 → 位带区</h2><p><strong>ARM Cortex-M4</strong>存储映射当中包含有<strong>位带别名区</strong>（Bit BandAlias）和<strong>位带区</strong>（Bit BandRegion）两个区域，通过将<strong>位带别名区</strong>（Bit BandAlias）当中的每 1 个 <code>Word</code><strong>字</strong>映射到<strong>位带区</strong>（Bit Band Region）里的<code>Bit</code> <strong>位</strong>（ARM 体系结构中 1个<strong>字</strong>的长度为 32<strong>位</strong>），这样操作<strong>位带别名区</strong>当中的<strong>字</strong>，就等于操作<strong>位带区</strong>相应的<strong>位</strong>，具体原理可以参照下面示意图：</p><p><img src="/Project/UINIO-MCU-GD32/8-Bit-Band/1.png"></p><p>基于 <strong>ARM Cortex-M4</strong> 架构的<strong>GD32F350RBT6</strong>微控制器，分别在两个区域实现了<strong>位带</strong>功能（即从<strong>位带别名区</strong>到<strong>位带区</strong>的映射）：</p><ol type="1"><li><strong>外设 Peripheral</strong> 的<code>0x44000000 ~ 0x42000000</code>地址范围属于<strong>位带别名区</strong>，而最低的<code>0x40100000 ~ 0x40000000</code>区别则属于<strong>位带区</strong>。</li><li><strong>静态随机存储器 SRAM</strong> 的<code>0x24000000 ~ 0x22000000</code>地址范围属于<strong>位带别名区</strong>，而最低的<code>0x20100000 ~ 0x20000000</code>区别则属于<strong>位带区</strong>。</li></ol><h2 id="建立通用的映射公式">建立通用的映射公式</h2><p>下面的公式展示了<strong>位带别名区域</strong>当中的每 1个<strong>字</strong>，如何对应到<strong>位带区域</strong>的相应<strong>位</strong>上面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">映射到位带区目标位的别名区的字地址 = 位带别名区起始地址 + (位带区目标位所在字节的地址偏移量 × <span class="number">32</span>) + (目标位在对应字节当中的位置 × <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>根据上面的公式，位带区目标位的序号为 <code>number</code>（取值范围<code>0 &lt;= number &lt;= 31</code>，具体由待操作的目标寄存器决定），则该比特位在别名区的对应地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标位映射到外设别名区的地址 = <span class="number">0x42000000</span> + (位带区目标位所在字节的地址 - <span class="number">0x40000000</span>) * <span class="number">8</span> * <span class="number">4</span> + (number * <span class="number">4</span>);</span><br><span class="line">目标位映射到 SRAM 别名区的地址 = <span class="number">0x22000000</span> + (位带区目标位所在字节的地址 - <span class="number">0x20000000</span>) * <span class="number">8</span> * <span class="number">4</span> + (number * <span class="number">4</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述公式当中，因为 1 个字节有 8位，所以需要乘以 <code>8</code>，而 1 个位膨胀之后对应着 4个字节，所以需要再乘以 <code>4</code>。</p></blockquote><p>接下来，可以将上述的两个公式合并，成为一个用于将<strong>位带区地址</strong><code>address</code> 和<strong>位序号</strong> <code>bit_number</code>转换为<strong>位带别名区地址</strong>的 <code>BITBAND()</code>宏定义函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(address, bit_number) ((address &amp; 0xF0000000) + 0x02000000 + ((address &amp; 0x00FFFFFF) &lt;&lt; 5) + (bit_number &lt;&lt; 2)) <span class="comment">// 将位带区地址和位序号转换为位带别名区地址</span></span></span><br></pre></td></tr></table></figure><p>上述宏定义语句当中的 <code>address &amp; 0xF0000000</code> 用于取出<code>4</code> 或者 <code>2</code>，并且以此来判断当前操作的是 SRAM还是外设别名区：</p><ul><li>如果取出的是 <code>4</code>，加上 <code>0X0200 0000</code>之后等于<strong>外设别名区的起始地址</strong><code>0X4200 0000</code>;</li><li>如果取出的是 <code>2</code>，加上 <code>0X0200 0000</code> 之后等于<strong>SRAM 别名区的起始地址</strong> <code>0X2200 0000</code>；</li></ul><p>而上述宏定义语句当中 <code>address &amp; 0x00FF FFFF</code>得到的结果，与减去 <code>0X2000 0000</code> 或者<code>0X4000 0000</code> 得到的结果相同，而后续的<code>&lt;&lt; 5</code> 以及 <code>&lt;&lt; 2</code> 则分别起到了乘以<code>32</code> 和乘以 <code>4</code>的作用（即两种计算方式获得的二进制、十进制、十六进制结果完全相同）：</p><table><colgroup><col style="width: 27%"><col style="width: 23%"><col style="width: 24%"><col style="width: 24%"></colgroup><thead><tr class="header"><th style="text-align: left;">乘法与位运算的对应关系</th><th style="text-align: left;"></th><th style="text-align: left;"></th><th style="text-align: left;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>10 * 2 = 10 &lt;&lt; 1</code></td><td style="text-align: left;"><code>10 * 4 = 10 &lt;&lt; 2</code></td><td style="text-align: left;"><code>10 * 8 = 10 &lt;&lt; 3</code></td><td style="text-align: left;"><code>10 * 16 = 10 &lt;&lt; 4</code></td></tr><tr class="even"><td style="text-align: left;"><code>10 * 32 = 10 &lt;&lt; 5</code></td><td style="text-align: left;"><code>10 * 64 = 10 &lt;&lt; 6</code></td><td style="text-align: left;"><code>10 * 108 = 10 &lt;&lt; 7</code></td><td style="text-align: left;"><code>10 * 256 = 10 &lt;&lt; 8</code></td></tr></tbody></table><table><colgroup><col style="width: 27%"><col style="width: 23%"><col style="width: 24%"><col style="width: 24%"></colgroup><thead><tr class="header"><th style="text-align: left;">除法与位运算的对应关系</th><th style="text-align: left;"></th><th style="text-align: left;"></th><th style="text-align: left;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>10 / 2 = 10 &gt;&gt; 1</code></td><td style="text-align: left;"><code>10 / 4 = 10 &gt;&gt; 2</code></td><td style="text-align: left;"><code>10 / 8 = 10 &gt;&gt; 3</code></td><td style="text-align: left;"><code>10 / 16 = 10 &gt;&gt; 4</code></td></tr><tr class="even"><td style="text-align: left;"><code>10 / 32 = 10 &gt;&gt; 5</code></td><td style="text-align: left;"><code>10 / 64 = 10 &gt;&gt; 6</code></td><td style="text-align: left;"><code>10 / 108 = 10 &gt;&gt; 7</code></td><td style="text-align: left;"><code>10 / 256 = 10 &gt;&gt; 8</code></td></tr></tbody></table><p>最后，就可以通过<strong>指针</strong>操作<strong>位带别名区</strong>的地址，进而实现对于<strong>位带区</strong>相应比特位的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_POINTER(address)         *((volatile unsigned long  *)(address))       <span class="comment">// 将地址转换为 unsigned long 类型指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(address, bit_number) ADDRESS_POINTER(BITBAND(address, bit_number)) <span class="comment">// 使用前面定义的宏定义语句 BITBAND()，将位带别名区地址转换为指针</span></span></span><br></pre></td></tr></table></figure><p>由于 <strong>GD32F350RBT6</strong> 微控制器的<code>GPIOA ~ GPIOF</code> 基地址定义如下面列表所示：</p><ol type="1"><li><strong>GPIOA</strong> 基地址：<code>0x4800 0000</code>；</li><li><strong>GPIOB</strong> 基地址：<code>0x4800 0400</code>；</li><li><strong>GPIOC</strong> 基地址：<code>0x4800 0800</code>；</li><li><strong>GPIOD</strong> 基地址：<code>0x4800 0C00</code>；</li><li><strong>GPIOF</strong> 基地址：<code>0x4800 1400</code>；</li></ol><p>则可以将上述 GPIO 接口所对应的<strong>端口输出控制寄存器</strong><code>GPIOx_OCTL</code> 以及<strong>端口输入状态寄存器</strong><code>GPIOx_ISTAT</code> 地址，封装为如下的宏定义语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 端口输出控制寄存器 GPIOx_OCTL 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL_ADDRESS (GPIOA + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_ADDRESS (GPIOB + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_OCTL_ADDRESS (GPIOC + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_OCTL_ADDRESS (GPIOD + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_OCTL_ADDRESS (GPIOE + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OCTL_ADDRESS (GPIOF + 0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输入状态寄存器 GPIOx_ISTAT 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ISTAT_ADDRESS (GPIOA + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ISTAT_ADDRESS (GPIOB + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ISTAT_ADDRESS (GPIOC + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ISTAT_ADDRESS (GPIOD + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ISTAT_ADDRESS (GPIOE + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ISTAT_ADDRESS (GPIOF + 0x10)</span></span><br></pre></td></tr></table></figure><p>上述代码当中的 <code>GPIOx</code> 已经被定义在固件库的<code>gd32f3x0_gpio.h</code> 头文件当中，编译的时候已经由 <strong>KeiluVision5</strong>自动包含相关路径。接下来的时间，就可以基于上面列出的寄存器地址，进一步将它们封装为控制GPIO 输入与输出的宏定义函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 控制 GPIOA 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_Out(number) BIT_ADDRESS(GPIOA_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_In(number)  BIT_ADDRESS(GPIOA_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOB 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_Out(number) BIT_ADDRESS(GPIOB_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_In(number)  BIT_ADDRESS(GPIOB_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOC 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_Out(number) BIT_ADDRESS(GPIOC_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_In(number)  BIT_ADDRESS(GPIOC_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOD 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_Out(number) BIT_ADDRESS(GPIOD_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_In(number)  BIT_ADDRESS(GPIOD_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOF 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_Out(number) BIT_ADDRESS(GPIOF_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_In(number)  BIT_ADDRESS(GPIOF_ISTAT_ADDRESS, number)</span></span><br></pre></td></tr></table></figure><h2 id="完整-keil-µvision-工程代码-2">完整 Keil µVision 工程代码</h2><h3 id="bitband.h">BitBand.h</h3><p>把上述的宏定义代码保存至 <code>Drivers/BitBand</code> 目录下的<code>BitBand.h</code> 头文件里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== BitBand.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_BitBand_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_BitBand_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(address, bit_number) ((address &amp; 0xF0000000) + 0x02000000 + ((address &amp; 0x00FFFFFF) &lt;&lt; 5) + (bit_number &lt;&lt; 2)) <span class="comment">// 将位带区地址和位序号转换为位带别名区地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_POINTER(address)         *((volatile unsigned long  *)(address))                                               <span class="comment">// 将地址转换为 unsigned long 类型指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(address, bit_number) ADDRESS_POINTER(BITBAND(address, bit_number))                                         <span class="comment">// 使用前面定义的宏定义语句 BITBAND()，将位带别名区地址转换为指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输出控制寄存器 GPIOx_OCTL 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL_ADDRESS (GPIOA + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_ADDRESS (GPIOB + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_OCTL_ADDRESS (GPIOC + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_OCTL_ADDRESS (GPIOD + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_OCTL_ADDRESS (GPIOE + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OCTL_ADDRESS (GPIOF + 0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输入状态寄存器 GPIOx_ISTAT 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ISTAT_ADDRESS (GPIOA + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ISTAT_ADDRESS (GPIOB + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ISTAT_ADDRESS (GPIOC + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ISTAT_ADDRESS (GPIOD + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ISTAT_ADDRESS (GPIOE + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ISTAT_ADDRESS (GPIOF + 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOA 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_Out(number) BIT_ADDRESS(GPIOA_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_In(number)  BIT_ADDRESS(GPIOA_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOB 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_Out(number) BIT_ADDRESS(GPIOB_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_In(number)  BIT_ADDRESS(GPIOB_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOC 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_Out(number) BIT_ADDRESS(GPIOC_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_In(number)  BIT_ADDRESS(GPIOC_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOD 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_Out(number) BIT_ADDRESS(GPIOD_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_In(number)  BIT_ADDRESS(GPIOD_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOF 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_Out(number) BIT_ADDRESS(GPIOF_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_In(number)  BIT_ADDRESS(GPIOF_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_BitBand_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="main.c">main.c</h3><p>继续修改之前的 LED 闪烁示例工程 <code>main.c</code> 源文件，在包含<code>BitBand.h</code> 头文件的同时，通过调用宏定义函数<code>GPIOB_Out(8)</code> 修改 <strong>GPIOB8</strong>引脚的电平状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/BitBand/BitBand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();  <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config(); <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    GPIOB_Out(<span class="number">8</span>) = <span class="number">1</span>;      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    GPIOB_Out(<span class="number">8</span>) = <span class="number">0</span>;      <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，也可以将位带操作相关的宏定义代码，更加直观的声明在<code>main.c</code> 源文件当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偏移量 = GPIOB 基地址 0x48000400 + GPIOx_OCTL 偏移量 0x14 - 片上外设起始地址 0x40000000 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_OFFSET ((GPIOB + 0x14) - 0x40000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位带别名区的字地址 = 位带别名区起始地址 + (位带区目标位所在字节的地址偏移量 × 32) + (目标位在对应字节当中的位置 × 4) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(byte_offset, bit_number) (volatile unsigned long *)(0x42000000 + (byte_offset &lt;&lt; 5) + (bit_number &lt;&lt; 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 GPIOB 端口指定引脚的输出状态，例如 GPIOB_OUT(8) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OUT(number) *(BIT_ADDRESS(GPIOB_OCTL_OFFSET, number))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config(); <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    GPIOB_OUT(<span class="number">8</span>) = <span class="number">1</span>;      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    GPIOB_OUT(<span class="number">8</span>) = <span class="number">0</span>;      <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gpio-输入模式与按键">GPIO 输入模式与按键</h1><h2 id="按键使用原理">按键使用原理</h2><p><strong>微动开关</strong>或者<strong>轻触按键</strong>是通过内部的<code>触点</code>与<code>弹片</code>来实现导通与截止，将其连接至<strong>GD32F350RBT6</strong> 的 GPIO 引脚，就可以通过检测其按下之后GPIO 引脚获取的电平状态，来判断当前是处于按下还是松开的情况：</p><p><img src="/Project/UINIO-MCU-GD32/9-Key/1.png"></p><p>当按键在被按下或者松开的时候，会由于触点上弹片的弹性作用，发生<code>5ms ~ 10ms</code> 机械抖动，为了避免 GPIO得到错误的状态，必须考虑采取一定的措施去消除这种抖动所带来的干扰：</p><ul><li><strong>硬件消抖</strong>：微动开关两侧并联上一枚<strong>电容</strong>，利用其充放电作用吸收抖动产生的振荡。</li><li><strong>软件消抖</strong>：当开关按下时，通过延时代码规避掉抖动发生的时间。</li></ul><p>首先，将一枚轻触按键 <code>SW1</code> 连接到<strong>UINIO-MCU-GD32F350RBT6</strong> 的 <strong>GPIOB9</strong>引脚，其中一端连接至 <code>3V3</code> 引脚，而另一端经过位号为<code>R3</code> 的 <code>10KΩ</code> <strong>下拉电阻</strong>之后连接至<code>GND</code> 引脚：</p><p><img src="/Project/UINIO-MCU-GD32/9-Key/2.png"></p><p>然后，使用固件库提供的工具函数，把 <strong>GPIOB9</strong>配置为带<strong>下拉电阻</strong>的<strong>输入模式</strong>，通过检测该引脚的电平状态，就可以判断按键<code>SW1</code>是否被按下（按键松开为<strong>低电平</strong>，按键按下为<strong>高电平</strong>）。</p><h2 id="完整-keil-µvision-工程代码-3">完整 Keil µVision 工程代码</h2><p>如前所述，使用 GPIO端口的输入输出功能，通常会需要经历下面三个步骤：</p><ol type="1"><li>通过<code>void rcu_periph_clock_enable(rcu_periph_enum periph);</code>固件库函数启用 GPIO 端口对应的<strong>外设时钟</strong>。</li><li>通过<code>void gpio_mode_set(uint32_t gpio_periph, uint32_t mode, uint32_t pull_up_down, uint32_t pin);</code>固件库函数配置 GPIO 端口的<strong>工作模式</strong>（输入模式<code>GPIO_MODE_INPUT</code>、输出模式<code>GPIO_MODE_OUTPUT</code>、备用功能模式<code>GPIO_MODE_AF</code>、模拟模式<code>GPIO_MODE_ANALOG</code>），以及设置<strong>上下拉电阻状态</strong>（悬空无上下拉<code>GPIO_PUPD_NONE</code>、带上拉电阻<code>GPIO_PUPD_PULLUP</code>、带下拉电阻<code>GPIO_PUPD_PULLDOWN</code>）。</li><li>通过<code>void gpio_bit_toggle(uint32_t gpio_periph, uint32_t pin);</code>固件库函数翻转 LED 对应 GPIO 引脚的电平状态。</li></ol><blockquote><p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目<code>Examples</code> 目录下的 <strong>5-Key</strong> 工程当中。</p></blockquote><h3 id="driverskey.h">Drivers/key.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Key.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_RCU  RCU_GPIOB   <span class="comment">// 宏定义按键对应的 GPIO 端口时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PORT GPIOB       <span class="comment">// 宏定义按键对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PIN  GPIO_PIN_9  <span class="comment">// 宏定义按键对应的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 调用开关对应 GPIO 引脚的配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_Scan</span><span class="params">(<span class="type">void</span>)</span>;         <span class="comment">// 按键状态扫描函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_KEY_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driverskey.c">Drivers/key.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Key.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键对应 GPIO 引脚的配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_KEY_RCU);                                            <span class="comment">// 使能外设时钟</span></span><br><span class="line">  gpio_mode_set(UINIO_KEY_PORT, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, UINIO_KEY_PIN); <span class="comment">// 配置 GPIO 为带下拉电阻的输入模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_Scan</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断按键是否被按下（高电平按下，低电平松开） */</span></span><br><span class="line">  <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">    delay_1ms(<span class="number">20</span>);                                                       <span class="comment">// 延时 20 毫秒，规避按键弹片抖动时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次判断按键是否被按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">      gpio_bit_toggle(UINIO_LED_PORT, UINIO_LED_PIN);                    <span class="comment">// 翻转 LED 对应 GPIO 引脚的电平状态</span></span><br><span class="line">      <span class="keyword">while</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET);  <span class="comment">// 判断按键是否被松开</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-2">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/Key/Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 滴答定时器初始化</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 配置 LED 相关的 GPIO 外设</span></span><br><span class="line">  UINIO_Key_GPIO_Config();  <span class="comment">// 配置按键相关的 GPIO 外设</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UINIO_Key_Scan();       <span class="comment">// 循环扫描按键状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="usart-通用同步异步收发器">USART 通用同步/异步收发器</h1><h2 id="usart-串行协议分析">USART 串行协议分析</h2><p><strong>通用同步/异步收发器</strong>（USART，UniversalSynchronous/Asynchronous ReceiverTransmitter）是一种基于<strong>数据帧</strong>的串行数据通信方式，每一个数据帧都会以1 个<code>起始位</code>开始，并且以 1个<code>停止位</code>结束，其数据帧的基本格式如下面示意图所示：</p><p><img src="/Project/UINIO-MCU-GD32/10-USART/1.png"></p><ol type="1"><li><strong>起始位</strong>：首先发送一个起始位，通常为逻辑低电平<code>0</code>，用于通知接收端数据即将开始发送。</li><li><strong>数据位</strong>：紧接着是数据位，可以有 <code>5 ~ 8</code>位长度，按照由 <strong>LSB</strong>（最低有效位）到<strong>MSB</strong>（最高有效位）的顺序发送。</li><li><strong>校验位</strong>：数据位之后是可选的奇偶校验位，用于检查数据传输过程当中，是否存在错误。</li><li><strong>停止位</strong>：最后是停止位，通常为逻辑高电平<code>1</code>，用于标记数据帧传输完毕。</li></ol><blockquote><p><strong>注意</strong>：<strong>空闲帧</strong>与停止位一样均为<strong>高电平</strong>，如果USART连接断开，则下拉为<strong>低电平</strong>，从而成为<strong>断开帧</strong>。</p></blockquote><p><strong>USART</strong>串行接口可以工作在<strong>单工</strong>（单向通信）、<strong>半双工</strong>（双向分时通信）、<strong>全双工</strong>（双向通信）模式下。每个USART 通信设备之间的 <strong>波特率</strong>（单位为<code>bit/s</code>，即每秒钟传送的比特位数）、<strong>数据位</strong>、<strong>停止位</strong>、<strong>奇偶校验位</strong>必须保持一致。</p><p><img src="/Project/UINIO-MCU-GD32/10-USART/2.png"></p><p>将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板与另一款 UINIO系列开源硬件 <a href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>串口调试器</a> ，参照下图的线路相互进行连接（即<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOA9</code> 和<code>GPIOA10</code> 分别连接至 <strong>UINIO-USB-UART</strong>串口调试器的 <code>RXD</code> 和 <code>TXD</code> 引脚），并且将后者的Type-C 接口通过 USB 线缆连接至计算机，从而建立起与串行通信上位机软件的USART 连接，进而可以查看到后续实验代码所打印出的测试数据。</p><h2 id="完整-keil-µvision-工程代码-4">完整 Keil µVision 工程代码</h2><p>使用 <strong>GD32F350RBT6</strong> 的片上 USART外设进行通信，需要经历下面六个步骤：</p><ol type="1"><li>使能 USART 和 GPIO 外设时钟<code>rcu_periph_clock_enable()</code>。</li><li>配置 GPIO 复用模式 <code>gpio_af_set()</code>。</li><li>配置 GPIO 的工作模式 <code>gpio_mode_set()</code>。</li><li>配置 GPIO 的输出模式与速度<code>gpio_output_options_set</code>。</li><li>复位 USART 外设 <code>usart_deinit()</code>，并且配置其工作参数<code>usart_deinit()</code>、<code>usart_baudrate_set()</code>、<code>usart_parity_config()</code>、<code>usart_word_length_set()</code>、<code>usart_stop_bit_set()</code>。</li><li>使能 USART 串口 <code>usart_enable()</code> 及其发送功能<code>usart_transmit_config()</code>。</li></ol><blockquote><p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目<code>Examples</code> 目录下的 <strong>6-USART</strong> 工程当中。</p></blockquote><h3 id="driversusart.h">Drivers/USART.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART USART0             <span class="comment">// 定义 USART 外设资源</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RCU RCU_USART0     <span class="comment">// 定义 USART0 的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_AF GPIO_AF_1       <span class="comment">// 定义 GPIO 引脚的复用功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 外设时钟 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_RCU RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_RCU RCU_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 接口*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_PORT GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 引脚*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_PIN GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_PIN GPIO_PIN_10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_GPIO_Config</span><span class="params">(<span class="type">uint32_t</span> band_rate)</span>; <span class="comment">// USART 外设资源配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_Data</span><span class="params">(<span class="type">char</span> ucch)</span>;            <span class="comment">// 用于发送 1 个字节的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_String</span><span class="params">(<span class="type">char</span> *ucstr)</span>;        <span class="comment">// 用于发送字符串的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_USART_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driversusart.c">Drivers/USART.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置 USART 相关的 GPIO，参数 band_rate 是波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_GPIO_Config</span><span class="params">(<span class="type">uint32_t</span> band_rate)</span> &#123;</span><br><span class="line">  <span class="comment">/* 开启时钟 */</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_TX_RCU); <span class="comment">// 使能 TX 对应 GPIO 引脚的时钟</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_RX_RCU); <span class="comment">// 使能 RX 对应 GPIO 引脚的时钟</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_RCU);    <span class="comment">// 使能 USART 外设时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 GPIO 引脚的复用功能 */</span></span><br><span class="line">  gpio_af_set(UINIO_USART_TX_PORT, UINIO_USART_AF, UINIO_USART_TX_PIN);</span><br><span class="line">  gpio_af_set(UINIO_USART_RX_PORT, UINIO_USART_AF, UINIO_USART_RX_PIN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 TX 和 RX 对应 GPIO 引脚的模式与速度 */</span></span><br><span class="line">  gpio_mode_set(UINIO_USART_TX_PORT, GPIO_MODE_AF, GPIO_PUPD_PULLUP, UINIO_USART_TX_PIN);             <span class="comment">// 配置 TX 引脚为带上拉电阻的复用模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_USART_TX_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_USART_TX_PIN); <span class="comment">// 配置 TX 引脚为推挽输出，速率为 50MHZ</span></span><br><span class="line">  gpio_mode_set(UINIO_USART_RX_PORT, GPIO_MODE_AF, GPIO_PUPD_PULLUP, UINIO_USART_RX_PIN);             <span class="comment">// 配置 RX 引脚为带上拉电阻的复用模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_USART_RX_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_USART_RX_PIN); <span class="comment">// 配置 RX 引脚为推挽输出，速率为 50MHZ</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 USART 串行通信的参数 */</span></span><br><span class="line">  usart_deinit(UINIO_USART);                         <span class="comment">// 复位 USART 外设</span></span><br><span class="line">  usart_baudrate_set(UINIO_USART, band_rate);        <span class="comment">// 设置 USART 波特率</span></span><br><span class="line">  usart_parity_config(UINIO_USART, USART_PM_NONE);   <span class="comment">// 设置 USART 奇偶校验位</span></span><br><span class="line">  usart_word_length_set(UINIO_USART, USART_WL_8BIT); <span class="comment">// 设置 USART 数据位长度为 8 位</span></span><br><span class="line">  usart_stop_bit_set(UINIO_USART, USART_STB_1BIT);   <span class="comment">// 设置 USART 停止位长度为 1 位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使能和配置 USART串口 */</span></span><br><span class="line">  usart_transmit_config(UINIO_USART, USART_TRANSMIT_ENABLE); <span class="comment">// 使能 USART 发送功能</span></span><br><span class="line">  usart_enable(UINIO_USART);                                 <span class="comment">// 使能 USART 串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 USART 发送一个字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_Data</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">  usart_data_transmit(UINIO_USART, (<span class="type">uint8_t</span>)data);              <span class="comment">// 通过 USART 发送数据</span></span><br><span class="line">  <span class="keyword">while</span> (RESET == usart_flag_get(UINIO_USART, USART_FLAG_TBE)); <span class="comment">// 通过发送数据缓冲区空标志位来判断发送是否完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 USART 发送字符串 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_String</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 开始循环发送，当字符串为空或者指针地址为空时跳出 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">string</span> &amp;&amp; *<span class="built_in">string</span>) &#123;</span><br><span class="line">    UINIO_USART_Send_Data(*<span class="built_in">string</span>++);  <span class="comment">// 调用上面的函数，循环发送单个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过重写 C 语言 printf() 不断循环调用的 fputc() 函数，实现串口数据输出的重定向 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span> &#123;</span><br><span class="line">  UINIO_USART_Send_Data(character);    <span class="comment">// 调用上面的函数，发送单个字符</span></span><br><span class="line">  <span class="keyword">return</span> character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-3">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 配置 USART0，并将波特率设置为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> count1 = <span class="number">0</span>;       <span class="comment">// 声明短整型测试变量 count1</span></span><br><span class="line">  <span class="type">float</span> count2 = <span class="number">0.0</span>;              <span class="comment">// 声明浮点型测试变量 count2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 依次发送单个字符 `H` `a` `n` `k` */</span></span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    UINIO_USART_Send_String(<span class="string">&quot;UinIO.com\n&quot;</span>);                   <span class="comment">// 发送字符串 UinIO.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试 printf() 串口打印重定向 */</span></span><br><span class="line">    count1++;                                                 <span class="comment">// 短整型测试变量自增 1</span></span><br><span class="line">    count2 += <span class="number">1.0F</span>;                                           <span class="comment">// 浮点型测试变量自增 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count1 = %d, count2 = %.2f \n&quot;</span>, count1, count2);  <span class="comment">// 向 USART 串行接口打印格式化信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="外部中断-exti">外部中断 EXTI</h1><h2 id="嵌套向量中断控制-nvic">嵌套向量中断控制 NVIC</h2><p><strong>GD32F350RBT6</strong> 微控制器所采用的 ARM Cortex-M4内核架构集成有<strong>嵌套式矢量型中断控制器</strong>（NVIC，NestedVectored Interrupt Controller），主要用于管理和处理中断：</p><ol type="1"><li><strong>中断管理</strong>：当中断源产生中断信号的时候，NVIC就会捕获处理这些信号。</li><li><strong>优先级处理</strong>：通过对中断优先级进行排序，NVIC会确保高优先级的中断首先得到处理。</li><li><strong>中断嵌套</strong>：如果在一个中断服务程序当中，发生了另外一个更高优先级的中断，NVIC会暂停处理当前中断，转而处理更高优先级的中断。</li><li><strong>向量中断</strong>：每一个中断都关联有一个固定地址的中断服务程序，当中断发生时NVIC 就会根据这个地址去执行相应的中断服务程序。</li><li><strong>中断屏蔽</strong>：NVIC允许通过编程来屏蔽某些中断，以防止它们被处理，该功能在特定情况下非常有用，例如需要执行关键任务而不希望被其它中断事件打断的时候。</li><li><strong>低功耗模式支持</strong>：NVIC与微控制器的低功耗模式紧密集成，休眠模式下 NVIC 可以检测外部中断并且唤醒MCU，从而实现在低功耗状态下的快速响应。</li></ol><h2 id="外部中断事件控制器-exti">外部中断/事件控制器 EXTI</h2><p><strong>外部中断/事件控制器</strong>（EXTI，External Interrupt/EventController）负责检测来自于中断源的中断请求，并且通知微控制器进行处理。其包含有24个相互独立的边沿检测电路（每个边沿检测电路都可以独立进行配置与屏蔽），能够在微控制器内核当中产生<strong>中断请求</strong>以及<strong>唤醒事件</strong>。每一个中断都拥有4 位的<strong>中断优先级配置位</strong>，可以提供 16个<strong>中断优先等级</strong>，并且这些中断都拥有着<strong>上升沿</strong>、<strong>下降沿</strong>、<strong>任意边沿</strong>三种触发方式：</p><p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/1.png"></p><ol type="1"><li><strong>中断线配置</strong>：配置<strong>外部中断线</strong>（EXTILine），也就是 MCU当中用于接收中断请求的<strong>物理线路</strong>。</li><li><strong>触发条件方式</strong>：设置中断的触发方式，即<code>上升沿</code>、<code>下降沿</code>、<code>任意边沿</code>。</li><li><strong>中断优先级管理</strong>：分配不同的中断优先级，确保 MCU能够按照预期的顺序与优先级处理中断请求。</li><li><strong>中断请求生成与处理</strong>：当外部事件满足中断触发条件时，生成一个中断请求发送给<strong>NVIC</strong>（嵌套向量中断控制器），后者会根据中断的优先级来决定是否响应该中断，如果需要响应，就会暂停执行当前的程序，转而将控制权移交给指定的<strong>ISR</strong>（中断服务程序，Interrupt Service Routine）。</li><li><strong>中断服务程序执行</strong>：在 ISR中断服务程序当中，可以编写代码处理外部事件。待处理完毕之后，就会将控制权返还给刚才被中断的程序，从之前暂停的位置继续运行。</li></ol><p><strong>EXTI</strong> 中断的<strong>触发源</strong>可以来自于<code>GPIOA/B/C/F (0~15)</code> 引脚，以及<code>LVD</code>（低电压检测）、<code>RTC</code>（实时时钟）、<code>CEC</code>（HDMI的 CEC控制器）、<code>CMP</code>（比较器）、<code>USB</code>、<code>USART</code>等片上外设：</p><p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/2.png"></p><blockquote><p><strong>注意</strong>：上述表格当中 <strong>EXTI中断线</strong>与<strong>触发源</strong>的对应关系非常重要。</p></blockquote><p>接下来的实验里，首先需要将一枚轻触按键 <code>SW2</code> 连接到<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <strong>GPIOA0</strong>引脚，其中一端连接至 <code>3V3</code>，而另外一端经过位号为<code>R5</code> 的 <code>10KΩ</code> 下拉电阻之后连接至<code>GND</code>。然后再把 <code>LED3</code> 的一端通过限流电阻<code>R4</code> 连接至 <strong>GPIOB8</strong> 引脚，另外一端连接到<code>GND</code> 引脚：</p><p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/3.png"></p><p>最后，再将 <strong>UINIO-MCU-GD32F350RBT6</strong> 的<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 分别连接至<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和<code>TXD</code> 引脚，以便于通过上位机软件观察 USART串口输出的调试数据。</p><h2 id="完整-keil-µvision-工程代码-5">完整 Keil µVision 工程代码</h2><p>使用 <strong>GD32F350RBT6</strong> 微控制器的 EXTI外部中断功能，通常需要经历下面一系列步骤：</p><ol type="1"><li>通过 <code>rcu_periph_clock_enable()</code> 使能 GPIO 引脚和 CGFCMP系统配置外设时钟。</li><li>调用 <code>nvic_priority_group_set()</code>配置<strong>优先级分组</strong>。</li><li>调用 <code>nvic_irq_enable()</code> 使能 NVIC中断，并且配置<strong>抢占优先级</strong>和<strong>响应优先级</strong>。</li><li>通过 <code>syscfg_exti_line_config()</code> 将中断线与 GPIO引脚进行连接。</li><li>调用 <code>exti_init()</code>设置<strong>中断线</strong>、<strong>中断模式</strong>、<strong>触发类型</strong>。</li><li>使能中断线 <code>exti_interrupt_enable()</code>，并且清除中断标志位<code>exti_interrupt_flag_clear()</code>。</li><li>编写已经在 <code>startup_gd32f3x0.s</code>启动文件当中定义好名称，且参数和返回值皆为 <code>void</code>的<strong>中断服务函数</strong>（每次中断执行完毕之后都需要清除一下中断标志位）。</li></ol><blockquote><p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目<code>Examples</code> 目录下的 <strong>7-EXTI-Key</strong>工程当中。</p></blockquote><h3 id="driversexti-key.h">Drivers/EXTI-Key.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== EXTI-Key.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_EXTI_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_EXTI_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PORT GPIOA       <span class="comment">// 按键对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PIN  GPIO_PIN_0  <span class="comment">// 按键对应的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_RCU  RCU_GPIOA   <span class="comment">// 按键对应 GPIO 端口的外设时钟</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_PORT_SOURCE EXTI_SOURCE_GPIOA   <span class="comment">// 定义用于 EXTI 的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_PIN_SOURCE  EXTI_SOURCE_PIN0    <span class="comment">// 定义用于 EXTI 的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_LINE        EXTI_0              <span class="comment">// 定义 EXTI 中断线 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_IRQN        EXTI0_1_IRQn        <span class="comment">// 定义 EXTI 线 0 和线 1 中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_IRQ_Handler EXTI0_1_IRQHandler  <span class="comment">// 定义 EXTI 中断函数的名称</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_EXTI_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 按键中断配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_EXTI_KEY_H */</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述代码当中的<strong>中断线 0 和 1</strong>的中断服务函数名称 <code>EXTI0_1_IRQHandler</code> 已经被定义在<code>startup_gd32f3x0.s</code> 启动文件当中。</p></blockquote><h3 id="driversexti-key.c">Drivers/EXTI-Key.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== EXTI-Key.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../EXTI-Key/EXTI-Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按键中断配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_EXTI_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_KEY_RCU);  <span class="comment">// 使能按键对应的 GPIO 外设时钟</span></span><br><span class="line">  rcu_periph_clock_enable(RCU_CFGCMP);     <span class="comment">// 使能 CGFCMP 系统配置外设时钟</span></span><br><span class="line"></span><br><span class="line">  gpio_mode_set(UINIO_KEY_PORT, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, UINIO_KEY_PIN);  <span class="comment">// 配置按键对应的 GPIO 引脚为带下拉电阻的输入模式，默认为低电平</span></span><br><span class="line">  nvic_irq_enable(UINIO_KEY_EXTI_IRQN, <span class="number">3U</span>, <span class="number">3U</span>);                                       <span class="comment">// 使能 NVIC 中断，抢占优先级 1，子优先级 1</span></span><br><span class="line"></span><br><span class="line">  syscfg_exti_line_config(UINIO_KEY_EXTI_PORT_SOURCE, UINIO_KEY_EXTI_PIN_SOURCE);  <span class="comment">// 配置 GPIO 引脚作为 EXTI 外部中断</span></span><br><span class="line">  exti_init(UINIO_KEY_EXTI_LINE, EXTI_INTERRUPT, EXTI_TRIG_BOTH);                  <span class="comment">// 初始化 EXTI 外部中断线</span></span><br><span class="line">  exti_interrupt_enable(UINIO_KEY_EXTI_LINE);                                      <span class="comment">// 使能 EXTI 外部中断</span></span><br><span class="line">  exti_interrupt_flag_clear(UINIO_KEY_EXTI_LINE);                                  <span class="comment">// 清除 EXTI 外部中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按键中断处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_KEY_EXTI_IRQ_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 如果中断标志位为 1，那么表示按键被按下 */</span></span><br><span class="line">  <span class="keyword">if</span> (exti_interrupt_flag_get(UINIO_KEY_EXTI_LINE) == SET) &#123;</span><br><span class="line">    <span class="comment">/* 当按键被按下时，执行的任务 */</span></span><br><span class="line">    <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">      gpio_bit_toggle(UINIO_LED_PORT, UINIO_LED_PIN);  <span class="comment">// 翻转 LED 电平状态</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Key Press\n&quot;</span>);                           <span class="comment">// 串口打印 Key Press</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当按键被松开时，执行的任务 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Key Release\n&quot;</span>);                         <span class="comment">// 串口打印 Key Release</span></span><br><span class="line">    &#125;</span><br><span class="line">    exti_interrupt_flag_clear(UINIO_KEY_EXTI_LINE);    <span class="comment">// 清除 EXTI 外部中断标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-4">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/EXTI-Key/EXTI-Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 配置优先级分组（2 位用于抢占优先级，2 位用于响应优先级） */</span></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line"></span><br><span class="line">  UINIO_LED_GPIO_Config();         <span class="comment">// 初始化 LED 对应的 GPIO 引脚资源</span></span><br><span class="line">  UINIO_EXTI_Key_GPIO_Config();    <span class="comment">// 初始化按键所对应 GPIO 引脚的中断配置</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时器-timer-概览">定时器 TIMER 概览</h1><p><strong>GD32F350RBT6</strong>微控制器的定时器是一个可编程的无符号<strong>计数器</strong>，支持<code>输入捕获</code>与<code>输出比较</code>，可以按照功能特性被划分为六种类型：</p><ol type="1"><li><strong>高级定时器</strong>（<code>TIMER0</code>）；</li><li><strong>通用定时器 L0</strong>（<code>TIMER1</code> 和<code>TIMER2</code>）；</li><li><strong>通用定时器 L2</strong>（<code>TIMER13</code>）；</li><li><strong>通用定时器 L3</strong>（<code>TIMER14</code>）；</li><li><strong>通用定时器 L4</strong>（<code>TIMER15</code> 和<code>TIMER16</code>）；</li><li><strong>基本定时器</strong>（<code>TIMER5</code>）；</li></ol><p>也就是 1 个 <strong>16位高级定时器</strong>（<code>TIMER0</code>），1 个 <strong>32位通用定时器</strong>（<code>TIMER1</code>），5 个 <strong>16位通用定时器</strong>（<code>TIMER2</code>、<code>TIMER13 ~ TIMER16</code>），1个 <strong>16 位基本定时器</strong>（<code>TIMER5</code>）。</p><h2 id="高级定时器-timer0">高级定时器 TIMER0</h2><p><strong>高级定时器（TIMER0）</strong>属于可编程的<strong>四通道定时器</strong>，包含有<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生PWM信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p><table><colgroup><col style="width: 31%"><col style="width: 68%"></colgroup><thead><tr class="header"><th style="text-align: left;">高级定时器 TIMER0 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>总通道数</strong></td><td style="text-align: left;"><strong>4 通道</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER0</code> 是 <strong>16位</strong></td></tr><tr class="odd"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟、内部触发、外部输入、外部触发</td></tr><tr class="even"><td style="text-align: left;"><strong>多种计数模式</strong></td><td style="text-align: left;">向上计数、向下计数、中央计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>正交编码器接口</strong></td><td style="text-align: left;">用于追踪运动和分辨旋转方向和位置</td></tr><tr class="even"><td style="text-align: left;"><strong>霍尔传感器接口</strong></td><td style="text-align: left;">可以用于控制三相电机</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="even"><td style="text-align: left;"><strong>每个通道可配置</strong></td><td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM模式、单脉冲模式</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的死区时间</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中止输入功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td><td style="text-align: left;">更新事件、触发事件、比较/捕获事件、换相事件、中止事件</td></tr><tr class="even"><td style="text-align: left;"><strong>多个定时器的菊链</strong></td><td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td></tr><tr class="odd"><td style="text-align: left;"><strong>定时器的同步</strong></td><td style="text-align: left;">允许被选择的定时器在同一个时钟周期开始计数</td></tr><tr class="even"><td style="text-align: left;"><strong>定时器主-从管理</strong></td><td style="text-align: left;">支持</td></tr></tbody></table><p>下面的结构框图提供了<strong>高级定时器（TIMER0）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/1.png"></p><h2 id="通用定时器-l0---timer1-timer2">通用定时器 L0 - TIMER1,TIMER2</h2><p><strong>通用定时器 L0（TIMER1,TIMER2）</strong>同样属于可编程的<strong>四通道定时器</strong>，包含有<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生PWM 信号控制电机以及进行电源管理，其主要特性如下表所示：</p><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr class="header"><th style="text-align: left;">高级定时器 TIMER1, TIMER2 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>总通道数</strong></td><td style="text-align: left;"><strong>4 通道</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER2</code> 是 <strong>16位</strong>，<code>TIMER1</code> 是 <strong>32 位</strong></td></tr><tr class="odd"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟、内部触发、外部输入、外部触发</td></tr><tr class="even"><td style="text-align: left;"><strong>多种计数模式</strong></td><td style="text-align: left;">向上计数、向下计数、中央计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>正交编码器接口</strong></td><td style="text-align: left;">用于追踪运动和分辨旋转方向和位置</td></tr><tr class="even"><td style="text-align: left;"><strong>霍尔传感器接口</strong></td><td style="text-align: left;">可以用于控制三相电机</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="even"><td style="text-align: left;"><strong>每个通道可配置</strong></td><td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM模式、单脉冲模式</td></tr><tr class="odd"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td><td style="text-align: left;">更新事件、触发事件、比较/捕获事件</td></tr><tr class="odd"><td style="text-align: left;"><strong>多个定时器的菊链</strong></td><td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td></tr><tr class="even"><td style="text-align: left;"><strong>定时器的同步</strong></td><td style="text-align: left;">允许被选择的定时器在同一个时钟周期开始计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>定时器主-从管理</strong></td><td style="text-align: left;">支持</td></tr></tbody></table><p>下面的结构框图提供了<strong>通用定时器 L0（TIMER1,TIMER2）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/2.png"></p><h2 id="通用定时器-l2---timer13">通用定时器 L2 - TIMER13</h2><p><strong>通用定时器L2（TIMER13）</strong>属于可编程的<strong>单通道定时器</strong>，包含有<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生PWM 信号控制电机以及进行电源管理，其主要特性如下表所示：</p><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th style="text-align: left;">高级定时器 TIMER13 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>总通道数</strong></td><td style="text-align: left;"><strong>1 通道</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER13</code> 是 <strong>16位</strong></td></tr><tr class="odd"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟</td></tr><tr class="even"><td style="text-align: left;"><strong>计数模式</strong></td><td style="text-align: left;">向上计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="even"><td style="text-align: left;"><strong>每个通道可配置</strong></td><td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM模式</td></tr><tr class="odd"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中断输出</strong></td><td style="text-align: left;">更新事件、比较/捕获事件</td></tr></tbody></table><p>下面的结构框图提供了<strong>通用定时器L2（TIMER13）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/3.png"></p><h2 id="通用定时器-l3---timer14">通用定时器 L3 - TIMER14</h2><p><strong>通用定时器L3（TIMER14）</strong>属于可编程的<strong>两通道定时器</strong>，包含有<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生PWM信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p><table><colgroup><col style="width: 31%"><col style="width: 68%"></colgroup><thead><tr class="header"><th style="text-align: left;">高级定时器 TIMER14 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>总通道数</strong></td><td style="text-align: left;"><strong>2 通道</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER14</code> 是 <strong>16位</strong></td></tr><tr class="odd"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟、内部触发、外部输入</td></tr><tr class="even"><td style="text-align: left;"><strong>计数模式</strong></td><td style="text-align: left;">向上计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="even"><td style="text-align: left;"><strong>每个通道可配置</strong></td><td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM模式、单脉冲模式</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的死区时间</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中止输入功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td><td style="text-align: left;">更新事件、比较/捕获事件、换相事件、中止事件</td></tr><tr class="even"><td style="text-align: left;"><strong>多个定时器的菊链</strong></td><td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td></tr><tr class="odd"><td style="text-align: left;"><strong>定时器的同步</strong></td><td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td></tr><tr class="even"><td style="text-align: left;"><strong>定时器主-从管理</strong></td><td style="text-align: left;">支持</td></tr></tbody></table><p>下面的结构框图提供了<strong>通用定时器L3（TIMER14）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/4.png"></p><h2 id="通用定时器-l4---timer15-timer16">通用定时器 L4 - TIMER15,TIMER16</h2><p><strong>通用定时器 L4（TIMER15,TIMER16）</strong>属于可编程的<strong>单通道定时器</strong>，包含有<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生PWM信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p><table><colgroup><col style="width: 35%"><col style="width: 64%"></colgroup><thead><tr class="header"><th style="text-align: left;">高级定时器 TIMER15, TIMER16 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>总通道数</strong></td><td style="text-align: left;"><strong>单通道</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER15</code> 和<code>TIMER16</code> 都是 <strong>16 位</strong></td></tr><tr class="odd"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟</td></tr><tr class="even"><td style="text-align: left;"><strong>计数模式</strong></td><td style="text-align: left;">向上计数</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="even"><td style="text-align: left;"><strong>每个通道可配置</strong></td><td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM模式、单脉冲模式</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的死区时间</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中止输入功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="odd"><td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td><td style="text-align: left;">更新事件、比较/捕获事件、换相事件、中止事件</td></tr></tbody></table><p>下面的结构框图提供了<strong>通用定时器 L4（TIMER15,TIMER16）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/5.png"></p><h2 id="基本定时器---timer5">基本定时器 - TIMER5</h2><p><strong>基本定时器（TIMER5）</strong>包含有 <strong>16位无符号计数器</strong>，支持输入捕获与输出比较。可以用于通用定时器，产生DMA 请求，以及为 DAC 数模转换提供时钟，其主要特性如下表所示：</p><table><thead><tr class="header"><th style="text-align: left;">基本定时器 TIMER5 特性</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>计数器宽度</strong></td><td style="text-align: left;"><code>TIMER5</code> 是 <strong>16位</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>时钟源可选</strong></td><td style="text-align: left;">内部时钟</td></tr><tr class="odd"><td style="text-align: left;"><strong>计数模式</strong></td><td style="text-align: left;">向上计数</td></tr><tr class="even"><td style="text-align: left;"><strong>可编程的预分频器</strong></td><td style="text-align: left;">16 位（运行时可以被改变）</td></tr><tr class="odd"><td style="text-align: left;"><strong>自动重装载功能</strong></td><td style="text-align: left;">支持</td></tr><tr class="even"><td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td><td style="text-align: left;">更新事件</td></tr></tbody></table><p>下面的结构框图提供了<strong>基本定时器（TIMER5）</strong>的内部配置细节：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/6.png"></p><h1 id="基本定时器-timer5-与中断">基本定时器 TIMER5 与中断</h1><p>本章节内容，将会利用<strong>基本定时器</strong> <code>TIMER5</code>以及其关联的定时器中断，来实现让 LED 每隔 1秒不间断进行闪烁的实验。其中，定时器<strong>时钟</strong>和<strong>运行参数</strong>的配置，是两个比较重要的知识点，需要大家在实验过程当中特别留意。</p><h2 id="定时器时钟配置">定时器时钟配置</h2><p>观察下面定时器相关的<strong>时钟树</strong>，可以发现如果 <strong>APB总线</strong>的时钟<strong>分频系数</strong>为<code>1</code>，那么<strong>定时器时钟频率</strong>就会与 <strong>AHB总线</strong>保持一致。否则，定时器的时钟频率会被设定为 <strong>APB总线</strong>频率的 <strong>2 倍</strong>：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/7.png"></p><p>可以看到，<strong>系统时钟</strong> <code>CK_SYS</code> 在经过<strong>AHB 预分频器</strong>之后，可以得到 AHB 总线时钟<code>CK_AHB</code>。而这个 <code>CK_AHB</code> 再经过 <strong>APB1 和APB2 预分频器</strong>之后，就可以得到<strong>定时器时钟</strong><code>CK_TIMERx</code>，具体请参考下面的计算公式：</p><p><span class="math display">\[CK_{TIMERx} = \frac{CK_{AHB}}{APB_{x预分频值} \div 2}\]</span></p><p>由于固件库 <code>system_gd32f3x0.c</code> 源文件的<code>system_clock_config()</code> 函数当中，已经将<strong>APB1</strong> 和 <strong>APB2</strong> 的预分频值设定为<code>2</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* APB2 = AHB/2 */</span></span><br><span class="line">RCU_CFG0 |= RCU_APB2_CKAHB_DIV2;</span><br><span class="line"><span class="comment">/* APB1 = AHB/2 */</span></span><br><span class="line">RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;</span><br></pre></td></tr></table></figure><p>根据上面的计算公式，就可以知道<strong>定时器时钟</strong><code>CK_TIMERx</code> 与 <strong>AHB 总线时钟</strong><code>CK_AHB</code> 的时钟频率值相等：</p><p><span class="math display">\[CK_{TIMERx} = \frac{CK_{AHB}}{2 \div 2} = CK_{AHB} = 108MHz\]</span></p><h2 id="定时器工作参数配置">定时器工作参数配置</h2><p>官方固件库 <code>gd32f3x0_timer.h</code> 头文件当中定义的结构体变量<code>timer_parameter_struct</code>，可以用于配置定时器的相关工作参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constants definitions */</span></span><br><span class="line"><span class="comment">/* TIMER init parameter struct definitions*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> prescaler;         <span class="comment">/*!&lt; prescaler value */</span></span><br><span class="line">    <span class="type">uint16_t</span> alignedmode;       <span class="comment">/*!&lt; aligned mode */</span></span><br><span class="line">    <span class="type">uint16_t</span> counterdirection;  <span class="comment">/*!&lt; counter direction */</span></span><br><span class="line">    <span class="type">uint16_t</span> clockdivision;     <span class="comment">/*!&lt; clock division value */</span></span><br><span class="line">    <span class="type">uint32_t</span> period;            <span class="comment">/*!&lt; period value */</span></span><br><span class="line">    <span class="type">uint8_t</span>  repetitioncounter; <span class="comment">/*!&lt; the counter repetition value */</span></span><br><span class="line">&#125; timer_parameter_struct;</span><br></pre></td></tr></table></figure><p>在下面的列表里，展示了这些参数的具体功能与用途：</p><ul><li><strong>prescaler</strong>：时钟的 16 位 预分频值，取值范围为<code>0 ~ 65535</code>。</li><li><strong>alignedmode</strong>：对齐模式，可供选取的值有<code>TIMER_COUNTER_EDGE</code>、<code>TIMER_COUNTER_CENTER_DOWN</code>、<code>TIMER_COUNTER_CENTER_UP</code>、<code>TIMER_COUNTER_CENTER_BOTH</code>。</li><li><strong>counterdirection</strong>：计数方向，可供选取的值有<code>TIMER_COUNTER_UP</code> 和 <code>TIMER_COUNTER_DOWN</code>。</li><li><strong>period</strong>：周期，取值范围为<code>0 ~ 65535</code>，当计数器达到周期值的时候，计数值将会清零，可以配合计数器时钟频率计算出中断时间。</li><li><strong>clockdivision</strong>：时钟分频因子，可供选取的值有<code>TIMER_CKDIV_DIV1</code>、<code>TIMER_CKDIV_DIV2</code>、<code>TIMER_CKDIV_DIV4</code>，主要用于输入捕获场景。</li><li><strong>repetitioncounter</strong>：重复计数器值（仅限于高级定时器），取值范围为<code>0 ~ 255</code>。</li></ul><h2 id="实验电路的搭建">实验电路的搭建</h2><p>类似于前面 <a href="#通过-gpio-寄存器控制-led">《通过 GPIO 固件库控制LED》</a> 章节的实验电路，这里同样将 <code>4.7K</code> 限流电阻<code>R1</code> 与 LED 发光二极管串联之后，再连接到<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOB8</code>引脚（高电平点亮，低电平熄灭）：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/8.png"></p><p>除此之外，还需要再将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 引脚，分别连接至<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和<code>TXD</code> 引脚，这样就可以完成实验电路的搭建。</p><h2 id="完整-keil-µvision-工程代码-6">完整 Keil µVision 工程代码</h2><p>本节内容的实验，主要基于 16 位的<strong>基本定时器</strong><code>TIMER5</code> 来实现 LED 每间隔 1秒进行闪烁的效果，完成该功能大致需要经历下面六个步骤：</p><ol type="1"><li><strong>配置定时器时钟</strong>，由于固件库已经默认<code>CK_TIMERx = CK_AHB = 108MHz</code>，所以本示例缺省该步骤。</li><li><strong>配置并且初始化定时器</strong>，也就是设置<code>timer_parameter_struct</code> 结构体的成员属性，然后调用<code>timer_init()</code> 初始化定时器。</li><li>调用 <code>nvic_irq_enable()</code> 设置定时器中断的优先级。</li><li>调用 <code>timer_interrupt_enable()</code>使能定时器<strong>更新中断</strong>事件。</li><li>调用 <code>timer_enable()</code> 函数使能定时器自身。</li><li>自定义<strong>基本定时器 TIMER5</strong> 相关的中断服务函数<code>TIMER5_DAC_IRQHandler()</code>，该函数名称已在启动文件<code>startup_gd32f3x0.s</code> 进行过声明。</li></ol><blockquote><p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目<code>Examples</code> 目录下的 <strong>8-Timer-LED</strong>工程当中。</p></blockquote><h3 id="driverstimer-led.h">Drivers/Timer-LED.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== TIMER_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_TIMER_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_RCU         RCU_TIMER5             <span class="comment">// 定时器 Timer5 时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER             TIMER5                 <span class="comment">// 定时器 Timer5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_IRQ         TIMER5_DAC_IRQn        <span class="comment">// 定时器 Timer5 中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_IRQ_Handler TIMER5_DAC_IRQHandler  <span class="comment">// 定时器 Timer5 中断服务函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_RCU         RCU_TIMER2           // 定时器 Timer2 时钟</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER             TIMER2               // 定时器 Timer2</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_IRQ         TIMER2_IRQn          // 定时器 Timer2 中断</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_IRQ_Handler TIMER2_IRQHandler    // 定时器 Timer2 中断服务函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Basic_Timer_Config</span><span class="params">(<span class="type">uint16_t</span> pre, <span class="type">uint16_t</span> per)</span>; <span class="comment">// 基本定时器配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_TIMER_LED_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driverstimer-led.c">Drivers/Timer-LED.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== TIMER_LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Timer-LED/Timer-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 基本定时器配置，参数 UINIO_Clock_Prescale 为时钟预分频值，参数 UINIO_Clock_Period 为时钟周期 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Basic_Timer_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_TIMER_RCU); <span class="comment">// 使能定时器外设时钟</span></span><br><span class="line">  <span class="comment">/* CK_TIMERx = CK_AHB = 108MHz */</span></span><br><span class="line">  timer_deinit(UINIO_TIMER);                <span class="comment">// 复位定时器外设</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置定时器参数 */</span></span><br><span class="line">  timer_parameter_struct TimerParameter;                <span class="comment">// 定义 timer_parameter_struct 定时器参数结构体</span></span><br><span class="line">  TimerParameter.prescaler = UINIO_Clock_Prescale - <span class="number">1</span>;  <span class="comment">// 预分频值，由于该值从 0 开始计数，所以这里需要减去 1</span></span><br><span class="line">  TimerParameter.alignedmode = TIMER_COUNTER_EDGE;      <span class="comment">// 对齐模式，边缘对齐</span></span><br><span class="line">  TimerParameter.counterdirection = TIMER_COUNTER_UP;   <span class="comment">// 计数方向，向上计数</span></span><br><span class="line">  TimerParameter.period = UINIO_Clock_Period - <span class="number">1</span>;       <span class="comment">// 周期，同样由于该值从 0 开始计数，这里同样需要减去 1</span></span><br><span class="line">  TimerParameter.clockdivision = TIMER_CKDIV_DIV1;      <span class="comment">// 时钟分频因子</span></span><br><span class="line">  TimerParameter.repetitioncounter = <span class="number">0</span>;                 <span class="comment">// 重复计数器值，取值范围为 0 ~ 255，配置为 x 就会重复 x+1 次进入中断</span></span><br><span class="line">  timer_init(UINIO_TIMER, &amp;TimerParameter);             <span class="comment">// 初始化定时器</span></span><br><span class="line"></span><br><span class="line">  nvic_irq_enable(UINIO_TIMER_IRQ, <span class="number">3U</span>, <span class="number">3U</span>);             <span class="comment">// 配置定时器中断优先级，抢占优先级 3，子优先级 2</span></span><br><span class="line"></span><br><span class="line">  timer_interrupt_enable(UINIO_TIMER, TIMER_INT_UP);    <span class="comment">// 使能定时器更新中断</span></span><br><span class="line">  timer_enable(UINIO_TIMER);                            <span class="comment">// 使能定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 基本定时器中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_TIMER_IRQ_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断定时器中断标志位 TIMER_INT_FLAG_UP 是否置位 */</span></span><br><span class="line">  <span class="keyword">if</span> (timer_interrupt_flag_get(UINIO_TIMER, TIMER_INT_FLAG_UP) == SET) &#123;</span><br><span class="line">    timer_interrupt_flag_clear(UINIO_TIMER, TIMER_INT_FLAG_UP);  <span class="comment">// 清除定时器更新中断标志位</span></span><br><span class="line">    gpio_bit_toggle(UINIO_LED_Port, UINIO_LED_Pin);              <span class="comment">// 翻转 LED 对应 GPIO 引脚的电平状态</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UinIO.com\n&quot;</span>);                                       <span class="comment">// 串口打印调试信息 UinIO.com</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-5">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/Timer-LED/Timer-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 配置优先级分组（2 位用于抢占优先级，2 位用于响应优先级） */</span></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line"></span><br><span class="line">  UINIO_LED_GPIO_Config();         <span class="comment">// 初始化 LED 对应的 GPIO 引脚资源</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 频率(10800/108)兆赫兹 * 周期(10000)微秒 = 闪烁间隔为 1 秒 */</span></span><br><span class="line">  UINIO_Basic_Timer_Config(<span class="number">10800</span>, <span class="number">10000</span>);    <span class="comment">// 初始化基本定时器，第 1 个参数为时钟预分频值，第 2 个参数为时钟周期</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通用定时器-timer1-与-pwm">通用定时器 TIMER1 与 PWM</h1><h2 id="脉冲宽度调制-pwm-简介">脉冲宽度调制 PWM 简介</h2><p><strong>脉冲宽度调制</strong>（<strong>PWM</strong>，Pulse-widthmodulation）是一种通过将电平信号分散为离散形式，从而达到调整<strong>电压</strong>和<strong>频率</strong>，乃至于<strong>平均功率</strong>的目的。</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/9.png"></p><p>这项技术可以用于动态控制 LED亮度乃至于电机转速，其主要涉及到如下三个重要的参数：</p><ol type="1"><li><strong>频率</strong>（Frequency）：单位时间内周期性事件的重复次数，即PWM 在 1 秒钟之内，脉冲信号完整<strong>周期</strong>的出现次数，其值等于<span class="math inline">\(频率 f = \frac{1}{周期T}\)</span>，单位为<strong>赫兹</strong>。</li><li><strong>周期</strong>（Period）：一个完整信号<strong>周期</strong>所持续的时间，其值等于<span class="math inline">\(周期 T = \frac{1}{频率f}\)</span>，单位为<strong>秒</strong>。</li><li><strong>占空比</strong>（DutyCycle）：在一个完整的脉冲信号<strong>周期</strong>当中，<strong>高电平</strong>所占据的百分比值。</li></ol><h2 id="定时器-timer1-的-pwm-通道">定时器 TIMER1 的 PWM 通道</h2><p><strong>GD32F350RBT6</strong> 微控制器的 <code>TIMER1</code> 是一个<strong>通用定时器</strong>，拥有四路 PWM 通道，其中的每一路通道都对应着1 个 GPIO 引脚（需要进行复用设置）。通过下面的表格，可以发现<code>GPIOA5</code> 引脚的复用功能 <code>AF2</code>，对应的就是<code>TIMER1</code> 定时器的 <code>CH0</code> 通道：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/10.png"></p><blockquote><p><strong>注意</strong>：GPIO 的复用功能可以通过固件库函数<code>void gpio_af_set(uint32_t gpio_periph, uint32_t alt_func_num, uint32_t pin)</code>进行设置。</p></blockquote><h2 id="pwm-脉冲频率的计算">PWM 脉冲频率的计算</h2><p>根据下面<strong>通用定时器</strong> <code>TIMER1</code>的结构框图，可以观察到该定时器各个通道时钟信号的来龙去脉。其中带有层叠效果的框图，表示其对应有<strong>影子寄存器</strong>：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/11.png"></p><blockquote><p><strong>注意</strong>：<strong>影子寄存器</strong>可以让指令重复使用相同的寄存器编码，但是在不同模式下，这些编码对应的是不同的物理寄存器。</p></blockquote><p>相比于之前基本定时器的实验，本实验需要将定时器配置函数<code>UINIO_PWM_Config()</code> 的时钟分频值修改为<code>108</code>，从而使得分频后的定时器时钟频率等于：</p><p><span class="math display">\[分频后的时钟频率 PSC_{CLK} = \frac{定时器时钟频率 108MHz}{预分频值108} =1MHz\]</span></p><p>再根据下面的公式，就可以计算得到此时 PWM 脉冲宽度调制信号的输出频率为<code>100Hz</code>：</p><p><span class="math display">\[PWM 输出频率 = \frac{分频后的时钟频率 1MHz}{周期值 10000 微秒} = 100Hz\]</span></p><blockquote><p><strong>注意</strong>：该脉冲频率远高于肉眼可以鉴别出的<code>50Hz</code> <strong>临界闪烁频率</strong>，所以不会导致 LED发生明显的闪烁现象，可以呈现出比较完美的呼吸灯效果。</p></blockquote><h2 id="实验电路的搭建-1">实验电路的搭建</h2><p>类似于之前 <a href="#基本定时器-timer5-与中断">《基本定时器 TIMER5与中断》</a> 章节的实验电路，这里同样需要将 <code>4.7K</code> 限流电阻<code>R1</code> 与 LED发光二极管进行串联，有所不同之处在于这里需要将其连接至<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOA5</code>引脚，然后由<strong>通用定时器</strong> <code>TIMER1</code> 的通道<code>0</code> 输出 PWM 脉冲信号：</p><p><img src="/Project/UINIO-MCU-GD32/12-Timer/12.png"></p><p>除此之外，依然需要把 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 引脚，分别连接至<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和<code>TXD</code> 引脚，从而能够使用串口上位机软件，查看到当前 LED的亮灭状态调试信息。</p><h2 id="完整-keil-µvision-工程代码-7">完整 Keil µVision 工程代码</h2><p>本实验通过 PWM 输出脉冲波来实现 LED的呼吸灯效果，大致上需要经历如下一系列的配置过程：</p><ol type="1"><li>调用 <code>gpio_af_set()</code> 配置 PWM 功能对应 GPIO引脚的复用功能。</li><li>使用 <code>timer_init()</code> 配置 PWM 定时器参数。</li><li>使用 <code>timer_channel_output_config()</code> 配置 PWM输出通道参数。</li><li>通过 <code>timer_channel_output_pulse_value_config()</code>函数将定时器 <code>TIMER1</code> 通道输出的脉冲值置为<code>0</code>。</li><li>使用 <code>timer_channel_output_mode_config()</code>配置定时器输出通道的比较模式为 PWM 模式 0。</li><li>使用 <code>timer_channel_output_shadow_config()</code>失能定时器输出通道的<strong>比较影子寄存器</strong>。</li><li>调用 <code>timer_auto_reload_shadow_enable()</code>使能定时器<strong>自动重载影子寄存器</strong>。</li><li>调用 <code>timer_enable()</code> 使能 PWM 相关的定时器。</li><li>循环调用 <code>timer_channel_output_pulse_value_config()</code>函数，通过动态设定脉冲值（介于 <code>0 ~ 65535</code> 范围）实现 LED的呼吸灯效果。</li></ol><h3 id="driverspwm-led.h">Drivers/PWM-LED.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== PWM_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_PWM_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_RCU  RCU_GPIOA   <span class="comment">// 定义 PWM 对应 GPIOA 端口的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_PORT GPIOA       <span class="comment">// 定义 PWM 对应的 GPIOA 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_PIN  GPIO_PIN_5  <span class="comment">// 定义 PWM 对应的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_AF   GPIO_AF_2   <span class="comment">// 定义 PWM 对应 GPIO 引脚的复用功能 2</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_TIMER_RCU RCU_TIMER1  <span class="comment">// 定义通用定时器 TIMER1 的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_TIMER     TIMER1      <span class="comment">// 定义通用定时器 TIMER1 自身</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_CHANNEL   TIMER_CH_0  <span class="comment">// 定义定时器的通道 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span>; <span class="comment">// 预定义 PWM 工作参数配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_LED_Breathing</span><span class="params">(<span class="type">void</span>)</span>;                                                <span class="comment">// 预定义 PWM 呼吸灯控制函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_PWM_LED_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driverspwm-led.c">Drivers/PWM-LED.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== PWM_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../PWM-LED/PWM-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置 PWM 功能对应的 GPIO 引脚 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UINIO_PWM_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_PWM_RCU);                                                   <span class="comment">// 使能 PWM 对应 GPIO 引脚的外设时钟</span></span><br><span class="line">  gpio_mode_set(UINIO_PWM_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE, UINIO_PWM_PIN);               <span class="comment">// 配置 GPIO 引脚为悬空的复用功能模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_PWM_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_PWM_PIN); <span class="comment">// 设置 GPIO 引脚的输出模式（推挽输出）与速率（50MHz）</span></span><br><span class="line">  gpio_af_set(UINIO_PWM_PORT, UINIO_PWM_AF, UINIO_PWM_PIN);                                 <span class="comment">// 设置 GPIO 引脚的复用功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置脉冲宽度调制 PWM 的工作参数，参数 UINIO_Clock_Prescale 为时钟预分频值，参数 UINIO_Clock_Period 为时钟周期 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span> &#123;</span><br><span class="line">  UINIO_PWM_GPIO_Config();  <span class="comment">// 调用前面已经定义的 PWM 对应 GPIO 引脚的配置函数</span></span><br><span class="line"></span><br><span class="line">  rcu_periph_clock_enable(UINIO_PWM_TIMER_RCU);  <span class="comment">// 使能定时器 TIMER1 外设时钟</span></span><br><span class="line">  <span class="comment">/* CK_TIMERx = CK_AHB = 108MHz */</span></span><br><span class="line">  timer_deinit(UINIO_PWM_TIMER);                 <span class="comment">// 复位定时器 TIMER1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 PWM 定时器参数 TimerParameter */</span></span><br><span class="line">  timer_parameter_struct TimerParameter;               <span class="comment">// 定义 timer_parameter_struct 定时器参数结构体</span></span><br><span class="line">  TimerParameter.prescaler = UINIO_Clock_Prescale - <span class="number">1</span>; <span class="comment">// 预分频值，由于该值从 0 开始计数，所以这里需要减去 1</span></span><br><span class="line">  TimerParameter.alignedmode = TIMER_COUNTER_EDGE;     <span class="comment">// 对齐模式，边缘对齐</span></span><br><span class="line">  TimerParameter.counterdirection = TIMER_COUNTER_UP;  <span class="comment">// 计数方向，向上计数</span></span><br><span class="line">  TimerParameter.period = UINIO_Clock_Period - <span class="number">1</span>;      <span class="comment">// 周期，同样由于该值从 0 开始计数，这里同样需要减去 1</span></span><br><span class="line">  TimerParameter.clockdivision = TIMER_CKDIV_DIV1;     <span class="comment">// 时钟分频因子</span></span><br><span class="line">  TimerParameter.repetitioncounter = <span class="number">0</span>;                <span class="comment">// 重复计数器值，取值范围为 0 ~ 255，配置为 x 就会重复 x+1 次进入中断</span></span><br><span class="line">  timer_init(UINIO_PWM_TIMER, &amp;TimerParameter);        <span class="comment">// 初始化 PWM 相关的定时器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 PWM 输出通道参数 TimerOutChannel */</span></span><br><span class="line">  timer_oc_parameter_struct TimerOutChannel;                                         <span class="comment">// 输出通道配置结构体 timer_oc_parameter_struct</span></span><br><span class="line">  TimerOutChannel.ocpolarity = TIMER_OC_POLARITY_HIGH;                               <span class="comment">// 设置通道输出极性为高电平有效</span></span><br><span class="line">  TimerOutChannel.outputstate = TIMER_CCX_ENABLE;                                    <span class="comment">// 使能通道输出功能</span></span><br><span class="line">  timer_channel_output_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, &amp;TimerOutChannel); <span class="comment">// 开始配置定时器通道的输出功能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置占空比 */</span></span><br><span class="line">  timer_channel_output_pulse_value_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, <span class="number">0</span>);                  <span class="comment">// 配置定时器输出通道的脉冲值</span></span><br><span class="line">  timer_channel_output_mode_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, TIMER_OC_MODE_PWM0);        <span class="comment">// 配置定时器输出通道的比较模式为 PWM 模式 0</span></span><br><span class="line">  timer_channel_output_shadow_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, TIMER_OC_SHADOW_DISABLE); <span class="comment">// 失能定时器输出通道的比较影子寄存器</span></span><br><span class="line"></span><br><span class="line">  timer_auto_reload_shadow_enable(UINIO_PWM_TIMER); <span class="comment">// 使能定时器自动重载影子寄存器</span></span><br><span class="line">  timer_enable(UINIO_PWM_TIMER);                    <span class="comment">// 使能 PWM 相关的定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** PWM 呼吸灯控制函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_LED_Breathing</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> Direct = <span class="number">0</span>; <span class="comment">// 亮暗调节方向</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Value = <span class="number">0</span>; <span class="comment">// 脉冲值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 逐渐变亮 */</span></span><br><span class="line">  <span class="keyword">if</span> (Direct == <span class="number">0</span>) &#123;</span><br><span class="line">    Value += <span class="number">500</span>; <span class="comment">// 该值越大 LED 越亮</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get brighter...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">      Direct = <span class="number">1</span>; <span class="comment">// 切换至渐暗模式</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Switch to dark...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 逐渐变暗 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Value -= <span class="number">500</span>; <span class="comment">// 该值越小 LED 越暗</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get darker...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      Direct = <span class="number">0</span>; <span class="comment">// 切换至渐亮模式</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Switch to bright...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timer_channel_output_pulse_value_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, Value); <span class="comment">// 配置定时器通道输出的脉冲值</span></span><br><span class="line">  delay_1ms(<span class="number">50</span>);                                                                      <span class="comment">// 系统滴答定时器延时 50 毫秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-6">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/PWM-LED/PWM-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();</span><br><span class="line"></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2); <span class="comment">// 优先级分组</span></span><br><span class="line"></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>); <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 频率(10800/108)兆赫兹 * 周期(10000)微秒 = 亮度调整间隔为 0.01 秒 */</span></span><br><span class="line">  UINIO_PWM_Config(<span class="number">108</span>, <span class="number">10000</span>);   <span class="comment">// PWM 初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UINIO_PWM_LED_Breathing(); <span class="comment">// 调用 PWM 呼吸灯控制函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接存储器存取-dma-与中断">直接存储器存取 DMA 与中断</h1><h2 id="dma-功能简介">DMA 功能简介</h2><p><strong>直接存储器存取</strong>（DMA，Direct MemoryAccess）主要运用在不占用<strong>内核计算资源</strong>的情况下，进行数据的传递（<code>外设 → 存储器</code>、<code>存储器 → 外设</code>、<code>存储器 → 存储器</code>）。<strong>GD32F350RBT6</strong>只拥有一个 DMA 控制器，其拥有 <strong>7</strong>个通道，每个通道都用于处理各个外设的存储器访问请求，这些外设包括有<strong>ADC</strong>、<strong>SPI</strong>、<strong>I2C</strong>、<strong>USART</strong>、<strong>DAC</strong>、<strong>I2S</strong>以及<strong>定时器</strong>。</p><p><img src="/Project/UINIO-MCU-GD32/13-DMA/1.png"></p><p>观察上面的 DMA 功能结构框图，可以发现 DMA控制器主要由如下四个部分组成：</p><ol type="1"><li>通过 AHB 总线<strong>从接口</strong>进行 DMA 配置。</li><li>通过 AHB 总线<strong>主接口</strong>进行数据传输。</li><li>由<strong>仲裁器</strong>（Arbiter）对 DMA请求的优先级进行管理。</li><li>控制存储器或者外设的状态，并且管理计数器。</li></ol><h2 id="实验电路的搭建-2">实验电路的搭建</h2><p>本节内容的实验，需要通过 <strong>USART</strong> 输出 DMA传输过来的数据信息，所以依然要把 <strong>UINIO-MCU-GD32F350RBT6</strong>核心板与另外一款 UINIO 系列开源硬件 <a href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>串口调试器</a> ，参照下图的线路进行相互连接：</p><p><img src="/Project/UINIO-MCU-GD32/10-USART/2.png"></p><p>也就是把 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<code>GPIOA9</code> 和 <code>GPIOA10</code> 引脚，分别连接至<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和<code>TXD</code> 引脚，然后将后者的 Type-C 接口通过 USB线缆连接到计算机，进而可以借助 <strong>COMTransmit</strong>等串口调试助手软件，查看到 DMA 传输过来的各种数据和日志信息。</p><h2 id="完整-keil-µvision-工程代码-8">完整 Keil µVision 工程代码</h2><p>当使用 DMA进行数据传输时，会首先从<strong>源地址</strong>读取数据，然后再将读取的数据存储到<strong>目的地址</strong>，使用时通常需要遵循如下步骤：</p><ol type="1"><li>通过 <code>rcu_periph_clock_enable(RCU_DMA)</code> 使能 DMA外设时钟。</li><li>配置 DMA 参数结构体 <code>dma_parameter_struct</code>。</li><li>初始化 DMA 通道 <code>dma_init()</code>。</li><li>调用 <code>dma_circulation_enable/disable()</code> 和<code>dma_memory_to_memory_enable/disable()</code> 配置 DMA相关模式。</li><li>执行 <code>dma_interrupt_enable()</code> 使能 DMA 中断。</li><li>执行 <code>dma_channel_enable()</code> 使能 DMA 通道本身。</li></ol><h3 id="sourcesgd32f3x0_it.c">Sources/gd32f3x0_it.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== gd32f3x0_it.c ==========*/</span></span><br><span class="line"><span class="comment">/* interrupt service routines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0_it.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FlagStatus UINIO_Transfer_Complete;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Channel1_2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断 DMA 通道传输是否已经完成，参数 DMA_INT_FLAG_FTF 是传输完成中断标志位 */</span></span><br><span class="line">  <span class="keyword">if</span>(dma_interrupt_flag_get(DMA_CH1, DMA_INT_FLAG_FTF)) &#123;</span><br><span class="line">    dma_interrupt_flag_clear(DMA_CH1, DMA_INT_FLAG_G); <span class="comment">// 清除 DMA 通道全局中断标志位状态</span></span><br><span class="line">    UINIO_Transfer_Complete = SET;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-7">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetArrayNumber(arr_nanme)  (uint32_t)(sizeof(arr_nanme) / sizeof(*(arr_nanme)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> UINIO_String[] = <span class="string">&quot;UinIO.com : Copy current string from RAM to USART by DMA.\n&quot;</span>; <span class="comment">// 需要通过 DMA 传输给 USART 的字符串</span></span><br><span class="line">__IO FlagStatus UINIO_Transfer_Complete = RESET;                                        <span class="comment">// 固件库中预定义的枚举类型变量，取值为 SET 或者 RESET</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);             <span class="comment">// 调用 USART 串口配置函数</span></span><br><span class="line"></span><br><span class="line">  rcu_periph_clock_enable(RCU_DMA);           <span class="comment">// 使能 DMA 相关的外部时钟</span></span><br><span class="line">  nvic_irq_enable(DMA_Channel1_2_IRQn, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 配置 DMA 中断服务程序</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 DMA 通道 */</span></span><br><span class="line">  dma_deinit(DMA_CH1);</span><br><span class="line">  dma_parameter_struct DMA_Init_Struct;</span><br><span class="line">  DMA_Init_Struct.direction    = DMA_MEMORY_TO_PERIPHERAL;         <span class="comment">// 设置 DMA 通道数据传输方向为【读取存储器写入外设】</span></span><br><span class="line">  DMA_Init_Struct.memory_addr  = (<span class="type">uint32_t</span>)UINIO_String;           <span class="comment">// 设置存储器基地址为字符串首地址</span></span><br><span class="line">  DMA_Init_Struct.memory_inc   = DMA_MEMORY_INCREASE_ENABLE;       <span class="comment">// 配置外设地址生成算法模式为递增</span></span><br><span class="line">  DMA_Init_Struct.memory_width = DMA_MEMORY_WIDTH_8BIT;            <span class="comment">// 存储器数据传输宽度为 8 位（串口每次传送 1 个字节 8 位）</span></span><br><span class="line">  DMA_Init_Struct.number       = GetArrayNumber(UINIO_String);     <span class="comment">// 设置 DMA 通道数据传输量</span></span><br><span class="line">  DMA_Init_Struct.periph_addr  = (<span class="type">uint32_t</span>)(&amp;USART_TDATA(USART0)); <span class="comment">// 设置外设基地址</span></span><br><span class="line">  DMA_Init_Struct.periph_inc   = DMA_PERIPH_INCREASE_DISABLE;      <span class="comment">// 设置外设地址生成算法为固定地址模式</span></span><br><span class="line">  DMA_Init_Struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;        <span class="comment">// 外设数据传输宽度为 8 位</span></span><br><span class="line">  DMA_Init_Struct.priority     = DMA_PRIORITY_ULTRA_HIGH;          <span class="comment">// 配置 DMA 传输通道优先级为最高</span></span><br><span class="line">  dma_init(DMA_CH1, &amp;DMA_Init_Struct);                             <span class="comment">// 开始初始化 DMA 通道 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 DMA 模式 */</span></span><br><span class="line">  dma_circulation_disable(DMA_CH1);      <span class="comment">// 禁用 DMA 循环模式</span></span><br><span class="line">  dma_memory_to_memory_disable(DMA_CH1); <span class="comment">// 禁用存储器到存储器的 DMA 传输</span></span><br><span class="line"></span><br><span class="line">  usart_dma_transmit_config(USART0, USART_DENT_ENABLE); <span class="comment">// 使能串口 USART0 的 DMA 发送功能</span></span><br><span class="line">  dma_interrupt_enable(DMA_CH1, DMA_INT_FTF);           <span class="comment">// 使能 DMA1 通道传输完成中断</span></span><br><span class="line">  dma_channel_enable(DMA_CH1);                          <span class="comment">// 使能 DMA1 通道本身</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待传输完成 */</span></span><br><span class="line">  <span class="keyword">while</span>(RESET == UINIO_Transfer_Complete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="adc-模数转换器外设">ADC 模数转换器外设</h1><h2 id="adc-外设简介">ADC 外设简介</h2><p><strong>GD32F350RBT6</strong> 微控制器集成有 12位逐次逼近型<strong>模数转换器</strong>（<strong>ADC</strong>，AnalogDigital Converter），可以采集来自 <strong>16</strong>个<strong>外部通道</strong>（即 MCU 引脚）、<strong>2</strong>个<strong>内部通道</strong>，以及<strong>电池电压</strong><code>VBAT</code>通道的模拟信号。采样转换完成之后，转换结果可以按照<strong>最低/最高</strong>有效位的对齐方式，保存在相应的数据寄存器当中。</p><p><img src="/Project/UINIO-MCU-GD32/14-ADC/1.png"></p><blockquote><p><strong>注意</strong>：<strong>逐次逼近型 ADC</strong>通过产生一系列比较电压，逐次与输入的模拟电压信号进行比较，以一次一次逐步接近的方式，将模似信号转换成最接近的数字信号。</p></blockquote><table><colgroup><col style="width: 14%"><col style="width: 22%"><col style="width: 14%"><col style="width: 48%"></colgroup><thead><tr class="header"><th style="text-align: left;">ADC 内部输入信号</th><th style="text-align: left;">功能说明</th><th style="text-align: left;">ADC 输入引脚定义</th><th style="text-align: left;">功能说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="math inline">\(V_{SENSE}\)</span></td><td style="text-align: left;">内部温度传感器输出电压。</td><td style="text-align: left;"><span class="math inline">\(VDDA\)</span></td><td style="text-align: left;">模拟电源正等于 <span class="math inline">\(V_{DD}\)</span>，<span class="math inline">\(2.6V\le VDDA \le 3.6V\)</span>。</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(V_{REFINT}\)</span></td><td style="text-align: left;">内部参考输出电压。</td><td style="text-align: left;"><span class="math inline">\(VSSA\)</span></td><td style="text-align: left;">模拟电源负等于 <span class="math inline">\(V_{SS}\)</span>，通过<strong>磁珠</strong>单点接入<code>GND</code>。</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(V_{BAT} /2\)</span></td><td style="text-align: left;">硬件输入电压除以二。</td><td style="text-align: left;"><span class="math inline">\(ADCx_IN[15:0]\)</span></td><td style="text-align: left;">多达 16 路外部通道。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>UINIO-MCU-GD32F350RBT6</strong>核心板的模拟电源负引脚 <code>VSSA</code>，使用了对于 <code>100Mhz</code>高频杂散信号存在 <code>1KΩ</code>阻抗的<strong>磁珠</strong>进行单点接地；</p></blockquote><h2 id="adc-采样通道与模式">ADC 采样通道与模式</h2><p><strong>GD32F350RBT6</strong> 微控制器上的这总共 <strong>19</strong>条 ADC 采样通道，都支持如下几种运行模式：</p><ul><li><strong>单次转换模式</strong>：每进行 1 次 ADC 转换后，ADC就会自动停止，并将结果保存在 ADC 数据寄存器当中。 <img src="/Project/UINIO-MCU-GD32/14-ADC/2.png"></li><li><strong>扫描模式</strong>：用于对多个输入通道进行依次采集，ADC会根据配置的通道采集顺序，对多个通道依次进行采样转换。 <img src="/Project/UINIO-MCU-GD32/14-ADC/3.png"></li><li><strong>连续转换模式</strong>：当 ADC 完成 1次转换之后，就会启动另外 1次转换，周而复始，直至<code>外部触发</code>或者<code>软件触发</code>停止这个转换过程。<img src="/Project/UINIO-MCU-GD32/14-ADC/4.png"></li><li><strong>间断模式</strong>：用于在<strong>注入通道</strong>（即在规则通道转换时，需要强行插入的通道）和<strong>常规通道</strong>之间进行切换，ADC会优先转换注入通道，完成之后再自动切换到常规通道进行转换。 <img src="/Project/UINIO-MCU-GD32/14-ADC/5.png"></li></ul><p>ADC采样的触发方式主要有<strong>外部触发</strong>和<strong>软件触发</strong>两种：</p><ul><li><strong>外部触发</strong>：在外部输入信号的<code>上升沿</code> 或者<code>下降沿</code>，都可以触发<strong>规则组</strong>或者<strong>注入组</strong>的ADC 转换。</li><li><strong>软件触发</strong>：由软件控制在固定的时间点进行 ADC转换，通常用于采集精度要求较高的场景。</li></ul><h2 id="adc-性能参数">ADC 性能参数</h2><p>使用 ADC 模数转换器外设的时候，需要特别注意下面三个主要性能参数：</p><ol type="1"><li><strong>分辨率</strong>：表示 ADC 转换器的输出精度，单位为<code>bit</code> 位，分辨率越高，采样精度也就越高，但是 ADC所花费的采样转换时间就会越长。</li><li><strong>采样率</strong>：表示 ADC每秒对于模拟信号进行采样的次数，单位为赫兹 <code>Hz</code> 或者<code>样本数量Sample / 秒S</code>。采样率高就表示 ADC能够更快的将模拟信号转换为数字信号，从而更加准确的反映模拟信号的变化。</li><li><strong>采样范围</strong>：是指 ADC可以采集到的模拟电压输入信号范围，通常位于<strong>参考电压</strong><span class="math inline">\(V_{REF}\)</span> 范围之内，即 <span class="math inline">\(0V \le ADC \le V_{REF}\)</span>。</li></ol><h2 id="实验电路的搭建-3">实验电路的搭建</h2><p>本节的实验会将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<strong>GPIOC1</strong> 作为 ADC 采样引脚，分别去获取<code>TP1</code>（连接至 <code>3V3</code>）和 <code>TP2</code>（连接至<code>GND</code>）两个测试点的电压数据，同时仍然将核心板与另外一款 UINIO系列开源硬件 <a href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>串口调试器</a> ，参照下面的示意图相互进行连接：</p><p><img src="/Project/UINIO-MCU-GD32/14-ADC/6.png"></p><p>即 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<code>GPIOA9</code> 和 <code>GPIOA10</code> 引脚，分别连接至<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和<code>TXD</code> 引脚，然后将后者的 Type-C 接口通过 USB线缆连接到计算机，从而借助串口调试助手软件 <strong>COMTransmit</strong>查看 ADC 采集到的数据信息。</p><h2 id="完整-keil-µvision-工程代码-9">完整 Keil µVision 工程代码</h2><p>本实验通过将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的<strong>GPIOC1</strong> 作为 ADC 采样引脚，分别去获取核心板上<code>3V3</code> 和 <code>GND</code> 引脚的电压数据，并且通过 USART串口将这些数据打印出来。实现这个功能，需要遵循如下一系列的步骤去配置 ADC外设：</p><ol type="1"><li>使用 <code>rcu_periph_clock_enable()</code> 使能 GPIO 和 ADC外设时钟。</li><li>通过 <code>rcu_adc_clock_config()</code> 配置 ADC 时钟。</li><li>通过 <code>gpio_mode_set()</code> 配置 GPIO引脚为模拟输入模式。</li><li>配置 ADC 的<strong>特殊功能</strong><code>adc_special_function_config()</code>、<strong>数据对齐方式</strong><code>adc_data_alignment_config()</code>、<strong>分辨率</strong><code>adc_resolution_config()</code>、<strong>通道长度</strong><code>adc_channel_length_config()</code>。</li><li>配置 ADC 通道的触发源<code>adc_external_trigger_source_config()</code>。</li><li>使能 ADC的触发方式是<strong>软件触发</strong>还是<strong>外部触发</strong><code>adc_external/software_trigger_config()</code>。</li><li>调用 <code>adc_enable()</code> 使能 <strong>ADC 外设</strong>以及<code>adc_calibration_enable()</code> 使能<strong>校准功能</strong>。</li><li>配置 ADC <strong>规则通道组</strong>或者<strong>插入通道组</strong><code>adc_regular/inserted_channel_config()</code>。</li><li>使能 ADC <strong>外部触发</strong>或者<strong>软件触发</strong>功能<code>adc_external/software_trigger_enable()</code>。</li><li>持续判断<strong>通道组转换结束标志位</strong><code>ADC_FLAG_EOC</code>，然后再通过<code>adc_regular_data_read()</code> 读取范围为 <code>0 ~ 4095</code> 的ADC 采样数据。</li></ol><p>在上面的配置过程当中，<code>adc_data_alignment_config()</code>函数所配置的<strong>数据对齐方式</strong>是指：</p><ul><li><strong>右对齐模式</strong>：ADC采集到的数据被右对齐到最低位，不足的位数填充<code>0</code>，该模式可以在不损失精度的前提下，获得更好的动态范围。</li><li><strong>左对齐模式</strong>：ADC采集到的数据被左对齐到最高位，不足的位数填充<code>0</code>，虽然该模式可以提高采样的分辨率，但是会降低动态范围。</li></ul><h3 id="driversadc.h">Drivers/ADC.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== ADC.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_ADC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_ADC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_ADC_Config</span><span class="params">(<span class="type">void</span>)</span>;                         <span class="comment">// ADC 外设配置函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">UINIO_ADC_Value</span><span class="params">(<span class="type">uint8_t</span> ADC_CHANNEL_x)</span>; <span class="comment">// 获取指定 ADC 通道的采集值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_ADC_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="driversadc.c">Drivers/ADC.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== ADC.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 外设配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(RCU_GPIOC);        <span class="comment">// 使能 GPIOC 外设时钟</span></span><br><span class="line">  rcu_periph_clock_enable(RCU_ADC);          <span class="comment">// 使能 ADC 外设时钟</span></span><br><span class="line">  rcu_adc_clock_config(RCU_ADCCK_APB2_DIV6); <span class="comment">// 选择 APB 总线频率的 6 分频作为 ADC 的时钟源</span></span><br><span class="line"></span><br><span class="line">  gpio_mode_set(GPIOC, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, GPIO_PIN_1); <span class="comment">// 配置 GPIOC1 为不带上下拉电阻的模拟输入模式</span></span><br><span class="line"></span><br><span class="line">  adc_special_function_config(ADC_SCAN_MODE, ENABLE); <span class="comment">// 使能 ADC 特殊功能的扫描模式</span></span><br><span class="line">  adc_data_alignment_config(ADC_DATAALIGN_RIGHT);     <span class="comment">// 配置 ADC 数据对齐方式为右对齐</span></span><br><span class="line">  adc_resolution_config(ADC_RESOLUTION_12B);          <span class="comment">// 配置 ADC 分辨率为 12 位</span></span><br><span class="line">  adc_channel_length_config(ADC_REGULAR_CHANNEL, <span class="number">1</span>);  <span class="comment">// 配置规则通道组的通道长度为 1</span></span><br><span class="line"></span><br><span class="line">  adc_external_trigger_source_config(ADC_REGULAR_CHANNEL, ADC_EXTTRIG_REGULAR_NONE); <span class="comment">// 配置规则通道组的外部触发源为软件触发（规则组）</span></span><br><span class="line">  adc_external_trigger_config(ADC_REGULAR_CHANNEL, ENABLE);                          <span class="comment">// 使能 ADC 外部触发</span></span><br><span class="line"></span><br><span class="line">  adc_enable();             <span class="comment">// 使能 ADC 外设</span></span><br><span class="line">  adc_calibration_enable(); <span class="comment">// 使能 ADC 校准</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取 ADC 的值，参数 ADC_CHANNEL_x 用于指定采集通道 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">UINIO_ADC_Value</span><span class="params">(<span class="type">uint8_t</span>  ADC_CHANNEL_x)</span> &#123;</span><br><span class="line">  adc_regular_channel_config(<span class="number">0U</span>, ADC_CHANNEL_x, ADC_SAMPLETIME_55POINT5); <span class="comment">// 配置 ADC 规则通道组，选择通道 0，并且指定采样时间为 1.5 个周期</span></span><br><span class="line">  adc_software_trigger_enable(ADC_REGULAR_CHANNEL);                       <span class="comment">// 使能 ADC 软件触发功能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据 ADC 状态标志位，等待 ADC 采样完成 */</span></span><br><span class="line">  <span class="keyword">while</span> ( adc_flag_get(ADC_FLAG_EOC) == RESET ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ADC_Value = adc_regular_data_read(); <span class="comment">// 读 ADC 规则组的采样数据</span></span><br><span class="line">  <span class="keyword">return</span> ADC_Value;                                 <span class="comment">// 返回 ADC 采样数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sourcesmain.c-8">Sources/main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/ADC/ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();               <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>); <span class="comment">// 配置 USART0，并将波特率设置为 9600</span></span><br><span class="line">  UINIO_ADC_Config();             <span class="comment">// 配置 ADC 外设</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> Voltage = <span class="number">0</span>;           <span class="comment">// ADC 采集到的原始值（0 ~ 4095）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    Voltage = UINIO_ADC_Value(ADC_CHANNEL_11);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过串口打印出实际电压值 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADC_Value = %f\n&quot;</span>,(( Voltage / <span class="number">4095.0</span> ) * <span class="number">3.3</span>) ); <span class="comment">// 接入 3.3V 采集的 ADC 值为 4095，接入 GND 采集的 ADC 值为 0</span></span><br><span class="line"></span><br><span class="line">    delay_1ms(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="i2c-集成电路总线">I2C 集成电路总线</h1><h1 id="spi-串行外设总线">SPI 串行外设总线</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;早在新冠疫情爆发前的 &lt;strong&gt;2019&lt;/strong&gt; 年，就曾经撰写过一篇关于
&lt;strong&gt;ARM&lt;/strong&gt; 标准库的技术长文 &lt;a href=&quot;http://uinio.com/Embedded/STM32F103/&quot;&gt;&lt;strong&gt;《意法半导体
STM32F103 标准库典型实例》&lt;/strong&gt;&lt;/a&gt;
，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4
年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于&lt;a href=&quot;https://www.gigadevice.com.cn/product/mcu&quot;&gt;&lt;strong&gt;兆易创新&lt;/strong&gt;&lt;/a&gt;
推出的国产 ARM 微控制器，设计和制作了 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-GD32F350RBT6&quot;&gt;&lt;strong&gt;UINIO-MCU-GD32F350RBT6&lt;/strong&gt;&lt;/a&gt;
这款开源核心板，同时撰写了本篇文章作为配套的资料教程，希冀为国产芯片的商业化普及尽自己一份绵薄之力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-MCU-GD32/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uinika/UINIO-MCU-GD32F350RBT6&quot;&gt;&lt;strong&gt;UINIO-MCU-GD32F350RBT6&lt;/strong&gt;&lt;/a&gt;
是一款采用 LQFP64 封装的 &lt;strong&gt;GD32F350RBT6&lt;/strong&gt;
微控制器核心板，基于 &lt;strong&gt;ARM Cortex-M4&lt;/strong&gt; 内核架构，主频高达
&lt;code&gt;108MHz&lt;/code&gt;，拥有 &lt;code&gt;128K&lt;/code&gt; 容量 Flash，以及
&lt;code&gt;16K&lt;/code&gt; 的 SRAM。而 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-GD32F103C&quot;&gt;&lt;strong&gt;UINIO-MCU-GD32F103C&lt;/strong&gt;&lt;/a&gt;
采用 LQFP48 封装的 &lt;strong&gt;GD32F103Cxxx&lt;/strong&gt; 系列微控制器（包括
&lt;code&gt;GD32F103CBT6&lt;/code&gt;、&lt;code&gt;GD32F103C8T6&lt;/code&gt;、&lt;code&gt;GD32F103C6T6&lt;/code&gt;、&lt;code&gt;GD32F103C4T6&lt;/code&gt;），基于
&lt;strong&gt;ARM Cortex-M3&lt;/strong&gt; 内核架构，主频达到
&lt;code&gt;108MHz&lt;/code&gt;，拥有 &lt;code&gt;16K ~ 128K&lt;/code&gt; 容量 Flash，以及
&lt;code&gt;6K ~ 20K&lt;/code&gt; 的 SRAM。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="MCU" scheme="http://www.uinio.com/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>一篇简明扼要的 Markdown 魔法速成教程</title>
    <link href="http://www.uinio.com/Zen/Markdown/"/>
    <id>http://www.uinio.com/Zen/Markdown/</id>
    <published>2024-03-12T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:51.029Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.markdownguide.org/"><strong>Markdown</strong></a>是一款轻量级的文本标记语言，由<strong>约翰·格鲁伯</strong>（JohnGruber）于 <strong>2004</strong>年开发，主要用于在<strong>纯文本文档</strong>当中添加格式化元素。具有语法简单，易于读写的特点，同时也可以方便的纳入Git 进行版本控制。其源文件采用 <code>.md</code> 或者<code>.markdown</code> 扩展名，可以被 <a href="https://www.pandoc.org/"><strong>Pandoc</strong></a>等预处理工具渲染为指定 <strong>CSS</strong> 样式的 <strong>HTML</strong>页面。除了使用 <strong>VSCode</strong>、<strong>Sublime</strong>等编辑器进行撰写，还可以采用 <a href="https://markdown.com.cn/editor/">Markdown 在线编辑器</a>，或者借用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown在线表格生成器</a> 辅助生成内容。</p><p><img src="/Zen/Markdown/logo.png"></p><p>笔者日常开发设计工作当中，经常需要使用到 <strong>Markdown</strong>来撰写各类技术笔记，以及项目的 <code>README.md</code>文档。不同于网络上其它琳琅满目的 <strong>Markdown</strong>在线教程，这篇文章会在介绍相关语法特性的同时，侧重于体现<strong>Markdown</strong> 语法与 <strong>HTML</strong>元素之间的映射关系，从而更加清晰的呈现其底层的转换逻辑，便于大家结合自定义的<strong>CSS</strong> 样式与 <strong>HTML</strong>标签，创造出更加丰富多彩的 Markdown 文本内容。</p><span id="more"></span><h2 id="全体语法速览表">全体语法速览表</h2><p>下面表格当中的 <strong>Markdown 基本元素</strong>，是作者 John Gruber最初设计的元素，几乎所有的 Markdown 预处理工具都支持它们。</p><table><thead><tr><th>Markdown 基本元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><strong>标题</strong>（Heading）</td><td><code> # 标题层级 1 <br> ## 标题层级 2 <br> ### 标题层级 3 <br> ####标题层级 4 <br> ##### 标题层级 5 <br> ###### 标题层级 6 </code></td></tr><tr><td><strong>粗体</strong>（Bold）</td><td><code>**粗体文本内容**</code></td></tr><tr><td><strong>斜体</strong>（Italic）</td><td><code>*斜体文本内容*</code></td></tr><tr><td><strong>引用块</strong>（Blockquote）</td><td><code>&gt; 引用的内容</code></td></tr><tr><td><strong>有序列表</strong>（Ordered List）</td><td><code>1. 第 1 条有序列表项；</code><br> <code>2. 第 2条有序列表项；</code><br> <code>3. 第 3 条有序列表项；</code><br></td></tr><tr><td><strong>无序列表</strong>（Unordered List）</td><td><code> - 这是一条无序列表项；<br> - 这是一条无序列表项；<br> -这是一条无序列表项；<br> </code></td></tr><tr><td><strong>代码</strong>（Code）</td><td><code>`行内代码`</code></td></tr><tr><td><strong>分隔线</strong>（Horizontal Rule）</td><td><code>---</code></td></tr><tr><td><strong>链接</strong>（Link）</td><td><code>[链接名称](链接地址 "链接标题")</code></td></tr><tr><td><strong>图片</strong>（Image）</td><td><code>![图片替代文本](图片地址 "图片标题")</code></td></tr></tbody></table><p>而下面表格当中的 <strong>Markdown 扩展元素</strong>，则是由各种Markdown 预处理工具自行扩展而来，使用时需要特别注意其兼容性。</p><table><thead><tr><th>Markdown 扩展元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><strong>表格</strong>（Table）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    表头    |    表头    |</span><br><span class="line">| :--------: | :--------: |</span><br><span class="line">| 单元格内容 | 单元格内容 |</span><br><span class="line">| 单元格内容 | 单元格内容 |</span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>代码块</strong>（Fenced Code Block）</td><td><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">` ` ` json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;URL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UinIO.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;电子技术实验室&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">` ` `</span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>☀ 脚注</strong>（Footnote）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是一个带有脚注的句子。[^1]</span><br><span class="line"> [^1]: 这里是脚注的内容。</span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>☀ 标题自定义 ID</strong>（Heading ID）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### 这是一个标题 &#123;#自定义 ID &#125;</span></span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>☀ 定义列表</strong>（Definition List）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">专业术语</span><br><span class="line">: 第 1 条术语定义。</span><br><span class="line">: 第 2 条术语定义。</span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>删除线</strong>（Strikethrough）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是一段带有删除线的文字。~~</span><br></pre></td></tr></table></figure></td></tr><tr><td><strong>任务列表</strong>（Task List）</td><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 第 1 个任务项。</span><br><span class="line"><span class="bullet">-</span> [ ] 第 2 个任务项。</span><br><span class="line"><span class="bullet">-</span> [ ] 第 3 个任务项。</span><br></pre></td></tr></table></figure></td></tr></tbody></table><blockquote><p><strong>注意</strong>：上述表格当中使用 <strong>☀</strong> 标注的<strong>脚注</strong>、<strong>标题自定义ID</strong>、<strong>定义列表</strong>，在大部分 Markdown预处理工具当中存在有兼容性问题，使用时需要特别注意。</p></blockquote><h2 id="markdown-标题">Markdown 标题</h2><p><strong>Markdown</strong> 通过在内容的前面使用 <code>#</code>号来添加标题，其中 <code>#</code>的数量代表了标题的<strong>层级</strong>。例如 3 个 <code>#</code>号就表示创建了一个三级标题 <code>&lt;h3&gt;</code>。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题层级 1</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题层级 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1.75em;font-weight: bold;">标题层级 1</span></td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 标题层级 2</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题层级 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1.5em;font-weight: bold;">标题层级 2</span></td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### 标题层级 3</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题层级 3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1.25em;font-weight: bold;">标题层级 3</span></td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 标题层级 4</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题层级 4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1.125em;font-weight: bold;">标题层级 4</span></td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##### 标题层级 5</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题层级 5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1em;font-weight: bold;">标题层级 5</span></td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">###### 标题层级 6</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题层级 6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><span style="font-size:1em;font-weight: bold;">标题层级 6</span></td></tr></tbody></table><blockquote><p><strong>注意</strong>：最佳实践是在 <code>#</code>号与标题之间使用【<strong>空格</strong>】进行分隔，从而能够规避一些兼容性方面的问题。</p></blockquote><h2 id="markdown-段落">Markdown 段落</h2><p><strong>Markdown</strong>使用<strong>一个或者多个的空行</strong>来实现段落的效果。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是第 1 个段落。</span><br><span class="line"></span><br><span class="line">这是第 2 个段落。</span><br><span class="line"></span><br><span class="line">这是第 3 个段落。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第 1 个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第 2 个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第 3 个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><p>这是第 1 个段落。</p><p>这是第 2 个段落。</p><p>这是第 3 个段落。</p></td></tr></tbody></table><h2 id="markdown-换行">Markdown 换行</h2><p><strong>Markdown</strong>在内容的末尾添加<strong>两个或者多个空格</strong>，然后再按下<strong>回车键</strong>，就可以创建出一个换行效果。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是第 1 行内容。  </span><br><span class="line">这是第 2 行内容。  </span><br><span class="line">这是第 3 行内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  这是第 1 行内容。<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  这是第 2 行内容。<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  这是第 3 行内容。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><p>这是第 1 行内容。<br> 这是第 2 行内容。<br> 这是第 3 行内容。</p></td></tr></tbody></table><blockquote><p><strong>注意</strong>：某些 <strong>Markdown</strong>编辑器的格式化工具，会自动清除内容末尾的空格，从而导致换行不成功，所以推荐使用<strong>段落</strong>来实现类似换行的效果。</p></blockquote><style>   .section .container .columns .column-main .article .content code {    padding: 0 !important;  }</style><h2 id="markdown-强调">Markdown 强调</h2><p><strong>Markdown</strong>通过<strong>粗体</strong>和<strong>斜体</strong>来实现强调的效果。其中在内容的前后，分别添加<strong>两个星号</strong><code>**</code> 或者<strong>两条下划线</strong><code>__</code>，就可以实现<strong>粗体</strong>的效果。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="strong">**粗体内容**</span>。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用星号的<strong>粗体内容</strong>。</td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="strong">__粗体内容__</span>。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用下划线的<strong>粗体内容</strong>。</td></tr></tbody></table><p>除此之外在内容的前后，还可以分别添加<strong>一个星号</strong><code>*</code> 或者<strong>一条下划线</strong><code>_</code>，从而实现出<strong>斜体</strong>的效果。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="emphasis">*斜体内容*</span>。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用星号的<em>斜体内容</em>。</td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="emphasis">_粗体内容_</span>。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用下划线的<em>斜体内容</em>。</td></tr></tbody></table><p>如果需要同时运用<strong>粗体</strong>加上<strong>斜体</strong>的效果来强调内容，那么可以在该内容前后分别添加<strong>三个星号</strong><code>***</code> 或者<strong>三条下划线</strong><code>___</code>，并且保留一个空格。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="strong">**<span class="emphasis">*粗体加斜体*</span>**</span>内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用星号的<span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体加斜体内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用星号的<em><strong>粗体加斜体内容</strong></em>。</td></tr><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="strong">__<span class="emphasis">_粗体加斜体_</span>__</span>内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用下划线的<span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体加斜体内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>。</span><br></pre></td></tr></table></figure></td><td>使用下划线的 <em><strong>粗体加斜体内容</strong></em> 。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：某些 <strong>Markdown</strong>编辑器的格式化工具，会自动把 <code>_内容_</code> 转换为<code>*内容*</code>、<code>__内容__</code> 转换为<code>**内容**</code>、<code>***内容***</code> 转换为<code>**_内容_**</code>，所以这里推荐遵循如下规则来使用 Markdown的强调语法：</p><ol type="1"><li><strong>粗体</strong> 使用 <code>**内容**</code> 语法；</li><li><em>斜体</em> 使用 <code>*内容*</code> 语法；</li><li><strong><em>粗体加斜体</em></strong> 使用 <code>**_内容_**</code>语法（注意左右两侧需要保留 1 个空格）；</li></ol></blockquote><h2 id="markdown-引用">Markdown 引用</h2><p><strong>Markdown</strong> 通过在内容段落的前面添加 <code>&gt;</code>符号来实现<strong>引用</strong>效果。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这里引用了一段内容。</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里引用了一段内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><blockquote><p>这里引用了一段内容。</p></blockquote></td></tr></tbody></table><p>通过使用一个内容为空的 <code>&gt;</code>引用，就可以实现对引用内容的<strong>换行</strong>效果：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里是第 1 段引用内容。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这里是第 2 段引用内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是第 1 段引用内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是第 2 段引用内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><blockquote><p>这里是第 1 段引用内容。</p><p>这里是第 2 段引用内容。</p></blockquote></td></tr></tbody></table><p>通过重复使用 <code>&gt; 内容</code>还可以实现对于引用内容的<strong>嵌套</strong>显示：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是最外层的引用内容。</span><br><span class="line">&gt;&gt; 这是第 1 层嵌套的引用内容。</span><br><span class="line">&gt;&gt;&gt; 这是第 2 层嵌套的引用内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是最外层的引用内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第 1 层嵌套的引用内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第 2 层嵌套的引用内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><blockquote><p>这是最外层的引用内容。</p><blockquote><p>这是第 1 层嵌套的引用内容。</p><blockquote><p>这是第 2 层嵌套的引用内容。</p></blockquote></blockquote></blockquote></td></tr></tbody></table><p>除此之外，还可以在 <strong>Markdown</strong>的引用当中嵌套<strong>无序列表</strong>和<strong>有序列表</strong>：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一条引用内容：</span><br><span class="line">&gt; - 这是一条无序列表项；</span><br><span class="line">&gt; - 这是一条无序列表项；</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一条引用内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><blockquote><p>这是一条引用内容：</p><ul><li>这是一条无序列表项；</li><li>这是一条无序列表项；</li></ul></blockquote></td></tr><pre><code>&lt;tr&gt;  &lt;td&gt;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一条引用内容：</span><br><span class="line">&gt; 1. 这是第 1 条有序列表项；</span><br><span class="line">&gt; 2. 这是第 2 条有序列表项；</span><br></pre></td></tr></table></figure>  &lt;/td&gt;  &lt;td&gt;    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一条引用内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 1 条有序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 2 条有序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>  &lt;/td&gt;  &lt;td&gt;    &lt;blockquote&gt;      &lt;p&gt;这是一条引用内容：&lt;/p&gt;      &lt;ol&gt;        &lt;li&gt;这是第 1 条有序列表项；&lt;/li&gt;        &lt;li&gt;这是第 2 条有序列表项；&lt;/li&gt;      &lt;/ol&gt;    &lt;/blockquote&gt;  &lt;/td&gt;&lt;/tr&gt;</code></pre></tbody></table><h2 id="markdown-列表">Markdown 列表</h2><p><strong>Markdown</strong> 可以使用<code>- 列表项内容</code>（推荐使用）、<code>* 列表项内容</code>、<code>+ 列表项内容</code>语法来渲染<strong>无序列表</strong>：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 这是一条无序列表项；</span><br><span class="line">- 这是一条无序列表项；</span><br><span class="line">- 这是一条无序列表项；</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><ul><li>这是一条无序列表项；</li><li>这是一条无序列表项；</li><li>这是一条无序列表项；</li></ul></td></tr></tbody></table><p>除此之外，<strong>Markdown</strong> 还可以通过<code>序数. 列表内容</code> 语法来渲染<strong>有序列表</strong>：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 这是第 1 条有序列表项；</span><br><span class="line">2. 这是第 2 条有序列表项；</span><br><span class="line">3. 这是第 3 条有序列表项；</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 1 条有序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 2 条有序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 3 条有序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><ol><li>这是第 1 条有序列表项；</li><li>这是第 2 条有序列表项；</li><li>这是第 3 条有序列表项；</li></ol></td></tr></tbody></table><p>如需需要在列表当中插入其它内容（包括<code>图片</code>、<code>代码块</code>、<code>其它列表</code>、<code>换行</code>、<code>引用</code>），则需要将该内容缩进<strong>一个制表符</strong>或者<strong>四个空格</strong>：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 这是一条无序列表项；</span><br><span class="line">&gt; 这是一个引用。</span><br><span class="line">- 这是一条无序列表项；</span><br><span class="line">- 这是一条无序列表项；</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；</span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个引用。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是一条无序列表项；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><ul><li>这是一条无序列表项；<blockquote><p>这是一个引用。</p></blockquote><pre><code>      &lt;/li&gt;      &lt;li&gt;这是一条无序列表项；&lt;/li&gt;      &lt;li&gt;这是一条无序列表项；&lt;/li&gt;    &lt;/ul&gt;  &lt;/td&gt;&lt;/tr&gt;</code></pre></li></ul></td></tr></tbody></table><h2 id="markdown-代码">Markdown 代码</h2><p><strong>Markdown</strong> 使用一个<strong>反引号</strong> `语法来展示<strong>行内</strong>的代码片断：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`这是一条行内代码片断`</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>这是一条行内代码片断<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><code>这是一条行内代码片断</code></td></tr></tbody></table><p>如果需要在一个行内的代码片断当中，展示反引号内容，则可以将其包裹在两个<strong>反引号</strong>`` 当中进行转义。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`` 一行内容 `代码片段` 一行内容 ``</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>一行内容 `代码片段` 一行内容<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><code>一行内容 <code>代码片段</code> 一行内容</code></td></tr></tbody></table><p>除此之外，<strong>Markdown</strong>支持通过三个<strong>反引号</strong>```（推荐使用）或者<strong>波浪号</strong> ~~~来展示<strong>块级</strong>的代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">` ` `</span><br><span class="line">int main(void) &#123;</span><br><span class="line">  printf(&quot;Hello UinIO.com!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">` ` `</span><br></pre></td></tr></table></figure><p>如果在第一个 ``` 或 ~~~后面，添加当前代码片断所使用的编程语言名称（例如下面例子使用的 <strong>C语言</strong>），则可以启用相应的语法高亮：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">` ` ` C</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello UinIO.com!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">` ` `</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面代码为了避免错误渲染，在 ` 与 `之间添加了额外的<strong>空格</strong>，实际使用时需要去除掉这些空格。</p></blockquote><h2 id="markdown-分隔线">Markdown 分隔线</h2><p><strong>Markdown</strong>通过在单独的一行上面，使用三个或者多个<strong>星号</strong><code>***</code>、<strong>破折号</strong><code>---</code>、<strong>下划线</strong><code>___</code>（推荐使用）就可以渲染出分隔线：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><hr style="background:black;"></td></tr></tbody></table><h2 id="markdown-链接">Markdown 链接</h2><p><strong>Markdown</strong> 当中可以使用<code>[链接名称](链接地址 "链接标题")</code>格式的语法添加一个超级链接：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址 &quot;链接标题&quot;</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;链接地址&quot;</span> <span class="attr">title</span>=<span class="string">&quot;链接标题&quot;</span>&gt;</span>链接名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><a href="链接地址" title="链接标题">链接名称</a></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<code>链接标题</code>是鼠标在链接上悬停时显示的信息，<code>链接名称</code>是链接实际渲染时显示的内容，<code>链接地址</code> 则是需要跳转到的目标URL 地址。</p></blockquote><p>使用<strong>尖括号</strong> <code>&lt;&gt;</code> 语法，可以方便的将<strong>URL 地址</strong>或者 <strong>E-Mail地址</strong>转换为链接。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;http://www.uinio.com&gt;</span></span><br><span class="line"><span class="language-xml">&lt;uinika@outlook.com&gt;</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.uinio.com/&quot;</span>&gt;</span>http://www.uinio.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:uinika@outlook.com&quot;</span>&gt;</span>uinika@outlook.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><a href="http://www.uinio.com/">http://www.uinio.com</a><a href="mailto:uinika@outlook.com">uinika@outlook.com</a></td></tr></tbody></table><h2 id="markdown-图片">Markdown 图片</h2><p><strong>Markdown</strong> 里可以通过<code>![图片替代文本](图片地址 "图片标题")</code>格式语法插入一张图片：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Logo</span>](<span class="link">./Markdown/logo.png &quot;Markdown&quot;</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./Markdown/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Markdown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><img src="/Zen/Markdown/logo.png" alt="Logo" title="Markdown"></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<code>图片替代文本</code>是图片资源缺失时显示的信息，<code>图片地址</code> 是图片的 URL地址，<code>图片标题</code> 则是鼠标悬停时显示的信息。</p></blockquote><p>如果需要为图片添加一个 URL链接，则只需要将上述的<strong>图片语法</strong>嵌入至<strong>链接语法</strong>内部即可：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Logo</span>](<span class="link">./Markdown/logo.png &quot;Markdown&quot;</span>)](<span class="link">http://www.uinio.com</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.uinio.com/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./Markdown/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Markdown&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><a href="http://www.uinio.com/"><img src="/Zen/Markdown/logo.png" alt="Logo" title="Markdown"></a></td></tr></tbody></table><h2 id="markdown-表格">Markdown 表格</h2><p><strong>Markdown</strong> 当中可以通过使用<strong>连字符</strong><code>---</code> 和<strong>管道符</strong> <code>|</code>来构建表格。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头   | 表头   |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><table><thead><tr style="border-bottom: 1px solid gray;"><th>表头</th><th>表头</th></tr></thead><tbody><tr style="border-bottom: 1px solid gray;"><td>单元格</td><td>单元格</td></tr><tr style="border-bottom: 1px solid gray;"><td>单元格</td><td>单元格</td></tr></tbody></table></td></tr></tbody></table><p>通过向 <strong>Markdown</strong>表格当中<strong>连字符</strong>的左右两侧添加 <code>:</code><strong>冒号</strong>，就可以控制表格当中文本的<strong>左</strong>、<strong>中心</strong>、<strong>右</strong>对齐（实质是向表格的<code>&lt;th&gt;</code>、<code>&lt;td&gt;</code> 标签添加了<code>align="left/center/right"</code> 属性）。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头  |  表头  |</span><br><span class="line">| :----: | :----: |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><table><thead><tr style="border-bottom: 1px solid gray;"><th align="center">表头</th><th align="center">表头</th></tr></thead><tbody><tr style="border-bottom: 1px solid gray;"><td align="center">单元格</td><td align="center">单元格</td></tr><tr style="border-bottom: 1px solid gray;"><td align="center">单元格</td><td align="center">单元格</td></tr></tbody></table></td></tr></tbody></table><blockquote><p><strong>注意</strong>：如果需要在表格当中显示管道符<code>|</code>，为了避免语法冲突，则需要改为直接使用 HTML 实体<code>&amp;#124;</code>。</p></blockquote><h2 id="markdown-转义字符">Markdown 转义字符</h2><p><strong>Markdown</strong> 当中可以使用<strong>反斜杠</strong><code>\</code> 来转义下面列表当中的这些字符。</p><table><thead><tr class="header"><th style="text-align: center;">\</th><th style="text-align: center;">`</th><th style="text-align: center;">*</th><th style="text-align: center;">_</th><th style="text-align: center;">#</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>{ }</strong></td><td style="text-align: center;"><strong>[ ]</strong></td><td style="text-align: center;"><strong>( )</strong></td><td style="text-align: center;"><strong>+</strong></td><td style="text-align: center;"><strong>-</strong></td></tr><tr class="even"><td style="text-align: center;"><strong>.</strong></td><td style="text-align: center;"><strong>!</strong></td><td style="text-align: center;"><strong>|</strong></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><strong>注意</strong>：对于 <strong>Markdown</strong> 当中出现的<code>&lt;</code> 和 <code>&amp;</code> 两个特殊符号，就需要使用其对应的HTML 实体形式 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>才能够正常显示。</p></blockquote><h2 id="markdown-任务列表">Markdown 任务列表</h2><p><strong>Markdown</strong> 可以基于<strong>减号</strong><code>-</code>、<strong>方括号</strong><code>[ ]</code>、<strong>字母</strong> <code>x</code>创建出一个可进行勾选的<strong>任务列表</strong>。</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 今天的第 1 个任务项。</span><br><span class="line"><span class="bullet">-</span> [ ] 今天的第 2 个任务项。</span><br><span class="line"><span class="bullet">-</span> [ ] 今天的第 3 个任务项。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    今天的第 1 个任务项</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">    今天的第 2 个任务项。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">    今天的第 3 个任务项。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><ul><li><input disabled type="checkbox" checked> 今天的第 1 个任务项</li><li><input disabled type="checkbox"> 今天的第 2 个任务项。</li><li><input disabled type="checkbox"> 今天的第 3 个任务项。</li></ul></td></tr></tbody></table><h2 id="markdown-删除线">Markdown 删除线</h2><p><strong>Markdown</strong>可以通过向指定内容的左右两侧，分别添加两个<strong>波浪号</strong><code>~~</code>，从而在这些内容上面显示一条<strong>删除线</strong>：</p><table><thead><tr><th>Markdown 语法</th><th>HTML 语句</th><th>效果预览</th></tr></thead><tbody><tr><td><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是需要删除的内容~~，而这是正常显示的内容。</span><br></pre></td></tr></table></figure></td><td><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">del</span>&gt;</span>这是需要删除的内容<span class="tag">&lt;/<span class="name">del</span>&gt;</span>，而这是正常显示的内容。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></td><td><p><del>这是需要删除的内容</del>，而这是正常显示的内容。</p></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.markdownguide.org/&quot;&gt;&lt;strong&gt;Markdown&lt;/strong&gt;&lt;/a&gt;
是一款轻量级的文本标记语言，由&lt;strong&gt;约翰·格鲁伯&lt;/strong&gt;（John
Gruber）于 &lt;strong&gt;2004&lt;/strong&gt;
年开发，主要用于在&lt;strong&gt;纯文本文档&lt;/strong&gt;当中添加格式化元素。具有语法简单，易于读写的特点，同时也可以方便的纳入
Git 进行版本控制。其源文件采用 &lt;code&gt;.md&lt;/code&gt; 或者
&lt;code&gt;.markdown&lt;/code&gt; 扩展名，可以被 &lt;a href=&quot;https://www.pandoc.org/&quot;&gt;&lt;strong&gt;Pandoc&lt;/strong&gt;&lt;/a&gt;
等预处理工具渲染为指定 &lt;strong&gt;CSS&lt;/strong&gt; 样式的 &lt;strong&gt;HTML&lt;/strong&gt;
页面。除了使用 &lt;strong&gt;VSCode&lt;/strong&gt;、&lt;strong&gt;Sublime&lt;/strong&gt;
等编辑器进行撰写，还可以采用 &lt;a href=&quot;https://markdown.com.cn/editor/&quot;&gt;Markdown 在线编辑器&lt;/a&gt;，或者借用
&lt;a href=&quot;https://www.tablesgenerator.com/markdown_tables&quot;&gt;Markdown
在线表格生成器&lt;/a&gt; 辅助生成内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Zen/Markdown/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;笔者日常开发设计工作当中，经常需要使用到 &lt;strong&gt;Markdown&lt;/strong&gt;
来撰写各类技术笔记，以及项目的 &lt;code&gt;README.md&lt;/code&gt;
文档。不同于网络上其它琳琅满目的 &lt;strong&gt;Markdown&lt;/strong&gt;
在线教程，这篇文章会在介绍相关语法特性的同时，侧重于体现
&lt;strong&gt;Markdown&lt;/strong&gt; 语法与 &lt;strong&gt;HTML&lt;/strong&gt;
元素之间的映射关系，从而更加清晰的呈现其底层的转换逻辑，便于大家结合自定义的
&lt;strong&gt;CSS&lt;/strong&gt; 样式与 &lt;strong&gt;HTML&lt;/strong&gt;
标签，创造出更加丰富多彩的 Markdown 文本内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Zen" scheme="http://www.uinio.com/categories/Zen/"/>
    
    
    <category term="Markdown" scheme="http://www.uinio.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0</title>
    <link href="http://www.uinio.com/Web/Solidity/"/>
    <id>http://www.uinio.com/Web/Solidity/</id>
    <published>2024-02-21T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.879Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.soliditylang.org"><strong>Solidity</strong></a>是一款以由<strong>以太坊</strong>（<strong>ETH</strong>，Ethereum）开源社区推出的<strong>面向对象</strong>的<strong>静态</strong>程序设计语言，主要用于在<strong>Web 3.0</strong> 世界创建智能合约，其语法特性受到了C++、Python、JavaScript等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的Solidity 版本，从而获得安全修复以及各种新特性，本篇文章撰写时 Solidity最新的生产环境版本为 <code>v0.8.24</code>。</p><p><img src="/Web/Solidity/logo.png"></p><p>除了 Solidity 的各种常用语言特性之外，还会介绍一系列 Web 3.0开发过程当中，所经常使用的第三方开源项目。其中 Hardhat是一个用于编译、部署、测试、调试以太坊应用的开发环境，而 <a href="https://trufflesuite.com/ganache/"><strong>Ganache</strong></a>则是一款用于开发测试 <strong>dApps</strong>（DecentralizedApplications）的本地区块链应用。除此之外，<a href="https://wizard.openzeppelin.com/"><strong>OpenZeppelin</strong></a>的 <a href="https://docs.openzeppelin.com/contracts/5.x/"><strong>Contract</strong></a>则是一款用于开发安全智能合约的库，提供有 <strong>ERC20</strong> 和<strong>ERC721</strong>的标准实现，以及灵活的的权限方案，乃至于各种常用的工具组件。</p><span id="more"></span><h2 id="web-3.0-简介">Web 3.0 简介</h2><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th style="text-align: left;">Web 3.0 术语</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>区块</strong></td><td style="text-align: left;"><strong>区块</strong>包含有大量捆绑的交易，以其作为最小单位在所有节点当中进行分发，如果两个交易相互矛盾，那么排在第二位的交易会被拒绝，不会成为区块的一部分。</td></tr><tr class="even"><td style="text-align: left;"><strong>区块链</strong></td><td style="text-align: left;"><strong>区块链</strong>就是指<strong>区块</strong>按照<strong>时间</strong>形成的线性序列，区块每间隔一段时间就会被添加到链上面，其本质上就类似于一个公共的事务型数据库。</td></tr><tr class="odd"><td style="text-align: left;"><strong>以太坊虚拟机</strong></td><td style="text-align: left;"><strong>以太坊虚拟机</strong>（EVM，EthereumVirtual Machine）是以太坊智能合约的运行环境。</td></tr><tr class="even"><td style="text-align: left;"><strong>以太坊账户</strong></td><td style="text-align: left;">以太坊账户主要分为两种：<strong>外部账户</strong>（由公私钥对控制，地址由公钥确定）、<strong>合约账户</strong>（由与账户一起存储的代码控制，地址在合约创建时被确定）。</td></tr><tr class="odd"><td style="text-align: left;"><strong>以太坊账户余额</strong></td><td style="text-align: left;">以太坊账户<strong>余额</strong>的最小单位是<code>Wei</code>（<span class="math inline">\(1 ETH = 10^{18}wei\)</span>）)，余额会因为发生以太币的交易而改变。</td></tr><tr class="even"><td style="text-align: left;"><strong>交易</strong></td><td style="text-align: left;"><strong>交易</strong>可以视为帐户之间相互发送的消息，每笔交易都会消耗一定数量的Gas（由交易的发起人支付）。</td></tr></tbody></table><h2 id="构建-hardhat-环境">构建 Hardhat 环境</h2><h3 id="npm-安装-hardhat">npm 安装 Hardhat</h3><p><a href="https://hardhat.org/docs"><strong>Hardhat</strong></a>是一款编译、部署、测试和调试以太坊应用的开发工具，可以用于实现智能合约与dApps 开发过程当中的自动化任务，但是 Hardhat最核心的地方依然是编译、运行、测试智能合约。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Hardhat 需要运行在 <a href="https://nodejs.org/en">NodeJS</a> 基础之上，所以在安装 Hardhat之前需要先行安装 NodeJS，并且将安装目录填写至 <code>PATH</code>环境变量当中。</p></blockquote><p>通过上面的语句，可以在一个 npm 工程当中快速的安装Hardhat，然后在工程目录里执行<code>npx hardhat</code>，就可以快速查看当前可用的<strong>命令</strong>与<strong>任务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat</span><br><span class="line"></span><br><span class="line">Hardhat version 2.20.1</span><br><span class="line"></span><br><span class="line">Usage: hardhat [GLOBAL OPTIONS] [SCOPE] &lt;TASK&gt; [TASK OPTIONS]</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line"></span><br><span class="line">  --config              A Hardhat config file.</span><br><span class="line">  --emoji               Use emoji <span class="keyword">in</span> messages.</span><br><span class="line">  --flamegraph          Generate a flamegraph of your Hardhat tasks</span><br><span class="line">  --<span class="built_in">help</span>                Shows this message, or a task<span class="string">&#x27;s help if its name is provided</span></span><br><span class="line"><span class="string">  --max-memory          The maximum amount of memory that Hardhat can use.</span></span><br><span class="line"><span class="string">  --network             The network to connect to.</span></span><br><span class="line"><span class="string">  --show-stack-traces   Show stack traces (always enabled on CI servers).</span></span><br><span class="line"><span class="string">  --tsconfig            A TypeScript config file.</span></span><br><span class="line"><span class="string">  --typecheck           Enable TypeScript type-checking of your scripts/tests</span></span><br><span class="line"><span class="string">  --verbose             Enables Hardhat verbose logging</span></span><br><span class="line"><span class="string">  --version             Shows hardhat&#x27;</span>s version.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVAILABLE TASKS:</span><br><span class="line"></span><br><span class="line">  check                 Check whatever you need</span><br><span class="line">  clean                 Clears the cache and deletes all artifacts</span><br><span class="line">  compile               Compiles the entire project, building all artifacts</span><br><span class="line">  console               Opens a hardhat console</span><br><span class="line">  coverage              Generates a code coverage report <span class="keyword">for</span> tests</span><br><span class="line">  flatten               Flattens and prints contracts and their dependencies. If no file is passed, all the contracts <span class="keyword">in</span> the project will be flattened.</span><br><span class="line">  gas-reporter:merge</span><br><span class="line">  <span class="built_in">help</span>                  Prints this message</span><br><span class="line">  node                  Starts a JSON-RPC server on top of Hardhat Network</span><br><span class="line">  run                   Runs a user-defined script after compiling the project</span><br><span class="line">  <span class="built_in">test</span>                  Runs mocha tests</span><br><span class="line">  typechain             Generate Typechain typings <span class="keyword">for</span> compiled contracts</span><br><span class="line">  verify                Verifies a contract on Etherscan or Sourcify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVAILABLE TASK SCOPES:</span><br><span class="line"></span><br><span class="line">  vars                  Manage your configuration variables</span><br><span class="line"></span><br><span class="line">To get <span class="built_in">help</span> <span class="keyword">for</span> a specific task run: npx hardhat <span class="built_in">help</span> [SCOPE] &lt;TASK&gt;</span><br></pre></td></tr></table></figure><h3 id="初始化-hardhat-工程">初始化 Hardhat 工程</h3><p>通过运行 <code>npx hardhat init</code> 可以初始化出一个基本的 Hardhat工程目录结构：</p><ul><li><code>contracts</code> 目录：用于存放 <code>.sol</code>智能合约</li><li><code>scripts</code> 目录：用于存放任务脚本。</li><li><code>test</code> 目录：用于存放测试文件。</li><li><code>hardhat.config.js</code> 文件：Hardhat 配置文件。</li></ul><h3 id="编译智能合约">编译智能合约</h3><p>在工程目录运行 <code>npx hardhat compile</code> 命令，可以编译<code>contracts</code> 目录下的智能合约（例如该工程当中的<code>contracts/Lock.sol</code> 文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat compile</span><br><span class="line"></span><br><span class="line">Downloading compiler 0.8.24</span><br><span class="line">Compiled 1 Solidity file successfully (evm target: paris).</span><br></pre></td></tr></table></figure><h3 id="测试智能合约">测试智能合约</h3><p>然后再运行 <code>npx hardhat test</code> 命令，可以执行<code>contracts</code> 目录下的测试脚本文件（例如本工程当中的<code>test/Lock.js</code> 文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">  Lock</span><br><span class="line">    Deployment</span><br><span class="line">      √ Should <span class="built_in">set</span> the right unlockTime (11217ms)</span><br><span class="line">      √ Should <span class="built_in">set</span> the right owner</span><br><span class="line">      √ Should receive and store the funds to lock</span><br><span class="line">      √ Should fail <span class="keyword">if</span> the unlockTime is not <span class="keyword">in</span> the future (141ms)</span><br><span class="line">    Withdrawals</span><br><span class="line">      Validations</span><br><span class="line">        √ Should revert with the right error <span class="keyword">if</span> called too soon</span><br><span class="line">        √ Should revert with the right error <span class="keyword">if</span> called from another account (39ms)</span><br><span class="line">        √ Shouldn<span class="string">&#x27;t fail if the unlockTime has arrived and the owner calls it (42ms)</span></span><br><span class="line"><span class="string">      Events</span></span><br><span class="line"><span class="string">        √ Should emit an event on withdrawals</span></span><br><span class="line"><span class="string">      Transfers</span></span><br><span class="line"><span class="string">        √ Should transfer the funds to the owner (88ms)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  9 passing (12s)</span></span><br></pre></td></tr></table></figure><h3 id="部署智能合约">部署智能合约</h3><p>继续运行 <code>npx hardhat run scripts/deploy.js</code>命令，就可以执行 <code>scripts</code> 目录下的 Hardhat任务脚本（例如本工程当中的 <code>scripts/deploy.js</code> 文件），此时Hardhat 会将智能合约部署到执行命令时，自动启动的 Hardhat Network本地测试网络服务当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat run scripts/deploy.js</span><br><span class="line"></span><br><span class="line">Lock with 0.001ETH and unlock timestamp 1708929986 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br></pre></td></tr></table></figure><h3 id="启动-hardhat-network">启动 Hardhat Network</h3><p>除此之外，也可以通过手动运行 <code>npx hardhat node</code>命令，启动该本地测试网络服务的同时，还会生成一系列测试用账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat node</span><br><span class="line"></span><br><span class="line">Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/</span><br><span class="line"></span><br><span class="line">Accounts</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">WARNING: These accounts, and their private keys, are publicly known.</span><br><span class="line">Any funds sent to them on Mainnet or any other live network WILL BE LOST.</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)</span></span><br><span class="line">Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000 ETH)</span></span><br><span class="line">Private Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#2: 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC (10000 ETH)</span></span><br><span class="line">Private Key: 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#3: 0x90F79bf6EB2c4f870365E785982E1f101E93b906 (10000 ETH)</span></span><br><span class="line">Private Key: 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#4: 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 (10000 ETH)</span></span><br><span class="line">Private Key: 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#5: 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc (10000 ETH)</span></span><br><span class="line">Private Key: 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba</span><br><span class="line"></span><br><span class="line">..... ..... ..... ..... ..... .....</span><br><span class="line">..... ..... ..... ..... ..... .....</span><br><span class="line"></span><br><span class="line">WARNING: These accounts, and their private keys, are publicly known.</span><br><span class="line">Any funds sent to them on Mainnet or any other live network WILL BE LOST.</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Hardhat 内置的 Hardhat Network是一个为开发而设计的<strong>本地以太坊网络</strong>。</p></blockquote><h3 id="连接-hardhat-network">连接 Hardhat Network</h3><p>通过 <code>npx hardhat node</code> 启动 Hardhat Network本地测试网络服务之后，就会向外暴露一个 JSON-RPC 服务接口<code>http://127.0.0.1:8545/</code>，把区块链钱包等应用连接至该接口就可以使用。此时如果需要将上面的<code>Lock.sol</code>智能合约，部署到上述这个已经启动了的测试网络，则需要再添加上一个<code>--network localhost</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat run scripts/deploy.js --network localhost</span><br><span class="line"></span><br><span class="line">Lock with 0.001ETH and unlock timestamp 1708931638 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br></pre></td></tr></table></figure><h3 id="日志打印-console.log">日志打印 console.log()</h3><p>通过向 Hardhat 项目当中的 <code>.sol</code> 智能合约里引入<code>console.sol</code>，就可以愉快的在项目当中使用<code>console.log();</code> 日志打印方法，从而能够更加便捷的在 HardhatNetwork 控制台查看到智能合约打印的调试信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;hardhat/console.sol&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="引入以太坊-web3.js">引入以太坊 Web3.js</h2><p><a href="https://docs.web3js.org/">web3.js</a>是以太坊官方开源社区提供的一个 JavaScript 库，允许通过HTTP、IPC、WebSocket 与本地或者远程的<strong>以太坊</strong> EVM区块链节点进行各种交互，可以通过下面的命令将其安装在 Hardhat工程当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev web3</span><br></pre></td></tr></table></figure><p>除此之外，也可以通过在 Hardhat 项目当中安装插件的形式，将 Web3.js无缝整合到到工程当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-web3-v4</span><br></pre></td></tr></table></figure><p>通过在 <strong>Hardhat</strong> 当中编写 <code>script</code>脚本，就可以借助 <strong>Web3.js</strong> 与 Hardhat本地的测试网络进行交互，具体步骤请参考下面的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Web3</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;http://127.0.0.1:8545/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 本地 Hardhat 测试网络账户地址 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">TestAccounts</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 查询区块链信息 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">BlockNumber</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getBlockNumber</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块号: &quot;</span>, <span class="title class_">BlockNumber</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Balance</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;指定账户地址的余额: &quot;</span>, <span class="title class_">Balance</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ChainId</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getChainId</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块链 ID: &quot;</span>, <span class="title class_">ChainId</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">TransactionCount</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getTransactionCount</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;指定账户的交易数量: &quot;</span>, <span class="title class_">TransactionCount</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">GasPrice</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getGasPrice</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块链网络的 Gas 价格: &quot;</span>, <span class="title class_">GasPrice</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 设置 Web3.js 本地钱包 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">WalletAccounts</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="property">wallet</span>.<span class="title function_">create</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;随机生成 3 个钱包账户: &quot;</span>, <span class="title class_">WalletAccounts</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">PrivateWalletAccount</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="property">wallet</span>.<span class="title function_">add</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">privateKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通过私钥生成的钱包账户地址: &quot;</span>, <span class="title class_">PrivateWalletAccount</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通过私钥生成的钱包账户私钥: &quot;</span>, <span class="title class_">PrivateWalletAccount</span>[<span class="number">0</span>].<span class="property">privateKey</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 向 Hardhat 测试网络发起交易 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">TX</span> = &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="title class_">TestAccounts</span>[<span class="number">1</span>].<span class="property">address</span>,</span><br><span class="line">    <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.000001&quot;</span>, <span class="string">&quot;ether&quot;</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> txReceipt = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(<span class="variable constant_">TX</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转账交易哈希:&quot;</span>, txReceipt.<span class="property">transactionHash</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 智能合约 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlAddress</span> = <span class="string">&quot;0x322813Fd9A801c5507c9de605d63CEA4f2CE6c44&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlABI</span> = <span class="built_in">require</span>(<span class="string">&quot;../artifacts/contracts/TestAccessControl.sol/TestAccessControl.json&quot;</span>).<span class="property">abi</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlContract</span> = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(<span class="title class_">AccessControlABI</span>, <span class="title class_">AccessControlAddress</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 读取智能合约方法的返回值 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ReturnValue</span> = <span class="keyword">await</span> <span class="title class_">AccessControlContract</span>.<span class="property">methods</span>.<span class="title function_">securedFunction</span>().<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;智能合约调用返回值 :&quot;</span>, <span class="title class_">ReturnValue</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 向智能合约方法写入参数 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ReceiptTX</span> = <span class="keyword">await</span> <span class="title class_">AccessControlContract</span>.<span class="property">methods</span>.<span class="title function_">addToRole</span>(<span class="title class_">TestAccounts</span>[<span class="number">1</span>].<span class="property">address</span>).<span class="title function_">send</span>(&#123; <span class="attr">from</span>: <span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;智能合约调用交易哈希:&quot;</span>, <span class="title class_">ReceiptTX</span>.<span class="property">transactionHash</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  process.<span class="property">exitCode</span> = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="智能合约基本结构">智能合约基本结构</h2><p>Solidity 将 Web 3.0当中的<strong>智能合约</strong>视为面向对象编程当中的<strong>类</strong>，每一份智能合约可以包含<code>状态变量</code>、<code>函数</code>、<code>函数修饰器</code>、<code>事件</code>、<code>错误</code>、<code>结构体类型</code>、<code>枚举类型</code>的声明，并且智能合约之间也可以相互进行继承。</p><h3 id="许可标识-编译指示">许可标识 &amp; 编译指示</h3><ol type="1"><li>第 1 行的 <code>// SPDX-License-Identifier: MIT</code> 称为 <a href="https://spdx.org/licenses/"><strong>SPDX许可标识符</strong></a>，用于声明当前 Solidity 源代码基于 MIT开源协议编写。</li><li>第 2 行的 <code>pragma solidity &gt;=0.8.24 &lt;0.9.0;</code>称为<strong>版本编译指示</strong>，用于声明当前代码所要使用的 Solidity编译器版本（大于或等于 <code>0.8.24</code> 但是低于 <code>0.9.0</code>的版本）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 智能合约内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：访问 Solidity智能合约当中的状态变量（例如上面的 <code>data</code>状态变量），通常不需要添加 <code>this</code>关键字，通过变量名称就可以直接进行访问。</p></blockquote><h3 id="状态变量">状态变量</h3><p><strong>状态变量</strong>是指其值被永久地存储在合约存储中的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint data; <span class="comment">// 状态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p><strong>函数</strong> <code>function</code>用于接受参数并且返回变量，即可以在智能合约 <code>contract</code>的内部定义，也可以在智能合约的外部定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint data;  <span class="comment">// 声明一个无符号整型的状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置状态变量函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取状态变量函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数修饰器">函数修饰器</h3><p>函数<strong>修饰器</strong> <code>modifier</code>可以用于以声明的方式修改函数的语义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address public user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义函数修饰器 */</span></span><br><span class="line">    modifier <span class="title function_">onlyUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.<span class="property">sender</span> == user,</span><br><span class="line">            <span class="string">&quot;Only user can invoke this.&quot;</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应用函数修饰器 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) public view onlyUser &#123;</span><br><span class="line">        <span class="comment">// ... ... ... ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：修饰器与函数一样也可以被<strong>重载</strong>。</p></blockquote><h3 id="事件">事件</h3><p><strong>事件</strong> <code>event</code>可以用于方便的调用以太坊虚拟机 EVM 的日志功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    event <span class="title function_">myEvent</span>(address user, uint money);  <span class="comment">// 声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">triggerEvent</span>(<span class="params"></span>) public payable &#123;</span><br><span class="line">        emit <span class="title function_">myEvent</span>(msg.<span class="property">sender</span>, msg.<span class="property">value</span>);  <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体类型">结构体类型</h3><p><strong>结构体类型</strong> <code>struct</code>是一种可以把多个具有关联关系的变量，组合在一起的自定义数据类型。当声明并且定义好一个结构体变量之后，就可以通过成员访问操作符<code>.</code> 访问结构体的成员：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明结构体类型 */</span></span><br><span class="line">    struct <span class="title class_">Person</span> &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        bool isStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Person</span> public person; <span class="comment">// 定义结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化结构体成员 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        person = <span class="title class_">Person</span>(<span class="string">&quot;Hank&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 name 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getPersonName</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (string memory) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">name</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 age 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getPersonAge</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">age</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 isStudent 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isPersonStudent</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (bool) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">isStudent</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类型">枚举类型</h3><p>枚举可用来创建由一定数量的'常量值'构成的自定义类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyEnumContract</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明枚举类型 */</span></span><br><span class="line">    enum <span class="title class_">Color</span> &#123;</span><br><span class="line">        <span class="title class_">Red</span>,</span><br><span class="line">        <span class="title class_">Green</span>,</span><br><span class="line">        <span class="title class_">Blue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Color</span> public favoriteColor; <span class="comment">// 定义枚举类型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化枚举类型变量 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        favoriteColor = <span class="title class_">Color</span>.<span class="property">Blue</span>; <span class="comment">// 设置favoriteColor为Green</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回枚举类型变量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getFavoriteColor</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (<span class="title class_">Color</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> favoriteColor; <span class="comment">// 返回favoriteColor枚举变量的当前值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误">错误</h3><p><strong>错误</strong> <code>error</code>可以用于为系统异常定义描述性的名称和信息，其 Gas开销要比使用字符串更加便宜。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有足够的资金用于转账，需要的资金为 requested`，但是可用的只有 available */</span></span><br><span class="line">error <span class="title class_">NotEnough</span>(uint requested, uint available); <span class="comment">// 定义错误</span></span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address to, uint amount</span>) public &#123;</span><br><span class="line">        uint balance = balances[msg.<span class="property">sender</span>];</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amount)</span><br><span class="line">            revert <span class="title class_">NotEnough</span>(amount, balance); <span class="comment">// 回滚函数，并且抛出错误</span></span><br><span class="line">        <span class="comment">// ... ... ... ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释语句">注释语句</h2><p>Solidity 支持 C 语言风格的单行与多行注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一条       单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一条</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除此之外，Solidity 还支持 NatSpec 风格的注释，也就是 <code>///</code>和 <code>/** ... */</code>，主要用于函数声明和定义相关的语句上面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title 一个简单的状态变量存储示例</span></span><br><span class="line">contract <span class="title class_">SimpleStorage</span> &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 存储参数 x 的值</span></span><br><span class="line">    <span class="comment">/// @param 参数 x 指待存储的值</span></span><br><span class="line">    <span class="comment">/// @dev 将数字存储在状态变量 storedData 当中</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">uint x</span>) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取存储的状态变量</span></span><br><span class="line">    <span class="comment">/// @dev 获取状态变量 storedData 的值</span></span><br><span class="line">    <span class="comment">/// @return 状态变量存储的值</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><p>Solidity当中的变量按照作用域可以划分为<strong>状态变量</strong>（StateVariable）、<strong>局部变量</strong>（LocalVariable）、<strong>全局变量</strong>（Global Variable）三种类型：</p><p><strong>状态变量</strong>是用于将数据保存在区块链上的变量，智能合约当中的函数都可以进行访问，所消耗的Gas 比较高：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">  uint public x = <span class="number">1</span>;</span><br><span class="line">  uint public y = <span class="number">2</span>;</span><br><span class="line">  uint public z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部变量</strong>只在函数执行期间有效，存储在内存当中，不会上链，所消耗的Gas 比较低：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) external pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 x = <span class="number">1</span>;</span><br><span class="line">        uint256 y = <span class="number">2</span>;</span><br><span class="line">        uint256 z = x + y;</span><br><span class="line">        <span class="keyword">return</span> (z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong>基本都是 Solidity预留的关键字，可以在函数当中不声明直接进行使用，具体请叁考官方文档中的<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">《单位和全局变量》</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">global</span>(<span class="params"></span>) external view <span class="title function_">returns</span>(<span class="params">address, uint, bytes memory</span>)&#123;</span><br><span class="line">        address mySender = msg.<span class="property">sender</span>;   <span class="comment">// 请求发起地址</span></span><br><span class="line">        uint256 myNumber = block.<span class="property">number</span>; <span class="comment">// 当前区块号</span></span><br><span class="line">        bytes memory myData = msg.<span class="property">data</span>;  <span class="comment">// 完整 calldata</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (mySender, myNumber, myData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量-constant">常量 constant</h2><p><strong>常量</strong> <code>constant</code>必须在声明的同时进行初始化，后续不能再进行修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public constant year = <span class="number">2024</span>;</span><br><span class="line">    uint public constant month = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不变量-immutable">不变量 immutable</h2><p><strong>不变量</strong> <code>immutable</code>可以在声明的时候，或者构造函数（非普通函数）当中进行初始化，使用起来将会更加便利。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public immutable year;</span><br><span class="line">    uint public immutable month = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        year = <span class="number">2024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件判断-循环控制">条件判断 &amp; 循环控制</h2><p>Solidity 同样提供有 <code>if else</code> 条件判断语句和<code>for</code>、<code>while</code>、<code>do while</code>循环控制语句，以及 <code>continue</code>、<code>break</code>关键字和三元操作符。</p><h3 id="if-else-判断">if else 判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testIfElse</span>(<span class="params">uint256 number</span>) public pure <span class="title function_">returns</span> (bool) &#123;</span><br><span class="line">        <span class="comment">/* if else 判断 */</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-循环">for 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testFor</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* for 循环 */</span></span><br><span class="line">        <span class="keyword">for</span> (uint256 index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-循环">while 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testWhile</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line">        uint256 index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* while 循环 */</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while-循环">do while 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testDoWhile</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line">        uint256 index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* do while 循环 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (index &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三元操作符">三元操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testTernaryOperator</span>(<span class="params">uint256 x, uint256 y</span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="comment">/* 三元操作符 */</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;  <span class="comment">// 返回参数 x 和 y 的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值类型-value-type">数值类型 Value Type</h2><p>对数值类型的变量进行赋值时候，直接传递的是数值本身。</p><h3 id="布尔类型-bool">布尔类型 bool</h3><p>Solidity 当中布尔类型 <code>bool</code> 可取的值只有<code>true</code> 和 <code>false</code> 两个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bool truly = <span class="literal">true</span>;</span><br><span class="line">    bool falsely = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整型-intuint">整型 int/uint</h3><ul><li>关键字<code>int</code> 和 <code>uint</code>分别表示<strong>有符号</strong>和<strong>无符号</strong>的整型变量（<code>uint</code>和 <code>int</code> 本质上分别是 <code>uint256</code> 和<code>int256</code> 的别名）。</li><li>关键字 <code>int8</code> 到 <code>int256</code> 以及<code>uint8</code> 到 <code>uint256</code> 可以用于表示<strong>从 8 位到256位</strong>，以<strong>八位</strong>作为步长递增的<strong>有符号</strong>或者<strong>无符号</strong>整型变量。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    int intValue = <span class="number">2024</span>;</span><br><span class="line">    uint uintValue = <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line">    int8 int8Value = <span class="number">99</span>;</span><br><span class="line">    int32 int32Value = <span class="number">2024</span>;</span><br><span class="line">    int256 int256Value = <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line">    uint8   uint8Value = <span class="number">99</span>;</span><br><span class="line">    uint32  uint32Value = <span class="number">2024</span>;</span><br><span class="line">    uint256 uint256Value = <span class="number">2024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址类型-address">地址类型 address</h3><p>地址类型是 Solidity提供的一种特殊数据类型，主要用于保存以太坊地址，并且拥有一系列的<a href="https://docs.soliditylang.org/zh/latest/units-and-global-variables.html#address-related">成员变量</a>：</p><ul><li><code>address</code>: 用于保存 20 字节的太坊地址，；</li><li><code>address payable</code>: 保存太坊地址的同时，还拥有额外的<code>transfer()</code> 和 <code>send()</code> 方法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address myAddress = <span class="number">0xd82b7E2f20C3FBAc76e74D1C8d8C6af8032bbEc0</span>;</span><br><span class="line">    address payable myPayableAddress = <span class="title function_">payable</span>(myAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述两种地址类型进行转换时，<code>address payable</code>可以自动转换为 <code>address</code>，而 <code>address</code> 则需要通过<code>payable(&lt;address&gt;)</code>，才能被强制转换为<code>address payable</code>。</p></blockquote><h3 id="枚举类型-enum">枚举类型 enum</h3><p>枚举类型 <code>enum</code> 用于为从 <code>0</code> 开始计数的<code>uint</code> 类型数据分配名称（最大不能超过<code>256</code>），从而提高代码的可读性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    enum <span class="title class_">Cars</span> &#123;<span class="variable constant_">HAVAL</span>, <span class="variable constant_">GEELY</span>, <span class="variable constant_">CHERY</span>&#125;         <span class="comment">// 把 uint 类型的 0、1、2 表示为 HAVAL、GEELY、CHERY</span></span><br><span class="line">    <span class="title class_">Cars</span> public myFavoriteCar = <span class="title class_">Cars</span>.<span class="property">GEELY</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用类型-reference-type">引用类型 Reference Type</h2><p>对引用类型变量进行赋值的时候，实际上传递的是地址指针。</p><h3 id="数组">数组 [ ]</h3><p><strong>Solidity</strong>的数组可以在声明时指定长度（<code>数组元素类型[长度]</code>），也可以动态调整长度（<code>数组元素类型[]</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    int[<span class="number">5</span>] intArray = [<span class="title function_">int</span>(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    uint[] uintArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory number = <span class="keyword">new</span> uint[](<span class="number">3</span>);</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1985</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2010</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">2024</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Solidity判别数组元素类型的时候，总是会以<strong>第 1个元素</strong>的数据类型作为判定依据。</p></blockquote><h3 id="定长字节数组-bytesx">定长字节数组 bytesX</h3><p>定长字节数组<code>bytes1</code>、<code>bytes2</code>、<code>bytes3</code> ...<code>bytes32</code> 用于表达从 <strong>1</strong> 至<strong>32</strong> 长度的字节序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bytes1 one = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    bytes3 three = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    bytes5 five = <span class="string">&quot;uinio&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长字节数组-bytesstring">变长字节数组 bytes/string</h3><p><strong>变长字节数组</strong> <code>bytes</code> 和<strong>变长 UTF-8编码字符串</strong> <code>string</code> 本质上是一种特殊的数组。</p><ul><li><code>bytes</code> 类似于<code>bytes1[]</code>，但是由于采用了紧打包，存储空间占用相对较少，更加节省Gas 费用；</li><li><code>string</code> 与 <code>bytes</code>相同，不过不允许通过长度或者索引来进行访问；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/* bytes1[] 类型 */</span></span><br><span class="line">    bytes1 one = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    bytes1[] bytes1Array = [one, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bytes 类型 */</span></span><br><span class="line">    bytes bytesArray = <span class="string">&quot;2024&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* string 类型 */</span></span><br><span class="line">    string test = <span class="string">&quot;Hello Hank!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>bytes</code> 和 <code>string</code>类型都提供有一个 <code>concat()</code>函数，用于连接两个字符串，该函数会分别返回 <code>bytes</code> 或<code>string</code> 类型的 <code>memory</code> 存储位置数组。</p></blockquote><h3 id="结构体-struct">结构体 struct</h3><p>Solidity 可以通过<strong>结构体</strong> <code>struct</code>来自定义数据类型，其中的元素既可以是<strong>数值类型</strong>，也可以是<strong>引用类型</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明 PCB 结构体 */</span></span><br><span class="line">    struct <span class="variable constant_">PCB</span>&#123;</span><br><span class="line">        uint256 width;   <span class="comment">// 长度</span></span><br><span class="line">        uint256 height;  <span class="comment">// 高度</span></span><br><span class="line">        uint256 layer;   <span class="comment">// 层数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">PCB</span> board = <span class="title function_">PCB</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">4</span>); <span class="comment">// 初始化 PCB 结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射类型-mapping">映射类型 mapping</h3><p>Solidity 的映射类型使用语法<code>mapping(键类型 键名称 =&gt; 值类型 值名称)</code>，其中键和值的名称都可以被省略，映射的值只能在函数内进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MappingExampleWithNames</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances1;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(address user =&gt; uint balance) public balances2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solidity 当中映射的存储位置必须为<code>storage</code>，向映射新增键值对的语法为<code>映射名称[键] = 值</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MappingExampleWithNames</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateBalances1</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        balances1[msg.<span class="property">sender</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(address user =&gt; uint balance) public balances2;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateBalances2</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        balances2[msg.<span class="property">sender</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储位置">存储位置</h3><p>可以将引用类型的<strong>数组</strong>、<strong>结构体</strong>、<strong>映射</strong>存储位置，分别指定为<code>storage</code>、<code>memory</code>、<code>calldata</code>，不同存储类型所耗费的Gas 成本不同：</p><ul><li><code>storage</code>：智能合当中的<strong>状态变量</strong>都默认为<code>storage</code> 类型，存储在链上面，消耗 Gas 较多。</li><li><code>memory</code>：函数当中的参数和临时变量都属于<code>memory</code> 类型，主要存储在内存当中，不会上链，消耗 Gas较少。</li><li><code>calldata</code>：类似于 memory存储在内存且不会上链，区别在于存储位置的变量不能被修改，消耗 Gas较少。</li></ul><h2 id="数据类型默认值">数据类型默认值</h2><p>不同于 JavaScript，在 Solidity 当中不存在 <code>未定义</code> 或者<code>空</code>值的概念，而且新声明的变量总是被指定为其所属数据类型的<strong>默认值</strong>。</p><table><colgroup><col style="width: 21%"><col style="width: 12%"><col style="width: 66%"></colgroup><thead><tr class="header"><th style="text-align: left;">名称</th><th style="text-align: left;">值类型</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>布尔类型</strong></td><td style="text-align: left;">boolean</td><td style="text-align: left;"><code>false</code></td></tr><tr class="even"><td style="text-align: left;"><strong>字符串类型</strong></td><td style="text-align: left;">string</td><td style="text-align: left;"><code>""</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>整型</strong></td><td style="text-align: left;">int</td><td style="text-align: left;"><code>0</code></td></tr><tr class="even"><td style="text-align: left;"><strong>无符号整型</strong></td><td style="text-align: left;">uint</td><td style="text-align: left;"><code>0</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>枚举类型</strong></td><td style="text-align: left;">enum</td><td style="text-align: left;"><code>首个元素</code></td></tr><tr class="even"><td style="text-align: left;"><strong>地址类型</strong></td><td style="text-align: left;">address</td><td style="text-align: left;"><code>0x0000000000000000000000000000000000000000</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>函数类型</strong></td><td style="text-align: left;">function</td><td style="text-align: left;"><code>空白函数</code></td></tr></tbody></table><table><colgroup><col style="width: 12%"><col style="width: 9%"><col style="width: 78%"></colgroup><thead><tr class="header"><th style="text-align: left;">名称</th><th style="text-align: left;">引用类型</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>映射</strong></td><td style="text-align: left;">mapping</td><td style="text-align: left;">所有元素都是其所属数据类型的默认值；</td></tr><tr class="even"><td style="text-align: left;"><strong>结构体</strong></td><td style="text-align: left;">struct</td><td style="text-align: left;">所有成员都是其所属数据类型的默认值；</td></tr><tr class="odd"><td style="text-align: left;"><strong>数组</strong></td><td style="text-align: left;">array</td><td style="text-align: left;"><strong>动态数组</strong>默认为<code>[]</code>，<strong>定长数组</strong>为元素所属数据类型的默认值；</td></tr></tbody></table><p>Solidity 提供了一个 <code>delete</code>操作符，可以将指定的变换恢复为初始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bool public boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) external &#123;</span><br><span class="line">        <span class="keyword">delete</span> boolean; <span class="comment">// 将 boolean 变换为默认值 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型-function">函数类型 function</h2><h3 id="函数的定义">函数的定义</h3><p>Solidity当中的函数可以接收参数，并且返回相应的处理结果，其基本的定义形式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名称(参数类型 _参数名称<span class="number">1</span>, 参数类型 _参数名称<span class="number">2</span>)  internal|external|public|private  pure|view|payable  <span class="title function_">returns</span>(<span class="params">返回值类型 返回值名称<span class="number">1</span>, 返回值类型 返回值名称<span class="number">2</span></span>)&#123;</span><br><span class="line"></span><br><span class="line">  返回值名称<span class="number">1</span> = _参数名称<span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">  返回值名称<span class="number">2</span> = _参数名称<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public result = <span class="title function_">add</span>(<span class="number">1</span>);  <span class="comment">// result = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a) &#123;</span><br><span class="line">        a = parameter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以显式的在 Solidity 当中使用 <code>return</code>关键字返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名称(参数类型 _参数名称<span class="number">1</span>, 参数类型 _参数名称<span class="number">2</span>)  internal|external|public|private  pure|view|payable  <span class="title function_">returns</span>(<span class="params">返回值类型 返回值名称<span class="number">1</span>, 返回值类型 返回值名称<span class="number">2</span></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(返回值<span class="number">1</span>, 返回值<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public result = <span class="title function_">add</span>(<span class="number">1</span>);  <span class="comment">// result = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a) &#123;</span><br><span class="line">        <span class="keyword">return</span> parameter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取返回值">读取返回值</h3><p>除此之外，Solidity函数返回值的读取，可以采用解构的方式，一次性读取全部或者部分的返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量类型 _变量名称<span class="number">1</span>;</span><br><span class="line">变量类型 _变量名称<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(_变量名称<span class="number">1</span>, _变量名称<span class="number">2</span>) = 函数名称() <span class="comment">// 读取所有返回值</span></span><br><span class="line">(_变量名称<span class="number">1</span>, ) = 函数名称()          <span class="comment">// 只读取部分返回值</span></span><br><span class="line">(, _变量名称<span class="number">2</span>) = 函数名称()          <span class="comment">// 只读取部分返回值</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a, uint b, uint c) &#123;</span><br><span class="line">        a = parameter + <span class="number">1</span>;</span><br><span class="line">        b = parameter + <span class="number">2</span>;</span><br><span class="line">        c = parameter + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params"></span>) public pure &#123;</span><br><span class="line">        uint resultA;</span><br><span class="line">        uint resultB;</span><br><span class="line">        uint resultC;</span><br><span class="line">        (resultA, resultB, resultC) = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态可变性-view-pure">状态可变性 view pure</h3><p>声明为 <code>view</code>的函数，可以读取状态，但是不能修改状态，这里的<strong>状态</strong>是指：</p><ol type="1"><li>修改状态变量；</li><li>产生事件；</li><li>创建其它智能合约；</li><li>使用了 <code>selfdestruct</code>；</li><li>通过调用发送 ETH 以太币；</li><li>调用没有被标记为 <code>view</code> 或者 <code>pure</code>的函数；</li><li>使用了低级调用；</li><li>使用了包含特定操作码的内联汇编；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">uint256 a, uint256 b</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + block.<span class="property">timestamp</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明为 <code>pure</code>的函数，即不能读取状态，也不能修改状态，而这里的<strong>状态</strong>则是指：</p><ol type="1"><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或者<code>&lt;address&gt;.balance</code>。</li><li>访问 <code>block</code>、<code>tx</code>、<code>msg</code>当中的成员（除 <code>msg.sig</code> 和 <code>msg.data</code>之外）。</li><li>调用没有被标记为 <code>pure</code> 的函数。</li><li>使用了包含某些操作码的内联汇编。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">uint256 a, uint256 b</span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：由于被声明为 <code>pure</code> 和<code>view</code>的函数不能修改<strong>状态变量</strong>，因而调用时也就无需被收取 Gas费用。</p></blockquote><h2 id="构造函数-constructor">构造函数 constructor</h2><p>每一份 Solidity 智能合约都可以定义一个 <code>constructor</code><strong>构造函数</strong>，该函数会在智能合约部署的时候自动被执行一次，因而可以用于初始化一些参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address owner; <span class="comment">// 定义一个 owner 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        owner = msg.<span class="property">sender</span>; <span class="comment">// 该智能合约部署的时候，会将 owner 设置为部署者的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数修饰器-modifier">函数修饰器 modifier</h2><p>Solidity 提供的 <code>modifier</code>修饰器语法，能够以<strong>声明</strong>的方式来改变一些函数的行为，例如在执行函数之前自动进行一个检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address owner;          <span class="comment">// 定义一个 owner 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        owner = msg.<span class="property">sender</span>; <span class="comment">// 该智能合约部署的时候，会将 owner 设置为部署者的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义一个 modifier 修饰器 */</span></span><br><span class="line">    modifier <span class="title function_">onlyOwner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.<span class="property">sender</span> == owner); <span class="comment">// 检查调用者地址</span></span><br><span class="line">        _;        <span class="comment">// 如果是就继续运行，否则报错并且回滚交易</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateOwner</span>(<span class="params">address _newOwner</span>) external onlyOwner &#123;</span><br><span class="line">        owner = _newOwner;  <span class="comment">// 只有 owner 地址运行这个函数，并改变owner</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：函数修饰器提供的<strong>占位符语句</strong><code>_</code>用于表示添加了<strong>修饰符</strong>的函数主体被插入的位置。</p></blockquote><h2 id="函数与状态变量的可见性">函数与状态变量的可见性</h2><h3 id="状态变量可见性">状态变量可见性</h3><ol type="1"><li><strong>声明为 <code>public</code>的状态变量</strong>：编译器会自动为其生成 <code>Getter</code>函数，从而允许其它智能合约读取其值。除此之外，同一个合约当中使用时，通过<code>this.x</code> 外部访问时也会调用 <code>Getter</code> 函数，而通过<code>x</code> 直接内部访问则会直接从存储获取变量值。 由于没有生成<code>Setter</code> 函数，所以其它智能合约无法修改其值。</li><li><strong>声明为 <code>internal</code>的状态变量</strong>：只能从其所定义的智能合约，或者派生出的智能合约当中进行访问，这也是状态变量的<strong>默认的可见性</strong>。</li><li><strong>声明为 <code>private</code>的状态变量</strong>：类似于内部变量，但是在派生出的智能合约当中不可以访问。</li></ol><h3 id="函数的可见性">函数的可见性</h3><ol type="1"><li><strong>声明为 <code>external</code>的函数</strong>：只能被其它智能合约或者交易调用，不能从智能合约内部被调用（无法通过<code>ext()</code> 调用，但是可以通过 <code>this.ext()</code>调用）。</li><li><strong>声明为 <code>public</code>的函数</strong>：可以被任何智能合约或者交易调用。</li><li><strong>声明为 <code>internal</code>的函数</strong>：只能在当前智能合约内部或者派生的智能合约当中访问，不能从智能合约的外部进行访问。</li><li><strong>声明为 <code>private</code>的函数</strong>：只能在被定义的智能合约内部进行访问，无论是外部还是派生的智能合约都无法进行访问。</li></ol><h2 id="事件-event">事件 event</h2><p>Solidity 当中事件 <code>event</code> 的本质是以太坊虚拟机 EVM日志功能的抽象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event 事件名称(事件变量类型 事件变量名称);</span><br></pre></td></tr></table></figure><p>下面的示例代码，每次调用 <code>transfer()</code>函数进行转账的时候，都会触发 <code>Transfer</code>事件，并且记录对应的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    event <span class="title class_">Transfer</span>(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义用于执行转帐的 transfer 函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address <span class="keyword">from</span>, address to, uint256 value</span>) external &#123;</span><br><span class="line">        <span class="comment">// ... ... ... ...</span></span><br><span class="line">        emit <span class="title class_">Transfer</span>(<span class="keyword">from</span>, to, value); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面代码当中出现的 <code>indexed</code>关键字，可以将变量保存在以太坊虚拟机 EVM 日志的 <code>topics</code>当中，从而可以方便的在后续进行检索。</p></blockquote><p>以太坊虚拟机 EVM 会使用日志 <code>Log</code> 来存储 Solidity事件，每一条 Log 日志都记录着 <code>topics</code> 主题和<code>data</code> 数据两个部分：</p><ol type="1"><li><strong>主题</strong> <code>Topics</code>：用于描述事件，只能容纳 32个字节，且只能保存最多三个 <code>indexed</code> 参数；</li><li><strong>数据</strong> <code>Data</code>：用于保存没有被标注为<code>indexed</code> 的参数，可以存储任意大小的数据；</li></ol><h2 id="异常处理-error">异常处理 error</h2><p>Solidity 可以使用 <code>error()</code>方法定义一个不带参数的异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(); <span class="comment">// 定义一个没有参数的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，也可以使用 <code>error()</code>方法定义一个携带有参数的异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(address sender); <span class="comment">// 定义一个带有地址参数的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，<code>error()</code> 必须搭配<strong>回退命令</strong><code>revert</code> 进行使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(address sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transferOwner</span>(<span class="params"></span>) public view  &#123;</span><br><span class="line">         revert <span class="title class_">TransferError</span>(msg.<span class="property">sender</span>); <span class="comment">// 使用 revert 回退命令抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，一些较早版本的 Solidity 还会使用已经废弃了的<code>require()</code> 方法来处理异常，其缺点在于 Gas费用会伴随异常描述字符串长度的增加而增加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(异常检查条件，<span class="string">&quot;异常描述信息&quot;</span>);</span><br></pre></td></tr></table></figure><p>而另外一个 <code>assert()</code>方法则不能抛出自定义的异常信息，只能直接抛出默认的异常错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">assert</span>(异常检查条件);</span><br></pre></td></tr></table></figure><h2 id="继承机制-is">继承机制 is</h2><p>Solidity 当中的智能合约可以通过 <code>is</code>关键字来<strong>继承</strong>其它合约，从而扩展其功能。<strong>子合约</strong>可以继承<strong>父合约</strong>当中<code>internal</code> 和 <code>public</code>的函数、状态变量以及事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 父合约 */</span></span><br><span class="line">contract <span class="title class_">ParentContract</span> &#123;</span><br><span class="line">    uint public parentVariable; <span class="comment">// 父合约状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parentFunction</span>(<span class="params"></span>) public virtual &#123;&#125; <span class="comment">// virtual 关键字用于明确标识一个函数可以在子合约当中被重写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父合约事件 */</span></span><br><span class="line">    event <span class="title class_">ParentEvent</span>(uint indexed value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子合约 */</span></span><br><span class="line">contract <span class="title class_">ChildContract</span> is <span class="title class_">ParentContract</span> &#123;</span><br><span class="line">    uint public childVariable; <span class="comment">// 子合约状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重写父合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parentFunction</span>(<span class="params"></span>) public override &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">childFunction</span>(<span class="params"></span>) public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触发父合约事件 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">triggerParentEvent</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        emit <span class="title class_">ParentEvent</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Solidity只能实现<strong>单继承</strong>，即一个子合约只能直接继承自一个父合约。</p></blockquote><h2 id="模块化导入-import">模块化导入 import</h2><p>Solidity 支持 <code>import</code>模块化导入，下面的一语句用于全局导入，可以将 <code>filename</code>导入路径源文件中的<strong>全局符号</strong>引入到当前源文件，但是会污染当前Solidity 源文件的命名空间，并不建议使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure><p>下面的导入语句将 <code>filename</code>当中的全局符号，导入到了一个新的命名空间 <code>symbolName</code>当中，从而有效避免了命名空间的污染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> symbolName <span class="keyword">from</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure><p>上述的语句，可以简化的写为如下的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;filename&quot;</span> <span class="keyword">as</span> symbolName;</span><br></pre></td></tr></table></figure><p>如果导入源文件当中的命名符号存在冲突，则可以在导入的时候对其进行重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; symbol1 <span class="keyword">as</span> alias, symbol2 &#125; <span class="keyword">from</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="openzeppelin-基础">OpenZeppelin 基础</h2><p><a href="https://www.openzeppelin.com/">OpenZeppelin</a> 是一家成立于2015 年的区块链技术企业，其推出的 <code>contracts</code>是一款是用于开发<strong>安全智能合约</strong>的开源 Solidity库，其主要提供了以下三方面的功能：</p><ol type="1"><li><strong>访问控制</strong>：用于在智能合约当中，指定每个角色可以进行的操作。</li><li><strong>Tokens</strong>：创建可以交易的资产或数字藏品，例如 ERC20或者 ERC721。</li><li><strong>工具</strong>：一些通用工具函数，包括不会溢出的数学运算、签名验证等。</li></ol><p>可以通过下面的 <code>npm</code> 命令快速安装<strong>OpenZeppelin</strong> 的 <code>contracts</code> 库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><p><strong>OpenZeppelin</strong> 提供的大多数特性，都需要通过 Solidity的 <code>is</code> 关键字，以<strong>继承</strong>的方式来进行使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contracts/MyNFT.sol</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ERC721</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyNFT</span> is <span class="title class_">ERC721</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC721</span>(<span class="string">&quot;MyNFT&quot;</span>, <span class="string">&quot;MNFT&quot;</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以通过 Solidity 的 <code>overrides</code>来重<strong>写</strong> <strong>OpenZeppelin</strong>当中提供的功能，例如希望改变 <code>AccessControl</code> 中的<code>revokeRole()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">AccessControl</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ModifiedAccessControl</span> is <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="comment">// 重写 revokeRole() 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">revokeRole</span>(<span class="params">bytes32, address</span>) public override &#123;</span><br><span class="line">        <span class="title function_">revert</span>(<span class="string">&quot;ModifiedAccessControl: cannot revoke roles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候会想<strong>继承</strong>某一部分 <strong>OpenZeppelin</strong>当中的功能，并非完全的重写它们，此时就需要用使用到 solidity 的<code>super</code> 关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line">contract <span class="title class_">ModifiedAccessControl</span> is <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">revokeRole</span>(<span class="params">bytes32 role, address account</span>) public override &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            role != <span class="variable constant_">DEFAULT_ADMIN_ROLE</span>,</span><br><span class="line">            <span class="string">&quot;ModifiedAccessControl: cannot revoke default admin role&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// super.revokeRole 语句将会调用 AccessControll 的原始 revokeRole 方法</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">revokeRole</span>(role, account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问控制-ownerable.sol">访问控制 Ownerable.sol</h2><p><strong>OpenZeppelin</strong> 将发布智能合约的账户称为<code>owner</code>，其提供了 <code>Ownerable.sol</code>来管理智能合约当中的所有权。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/Ownable.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyContract</span> is <span class="title class_">Ownable</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">normalThing</span>(<span class="params"></span>) public &#123;&#125; <span class="comment">// 所有人都可以调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">specialThing</span>(<span class="params"></span>) public onlyOwner &#123;&#125; <span class="comment">// 只有 Owner 才可以调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：示例代码当中的 <code>onlyOwner</code>关键字是由 Openzeppelin 当中的 <code>Ownerable.sol</code> 所提供的。</p></blockquote><p><code>Ownerable.sol</code> 主要提供了如下两个功能函数：</p><ul><li><code>transferOwnership()</code>将智能合约的所有权转移给另外一个账户；</li><li><code>renounceOwnership()</code> 放弃智能合约的所有权关系；</li></ul><h2 id="访问控制-accesscontrol.sol">访问控制 AccessControl.sol</h2><p>除此之外，<strong>OpenZeppelin</strong> 还提供了<code>AccessControl.sol</code>来基于<strong>角色</strong>进行访问控制（即定义多个角色，并且每个角色对应一组操作权限）。其使用非常简单，对于每个定义的角色都会创建一个<strong>角色标识符</strong>，用于授权、撤销、检查账户是否拥有该角色。</p><p>下面是一个基于 ERC20 Token 使用 <code>AccessControl.sol</code>的例子，它定义了一个名为 <code>minter</code>的角色，该角色允许账户创建新的 <code>token</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="comment">// 为 minter 角色创建一个新的角色标识符</span></span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address minter</span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">MINTER_ROLE</span>, minter); <span class="comment">// 将 minter 角色授予指定帐户</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public &#123;</span><br><span class="line">        <span class="built_in">require</span>(<span class="title function_">hasRole</span>(<span class="variable constant_">MINTER_ROLE</span>, msg.<span class="property">sender</span>), <span class="string">&quot;Caller is not a minter&quot;</span>); <span class="comment">// 检查调用帐号是否具有 minter 角色</span></span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OpenZeppelin</strong> 提供的 <code>AccessControl.sol</code>亮点在于需要细粒度权限控制的场景，这可以通过定义多个角色来实现。通过这样的拆分，可以实现比<code>Ownerable.sol</code>提供的简单所有权控制，层级要更多的访问控制。请注意，如果需要的话，<strong>同一个账户可以拥有多个不同的角色</strong>。</p><blockquote><p><strong>注意</strong>：限制系统中每个组件能做的事情被称为<strong>最小权限原则</strong>。</p></blockquote><p>接下来定义一个 <code>burner</code> 角色来扩展上面的 ERC20 token示例，并且通过使用 <code>onlyRole</code> 修饰符来允许账户销毁<code>token</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line">    bytes32 public constant <span class="variable constant_">BURNER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;BURNER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address minter, address burner</span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">MINTER_ROLE</span>, minter); <span class="comment">// 设置 minter 访问权限</span></span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">BURNER_ROLE</span>, burner); <span class="comment">// 设置 burner 访问权限</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过使用 `onlyRole` 修饰符来允许账户销毁 token</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">MINTER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">burn</span>(<span class="params">address <span class="keyword">from</span>, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">BURNER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_burn</span>(<span class="keyword">from</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码当中，使用了内部函数 <code>_setupRole()</code>来分配角色，除此之外还可以使用以下的工具函数来管理角色：</p><ul><li><code>hasRole()</code>：判断角色。</li><li><code>grantRole()</code>：授予角色。</li><li><code>revokeRole()</code>：回收角色。</li></ul><p>除此之外，<strong>OpenZeppelin</strong> 提供的<code>AccessControl.sol</code> 当中，还包含有一个称为<code>DEFAULT_ADMIN_ROLE</code>的特殊角色，它是<strong>所有角色的默认管理员</strong>，拥有该角色的账户可以去管理其它的角色，除非手工调用<code>_setRoleAdmin()</code> 内部函数来指定一个新的管理员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line">    bytes32 public constant <span class="variable constant_">BURNER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;BURNER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 授予合约部署者默认的 DEFAULT_ADMIN_ROLE 角色，使其能够授予和撤销任何角色</span></span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">DEFAULT_ADMIN_ROLE</span>, msg.<span class="property">sender</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">MINTER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">burn</span>(<span class="params">address <span class="keyword">from</span>, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">BURNER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_burn</span>(<span class="keyword">from</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，<code>AccessControl.sol</code>还提供了如下两个工具函数：</p><ul><li><code>getRoleMember()</code>：返回某个角色当中账户的地址；</li><li><code>getRoleMemberCount()</code>：返回某个角色当中账户的数量；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回某个角色当中账户的数量</span></span><br><span class="line"><span class="keyword">const</span> minterCount = <span class="keyword">await</span> myToken.<span class="title function_">getRoleMemberCount</span>(<span class="variable constant_">MINTER_ROLE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回某个角色当中账户的地址</span></span><br><span class="line"><span class="keyword">const</span> members = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minterCount; ++i) &#123;</span><br><span class="line">  members.<span class="title function_">push</span>(<span class="keyword">await</span> myToken.<span class="title function_">getRoleMember</span>(<span class="variable constant_">MINTER_ROLE</span>, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代币-erc20-token">代币 ERC20 Token</h2><p><strong>代币</strong>（Token）是指区块链上，各种可以通过智能合约来调用、交易、创建、销毁的虚拟资产，其中<strong>ERC721</strong> 是以太坊上用于非同质化代币（NFT，Non FungibleToken）的标准，<strong>OpenZeppelin</strong> 针对 ERC721标准提供了大量的接口方法，下面的代码可以用于构建一个 ERC721代币智能合约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/utils/Counters.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">GameItem</span> is <span class="title class_">ERC721URIStorage</span> &#123;</span><br><span class="line">    using <span class="title class_">Counters</span> <span class="keyword">for</span> <span class="title class_">Counters</span>.<span class="property">Counter</span>;</span><br><span class="line">    <span class="title class_">Counters</span>.<span class="property">Counter</span> private _tokenIds;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC721</span>(<span class="string">&quot;GameItem&quot;</span>, <span class="string">&quot;ITM&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">awardItem</span>(<span class="params">address player, string memory tokenURI</span>) public <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 newItemId = _tokenIds.<span class="title function_">current</span>();</span><br><span class="line">        <span class="title function_">_mint</span>(player, newItemId);</span><br><span class="line">        <span class="title function_">_setTokenURI</span>(newItemId, tokenURI); <span class="comment">// 设置物品的元数据</span></span><br><span class="line"></span><br><span class="line">        _tokenIds.<span class="title function_">increment</span>();</span><br><span class="line">        <span class="keyword">return</span> newItemId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码当中，新的 NFT 可以通过执行如下代码来进行生成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gameItem.awardItem(playerAddress, <span class="string">&quot;http://uinio.com/NFT.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">- Transfer(0x0000000000000000000000000000000000000000, playerAddress, 5)</span><br></pre></td></tr></table></figure><p>并且每个物品的所有者和元数据都可以通过如下的方式进行查询:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gameItem.ownerOf(5)</span><br><span class="line">playerAddress</span><br><span class="line"></span><br><span class="line">&gt; gameItem.tokenURI(5)</span><br><span class="line"><span class="string">&quot;http://uinio.com/NFT.json&quot;</span></span><br></pre></td></tr></table></figure><p>最终，获得的 <code>tokenURI</code> 就是一个如下所示的 JSON格式数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;雷神之锤&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;一个漫威电影当中的道具&quot;</span>,</span><br><span class="line">    <span class="string">&quot;image&quot;</span>: <span class="string">&quot;http://localhost:1985/Web/Solidity/logo.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;strength&quot;</span>: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="财务功能-finance">财务功能 Finance</h2><p><strong>OpenZeppelin</strong> 在 Finance 目录下提供了<strong>PaymentSplitter</strong>（只存在于 <strong>Contracts</strong>库的 <code>4.x</code> 版本）和 <strong>VestingWallet</strong>（存在于<strong>Contracts</strong> 库的 <code>4.x</code> 和 <code>5.x</code>版本）两个财务相关的智能合约：</p><ul><li><strong><code>PaymentSplitter</code>智能合约</strong>：通常用于管理和分配资金，可以允许将资金分割并发送到多个地址，通常基于预定义的分配规则或比例。通常用于众筹、团队资金分配或任何需要按照特定比例分割资金的场景。</li><li><strong><code>VestingWallet</code>智能合约</strong>：则是一种特殊的钱包，用于管理资产的逐步解锁或归属。它通常用于确保代币或资金在一定时间段内逐步释放给接收者，而不是立即全部可用。通常用于激励计划、团队代币锁定或者任何需要时间限制的资金释放场景。</li></ul><p>概括起来，<code>PaymentSplitter</code> 与 <code>VestingWallet</code>两者的区别主要体现在如下四个方面：</p><ol type="1"><li><strong>目的不同</strong>：<code>PaymentSplitter</code>旨在分割和分配资金，而 <code>VestingWallet</code>旨在逐步解锁和释放资金。</li><li><strong>使用场景不同</strong>：<code>PaymentSplitter</code>更适用于一次性的资金分配场景，而 <code>VestingWallet</code>更适用于需要长期管理和逐步释放资金的场景。</li><li><strong>功能不同</strong>：<code>PaymentSplitter</code>主要关注资金的即时分配，而 <code>VestingWallet</code>关注资金的时间锁定和逐步解锁。</li><li><strong>透明度与可追踪性</strong>：两者都可能提供事件来增强透明度和可追踪性，但事件的具体内容和触发条件会根据合约的具体实现而有所不同。</li></ol><h3 id="paymentsplitter-分帐">PaymentSplitter 分帐</h3><p>OpenZeppelin 的 PaymentSplitter智能合约库允许将一个以太坊地址收到的付款按照指定的<strong>份额</strong>（Shares）进行分割，并将这些部分按指定的份额值发送给收款人。这个合约非常适合用于在多个团队成员、投资者或合作伙伴之间分配资金的情况。</p><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th style="text-align: left;">PaymentSplitter 提供的方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>constructor(payees, shares_)</code></td><td style="text-align: left;">构造函数，数组<code>payees</code>（收款人）当中的每个账户，都会获得<code>shares_</code>（份额）数组中匹配位置的份额值。</td></tr><tr class="even"><td style="text-align: left;"><code>receive()</code></td><td style="text-align: left;">接收 ETH 以太币（会被记录至<code>PaymentReceived</code> 事件）。</td></tr><tr class="odd"><td style="text-align: left;"><code>totalShares()</code></td><td style="text-align: left;">获取收款人 <code>payees</code>持有的全部份额。</td></tr><tr class="even"><td style="text-align: left;"><code>totalReleased()</code></td><td style="text-align: left;">获取已经释放的 ETH 以太币总额。</td></tr><tr class="odd"><td style="text-align: left;"><code>totalReleased(token)</code></td><td style="text-align: left;">获取已经释放的 <code>token</code>代币总额。</td></tr><tr class="even"><td style="text-align: left;"><code>shares(account)</code></td><td style="text-align: left;">获取指定地址账户持有的份额值。</td></tr><tr class="odd"><td style="text-align: left;"><code>released(account)</code></td><td style="text-align: left;">获取已释放给指定地址收款人的 ETH以太币数量。</td></tr><tr class="even"><td style="text-align: left;"><code>released(token, account)</code></td><td style="text-align: left;">获取已释放给指定地址收款人的<code>token</code> 代币数量。</td></tr><tr class="odd"><td style="text-align: left;"><code>payee(index)</code></td><td style="text-align: left;">获取收款人数组 <code>payees</code> 指定<code>index</code> 索引的收款人的账户地址。</td></tr><tr class="even"><td style="text-align: left;"><code>releasable(account)</code></td><td style="text-align: left;">获取指定账户地址的收款人，当前可以释放的ETH 以太币数量。</td></tr><tr class="odd"><td style="text-align: left;"><code>releasable(token, account)</code></td><td style="text-align: left;">获取指定账户地址的收款人，当前可以释放的<code>token</code> 代币数量。</td></tr><tr class="even"><td style="text-align: left;"><code>release(account)</code></td><td style="text-align: left;">根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放ETH 以太币。</td></tr><tr class="odd"><td style="text-align: left;"><code>release(token, account)</code></td><td style="text-align: left;">根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放<code>token</code> 代币。</td></tr></tbody></table><table><colgroup><col style="width: 37%"><col style="width: 62%"></colgroup><thead><tr class="header"><th style="text-align: left;">PaymentSplitter 提供的事件</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>PayeeAdded(account, shares)</code></td><td style="text-align: left;">收款人添加事件，需要指定其账户地址<code>account</code> 以及所占份额 <code>shares</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>PaymentReceived(from, amount)</code></td><td style="text-align: left;">智能合约收款事件，向 <code>from</code>地址收取 <code>amount</code> 数额 ETH 以太币的事件。</td></tr><tr class="odd"><td style="text-align: left;"><code>PaymentReleased(to, amount)</code></td><td style="text-align: left;">受益人提款事件，即向 <code>to</code>地址支付 <code>amount</code> 数额 ETH 以太币的事件。</td></tr><tr class="even"><td style="text-align: left;"><code>ERC20PaymentReleased(token, to, amount)</code></td><td style="text-align: left;">受益人提款事件，即向 <code>to</code>地址支付 <code>amount</code> 数额 <code>token</code> 代币的事件。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：上述表格当中的 <code>token</code> 是一个IERC20 代币智能合约的地址。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../token/ERC20/utils/SafeERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../utils/Address.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../utils/Context.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">PaymentSplitter</span> is <span class="title class_">Context</span> &#123;</span><br><span class="line">    event <span class="title class_">PayeeAdded</span>(address account, uint256 shares);</span><br><span class="line">    event <span class="title class_">PaymentReleased</span>(address to, uint256 amount);</span><br><span class="line">    event <span class="title class_">ERC20PaymentReleased</span>(<span class="title class_">IERC20</span> indexed token, address to, uint256 amount);</span><br><span class="line">    event <span class="title class_">PaymentReceived</span>(address <span class="keyword">from</span>, uint256 amount);</span><br><span class="line"></span><br><span class="line">    uint256 private _totalShares;   <span class="comment">// 总份额</span></span><br><span class="line">    uint256 private _totalReleased; <span class="comment">// 总提款</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _shares;   <span class="comment">// 每个受益人占有的份额</span></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _released; <span class="comment">// 支付给每个受益人的金额</span></span><br><span class="line">    address[] private _payees;                     <span class="comment">// 受益人数组</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">IERC20</span> =&gt;</span> uint256) private _erc20TotalReleased;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">IERC20</span> =&gt;</span> <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256)) private _erc20Released;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 构造函数，数组 payees（收款人）当中的每个账户，都会获得 shares_（份额）数组中匹配位置的份额值 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address[] memory payees, uint256[] memory shares_</span>) payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(payees.<span class="property">length</span> == shares_.<span class="property">length</span>, <span class="string">&quot;PaymentSplitter: payees and shares length mismatch&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(payees.<span class="property">length</span> &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: no payees&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (uint256 i = <span class="number">0</span>; i &lt; payees.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">_addPayee</span>(payees[i], shares_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 接收 ETH 以太币（会被记录至 PaymentReceived 事件） */</span></span><br><span class="line">    <span class="title function_">receive</span>() external payable virtual &#123;</span><br><span class="line">        emit <span class="title class_">PaymentReceived</span>(<span class="title function_">_msgSender</span>(), msg.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取收款人 payees 持有的全部份额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalShares</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _totalShares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已经释放的 ETH 以太币总额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalReleased</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _totalReleased;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已经释放的 token 代币总额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalReleased</span>(<span class="params">IERC20 token</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20TotalReleased[token];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定地址账户持有的份额值 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">shares</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _shares[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已释放给指定地址收款人的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _released[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已释放给指定地址收款人的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">IERC20 token, address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20Released[token][account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取收款人数组 payees 指定 index 索引的收款人的账户地址 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">payee</span>(<span class="params">uint256 index</span>) public view <span class="title function_">returns</span> (address) &#123;</span><br><span class="line">        <span class="keyword">return</span> _payees[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定账户地址的收款人，当前可以释放的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 totalReceived = <span class="title function_">address</span>(<span class="variable language_">this</span>).<span class="property">balance</span> + <span class="title function_">totalReleased</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_pendingPayment</span>(account, totalReceived, <span class="title function_">released</span>(account));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定账户地址的收款人，当前可以释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">IERC20 token, address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 totalReceived = token.<span class="title function_">balanceOf</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>)) + <span class="title function_">totalReleased</span>(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_pendingPayment</span>(account, totalReceived, <span class="title function_">released</span>(token, account));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放 ETH 以太币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">address payable account</span>) public virtual &#123;</span><br><span class="line">        <span class="built_in">require</span>(_shares[account] &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account has no shares&quot;</span>); <span class="comment">// account 必须是有效的受益人</span></span><br><span class="line">        uint256 payment = <span class="title function_">releasable</span>(account);                                   <span class="comment">// 计算 account 可以得到的金额</span></span><br><span class="line">        <span class="built_in">require</span>(payment != <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account is not due payment&quot;</span>);    <span class="comment">// 可以得到的金额不能低于零</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  更新支付总额 totalReleased 和支付给每一个受益人的金额 released */</span></span><br><span class="line">        _totalReleased += payment;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _released[account] += payment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 开始转帐 */</span></span><br><span class="line">        <span class="title class_">Address</span>.<span class="title function_">sendValue</span>(account, payment);</span><br><span class="line">        emit <span class="title class_">PaymentReleased</span>(account, payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放 token 代币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">IERC20 token, address account</span>) public virtual &#123;</span><br><span class="line">        <span class="built_in">require</span>(_shares[account] &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account has no shares&quot;</span>);</span><br><span class="line">        uint256 payment = <span class="title function_">releasable</span>(token, account);</span><br><span class="line">        <span class="built_in">require</span>(payment != <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account is not due payment&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _erc20TotalReleased[token] += payment;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _erc20Released[token][account] += payment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">SafeERC20</span>.<span class="title function_">safeTransfer</span>(token, account, payment);</span><br><span class="line">        emit <span class="title class_">ERC20PaymentReleased</span>(token, account, payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@dev</span> 内部逻辑，计算一个账户的待支付金额，需要考虑该账户的历史余额和已提取的金额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_pendingPayment</span>(<span class="params"></span></span><br><span class="line"><span class="params">        address account,</span></span><br><span class="line"><span class="params">        uint256 totalReceived,</span></span><br><span class="line"><span class="params">        uint256 alreadyReleased</span></span><br><span class="line"><span class="params">    </span>) private view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="comment">/* 收款总额 x 账户份额 / 总份额 - 已提取金额 */</span></span><br><span class="line">        <span class="keyword">return</span> (totalReceived * _shares[account]) / _totalShares - alreadyReleased;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 新增受益人 account 以及其所对应的份额 shares_ */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_addPayee</span>(<span class="params">address account, uint256 shares_</span>) private &#123;</span><br><span class="line">        <span class="built_in">require</span>(account != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;PaymentSplitter: account is the zero address&quot;</span>);  <span class="comment">// account 不能为零地址</span></span><br><span class="line">        <span class="built_in">require</span>(shares_ &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: shares are 0&quot;</span>);                           <span class="comment">// 份额不能为 0</span></span><br><span class="line">        <span class="built_in">require</span>(_shares[account] == <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account already has shares&quot;</span>);   <span class="comment">// 该账户是否已经拥有份额</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新收款人数组 _payees、份额数组 _shares、总份额 _totalShares */</span></span><br><span class="line">        _payees.<span class="title function_">push</span>(account);</span><br><span class="line">        _shares[account] = shares_;</span><br><span class="line">        _totalShares = _totalShares + shares_;</span><br><span class="line">        emit <span class="title class_">PayeeAdded</span>(account, shares_);  <span class="comment">// 触发增加受益人事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vestingwallet-归属权钱包">VestingWallet 归属权钱包</h3><p><strong>OpenZeppelin</strong> 的 <a href="https://docs.openzeppelin.com/contracts/5.x/api/finance#VestingWallet"><strong>VestingWallet</strong></a>智能合约库，主要用于实现<strong>代币的逐步发放</strong>功能。这里的<code>Vesting</code>是一种<strong>归属权兑现</strong>机制，用于在一定时间内将<strong>代币</strong><code>token</code>发放给特定的受益人。换而言之，就是在一定时间期限内，代币逐渐可用或者可提取的过程。</p><table><colgroup><col style="width: 29%"><col style="width: 70%"></colgroup><thead><tr class="header"><th style="text-align: left;">VestingWallet 提供的方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>constructor(beneficiary, startTimestamp, durationSeconds)</code></td><td style="text-align: left;">默认将智能合约的发送方设置为<strong>初始所有者</strong>，其中<code>beneficiary</code> 为受益人，<code>startTimestamp</code>为开始时间戳，<code>durationSeconds</code> 为归属权存续时间。</td></tr><tr class="even"><td style="text-align: left;"><code>receive()</code></td><td style="text-align: left;">用于接收 ETH 以太币。</td></tr><tr class="odd"><td style="text-align: left;"><code>start()</code></td><td style="text-align: left;">获取开始时间戳。</td></tr><tr class="even"><td style="text-align: left;"><code>end()</code></td><td style="text-align: left;">获取结束时间戳。</td></tr><tr class="odd"><td style="text-align: left;"><code>duration()</code></td><td style="text-align: left;">获取归属权存续时间。</td></tr><tr class="even"><td style="text-align: left;"><code>released()</code></td><td style="text-align: left;">已被释放的 ETH 以太币数量。</td></tr><tr class="odd"><td style="text-align: left;"><code>released(address token)</code></td><td style="text-align: left;">已被释放的 <code>token</code>代币数量。</td></tr><tr class="even"><td style="text-align: left;"><code>releasable()</code></td><td style="text-align: left;">可以释放的 ETH 以太币数量。</td></tr><tr class="odd"><td style="text-align: left;"><code>releasable(address token)</code></td><td style="text-align: left;">可以释放的 <code>token</code>代币数量。</td></tr><tr class="even"><td style="text-align: left;"><code>release()</code></td><td style="text-align: left;">释放已归属的 ETH 以太币。</td></tr><tr class="odd"><td style="text-align: left;"><code>release(token)</code></td><td style="text-align: left;">释放已归属的 <code>token</code>代币。</td></tr><tr class="even"><td style="text-align: left;"><code>vestedAmount(timestamp)</code></td><td style="text-align: left;">已归属的 ETH以太币数量，默认实现为一个线性的释放曲线。</td></tr><tr class="odd"><td style="text-align: left;"><code>vestedAmount(token, timestamp)</code></td><td style="text-align: left;">已归属的 <code>token</code>代币数量，默认实现为一个线性的释放曲线。</td></tr><tr class="even"><td style="text-align: left;"><code>_vestingSchedule(totalAllocation, timestamp)</code></td><td style="text-align: left;">归属权公式的虚拟实现，返回值为已经释放的金额。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">VestingWallet 提供的事件</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>EtherReleased(amount)</code></td><td style="text-align: left;">以太币 ETH 被释放事件。</td></tr><tr class="even"><td style="text-align: left;"><code>ERC20Released(token, amount)</code></td><td style="text-align: left;">代币 <code>token</code> 被释放事件。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：上述表格当中的 <code>token</code> 是一个IERC20 代币智能合约的地址。</p></blockquote><p><strong>OpenZeppelin</strong> 的 <strong>Contracts</strong> 库在其<code>finance</code> 目录下的 <code>VestingWallet.sol</code>智能合约当中提供了如下源代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">IERC20</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../token/ERC20/IERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">SafeERC20</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../token/ERC20/utils/SafeERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Address</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../utils/Address.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Context</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../utils/Context.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Ownable</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../access/Ownable.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">VestingWallet</span> is <span class="title class_">Context</span>, <span class="title class_">Ownable</span> &#123;</span><br><span class="line">    event <span class="title class_">EtherReleased</span>(uint256 amount);</span><br><span class="line">    event <span class="title class_">ERC20Released</span>(address indexed token, uint256 amount);</span><br><span class="line"></span><br><span class="line">    uint256 private _released;</span><br><span class="line">    <span class="title function_">mapping</span>(address token =&gt; uint256) private _erc20Released;</span><br><span class="line">    uint64 private immutable _start;</span><br><span class="line">    uint64 private immutable _duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 默认将智能合约的发送方设置为初始所有者，其中 beneficiary 为受益人，startTimestamp 为开始时间戳，durationSeconds 为归属权存续时间 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address beneficiary, uint64 startTimestamp, uint64 durationSeconds</span>) payable <span class="title class_">Ownable</span>(beneficiary) &#123;</span><br><span class="line">        _start = startTimestamp;</span><br><span class="line">        _duration = durationSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 用于接收 ETH 以太币 */</span></span><br><span class="line">    <span class="title function_">receive</span>() external payable virtual &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取开始时间戳 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取归属权存续时间 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">duration</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取结束时间戳 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">end</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">start</span>() + <span class="title function_">duration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已被释放的 ETH 以太币数量。 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _released;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已被释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">address token</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20Released[token];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 可以释放的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vestedAmount</span>(<span class="title function_">uint64</span>(block.<span class="property">timestamp</span>)) - <span class="title function_">released</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 可以释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">address token</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vestedAmount</span>(token, <span class="title function_">uint64</span>(block.<span class="property">timestamp</span>)) - <span class="title function_">released</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 释放已归属的 ETH 以太币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params"></span>) public virtual &#123;</span><br><span class="line">        uint256 amount = <span class="title function_">releasable</span>();</span><br><span class="line">        _released += amount;</span><br><span class="line">        emit <span class="title class_">EtherReleased</span>(amount);</span><br><span class="line">        <span class="title class_">Address</span>.<span class="title function_">sendValue</span>(<span class="title function_">payable</span>(<span class="title function_">owner</span>()), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 释放已归属的 token 代币。 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">address token</span>) public virtual &#123;</span><br><span class="line">        uint256 amount = <span class="title function_">releasable</span>(token);                     <span class="comment">// 获取可以释放的 token 代币数量</span></span><br><span class="line">        _erc20Released[token] += amount;                        <span class="comment">// 更新已释放代币数量</span></span><br><span class="line">        emit <span class="title class_">ERC20Released</span>(token, amount);                      <span class="comment">// 触发代币 token 被释放事件</span></span><br><span class="line">        <span class="title class_">SafeERC20</span>.<span class="title function_">safeTransfer</span>(<span class="title class_">IERC20</span>(token), <span class="title function_">owner</span>(), amount); <span class="comment">// 安全转移代币</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已归属的 ETH 以太币数量，默认实现为一个线性的释放曲线 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">vestedAmount</span>(<span class="params">uint64 timestamp</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_vestingSchedule</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>).<span class="property">balance</span> + <span class="title function_">released</span>(), timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已归属的 token 代币数量，默认实现为一个线性的释放曲线 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">vestedAmount</span>(<span class="params">address token, uint64 timestamp</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_vestingSchedule</span>(<span class="title class_">IERC20</span>(token).<span class="title function_">balanceOf</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>)) + <span class="title function_">released</span>(token), timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 归属权公式的虚拟实现，返回值为已经释放的金额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_vestingSchedule</span>(<span class="params">uint256 totalAllocation, uint64 timestamp</span>) internal view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; <span class="title function_">start</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timestamp &gt;= <span class="title function_">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> totalAllocation;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (totalAllocation * (timestamp - <span class="title function_">start</span>())) / <span class="title function_">duration</span>(); <span class="comment">// 根据线性释放公式，计算已经释放的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.soliditylang.org&quot;&gt;&lt;strong&gt;Solidity&lt;/strong&gt;&lt;/a&gt;
是一款以由&lt;strong&gt;以太坊&lt;/strong&gt;（&lt;strong&gt;ETH&lt;/strong&gt;，Ethereum）开源社区推出的&lt;strong&gt;面向对象&lt;/strong&gt;的&lt;strong&gt;静态&lt;/strong&gt;程序设计语言，主要用于在
&lt;strong&gt;Web 3.0&lt;/strong&gt; 世界创建智能合约，其语法特性受到了
C++、Python、JavaScript
等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的
Solidity 版本，从而获得安全修复以及各种新特性，本篇文章撰写时 Solidity
最新的生产环境版本为 &lt;code&gt;v0.8.24&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Solidity/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了 Solidity 的各种常用语言特性之外，还会介绍一系列 Web 3.0
开发过程当中，所经常使用的第三方开源项目。其中 Hardhat
是一个用于编译、部署、测试、调试以太坊应用的开发环境，而 &lt;a href=&quot;https://trufflesuite.com/ganache/&quot;&gt;&lt;strong&gt;Ganache&lt;/strong&gt;&lt;/a&gt;
则是一款用于开发测试 &lt;strong&gt;dApps&lt;/strong&gt;（Decentralized
Applications）的本地区块链应用。除此之外，&lt;a href=&quot;https://wizard.openzeppelin.com/&quot;&gt;&lt;strong&gt;OpenZeppelin&lt;/strong&gt;&lt;/a&gt;
的 &lt;a href=&quot;https://docs.openzeppelin.com/contracts/5.x/&quot;&gt;&lt;strong&gt;Contract&lt;/strong&gt;&lt;/a&gt;
则是一款用于开发安全智能合约的库，提供有 &lt;strong&gt;ERC20&lt;/strong&gt; 和
&lt;strong&gt;ERC721&lt;/strong&gt;
的标准实现，以及灵活的的权限方案，乃至于各种常用的工具组件。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="http://www.uinio.com/categories/Web/"/>
    
    
    <category term="Solidity" scheme="http://www.uinio.com/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>基于树莓派 UINIO-MCU-RP2040 核心板制作逻辑分析仪</title>
    <link href="http://www.uinio.com/Project/UINIO-MCU-RP2040/"/>
    <id>http://www.uinio.com/Project/UINIO-MCU-RP2040/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.494Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派 <strong>RP2040</strong> 是一款采用 <strong>ARMCortex-M0+</strong> 双核心的微控制器，运行频率高达<code>133MHz</code>，片上内置有 <code>264KB</code> 容量的<strong>SRAM</strong> 内存，并且能够外接高达 <code>16MB</code>容量的片外 <strong>Flash</strong> 闪存（通过 QSPI总线连接），内部还集成有 DMA 控制器，以及 30 个 <strong>GPIO</strong>引脚（其中 4 个可用作模拟输入）。除此之外，片上还拥有 2 个<strong>UART</strong> 控制器、2 个 <strong>SPI</strong> 控制器、2 个<strong>I²C</strong> 控制器、16 个 <strong>PWM</strong> 通道，以及 2个可编程 <strong>PIO</strong>（Programmable I/O）块，并且支持<strong>USB 1.1</strong> 主机和设备模式。</p><p><img src="/Project/UINIO-MCU-RP2040/logo.png"></p><p><a href="https://gitee.com/uinika/UINIO-MCU-RP2040"><strong>UINIO-MCU-RP2040</strong></a>是一款基于 <strong>RP2040</strong> 的开发板，板载 Flash 采用更为小巧的<code>WSON8</code> 封装，添加 <code>SOD123</code>封装的<strong>肖特基势垒二极管</strong>防止正负级反接，同时增加用于全局异步复位的<strong>RESET</strong> 按钮，并且引出了官方 Pico 开发板所没有的<code>GPIO23</code> 和 <code>GPIO24</code>两个引脚资源。除此之外，由于模数转换引脚内部集成有连接至<code>IOVDD</code> 的反向二极管，所以采用 FET 场效应管<strong>DMG1012T</strong> 防止 RP2040 未上电时，这些引脚上施加的电压通过<code>ADC3</code> 引脚泄露至 <code>3.3V</code> 电源网络。</p><span id="more"></span><h2 id="硬件设计概要">硬件设计概要</h2><p><strong>树莓派基金会</strong>于 2021 年初推出的<strong>RP2040</strong> 是一款基于台积电 <code>40nm</code>工艺的低成本、高性能微控制器产品，采用了高达 <code>133MHz</code>主频的双核心 <strong>ARM Cortex-M0+</strong> 内核架构，拥有多达 30个多功能 <strong>GPIO</strong> 引脚（其中 4个可以用作<strong>模拟输入</strong>），片上载有 <code>264kB</code>的静态随机存储器 <strong>SRAM</strong>。除此之外，通过 <code>QSPI</code>总线还可以支持高达 <code>16MB</code> 的片外 <strong>Flash</strong>闪存，下图展示了 <strong>RP2040</strong> 芯片各个功能引脚的分布：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Overview-1.png"></p><p>而接下来的表格，则描述了上图当中 <strong>RP2040</strong>各个引脚的具体功能：</p><table><colgroup><col style="width: 18%"><col style="width: 81%"></colgroup><thead><tr class="header"><th style="text-align: left;">引脚名称</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>GPIOx</strong></td><td style="text-align: left;">通用数字输入输出引脚，可以将多个内部外设映射至GPIO。</td></tr><tr class="even"><td style="text-align: left;"><strong>GPIOx</strong>/<strong>ADCy</strong></td><td style="text-align: left;">具有模数转换功能的通用数字输入输出引脚，用于采集电压信号。</td></tr><tr class="odd"><td style="text-align: left;"><strong>QSPIx</strong></td><td style="text-align: left;">用于连接 SPI、Dual-SPI、Quad-SPI 接口的Flash 存储芯片，如果未连接，则也可以复用为可编程的 GPIO 引脚。</td></tr><tr class="even"><td style="text-align: left;"><strong>USB_DM</strong> 和<strong>USB_DP</strong></td><td style="text-align: left;">USB控制器引脚，支持全速的设备（Device）模式，以及全速/低速的主机（Host）模式，必须分别串接27Ω 的终端电阻。</td></tr><tr class="odd"><td style="text-align: left;"><strong>XIN</strong> 和<strong>XOUT</strong></td><td style="text-align: left;">用于连接 12MHz 频率的晶体振荡器。</td></tr><tr class="even"><td style="text-align: left;"><strong>RUN</strong></td><td style="text-align: left;">全局异步复位引脚（低电平复位，高电平运行），如果不需要外部复位，则该引脚可以连接至<code>IOVDD</code>。</td></tr><tr class="odd"><td style="text-align: left;"><strong>SWCLK</strong> 和<strong>SWDIO</strong></td><td style="text-align: left;">SW 串行调试引脚，用于调试和下载固件。</td></tr><tr class="even"><td style="text-align: left;"><strong>TESTEN</strong></td><td style="text-align: left;">工厂调试模式引脚，需要接入<code>GND</code> 使用。</td></tr><tr class="odd"><td style="text-align: left;"><strong>GND</strong></td><td style="text-align: left;">外部接地引脚。</td></tr><tr class="even"><td style="text-align: left;"><strong>IOVDD</strong></td><td style="text-align: left;">GPIO 的数字电源引脚，额定电压介于<code>1.8V ~ 3.3V</code> 范围。</td></tr><tr class="odd"><td style="text-align: left;"><strong>USB_VDD</strong></td><td style="text-align: left;">内部 USB 全速 PHY 电源引脚，额定电压为<code>3.3V</code>。</td></tr><tr class="even"><td style="text-align: left;"><strong>ADC_AVDD</strong></td><td style="text-align: left;">模数转换器电源引脚，额定工作电压为<code>3.3V</code>。</td></tr><tr class="odd"><td style="text-align: left;"><strong>VREG_VIN</strong></td><td style="text-align: left;">RP2040内核稳压器电源<strong>输入</strong>引脚，额定电压介于<code>1.8V ~ 3.3V</code> 范围。</td></tr><tr class="even"><td style="text-align: left;"><strong>VREG_VOUT</strong></td><td style="text-align: left;">RP2040内核稳压器电源<strong>输出</strong>引脚，额定电压为<code>1.1V</code>，最大输出电流为 <code>100mA</code>。</td></tr><tr class="odd"><td style="text-align: left;"><strong>DVDD</strong></td><td style="text-align: left;">数字核心电源引脚，额定电压为<code>1.1V</code>，可以连接至上面的 <code>VREG_VOUT</code>。</td></tr></tbody></table><p>下面展示了 <strong>RP2040</strong>微控制器芯片内部的系统结构框图：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Overview-2.png"></p><ul><li>内嵌的 <code>264kB</code> 容量 SRAM 分布在 6 个独立的 Bank区块，可以通过专用的 AHB 总线进行访问；</li><li>固件程序运行在采用 QSPI 接口的外部 Flash存储器当中，调试工作则需要通过 SWD 串行线进行。</li><li>分别拥有 <code>2</code> 个 <strong>UART</strong>、<code>2</code> 个<strong>SPI</strong>、<code>2</code> 个 <strong>I²C</strong>总线控制器，以及 <code>16</code> 条 <strong>PWM</strong> 通道；</li><li>支持 <code>Host</code> 和 <code>Device</code> 模式的 USB 1.1控制器以及用于物理信号转换的 <strong>PHY</strong>（PhysicalLayer）接口；</li><li>通过 2 个 PLL <strong>锁相环</strong>来生成 USB以及内核的时钟信号；</li></ul><p><strong>UINIO-MCU-RP2040</strong>的最小系统主要由<strong>电源</strong>、<strong>Flash存储器</strong>、<strong>晶振</strong>、<strong>输入输出</strong>四个部分构成，接下来的内容将会分别进行讨论。</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Overview-3.png"></p><h2 id="v-线性稳压电路">3.3V 线性稳压电路</h2><p><strong>UINIO-MCU-RP2040</strong> 采用 <a href="https://cn.sg-micro.com/"><strong>北京圣邦微电子</strong></a>推出的 <a href="https://cn.sg-micro.com/uploads/soft/20190906/1567744517.pdf">SGM2019-3.3YN5G</a>低压差线性稳压芯片，采用 <code>SOT-23-5</code> 封装，能够提供最大<code>300mA</code> 的输出电流（此时压差为<code>400mV</code>），输入电压范围为<code>2.5V ~ 5.5V</code>，输出电压为 <code>3.3V</code>，下图是官方提供的SGM2019-3.3YN5G 的典型应用电路：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/LDO-1.png"></p><p>圣邦微的 <code>SGM2019-3.3YN5G</code> 相比于微盟电子的<code>ME6211C33M5G</code> 线性稳压芯片，其最大的特点在于提供了一个<code>EN</code> 输入使能引脚，<strong>UINIO-MCU-RP2040</strong>已经将该引脚连接至杜邦排针，并且与核心板的 <code>GND</code>相毗邻，可以方便的使用跳线帽禁用电源输入，当然也可以用于逻辑控制核心板的运行与停止。下面的表格，提供了<code>SGM2019-3.3YN5G</code> 全部引脚的功能说明：</p><table><colgroup><col style="width: 7%"><col style="width: 8%"><col style="width: 83%"></colgroup><thead><tr class="header"><th style="text-align: center;">引脚编号</th><th style="text-align: left;">引脚名称</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>1</code></td><td style="text-align: left;"><strong>IN</strong></td><td style="text-align: left;">稳压输入引脚<code>2.5V ~ 5.5V</code>，需要连接 <code>1uF</code> 的接地电容。</td></tr><tr class="even"><td style="text-align: center;"><code>2</code></td><td style="text-align: left;"><strong>GND</strong></td><td style="text-align: left;">接地引脚。</td></tr><tr class="odd"><td style="text-align: center;"><code>3</code></td><td style="text-align: left;"><strong>EN</strong></td><td style="text-align: left;">输入使能引脚，低电平时可以将输入电流降低至<code>10nA</code>，通常将其连接至输入电压引脚 <code>IN</code>。</td></tr><tr class="even"><td style="text-align: center;"><code>4</code></td><td style="text-align: left;"><strong>BP/FB</strong></td><td style="text-align: left;">参考噪声旁路(仅限固定电压版本)。旁路采用低漏0.01μF 陶瓷电容，降低输出噪声。</td></tr><tr class="odd"><td style="text-align: center;"><code>5</code></td><td style="text-align: left;"><strong>OUT</strong></td><td style="text-align: left;"><code>3.3V</code> 稳压输出引脚。</td></tr></tbody></table><p><img src="/Project/UINIO-MCU-RP2040/Hardware/LDO-2.png"></p><blockquote><p><strong>注意</strong>：树莓派 <strong>RP2040</strong>需要使用到两种不同的工作电压，其中 <code>3.3V</code>主要用于输入输出，而 <code>1.1V</code>则是用于数字核心。由于芯片内部已经集成有 <code>3.3V</code> 转<code>1.1V</code> 的 LDO 低压差线性稳压器，所以硬件电路当中不需要再考虑<code>1.1V</code> 电压的供电问题，直接把 <strong>VREG_VOUT</strong> 与<strong>DVDD</strong> 连接起来即可。</p></blockquote><h2 id="电源去耦电容">电源去耦电容</h2><p>除此之外，电源设计当中另外一个需要关注的方面在于<strong>RP2040</strong>电源引脚的去耦电容，它们在电路当中可以提供如下两个基本功能：</p><ol type="1"><li>过滤掉一部分电源噪声纹波；</li><li>防止电流需求突然增大时，电源网络产生过大的压降；</li></ol><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Capacitor-1.png"></p><p><strong>UINIO-MCU-RP2040</strong> 采用官方推荐的容值分别为<code>0.1uF</code>（有效滤除 <code>10MHz</code> 以下的电源纹波）和<code>2.2uF</code>（有效滤除 <code>20MHz</code>以上的高频纹波）的贴片陶瓷电容器（<strong>0402</strong>封装）作为去耦电容，并且将它们全部放置在靠近 <strong>RP2040</strong>芯片电源引脚的位置：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Capacitor-2.png"></p><p>除此之外，由于 <strong>RP2040</strong> 需要通过<code>SGM2019-3.3YN5G</code> 线性稳压器，将输入到 <code>VREG_IN</code>引脚的 <code>3.3V</code> 电压转换为 <code>VREG_OUT</code> 输出的<code>1.1V</code> 电压（最大输出电流为<code>100mA</code>），所以这里需要将 <code>VREG_OUT</code>连接至<strong>数字核心</strong>的 <code>1.1V</code> 电源输入引脚<code>DVDD</code>，此时依然分别需要添加相应的去耦电容。</p><h2 id="flash-存储器">Flash 存储器</h2><p><strong>RP2040</strong> 微控制器运行的固件程序代码都被保存外部的Flash 存储器当中，<strong>UINIO-MCU-RP2040</strong> 核心板采用 <a href="https://www.winbond.com/hq/product/code-storage-flash-memory/serial-nor-flash?__locale=zh"><strong>台湾华邦电子</strong></a>推出的 <code>W25Q128JVP</code> 型 Flash 存储器，封装形式为更加小巧的<code>WSON8</code>，选型容量为 <code>128Mbit</code>（即<code>16MB</code>），也就是 <strong>RP2040</strong>微控制器可以支持的<strong>最大存储容量</strong>：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Flash-1.png"></p><p><code>QSPI_SS</code> 片选引脚连接的 <code>1.5kΩ</code> 电阻为连接到<code>3.3V</code> 电源的<strong>上拉电阻</strong>，虽然<code>QSPI_SS</code> 引脚自动默认为上拉，但是在 <strong>RP2040</strong>上电的某个瞬间，无法确保其始终的处于高电平状态，所以这里增加了一枚上拉电阻器来确保该片选引脚始终处于上拉状态。除此之外，在靠近Flash 存储芯片的电源引脚位置，同样也添加了一枚 <code>0.1uF</code>的去耦电容。</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Flash-2.png"></p><blockquote><p><strong>注意</strong>： 由于连接 Flash 存储器的 <strong>QSPI</strong>总线频率较高，需要采用尽可能短的 PCB走线距离，从而确保信号的完整性，并减少周边电路带来的<strong>串扰</strong>。</p></blockquote><h2 id="boot-与-reset-按键">BOOT 与 RESET 按键</h2><p>相较于官方的 <strong>Raspberry Pi Pico</strong>开发板只拥有一枚【BOOT】按键，为了方便日常开发使用，<strong>UINIO-MCU-RP2040</strong>核心板同时提供了【BOOT】和【REST】两枚按键，其原理图与功能说明分别如下所示：</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Key.png"></p><ol type="1"><li><strong>【BOOT】按键</strong>：通过一枚 <code>1kΩ</code> 电阻连接至Flash 存储芯片的 SPI 片选引脚，用于失能 Flash 片选信号，从而选择强制从USB 启动。此时 <strong>RP2040</strong> 会呈现为 USB大容量存储设备，可以用于直接复制下载固件。</li><li><strong>【REST】按键</strong>：默认情况下 <code>RUN</code> 引脚通过<code>10kΩ</code>上拉电阻钳位在高电平，从而保持核心板处于正常运行状态。而该按键可以将<strong>全局异步复位引脚</strong><code>RUN</code>下拉为低电平状态，从而配合【BOOT】按键进入下载引导模式。</li></ol><blockquote><p><strong>注意</strong>：按键并联的 <code>0.1uF</code>电容用于滤除被按下时产生的抖动信号，实际应用时可以选择不进行贴装。</p></blockquote><h2 id="晶振电路">晶振电路</h2><p>虽然 <strong>RP2040</strong>拥有内部的时钟源，但是其工作状态容易受到电源电压和温度的影响，因此官方建议使用一个更加稳定和精确的外部时钟源。<strong>RP2040</strong>微控制器的<strong>外部时钟源</strong>可以通过如下两种方式进行提供：</p><ol type="1"><li>将输出 <code>3.3V</code> 方波信号的时钟源连接至 RP2040 的<code>XIN</code> 引脚；</li><li>在 RP2040 芯片的 <code>XIN</code> 和 <code>XOUT</code> 引脚之间加入<code>12MHz</code> 晶体振荡器（首选）；</li></ol><p><img src="/Project/UINIO-MCU-RP2040/Hardware/Oscillator-1.png"></p><p><strong>UINIO-MCU-RP2040</strong>选用的是外置石英晶振方案，该款石英晶振的负载电容为<code>11pF</code>。晶振的<strong>负载电容</strong>是指与该晶振<strong>并联</strong>的全部有效电容的总和，可以将其视为晶振电路上<strong>串联</strong>的一枚电容器，其主要作用是稳定晶振的<code>谐振频率</code>和<code>输出幅度</code>，根据两个电容器并联之后总电容的计算公式：</p><p><span class="math display">\[C_{负载电容} = \frac{C_{对地电容1} \times C_{对地电容2}}{C_{对地电容1} +C_{对地电容2}} + C_{PCB 杂散电容}\]</span></p><p>由于 <span class="math inline">\(C_{对地电容1}\)</span> 与 <span class="math inline">\(C_{对地电容2}\)</span> 两枚并联电容的容值相等，而<span class="math inline">\(C_{PCB 杂散电容}\)</span> 的容值通常选取在<code>3pF ~ 5pF</code> 范围，从而可以得到晶振两枚并联的 <span class="math inline">\(C_{对地电容}\)</span> 的容值计算公式：</p><p><span class="math display">\[C_{对地电容} = (C_{负载电容} - C_{PCB 杂散电容}) \times 2\]</span></p><p>这里选择 <span class="math inline">\(C_{PCB 杂散电容}\)</span>为典型值 <code>5pF</code>，而负载电容 <span class="math inline">\(C_{负载电容}\)</span> 为<code>11pF</code>，从而就可以计算得到两枚接地电容的容值分别为：</p><p><span class="math display">\[C_{对地电容} = (11pF - 5pF) \times 2 = 12pF\]</span></p><h2 id="usb-接口电路">USB 接口电路</h2><p><strong>RP2040</strong> 微控制器提供有 <code>USB_DM</code> 和<code>USB_DP</code>两个引脚（无需额外的上拉和下拉），用于<strong>全速</strong>（FS，FullSpeed）或者<strong>低速</strong>（LS，Low Speed）的 USB 通信，即可以作为USB Host（主机），也可以作为 USB Device（设备）。虽然 RP2040 的全速 USB通信速率被限制为 <code>12Mbps</code> 兆位/秒，但是为了满足 USB的阻抗规范，依然需要分别串联 <code>27Ω</code>的终端电阻，并且尽量靠近芯片放置。同时走线需要尽可能的遵循<code>90Ω</code> 的 <strong>USB差分阻抗规范</strong>，并且走线下方尽量<strong>保持一个完整的接地平面</strong>。</p><p><img src="/Project/UINIO-MCU-RP2040/Hardware/USB-1.png"></p><p>自从 USB Type-C 标准开始，USB 增加了 <code>CC1</code> 和<code>CC2</code> 两个配置通道（Configuration Channel），当其串联上<code>5.1kΩ</code> 下拉电阻的时候，表明<strong>UINIO-MCU-RP2040</strong> 当前已经被配置为<strong>上行接口</strong>（UFP，Upstream Facing Port）用电端，从而提升USB Type-C 与传统 USB 接口的电源兼容性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;树莓派 &lt;strong&gt;RP2040&lt;/strong&gt; 是一款采用 &lt;strong&gt;ARM
Cortex-M0+&lt;/strong&gt; 双核心的微控制器，运行频率高达
&lt;code&gt;133MHz&lt;/code&gt;，片上内置有 &lt;code&gt;264KB&lt;/code&gt; 容量的
&lt;strong&gt;SRAM&lt;/strong&gt; 内存，并且能够外接高达 &lt;code&gt;16MB&lt;/code&gt;
容量的片外 &lt;strong&gt;Flash&lt;/strong&gt; 闪存（通过 QSPI
总线连接），内部还集成有 DMA 控制器，以及 30 个 &lt;strong&gt;GPIO&lt;/strong&gt;
引脚（其中 4 个可用作模拟输入）。除此之外，片上还拥有 2 个
&lt;strong&gt;UART&lt;/strong&gt; 控制器、2 个 &lt;strong&gt;SPI&lt;/strong&gt; 控制器、2 个
&lt;strong&gt;I²C&lt;/strong&gt; 控制器、16 个 &lt;strong&gt;PWM&lt;/strong&gt; 通道，以及 2
个可编程 &lt;strong&gt;PIO&lt;/strong&gt;（Programmable I/O）块，并且支持
&lt;strong&gt;USB 1.1&lt;/strong&gt; 主机和设备模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-MCU-RP2040/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/uinika/UINIO-MCU-RP2040&quot;&gt;&lt;strong&gt;UINIO-MCU-RP2040&lt;/strong&gt;&lt;/a&gt;
是一款基于 &lt;strong&gt;RP2040&lt;/strong&gt; 的开发板，板载 Flash 采用更为小巧的
&lt;code&gt;WSON8&lt;/code&gt; 封装，添加 &lt;code&gt;SOD123&lt;/code&gt;
封装的&lt;strong&gt;肖特基势垒二极管&lt;/strong&gt;防止正负级反接，同时增加用于全局异步复位的
&lt;strong&gt;RESET&lt;/strong&gt; 按钮，并且引出了官方 Pico 开发板所没有的
&lt;code&gt;GPIO23&lt;/code&gt; 和 &lt;code&gt;GPIO24&lt;/code&gt;
两个引脚资源。除此之外，由于模数转换引脚内部集成有连接至
&lt;code&gt;IOVDD&lt;/code&gt; 的反向二极管，所以采用 FET 场效应管
&lt;strong&gt;DMG1012T&lt;/strong&gt; 防止 RP2040 未上电时，这些引脚上施加的电压通过
&lt;code&gt;ADC3&lt;/code&gt; 引脚泄露至 &lt;code&gt;3.3V&lt;/code&gt; 电源网络。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="MCU" scheme="http://www.uinio.com/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>运用 U8G2 与 TFT_eSPI 玩转 UINIO-Monitor 显示屏</title>
    <link href="http://www.uinio.com/Project/UINIO-Monitor/"/>
    <id>http://www.uinio.com/Project/UINIO-Monitor/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.522Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/uinika/UINIO-Monitor"><strong>UINIO-Monitor</strong></a>同时拼接有 <code>128×64</code> 分辨率 <strong>SSD1315</strong> 驱动的0.96 英寸 OLED 显示屏，<code>160×80</code> 分辨率<strong>ST7735</strong> 驱动的 0.96 英寸 LCD显示屏，<code>240×240</code> 分辨率 <strong>ST7789</strong> 驱动的 1.3英寸 LCD 显示屏。以及采用相同驱动芯片，但是分辨率分别为<code>240×320</code> 与 <code>240×280</code> 的 2.4 英寸以及 1.69 英寸LCD 显示屏。所有屏幕全部板载有 <code>0.5mm</code> 间距的<strong>FPC</strong> 柔性排线连接器，同时还引出 <code>2.54mm</code>间距的直插排针，便于通过杜邦线快速搭建实验电路。</p><p><img src="/Project/UINIO-Monitor/logo.png"></p><p>之前由我设计制作并且开源出来的 <a href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>和 <a href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>两款核心板，分别基于乐鑫科技的 <strong>ESP32-C3</strong> (RISC-V) 与<strong>ESP32-S3</strong> (Xtensa) 微控制器（更多玩法可以参考之前撰写的<a href="http://uinio.com/Project/Arduino-ESP32/">《基于 UINIO-MCU-ESP32的 Arduino 进阶教程》</a>一文）。而本篇文章就会采用这两款核心板，以及乐鑫官方的<strong>Arduino-ESP32</strong> 板级支持包，结合 <a href="https://github.com/olikraus/u8g2"><strong>U8G2</strong></a> 和 <a href="https://github.com/Bodmer/TFT_eSPI"><strong>TFT_eSPI</strong></a>两款开源显示库，帮助大家快速上手 <strong>UINIO-Monitor</strong> 系列里的5 款显示屏。</p><span id="more"></span><h1 id="英寸-oled-显示屏">0.96 英寸 OLED 显示屏</h1><p><strong>UINIO-Monitor</strong> 系列显示屏幕当中的 0.96 英寸OLED（有机发光二极管，Organic Light-Emitting Diode）显示屏，分辨率为<code>128 × 64</code> 像素，使用 I²C总线进行通信，驱动集成电路采用的是香港<a href="https://www.solomon-systech.com.cn/zh-hans/"><strong>晶门半导体</strong></a>（SolomonSystech）的 <strong>SSD1315</strong>（可以同时兼容<strong>SSD1306</strong>）。</p><p><img src="/Project/UINIO-Monitor/0.96-OLED-1.png"></p><blockquote><p><strong>注意</strong>：如果焊接上丝印为 <code>0x78</code> 的电阻<strong>R20</strong>，就会把 I²C 从设备的地址配置为<code>0x78</code>。相应的，如果焊接上 <code>0x7A</code> 丝印的电阻<strong>R19</strong>，则表示从设备地址为 <code>0x7A</code>。当使用<strong>Arduino-ESP32</strong> 和 <strong>U8G2</strong>库进行通信时，需要焊接上 <strong>R20</strong>，而 <strong>R19</strong>位置留空。</p></blockquote><p>该屏幕模组采用了日本<strong>特瑞仕</strong>（TOREX）的<strong>XC6206P332MR</strong> 低压差线性稳压芯片，可以同时兼容<code>3.3V</code> 与 <code>5V</code>两种工作电压。屏幕在全亮状态下的工作电流约为<code>25mA</code>，而全部熄灭黑屏状态下的待机电流约为<code>1.5mA</code>。正是由于该屏幕工作电流较小，为了防止正负极反接导致稳压芯片损坏，所以串接了一枚型号为<strong>1N5819</strong> 的肖特基二极管（额定正向电流为<code>1A</code>）作为防反接设计，具体电路设计可以参考如下的原理图（鼠标双击可以放大）：</p><p><img src="/Project/UINIO-Monitor/0.96-OLED-2.png"></p><p>开始上手实践之前，需要把 <strong>UINIO-Monitor</strong> 上 0.96 英寸OLED 显示屏的<code>SCK</code>、<code>SDA</code>、<code>GND</code>、<code>VCC</code>引脚，分别与 <strong>UINIO-MCU-ESP32S3</strong> 核心板的<code>GPIO16</code>、<code>GPIO17</code>、<code>5V</code>、<code>GND</code>引脚进行连接，后续 <strong>U8G2</strong>库相关的示例代码都将会沿用这个连接关系：</p><p><img src="/Project/UINIO-Monitor/0.96-OLED-3.png"></p><blockquote><p><strong>注意</strong>：为了文章撰写与阅读的方便直观，<strong>UINIO-Monitor</strong>当中的 0.96 英寸 OLED 显示屏，在后续 <strong>U8G2</strong>库相关章节的内容里全部直接简称为 <strong>UINIO-Monitor</strong>。</p></blockquote><h1 id="u8g2-库开发速成">U8G2 库开发速成</h1><p><a href="https://github.com/olikraus/u8g2"><strong>U8G2</strong></a>是一款运行在嵌入式设备上的 Arduino 单色显示库，可以通过 <strong>ArduinoIDE</strong> 的【库管理器】直接进行安装。<strong>U8G2</strong> 库包含有<code>文字</code>、<code>位图</code>、<code>线/框/圆</code>的绘制方法，并且可以支持多种字体，显示内容时需要使用到微控制器的 RAM作为缓冲区。除此之外，<strong>U8G2</strong> 库还内嵌有一个小巧的<strong>U8x8</strong>库，该库只能输出文本内容，并且只能显示固定像素大小的字体，不过显示内容时无需再使用微控制器的RAM 存储器作为缓冲区。关于两个库的更多介绍，可以参考 <a href="https://github.com/olikraus/u8g2/wiki/u8g2reference"><strong>《U8g2Reference Manual》</strong></a> 和 <a href="https://github.com/olikraus/u8g2/wiki/u8x8reference"><strong>《U8x8Reference Manual》</strong></a> 两份官方文档。</p><p><img src="/Project/UINIO-Monitor/U8G2-0.png"></p><h2 id="u8g2-构造函数">u8g2() 构造函数</h2><p>使用 <strong>U8G2</strong>库的第一步是要根据当前使用的屏幕规格与总线通信方式，选择对应的<code>u8g2()</code> 构造函数，从而实例化出相应的 <code>u8g2</code>对象。本文以 <strong>UINIO-Monitor</strong> 当中 0.96 英寸 OLED显示屏所需要使用到的 <code>U8G2_SSD1306_128X64_NONAME_F_HW_I2C</code>硬件 I²C 类型和 <code>U8G2_SSD1306_128X64_NONAME_F_SW_I2C</code> 软件I²C 类型为例进行讨论：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 采用 SSD1306 驱动芯片，分辨率为 128*X*64，通信方式为软件 I²C 总线 */</span></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_SW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* clock=*/</span> <span class="number">16</span>, <span class="comment">/* data=*/</span> <span class="number">17</span>, <span class="comment">/* reset=*/</span> U8X8_PIN_NONE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用 SSD1306 驱动芯片，分辨率为 128*X*64，通信方式为硬件 I²C 总线 */</span></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span> U8X8_PIN_NONE, <span class="comment">/* clock=*/</span> <span class="number">16</span>, <span class="comment">/* data=*/</span> <span class="number">17</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：硬件 I²C 相比于软件 I²C总线的显示刷新频率更高，渲染动画效果的时候更加顺滑。</p></blockquote><p>事实上，<strong>U8G2</strong> 库的 <strong>Arduino C++</strong>构造函数 <code>u8g2()</code>，其返回值类型都遵循着统一的命名规则：</p><table><colgroup><col style="width: 10%"><col style="width: 28%"><col style="width: 14%"><col style="width: 14%"><col style="width: 17%"><col style="width: 14%"></colgroup><thead><tr class="header"><th style="text-align: center;">前缀</th><th style="text-align: center;">屏幕驱动芯片型号</th><th style="text-align: center;">分辨率</th><th style="text-align: center;">生产品牌</th><th style="text-align: center;">缓冲区大小</th><th style="text-align: center;">通信方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>U8G2</code></td><td style="text-align: center;"><code>SSD1306</code></td><td style="text-align: center;"><code>128X64</code></td><td style="text-align: center;"><code>NONAME</code></td><td style="text-align: center;"><code>F</code></td><td style="text-align: center;"><code>HW_I2C</code></td></tr><tr class="even"><td style="text-align: center;"><code>U8G2</code></td><td style="text-align: center;"><code>SSD1306</code></td><td style="text-align: center;"><code>128X64</code></td><td style="text-align: center;"><code>NONAME</code></td><td style="text-align: center;"><code>F</code></td><td style="text-align: center;"><code>SW_I2C</code></td></tr></tbody></table><p>接下来的三个表格，分别展示了上述表格当中<strong>缓冲区大小</strong>、<strong>通信方式</strong>、<strong>显示旋转方向</strong>的具体参数信息：</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th style="text-align: center;">缓冲区大小</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>1</code></td><td style="text-align: left;">占用 1 页的微控制器 RAM 作为缓冲区。</td></tr><tr class="even"><td style="text-align: center;"><code>2</code></td><td style="text-align: left;">占用 2 页的微控制器 RAM作为缓冲区（可以获得更快的显示刷新速度）。</td></tr><tr class="odd"><td style="text-align: center;"><code>F</code></td><td style="text-align: left;">在微控制器 RAM当中保存完整的显示帧（推荐在 RAM 存储空间足够大的场景下使用）。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">显示旋转方向</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>U8G2_R0</code></td><td style="text-align: left;">不旋转，横向显示。</td></tr><tr class="even"><td style="text-align: left;"><code>U8G2_R1</code></td><td style="text-align: left;">顺时针 90° 度旋转。</td></tr><tr class="odd"><td style="text-align: left;"><code>U8G2_R2</code></td><td style="text-align: left;">顺时针 180° 度旋转。</td></tr><tr class="even"><td style="text-align: left;"><code>U8G2_R3</code></td><td style="text-align: left;">顺时针 270° 度旋转。</td></tr><tr class="odd"><td style="text-align: left;"><code>U8G2_MIRROR</code></td><td style="text-align: left;">不旋转，横向显示，但是内容会被镜像。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">通信方式</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>4W_SW_SPI</code></td><td style="text-align: left;">四线制（<code>Clock\Data\CS\DC</code>）的软件模拟SPI。</td></tr><tr class="even"><td style="text-align: left;"><code>4W_HW_SPI</code></td><td style="text-align: left;">四线制（<code>Clock\Data\CS\DC</code>）的硬件SPI。</td></tr><tr class="odd"><td style="text-align: left;"><code>2ND_4W_HW_SPI</code></td><td style="text-align: left;">第 2 个四线制的硬件 SPI。</td></tr><tr class="even"><td style="text-align: left;"><code>3W_SW_SPI</code></td><td style="text-align: left;">三线制（<code>Clock\Data\CS</code>）的软件模拟SPI。</td></tr><tr class="odd"><td style="text-align: left;"><code>SW_I2C</code></td><td style="text-align: left;">软件模拟的 I²C 总线通信。</td></tr><tr class="even"><td style="text-align: left;"><code>HW_I2C</code></td><td style="text-align: left;">硬件 I²C 总线通信。</td></tr><tr class="odd"><td style="text-align: left;"><code>2ND_HW_I2C</code></td><td style="text-align: left;">第 2 个硬件 I²C 通信总线。</td></tr><tr class="even"><td style="text-align: left;"><code>6800</code></td><td style="text-align: left;">采用 <strong>6800 协议</strong>的 8位并行接口。</td></tr><tr class="odd"><td style="text-align: left;"><code>8080</code></td><td style="text-align: left;">采用 <strong>8080 协议</strong>的 8位并行接口。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：如果当前没有连接重置输入引脚，那么就可以将构造函数中的<code>reset</code> 参数，直接填写为 <code>U8X8_PIN_NONE</code>。</p></blockquote><p>采用 <code>u8g2()</code> 构造函数创建 <code>u8g2</code>类的时候，需要传入一系列的参数，下面表格就展示了这些参数的具体信息：</p><table><colgroup><col style="width: 12%"><col style="width: 25%"><col style="width: 62%"></colgroup><thead><tr class="header"><th style="text-align: left;">引脚参数</th><th style="text-align: left;">数据手册名称</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>clock</code></td><td style="text-align: left;"><code>SCL / SCLK ...</code></td><td style="text-align: left;">SPI 或者 I²C 总线的时钟线。</td></tr><tr class="even"><td style="text-align: left;"><code>data</code></td><td style="text-align: left;"><code>SDA / MOSI / SDIN ...</code></td><td style="text-align: left;">SPI 或者 I²C 总线的数据线。</td></tr><tr class="odd"><td style="text-align: left;"><code>d0 ... d7</code></td><td style="text-align: left;"><code>D0 ... D7</code></td><td style="text-align: left;">并行接口的数据线。</td></tr><tr class="even"><td style="text-align: left;"><code>cs</code></td><td style="text-align: left;"><code>CS</code></td><td style="text-align: left;">片选信号线。</td></tr><tr class="odd"><td style="text-align: left;"><code>dc</code></td><td style="text-align: left;"><code>D/C / A0 / RS, ...</code></td><td style="text-align: left;">数据/命令选择线。</td></tr><tr class="even"><td style="text-align: left;"><code>enable</code></td><td style="text-align: left;"><code>8080:WR / 6800:E</code></td><td style="text-align: left;">8080 接口的 <code>Write</code>写入线，6800 接口的 <code>Enable</code> 使能线。</td></tr><tr class="odd"><td style="text-align: left;"><code>reset</code></td><td style="text-align: left;">-</td><td style="text-align: left;">重置信号线。</td></tr></tbody></table><p><strong>U8G2</strong> 库默认使用 <strong>8</strong> 位显示模式（即256 色），如果需要使用 <strong>16</strong> 位显示模式，则必须在<code>u8g2.h</code> 头文件当中添加如下注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> U8G2_16BIT</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：16 位显示模式下，保存 U8G2像素坐标的数据类型也会从 8 位变换为 16 位。</p></blockquote><p>接下来，就会通过 <strong>Arduino C++</strong> 和<strong>U8G2</strong> 库，结合 <strong>UINIO-MCU-ESP32S3</strong> 和<strong>UINIO-Monitor</strong> 实现一个显示<code>Hello UinIO.com!</code> 字符串的示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* U8G2 构造函数 */</span></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();  <span class="comment">// 设置与初始化显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.f</span>irstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_ncenB10_tr);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">drawStr</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="string">&quot;Hello UinIO.com!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> (u8g<span class="number">2.</span><span class="built_in">nextPage</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="u8x8-构造函数">u8x8() 构造函数</h2><p><strong>U8G2</strong> 所包含的 <strong>U8x8</strong>库无需占用微控制器的 RAM存储空间，可以用于直接显示一些文本信息。但是需要注意 <code>u8x8()</code>构造函数的参数构成，与 <code>u8g2()</code> 构造函数并不相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U8X8_SSD1306_128X64_NONAME_SW_I2C <span class="title">u8x8</span><span class="params">(<span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>U8x8</strong> 库的 <strong>Arduino C++</strong> 构造函数<code>u8x8()</code>，其返回值类型都遵循着如下的命名规则：</p><table><thead><tr class="header"><th style="text-align: center;">前缀</th><th style="text-align: center;">屏幕驱动芯片型号</th><th style="text-align: center;">分辨率</th><th style="text-align: center;">生产品牌</th><th style="text-align: center;">通信方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>U8G2</code></td><td style="text-align: center;"><code>SSD1306</code></td><td style="text-align: center;"><code>128X64</code></td><td style="text-align: center;"><code>NONAME</code></td><td style="text-align: center;"><code>HW_I2C</code></td></tr><tr class="even"><td style="text-align: center;">...</td><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td><td style="text-align: center;"><code>SW_I2C</code></td></tr></tbody></table><p>观察可以发现，除了没有缓冲区大小设置相关的参数之外，<code>u8x8()</code>构造函数的返回类型命名方式，与 <strong>U8G2</strong> 库的<code>u8g2()</code> 构造函数基本保持一致。接下来同样可以通过<strong>Arduino C++</strong> 和 <strong>U8x8</strong> 库，基于<strong>UINIO-MCU-ESP32S3</strong> 和 <strong>UINIO-Monitor</strong>实现一个 <code>Hello UinIO.com!</code> 字符串显示的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8x8lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* u8x8 构造函数 */</span></span><br><span class="line"><span class="function">U8X8_SSD1306_128X64_NONAME_SW_I2C <span class="title">u8x8</span><span class="params">(<span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x<span class="number">8.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8x<span class="number">8.</span><span class="built_in">setFont</span>(u8x8_font_chroma48medium8_r);</span><br><span class="line">  u8x<span class="number">8.</span><span class="built_in">drawString</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Hello UinIO.com!&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化工作">初始化工作</h2><p><code>u8g2</code> 类的 <code>begin()</code> 函数用于简化 Arduino环境下的显示设置步骤，该函数在底层会依次调用<code>initDisplay()</code>、<code>clearDisplay()</code>、<code>setPowerSave()</code>三个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">begin</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>begin()</code> 函数还可以用于绑定按键检测事件（最高可以绑定 6个按键），如果没有连接相应的按键，则对应的参数可以设置为<code>U8X8_PIN_NONE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">begin</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_select_pin,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_next_pin,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_prev_pin,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_up_pin = U8X8_PIN_NONE,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_down_pin = U8X8_PIN_NONE,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span> menu_home_pin = U8X8_PIN_NONE</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>除了 <code>begin()</code> 函数之外，<code>u8g2</code>类还提供有如下的屏幕显示初始化函数：</p><table><colgroup><col style="width: 27%"><col style="width: 72%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void setBusClock(uint32_t clock_speed);</code></td><td style="text-align: left;">设置总线通信的时钟频率，I²C 总线可以尝试<code>200000</code> 或者 <code>400000</code>，SPI 总线可以尝试<code>1000000</code> 或者 <code>8000000</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>void setContrast(uint8_t value)</code></td><td style="text-align: left;">设置显示对比度，取值范围从<code>0 ~ 255</code>。</td></tr></tbody></table><h2 id="字体配置">字体配置</h2><p><strong>U8G2</strong> 库使用的是<a href="https://github.com/olikraus/u8g2/wiki/fntlistall"><strong>点阵字体</strong></a>，使用时需要通过<code>setFont()</code> 函数配置当前所要显示的字体，其中字体名称<code>u8g2_font_字体类型与字符集</code>的最后两个字符定义了字体的<strong>类型</strong>和<strong>字符集</strong>：</p><table><thead><tr class="header"><th style="text-align: left;">字体名称</th><th style="text-align: left;">助记词</th><th style="text-align: left;">字体类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>u8g2_xxx_tx</code></td><td style="text-align: left;">Transparent</td><td style="text-align: left;">具有可变宽度的透明字体。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_xxx_mx</code></td><td style="text-align: left;">Monospace</td><td style="text-align: left;">等宽字体。</td></tr><tr class="odd"><td style="text-align: left;"><code>u8g2_xxx_hx</code></td><td style="text-align: left;">Height</td><td style="text-align: left;">具有可变宽度和共同高度的字体。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_xxx_8x</code></td><td style="text-align: left;">8x8</td><td style="text-align: left;">位于 8x8 盒子当中的等宽字体。</td></tr></tbody></table><table><colgroup><col style="width: 31%"><col style="width: 14%"><col style="width: 53%"></colgroup><thead><tr class="header"><th style="text-align: left;">字体名称</th><th style="text-align: left;">助记词</th><th style="text-align: left;">字符集</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>u8g2_xxx_xe</code></td><td style="text-align: left;">Extended</td><td style="text-align: left;">包含 Unicode 编码 <code>32 ~ 701</code>的字符。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_xxx_xf</code></td><td style="text-align: left;">Full</td><td style="text-align: left;">包含 Unicode 编码 <code>32 ~ 255</code>的字符。</td></tr><tr class="odd"><td style="text-align: left;"><code>u8g2_xxx_xr</code></td><td style="text-align: left;">Restricted</td><td style="text-align: left;">包含 Unicode 编码 <code>32 ~ 127</code>的字符。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_xxx_xu</code></td><td style="text-align: left;">Uppercase</td><td style="text-align: left;">只包含有数字和大写字母。</td></tr><tr class="odd"><td style="text-align: left;"><code>u8g2_xxx_xn</code></td><td style="text-align: left;">Numbers</td><td style="text-align: left;">包含日期和时间表达的数值与额外字符。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_xxx_x_something</code></td><td style="text-align: left;">-</td><td style="text-align: left;">特殊字体。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>U8G2</strong>库不支持直接设置字体的大小，而是通过选用不同尺寸的字体来完成字体大小的控制。</p></blockquote><p>如果需要通过 U8G2 库显示中文，则必须在 <code>begin()</code>调用之后，<code>print()</code> 调用之前执行下面的方法，从而使能 UTF8编码字符的显示输出，具体说明请参见下表所示：</p><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void enableUTF8Print(void)</code></td><td style="text-align: left;">使能 UTF8 显示支持，从而可以通过<code>u8g2.print()</code> 打印中文;</td></tr><tr class="even"><td style="text-align: left;"><code>void disableUTF8Print(void)</code></td><td style="text-align: left;">失能 UTF8 显示支持，默认状态。</td></tr></tbody></table><p>目前 U8G2 库已经包含了中文的<strong>文泉驿字体</strong>，可以同时支持<code>12</code>、<code>13</code>、<code>14</code>、<code>15</code>、<code>16</code>像素大小的字体：</p><ul><li><code>u8g2_font_wqy(12~16)_t_chinese1</code>：只包含 U8G2官方提供的小字符集。</li><li><code>u8g2_font_wqy(12~16)_t_chinese2</code>：只包含 U8G2官方提供的小字符集。</li><li><code>u8g2_font_wqy(12~16)_t_chinese3</code>：只包含 U8G2官方提供的小字符集。</li><li><code>u8g2_font_wqy(12~16)_t_gb2312</code>：包含有完整的 GB2312中文简体字符集。</li><li><code>u8g2_font_wqy(12~16)_t_gb2312a</code>：仅包含 GB2312 的<code>01</code>、<code>02</code> 和 <code>16 ~ 55</code> 以及部分<code>08</code> 区编码，没有包含全角标点符号。</li><li><code>u8g2_font_wqy(12~16)_t_gb2312b</code>：仅包含 GB2312 的<code>1 ~ 55</code> 区编码，其中 <code>10 ~ 15</code> 属于空区，相比于<code>gb2312a</code> 会多出一些额外的符号。</li></ul><blockquote><p><strong>注意</strong>：使用上述字体时，只需要将 <code>(12~16)</code>部分替换为当前所需的像素大小即可。</p></blockquote><p>除此之外，U8G2 库还可以支持 GNU 的 <a href="http://unifoundry.com/unifont/index.html">Unifont</a><strong>点阵黑</strong>中文字体，不过这些字体的美观程度明显逊色于文泉驿字体：</p><ul><li><code>u8g2_font_unifont_t_chinese1</code>：包含 U8G2官方提供的小字符集。</li><li><code>u8g2_font_unifont_t_chinese2</code>：包含 U8G2官方提供的小字符集。</li><li><code>u8g2_font_unifont_t_chinese3</code>：包含 U8G2官方提供的小字符集。</li></ul><p>下面的示例代码，就将会分别使用 <code>u8g2_font_wqy16_t_gb2312</code>和 <code>u8g2_font_wqy13_t_gb2312</code> 两种字体，在<strong>UINIO-Monitor</strong> 上面显示 <code>"Hello UinIO.com!"</code>和 <code>"你好，电子技术博客！"</code> 两组字符串内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();    <span class="comment">// 使能 UTF8 显示支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFontDirection</span>(<span class="number">0</span>);  <span class="comment">// 从左至右进行显示</span></span><br><span class="line">  u8g<span class="number">2.f</span>irstPage();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* 使用高度为 16 像素，包含完整 GB2312 字符集的文泉驿字体 */</span></span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_wqy16_t_gb2312);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">print</span>(<span class="string">&quot;Hello UinIO.com!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用高度为 13 像素，包含完整 GB2312 字符集的文泉驿字体 */</span></span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_wqy13_t_gb2312);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">print</span>(<span class="string">&quot;你好，电子技术博客！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> (u8g<span class="number">2.</span><span class="built_in">nextPage</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面介绍的方法之外，<strong>U8G2</strong>库还额外提供有如下几个字体显示相关的工具函数：</p><table><colgroup><col style="width: 32%"><col style="width: 67%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>u8g2_uint_t getMaxCharHeight(void)</code></td><td style="text-align: left;">返回指定点阵字体里，最大的字体<strong>高度</strong>。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_uint_t getMaxCharWidth(void)</code></td><td style="text-align: left;">返回指定点阵字体里，最大的字体<strong>宽度</strong>。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setDrawColor(uint8_t color)</code></td><td style="text-align: left;">参数 <code>color</code> 为 <code>0</code>表示字体不亮背景亮，为 <code>1</code> 表示背景不亮字体亮（默认）。</td></tr></tbody></table><h2 id="显示坐标系统">显示坐标系统</h2><p>显示坐标系统是 <strong>U8G2</strong>库当中比较重要的概念，运用显示相关的函数时，需要特别关注其显示起始的坐标。当使用<code>u8g2</code> 类的 <code>print()</code> 函数显示内容时，需要先运用<code>setCursor()</code> 函数设置显示内容在 <code>x</code> 轴与<code>y</code> 轴的起始像素坐标位置：</p><table><colgroup><col style="width: 47%"><col style="width: 52%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void setCursor(u8g2_uint_t x, u8g2_uint_t y)</code></td><td style="text-align: left;">设置显示内容的起始像素坐标位置。</td></tr><tr class="even"><td style="text-align: left;"><code>void home(void)</code></td><td style="text-align: left;">将光标放置到屏幕的左上角。</td></tr><tr class="odd"><td style="text-align: left;"><code>void clear(void)</code></td><td style="text-align: left;">清除屏幕和缓冲区上的内容，并且将光标放置到左上角。</td></tr></tbody></table><p><strong>U8G2</strong> 库将屏幕的左上角作为<strong>坐标原点</strong><code>(0, 0)</code>，显示内容将会沿着起始坐标位置分别<strong>向上</strong>和<strong>向右</strong>进行输出，例如下图左侧的代码分别将显示的起始坐标设置为<code>x = 0</code> 与<code>y = 15</code>，最终渲染显示出来的结果如下面右图所示：</p><p><img src="/Project/UINIO-Monitor/U8G2-1.png"></p><h2 id="屏幕刷新方法">屏幕刷新方法</h2><p><strong>U8G2</strong> 库提供有 <code>clearBuffer()</code> 和<code>sendBuffer()</code> 这组屏幕显示刷新的方法（刷新速度比较快，但是RAM 空间占用较大）：</p><table><colgroup><col style="width: 31%"><col style="width: 68%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void clearBuffer(void)</code></td><td style="text-align: left;">清除微控制器 RAM帧缓冲区当中的所有内容。</td></tr><tr class="even"><td style="text-align: left;"><code>void sendBuffer(void)</code></td><td style="text-align: left;">将微控制器 RAM帧缓冲区当中的内容发送至屏幕进行显示。</td></tr></tbody></table><p>显示缓冲区操作相关的代码，都必须放置到 <code>clearBuffer()</code> 和<code>sendBuffer()</code> 函数之间的区域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line">  <span class="comment">/* ................................................ */</span></span><br><span class="line">  <span class="comment">/* 显示缓冲区相关的操作代码都放置到这里 */</span></span><br><span class="line">  <span class="comment">/* ................................................ */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>除此之外，<strong>U8G2</strong> 库还提供了 <code>firstPage()</code>与 <code>nextPage()</code> 来刷新屏幕显示内容（消耗的 RAM空间相对较小）：</p><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void firstPage(void)</code></td><td style="text-align: left;">该命令是内容渲染循环的一部分，需要与<code>nextPage()</code> 配合使用。</td></tr><tr class="even"><td style="text-align: left;"><code>uint8_t nextPage(void)</code></td><td style="text-align: left;">该命令是内容渲染循环的一部分，需要与<code>firstPage()</code> 配合使用。</td></tr></tbody></table><p>使用时即可以采用 <code>do...while()</code> 循环的方式来组合调用<code>firstPage()</code> 与 <code>nextPage()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u8g<span class="number">2.f</span>irstPage();</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">/* ....................................................... */</span></span><br><span class="line">  <span class="comment">/* 所有显示内容的代码，都必须出现在该循环体内 */</span></span><br><span class="line">  <span class="comment">/* ....................................................... */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (u8g<span class="number">2.</span><span class="built_in">nextPage</span>());</span><br></pre></td></tr></table></figure><p>也可以把 <code>firstPage()</code> 放置到 Arduino 草图代码的<code>setup()</code> 函数当中，而 <code>nextPage()</code> 函数放置到<code>loop()</code> 循环的内部：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.f</span>irstPage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ....................................................... */</span></span><br><span class="line">  <span class="comment">/* 显示内容到屏幕的相关代码都必须出现在这里 */</span></span><br><span class="line">  <span class="comment">/* ....................................................... */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">nextPage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本输出函数">文本输出函数</h2><p>除了之前示例代码当中使用过的 <code>print()</code> 和<code>drawStr()</code> 之外，<strong>U8G2</strong>库还提供有如下一系列可以用于显示内容输出的方法：</p><table><colgroup><col style="width: 35%"><col style="width: 64%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>u8g2_uint_t drawStr(u8g2_uint_t x, u8g2_uint_t y, const char *s)</code></td><td style="text-align: left;">在指定的坐标位置绘制字符串（不能绘制编码大于或等于256 的字符），使用前必须指定字体。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_uint_t drawStrX2(u8g2_uint_t x, u8g2_uint_t y, const char *s)</code></td><td style="text-align: left;">功能同上，只是绘制的字体大小加倍。</td></tr><tr class="odd"><td style="text-align: left;"><code>u8g2_uint_t drawUTF8(u8g2_uint_t x, u8g2_uint_t y, const char *s)</code></td><td style="text-align: left;">绘制一个编码为 UTF-8的字符串（中文），该函数能够绘制编码值大于 <code>127</code>的字符。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_uint_t drawUTF8X2(u8g2_uint_t x, u8g2_uint_t y, const char *s)</code></td><td style="text-align: left;">功能同上，只是绘制的字体大小加倍。</td></tr><tr class="odd"><td style="text-align: left;"><code>u8g2_uint_t drawGlyph(u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)</code></td><td style="text-align: left;">在指定的坐标位置绘制图像字符，需要配合特殊的图像字体一起使用。</td></tr><tr class="even"><td style="text-align: left;"><code>u8g2_uint_t drawGlyphX2(u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)</code></td><td style="text-align: left;">功能同上，只是绘制的字体大小加倍。</td></tr><tr class="odd"><td style="text-align: left;"><code>void print(...)</code></td><td style="text-align: left;">向当前的光标位置（通过<code>setCursor()</code> 设置）写入指定字体（通过 <code>setFont()</code>设置）的文本（需要调用 <code>enableUTF8Print()</code> 使能 UTF-8编码）。</td></tr></tbody></table><p>接下来的示例代码，就会分别采用上面表格当中介绍的各种工具函数，测试输出各种显示内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span> U8X8_PIN_NONE, <span class="comment">/* clock=*/</span> <span class="number">16</span>, <span class="comment">/* data=*/</span> <span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setBusClock</span>(<span class="number">800000</span>);  <span class="comment">// 设置 I²C 总线时钟频率</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();              <span class="comment">// 初始化显示相关的一系列设置</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();    <span class="comment">// 使能 UTF8 编码支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> start = <span class="built_in">millis</span>(); <span class="comment">// 代码开始执行时候的毫秒数</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置一个英文字体，并且调用 drawStr() 函数显示英文 */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_adventurer_tf);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawStr</span>(<span class="number">0</span>, <span class="number">13</span>, <span class="string">&quot;Hello UinIO.com!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置一个中文字体，并且调用 print() 函数显示中文 */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_wqy13_t_gb2312b);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">30</span>);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">print</span>(<span class="string">&quot;你好，电子技术博客！&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用 drawUTF8() 绘制 UTF8 编码的雪人字符 */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_unifont_t_symbols);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawUTF8</span>(<span class="number">0</span>, <span class="number">55</span>, <span class="string">&quot;Snowman:☃&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用 drawGlyph() 绘制太阳图标 */</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFont</span>(<span class="type">u8g2_font_open_iconic_weather_2x_t</span>);</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawGlyph</span>(<span class="number">100</span>, <span class="number">57</span>, <span class="number">0x0045</span>);</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> end = <span class="built_in">millis</span>(); <span class="comment">// 代码结束执行时候的毫秒数</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(end - start);        <span class="comment">// 向串口打印上述代码执行所花费的毫秒数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制位图">绘制位图</h2><p><strong>XBM</strong>（X-Bitmap）是一种通用的图像文件格式，可以通过一个16 进制数组来表示二进制图像。<strong>U8G2</strong> 库提供的<code>drawXBM()</code>函数，可以直接用来绘制单色位图（图片在使用之前需要进行<strong>单值化</strong>处理和<strong>取模</strong>）：</p><table><colgroup><col style="width: 42%"><col style="width: 57%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawXBM(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap)</code></td><td style="text-align: left;">绘制 XBM 格式的位图，参数 <code>x</code>和 <code>y</code> 表示位图的左上角，而 <code>w</code> 与 <code>h</code>表示位图的宽高，参数 <code>bitmap</code>表示取模之后得到的单色位图数组。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：通常会将 <code>bitmap</code> 数组变量定义为<code>PROGMEM</code> 类型，表示将其存储在 Flash存储器当中，便于保存一些较大的位图数据，并且节省微控制器 RAM的存储空间。</p></blockquote><h3 id="位图取模">位图取模</h3><p><code>drawXBM()</code> 中的单色位图数组参数<code>bitmap</code>，可以通过取模工具软件 <strong>PCtoLCD2002</strong>获取，具体操作步骤如下面列表所示：</p><ol type="1"><li><strong>调整分辨率</strong>：将图片转换为适配 OLED 屏幕的<code>128*64</code> 分辨率。</li><li><strong>转换单色位图</strong>：再将转换分辨率之后的图片处理为<code>.bmp</code> 单色位图格式。</li><li><strong>生成 XBM 数组</strong>：使用 <strong>PCtoLCD2002</strong>工具软件对该单色位图进行取模，得到 XBM 数组。</li><li><strong>U8G2 绘制位图</strong>：调用 <code>u8g2</code> 类的<code>drawXBM()</code> 函数显示位图。</li></ol><blockquote><p><strong>注意</strong>：可以采用更为方便的在线工具 <a href="https://arduino.me/a/image-to-bitmap-array">image-to-bitmap-array</a>进行取模操作。</p></blockquote><p>首先使用 <strong>Windows</strong>操作系统自带的画图工具打开目标图片，然后点击顶部工具栏的【重新调整大小】，在弹出的对话框中选择【像素】，再将水平和垂直高度分别设置为<code>64</code> 个像素：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-1.png"></p><p>完成位图尺寸的调整之后，鼠标依次点击 <strong>Windows</strong>画图工具顶部菜单栏的【文件 → 另存为 → BMP 图片】：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-2.png"></p><p>在接下来弹出的【保存为】对话框当中，选择保存类型为【单色位图】的<code>.bmp</code> 文件：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-3.png"></p><p>接着打开 <strong>PCtoLCD2002</strong>取模软件，点击顶部工具栏上的【字模生成和液晶面板选项】按钮，在弹出的【字模选项】对话框当中进行如下设置：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-4.png"></p><p>最后，鼠标再次点击顶部工具栏上的【打开一个 BMP图像】按钮，将刚才得到的 <code>.bmp</code>单色位图文件导入，再点击【生成字模】按钮，就会在界面的底部区域得到<strong>U8G2</strong> 库绘图所需的 XBM 数组：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-5.png"></p><p>把这里得到的位图数组赋值给下面示例代码的 <code>Hank</code>变量，然后调用 <code>drawXBM()</code> 函数就可以进行位图的显示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">PROGMEM <span class="type">const</span> <span class="type">uint8_t</span> Hank[] = &#123;</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x7F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFE</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0xFC</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0xBF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0xFC</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0xC0</span>, <span class="number">0x87</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x60</span>, <span class="number">0x80</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x88</span>, <span class="number">0x3C</span>, <span class="number">0x1F</span>, <span class="number">0xF8</span>, <span class="number">0x3C</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8C</span>, <span class="number">0xFB</span>, <span class="number">0xA7</span>, <span class="number">0xE5</span>, <span class="number">0xDF</span>, <span class="number">0x31</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0xCA</span>, <span class="number">0x21</span>, <span class="number">0x84</span>, <span class="number">0xD3</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x02</span>, <span class="number">0x20</span>, <span class="number">0x04</span>, <span class="number">0xC0</span>, <span class="number">0x21</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x02</span>, <span class="number">0x90</span>, <span class="number">0x08</span>, <span class="number">0x80</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0xFD</span>, <span class="number">0x8F</span>, <span class="number">0xF0</span>, <span class="number">0x9F</span>, <span class="number">0x31</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x01</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x18</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x03</span>, <span class="number">0xC0</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0xFC</span>, <span class="number">0x3F</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xF7</span>, <span class="number">0xEF</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x8F</span>, <span class="number">0xF1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xDF</span>, <span class="number">0xF9</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xEC</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x17</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setBusClock</span>(<span class="number">800000</span>);  <span class="comment">// 设置 I²C 总线时钟频率</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();              <span class="comment">// 初始化显示相关的一系列设置</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();    <span class="comment">// 使能 UTF8 编码支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawXBM</span>(<span class="number">32</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">64</span>, Hank); <span class="comment">// 调用 drawXBM() 函数绘制位图</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码下载到 <strong>UINIO-MCU-ESP32S3</strong>核心板执行之后，显示到 <strong>UINIO-Monitor</strong> 的 OLED屏幕内容如下面所示：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-6.png"></p><h3 id="汉字取模">汉字取模</h3><p>除了支持把位图转换为 XBM 数组之外，<strong>PCtoLCD2002</strong>还能够把字符转换为 XBM 数组。首先在打开 <strong>PCtoLCD2002</strong>取模软件之后，选择顶部菜单栏上的【模式 → 字符模式】：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-7.png"></p><p>接下来，依然需要点击顶部工具栏上的【字模生成和液晶面板选项】按钮，在弹出的【字模选项】对话框当中进行如下设置：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-8.png"></p><p>然后，选择字体为 <code>楷体</code>，每一个字的宽度与高度都设置为<code>64</code> 个像素，并且在中间的输入框填写汉字<code>成都</code>，点击【生成字模】按钮：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-9.png"></p><p>最后，把上述步骤得到的两个 XBM 数组，分别赋予如下示例代码当中的<code>Chengdu</code> 和 <code>Du</code> 两个变量，再分别调用<code>drawXBM()</code> 函数就可以完成显示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">PROGMEM <span class="type">const</span> <span class="type">uint8_t</span> Cheng[] = &#123;</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x80</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x7E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xC3</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x7F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x7F</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0xE0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x3C</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x78</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x70</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x1F</span>, <span class="number">0x70</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x81</span>, <span class="number">0x7F</span>, <span class="number">0xF0</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x7F</span>, <span class="number">0xE0</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0x7D</span>, <span class="number">0xE0</span>, <span class="number">0x79</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x3F</span>, <span class="number">0x3C</span>, <span class="number">0xC0</span>, <span class="number">0x3D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x07</span>, <span class="number">0x3C</span>, <span class="number">0xC0</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x3C</span>, <span class="number">0x80</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x3C</span>, <span class="number">0x80</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x3C</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x3C</span>, <span class="number">0x80</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x00</span>, <span class="number">0x3C</span>, <span class="number">0xC0</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x3C</span>, <span class="number">0xC0</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0xE0</span>, <span class="number">0x3D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0xF0</span>, <span class="number">0x7C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x78</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x3C</span>, <span class="number">0x18</span>, <span class="number">0x1E</span>, <span class="number">0x1C</span>, <span class="number">0xF0</span>, <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0xF0</span>, <span class="number">0x1F</span>, <span class="number">0x0E</span>, <span class="number">0xF0</span>, <span class="number">0x01</span>, <span class="number">0x06</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0xE0</span>, <span class="number">0x0F</span>, <span class="number">0x03</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0xC0</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x07</span>, <span class="number">0x06</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0xC0</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x1F</span>, <span class="number">0x07</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7F</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/*&quot;成&quot;,0*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PROGMEM <span class="type">const</span> <span class="type">uint8_t</span> Du[] = &#123;</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x1E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x1E</span>, <span class="number">0x00</span>, <span class="number">0x78</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x7F</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0xFC</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x7F</span>, <span class="number">0x8F</span>, <span class="number">0x87</span>, <span class="number">0xFF</span>, <span class="number">0x03</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xFF</span>, <span class="number">0x8F</span>, <span class="number">0x87</span>, <span class="number">0xFF</span>, <span class="number">0xFB</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xFF</span>, <span class="number">0x81</span>, <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0xC1</span>, <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x78</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x3C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x1C</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x71</span>, <span class="number">0x3C</span>, <span class="number">0x0F</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0x7F</span>, <span class="number">0x0F</span>, <span class="number">0x06</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x0F</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x8F</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xE0</span>, <span class="number">0x7F</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x30</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0xFC</span>, <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x0F</span>, <span class="number">0xE0</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x03</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0x0D</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x8F</span>, <span class="number">0x87</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x70</span>, <span class="number">0x8C</span>, <span class="number">0xC7</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xFF</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0xFC</span>, <span class="number">0xC7</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xFC</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0xFC</span>, <span class="number">0xC3</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xF8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x03</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xE0</span>, <span class="number">0x03</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0xC0</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0xEF</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span>, <span class="number">0x01</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0xE0</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0xC0</span>, <span class="number">0x01</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xC0</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/*&quot;都&quot;,1*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setBusClock</span>(<span class="number">800000</span>);  <span class="comment">// 设置 I²C 总线时钟频率</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();              <span class="comment">// 初始化显示相关的一系列设置</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();    <span class="comment">// 使能 UTF8 编码支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawXBM</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">64</span>, Cheng);  <span class="comment">// 调用 drawXBM() 函数绘制 &quot;成&quot; 字</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawXBM</span>(<span class="number">64</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">64</span>, Du);    <span class="comment">// 调用 drawXBM() 函数绘制 &quot;都&quot; 字</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里同样将上述代码下载到 <strong>UINIO-MCU-ESP32S3</strong>核心板运行，此时 <strong>UINIO-Monitor</strong> 的 OLED屏幕显示结果如下面所示：</p><p><img src="/Project/UINIO-Monitor/U8G2-Bitmap-10.png"></p><h2 id="绘制基本图形">绘制基本图形</h2><h3 id="矩形绘制">矩形绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawBox()</code> 和<code>drawFrame()</code> 两个函数用于矩形的绘制：</p><table><colgroup><col style="width: 41%"><col style="width: 58%"></colgroup><thead><tr class="header"><th style="text-align: left;">矩形绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawBox(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)</code></td><td style="text-align: left;">绘制一个<strong>实心</strong>的矩形，参数<code>x</code> 和 <code>y</code>表示矩形<strong>左上角</strong>的起始位置，而 <code>w</code> 和<code>h</code> 分别表示其宽度与高度。</td></tr><tr class="even"><td style="text-align: left;"><code>void drawFrame(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)</code></td><td style="text-align: left;">绘制一个<strong>空心</strong>的矩形，参数<code>x</code> 和 <code>y</code>表示矩形<strong>左上角</strong>的起始位置，而 <code>w</code> 和<code>h</code> 分别表示其宽度与高度。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong>屏幕的左右两侧，分别绘制一个实心矩形和一个空心矩形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawBox</span>(<span class="number">16</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>);    <span class="comment">// 绘制实心矩形</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawFrame</span>(<span class="number">80</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>);  <span class="comment">// 绘制空心矩形</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆形绘制">圆形绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawCircle()</code> 和<code>drawDisc()</code> 两个函数用于圆形的绘制：</p><table><colgroup><col style="width: 48%"><col style="width: 51%"></colgroup><thead><tr class="header"><th style="text-align: left;">圆形绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawCircle(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt = U8G2_DRAW_ALL)</code></td><td style="text-align: left;">以 <code>(x0, y0)</code>位置为圆心，绘制一个半径为 <code>rad</code>的<strong>空心</strong>圆，参数 <code>opt</code>用于指定只绘制圆形的哪些部分。</td></tr><tr class="even"><td style="text-align: left;"><code>void drawDisc(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt = U8G2_DRAW_ALL)</code></td><td style="text-align: left;">以 <code>(x0, y0)</code>位置为圆心，绘制一个半径为 <code>rad</code>的<strong>实心</strong>圆，参数 <code>opt</code>用于指定只绘制圆形的哪些部分。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong>屏幕的左右两侧，分别绘制一个实心圆形和一个空心圆形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawCircle</span>(<span class="number">32</span>, <span class="number">32</span>, <span class="number">16</span>);  <span class="comment">// 绘制实心圆形</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawDisc</span>(<span class="number">96</span>, <span class="number">32</span>, <span class="number">16</span>);    <span class="comment">// 绘制空心圆形</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="椭圆形绘制">椭圆形绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawEllipse()</code> 和<code>drawFilledEllipse()</code> 两个函数用于椭圆形的绘制：</p><table><colgroup><col style="width: 45%"><col style="width: 54%"></colgroup><thead><tr class="header"><th style="text-align: left;">椭圆形绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawEllipse(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt)</code></td><td style="text-align: left;">以 <code>(x0, y0)</code>作为圆心，位置绘制水平半径为 <code>rx</code>，垂直半径为 <code>ry</code>的<strong>空心</strong>椭圆（8 位显示模式下，两者取值必须小于512）。</td></tr><tr class="even"><td style="text-align: left;"><code>void drawFilledEllipse(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt)</code></td><td style="text-align: left;">以 <code>(x0, y0)</code>作为圆心，位置绘制水平半径为 <code>rx</code>，垂直半径为 <code>ry</code>的<strong>实心</strong>椭圆（8 位显示模式下，两者取值必须小于512）。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong>屏幕的左右两侧，分别绘制一个实心椭圆形和一个空心椭圆形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawEllipse</span>(<span class="number">32</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">16</span>);        <span class="comment">// 绘制实心椭圆形</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawFilledEllipse</span>(<span class="number">96</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">16</span>);  <span class="comment">// 绘制空心椭圆形</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直线绘制">直线绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawHLine()</code> 和<code>drawVLine()</code> 以及 <code>drawLine()</code>三个函数来绘制直线：</p><table><colgroup><col style="width: 43%"><col style="width: 56%"></colgroup><thead><tr class="header"><th style="text-align: left;">直线绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawHLine(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w)</code></td><td style="text-align: left;">基于 <code>(x, y)</code>位置<strong>从左至右</strong>绘制一条长度为 <code>w</code>像素的<strong>水平</strong>直线。</td></tr><tr class="even"><td style="text-align: left;"><code>void drawVLine(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t h)</code></td><td style="text-align: left;">基于 <code>(x, y)</code>位置<strong>从下至上</strong>绘制一条长度为 <code>w</code>像素的<strong>垂直</strong>直线。</td></tr><tr class="odd"><td style="text-align: left;"><code>void drawLine(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)</code></td><td style="text-align: left;">基于两个像素点的位置绘制一条直线，参数<code>(x0, y0)</code> 是第 1 个点的坐标，而 <code>(x1, y1)</code> 则是第2 个点的坐标。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong>屏幕上面，绘制呈现<strong>米</strong>字形交错的 1 条水平直线和 1条垂直直线，以及 2 条斜线（类似于英国国旗的图案）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawLine</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">64</span>);  <span class="comment">// 绘制一条从屏幕左上角到右下角的斜线</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawLine</span>(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">64</span>);  <span class="comment">// 绘制一条从屏幕右上角到左下角的斜线</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawHLine</span>(<span class="number">0</span>, <span class="number">32</span>, <span class="number">128</span>);    <span class="comment">// 绘制一条水平直线</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawVLine</span>(<span class="number">64</span>, <span class="number">0</span>, <span class="number">64</span>);     <span class="comment">// 绘制一条垂直直线</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="像素点绘制">像素点绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawPixel()</code>函数来绘制一个像素点：</p><table><colgroup><col style="width: 58%"><col style="width: 41%"></colgroup><thead><tr class="header"><th style="text-align: left;">像素点绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawPixel(u8g2_uint_t x, u8g2_uint_t y)</code></td><td style="text-align: left;">在 <code>(x, y)</code>位置绘制一个像素点。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong> 屏幕当中，每间隔 8个像素绘制一个点，最终形成一条水平的虚线效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从左侧第 8 个像素位置开始，每间隔 8 个像素绘制出一个点 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">8</span>; index &lt;= <span class="number">128</span>; index += <span class="number">8</span>) &#123;</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">drawPixel</span>(index, <span class="number">32</span>);  <span class="comment">// 绘制一条由像素点组成的虚线</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆角矩形绘制">圆角矩形绘制</h3><p><strong>U8G2</strong> 库提供了 <code>drawRBox()</code> 和<code>drawRFrame()</code> 两个函数用于圆角矩形的绘制：</p><table><colgroup><col style="width: 48%"><col style="width: 51%"></colgroup><thead><tr class="header"><th style="text-align: left;">直线绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawRBox(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r)</code></td><td style="text-align: left;">以 <code>(x, y)</code>位置作为左上角，绘制一个宽高度分别为 <code>w</code> 和 <code>h</code>的圆角<strong>实心</strong>矩形，圆角的半径为 <code>r</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>void drawRFrame(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r)</code></td><td style="text-align: left;">以 <code>(x, y)</code>位置作为左上角，绘制一个宽高度分别为 <code>w</code> 和 <code>h</code>的圆角<strong>空心</strong>矩形，圆角的半径为 <code>r</code>。</td></tr></tbody></table><p>下面的示例代码会在 <strong>UINIO-Monitor</strong>屏幕的左右两侧，分别绘制一个实心和一个空心的圆角矩形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawRBox</span>(<span class="number">30</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">8</span>);    <span class="comment">// 绘制实心圆角矩形</span></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawRFrame</span>(<span class="number">66</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">8</span>);  <span class="comment">// 绘制空心圆角矩形</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制三角形">绘制三角形</h2><p><strong>U8G2</strong> 库提供了 <code>drawTriangle()</code>函数用于绘制实心的三角形：</p><table><colgroup><col style="width: 54%"><col style="width: 45%"></colgroup><thead><tr class="header"><th style="text-align: left;">直线绘制 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2)</code></td><td style="text-align: left;">分别以<code>(x0, y0)</code>、<code>(x1, y1)</code>、<code>(x2, y2)</code>作为顶点绘制一个<strong>实心</strong>的三角形。</td></tr></tbody></table><p>下面的示例代码，分别以屏幕顶部中间点 <code>(64, 0)</code>、屏幕左下角<code>(0, 64)</code>、屏幕右下角 <code>(128, 64)</code>作为顶点，绘制出了一个实心的三角形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, <span class="comment">/* reset=*/</span>U8X8_PIN_NONE, <span class="comment">/* clock=*/</span><span class="number">16</span>, <span class="comment">/* data=*/</span><span class="number">17</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();</span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">drawTriangle</span>(<span class="number">64</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">64</span>);  <span class="comment">// 绘制实心三角形</span></span><br><span class="line"></span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mui-图形界面库">MUI 图形界面库</h2><p><strong>MUI</strong> 是一款基于 <strong>U8G2</strong>库的单色图形用户界面库，提供了诸如<code>事件处理</code>、<code>用户界面绘图</code>、<code>丰富的预定义用户元素</code>、<code>静态菜单定义</code>等特性。详细信息可以参考 <strong>U8G2</strong> 库作者提供的 <a href="https://github.com/olikraus/u8g2/wiki/muimanual">《MUI手册》</a>和 <a href="https://github.com/olikraus/u8g2/wiki/muiref">《MUI 参考》</a>两份文档。</p><h1 id="英寸-lcd-显示屏">0.96/1.3/1.69/2.4 英寸 LCD 显示屏</h1><p><strong>UINIO-Monitor</strong> 里的 <strong>2.4</strong>英寸显示屏幕，采用了 <code>320 × 240</code>分辨率的<strong>薄膜晶体管</strong>（TFT，Thin FilmTransistor）屏幕材质，总线通信方式为<strong>SPI</strong>，驱动芯片型号是<a href="https://www.sitronix.com.tw/cn/index-cn/">台湾矽创电子（Sitronix）</a>的<strong>ST7789</strong>，属于本系列当中显示尺寸最大的屏幕：</p><p><img src="/Project/UINIO-Monitor/LCD-2.4.png"></p><p><strong>UINIO-Monitor</strong> 里的 <strong>1.3</strong>英寸显示屏幕，采用了 <code>240 × 240</code>分辨率的<strong>薄膜晶体管</strong>（TFT，Thin FilmTransistor）屏幕材质，总线通信方式为<strong>SPI</strong>，驱动芯片型号是<a href="https://www.sitronix.com.tw/cn/index-cn/">台湾矽创电子（Sitronix）</a>的<strong>ST7789</strong>：</p><p><img src="/Project/UINIO-Monitor/LCD-1.3.png"></p><p><strong>UINIO-Monitor</strong> 里的 <strong>1.69</strong>英寸圆角显示屏幕，采用了 <code>280 × 240</code>分辨率的<strong>薄膜晶体管</strong>（TFT，Thin FilmTransistor）屏幕材质，总线通信方式为<strong>SPI</strong>，驱动芯片型号是<a href="https://www.sitronix.com.tw/cn/index-cn/">台湾矽创电子（Sitronix）</a>的<strong>ST7789</strong>：</p><p><img src="/Project/UINIO-Monitor/LCD-1.69.png"></p><p><strong>UINIO-Monitor</strong> 里的 <strong>0.96</strong>英寸显示屏幕，采用了 <code>160 × 80</code>分辨率的<strong>薄膜晶体管</strong>（TFT，Thin FilmTransistor）屏幕材质，总线通信方式为<strong>SPI</strong>，驱动芯片型号是<a href="https://www.sitronix.com.tw/cn/index-cn/">台湾矽创电子（Sitronix）</a>的<strong>ST7735</strong>：</p><p><img src="/Project/UINIO-Monitor/LCD-0.96.png"></p><p>由于 <strong>UINIO-Monitor</strong> 系列的 TFT屏幕都采用了台湾矽创电子（Sitronix）的主控方案，因而原理图设计方面基本上大同小异，不过建议线性稳压芯片采用带<strong>反接保护</strong>的德州仪器<a href="https://www.ti.com/lit/ds/symlink/lp2992.pdf">LP2992IM5-3.3</a>，虽然价格相对于国产微盟的ME6211C33M5G 更贵，不过一分钱一分货，总比烧坏了成本更高的 TFT屏幕要强：</p><p><img src="/Project/UINIO-Monitor/LCD-Schematic.png"></p><p>同样在开始上手实践之前，需要把 <strong>UINIO-Monitor</strong> 当中TFT 显示屏的<code>BLK</code>、<code>CS</code>、<code>D/C</code>、<code>RST</code>、<code>SCL</code>、<code>SDA</code>、<code>GND</code>、<code>VCC</code>引脚，分别与 <strong>UINIO-MCU-ESP32S3</strong> 核心板的<code>3V3</code>、<code>GPIO15</code>、<code>GPIO16</code>、<code>GPIO17</code>、<code>GPIO18</code>、<code>GPIO19</code>、<code>GND</code>、<code>5V</code>引脚进行连接，后续 <strong>TFT_eSPI</strong>库相关的示例代码都将会沿用这个连接关系，下面的连接示意图以<code>280 × 240</code> 分辨率的 <strong>1.69</strong>英寸圆角显示屏幕为例：</p><p><img src="/Project/UINIO-Monitor/LCD-ESP32S3.png"></p><h1 id="tft_espi-库开发速成">TFT_eSPI 库开发速成</h1><p><a href="https://github.com/Bodmer/TFT_eSPI">TFT_eSPI</a>是一款可以运行在 32 位微控制器上的 TFT屏幕图形与字体显示库，本文撰写时的最新版本为 <code>v2.5.0</code>，相关的API 函数可以参考 <a href="https://github.com/Bodmer/User_Manual_TFT_eSPI">《TFT_eSPI库用户手册》</a>，该库对于如下一系列微控制器进行了专门的性能优化：</p><ul><li><strong>树莓派 Pico</strong> 上的 <code>RP2040</code>微控制器。</li><li><strong>乐鑫科技</strong>的<code>ESP8266</code>、<code>ESP32</code>、<code>ESP32-S2</code>、<code>ESP32-C3</code>、<code>ESP32-S3</code>微控制器。</li><li><strong>意法半导体</strong>的<code>STM32F1xx</code>、<code>STM32F2xx</code>、<code>STM32F4xx</code>、<code>STM32F767</code>微控制器（推荐采用 RAM 空间较大的型号）。</li></ul><p>上述的微控制器在 <strong>TFT_eSPI</strong>库当中，可以支持如下表格当中的接口类型：</p><table><colgroup><col style="width: 22%"><col style="width: 16%"><col style="width: 20%"><col style="width: 22%"><col style="width: 18%"></colgroup><thead><tr class="header"><th style="text-align: left;">微控制器</th><th style="text-align: center;">4 线制 SPI</th><th style="text-align: center;">8 位并行总线</th><th style="text-align: center;">16 位并行总线</th><th style="text-align: left;">DMA 支持</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>ESP32 C3</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: left;">否</td></tr><tr class="even"><td style="text-align: left;"><strong>ESP32 S3</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: left;">是 (仅 SPI)</td></tr><tr class="odd"><td style="text-align: left;"><strong>ESP32 S2</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: left;">否</td></tr><tr class="even"><td style="text-align: left;"><strong>ESP32</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: left;">是 (仅 SPI)</td></tr><tr class="odd"><td style="text-align: left;"><strong>RP2040</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: left;">是 (全部)</td></tr><tr class="even"><td style="text-align: left;"><strong>ESP8266</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: left;">否</td></tr><tr class="odd"><td style="text-align: left;"><strong>STM32Fxxx</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: left;">是 (仅 SPI)</td></tr><tr class="even"><td style="text-align: left;">其它</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: left;">否</td></tr></tbody></table><p><strong>TFT_eSPI</strong> 库能够支持如下一系列 TFT液晶显示屏驱动芯片（官方推荐使用内置有 <code>ILI9341</code> 和<code>ST7796</code> 两款驱动芯片的 SPI 屏幕）：</p><table><thead><tr class="header"><th style="text-align: left;">型号</th><th style="text-align: left;">型号</th><th style="text-align: left;">型号</th><th style="text-align: left;">型号</th><th style="text-align: left;">型号</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">ILI9163</td><td style="text-align: left;">ILI9225</td><td style="text-align: left;">ILI9341</td><td style="text-align: left;">ILI9342</td><td style="text-align: left;">ILI9481</td></tr><tr class="even"><td style="text-align: left;">ILI9486</td><td style="text-align: left;">ILI9488</td><td style="text-align: left;">HX8357B</td><td style="text-align: left;">HX8357C</td><td style="text-align: left;">HX8357D</td></tr><tr class="odd"><td style="text-align: left;">GC9A01</td><td style="text-align: left;">R61581</td><td style="text-align: left;">RM68120</td><td style="text-align: left;">RM68140</td><td style="text-align: left;">S6D02A1</td></tr><tr class="even"><td style="text-align: left;">SSD1351</td><td style="text-align: left;">SSD1963</td><td style="text-align: left;">ST7735</td><td style="text-align: left;">ST7789</td><td style="text-align: left;">ST7796</td></tr></tbody></table><h2 id="配置-user_setup.h">配置 User_Setup.h</h2><p>通过 <strong>Arduino IDE</strong> 的【库管理器】安装完成<strong>TFT_eSPI</strong> 库之后，还需要对<code>D:\Workspace\Workspace_Arduino\libraries\TFT_eSPI</code>路径下面的 <code>User_Setup.h</code> 头文件进行相应的编辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USER_SETUP_INFO <span class="string">&quot;UINIO_Monitor_Setup&quot;</span> <span class="comment">// 用于测试和诊断的用户自定义信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 TFT 液晶屏驱动芯片型号，只能预定义一个驱动芯片型号 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_DRIVER     <span class="comment">// ST7735 的配置选项</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_DRIVER     <span class="comment">// ST7789 的完整配置选项</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_2_DRIVER   <span class="comment">// ST7789 的最小配置选项</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以纵向排列的方式（高度大于宽度），配置 TFT 屏幕的像素高度与宽度 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_WIDTH  240    <span class="comment">// 2.4 英寸 ST7789 屏幕的宽度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_HEIGHT 320    <span class="comment">// 2.4 英寸 ST7789 屏幕的高度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_WIDTH  240    <span class="comment">// 1.3 英寸 ST7789 屏幕的宽度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_HEIGHT 240    <span class="comment">// 1.3 英寸 ST7789 屏幕的宽度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_WIDTH  240    <span class="comment">// 1.69 英寸 ST7789 屏幕的宽度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_HEIGHT 280    <span class="comment">// 1.69 英寸 ST7789 屏幕的宽度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_WIDTH  80     <span class="comment">// 0.96 英寸 ST7735 屏幕的宽度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_HEIGHT 160    <span class="comment">// 0.96 英寸 ST7735 屏幕的宽度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 TFT 液晶屏当前所使用的 SPI 通信总线 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_MOSI 19       <span class="comment">// 从机输出/主机输入，即 UINIO-Monitor 上丝印为 SDA 的引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_SCLK 18       <span class="comment">// 时钟引脚，即 UINIO-Monitor 上丝印为 SCL 的引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_RST  17       <span class="comment">// 重置引脚，如果已经连接至 UINIO-MCU-EESP32 的 RST 引脚，那么可以将其配置为 -1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_DC   16       <span class="comment">// 数据/命令控制引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_CS   15       <span class="comment">// 片选引脚</span></span></span><br><span class="line"><span class="comment">// #define TFT_BL            // LED 背光控制引脚，可以接入 UINIO-MCU-ESP32S3 的 3V3 输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TFT_eSPI 库自带的字体（非中文），加载全部字体会消耗约 17kb 的 Flash 存储空间，可以按需进行启用（ESP32-C3 和 ESP32-S3 的存储空间足够保存所有字体） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_GLCD         <span class="comment">// 8 像素字体，占用约 1820 bytes 的 Flash 存储空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_FONT2        <span class="comment">// 16 像素字体，占用约 3534 bytes 的 Flash 存储空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_FONT4        <span class="comment">// 16 像素字体，占用约 5848 bytes 的 Flash 存储空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_FONT6        <span class="comment">// 48 像素字体，占用约 2666 bytes 的 Flash 存储空间，仅包含字符 1234567890:-.apm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_FONT7        <span class="comment">// 7 段 48 像素字体，占用约 2438 bytes 的 Flash 存储空间，仅包含字符 1234567890:-.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_FONT8        <span class="comment">// 75 像素字体，占用约 3256 bytes 的 Flash 存储空间，仅包含字符 1234567890:-.</span></span></span><br><span class="line"><span class="comment">// #define LOAD_FONT8N       // 用于代替上面的 LOAD_FONT8 字体，稍微窄一点，适合 3 个数字 160 像素的 TFT 屏幕</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_GFXFF        <span class="comment">// 免费字体，包括 Adafruit_GFX 免费字体，以及 FF1 至 FF48 的自定义字体</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于停止加载 SPIFFS 文件系统和平滑字体代码，这样会节省约 20 kbytes 的 Flash 存储空间 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMOOTH_FONT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 SPI 总线时钟频率，该参数会影响到图形的渲染速度，超过 27MHz 会导致使用 ST7735 驱动芯片的屏幕显示异常 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_FREQUENCY  27000000         <span class="comment">// 可以选择的参数有 1000000、5000000、10000000、20000000、40000000、55000000、80000000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_READ_FREQUENCY  20000000    <span class="comment">// 定义 SPI 读取 TFT 屏幕的频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TOUCH_FREQUENCY  2500000    <span class="comment">// 触摸信号的 SPI 通信频率（触摸芯片 XPT2046 需要使用 2.5MHz 的时钟信号频率）</span></span></span><br></pre></td></tr></table></figure><p>如果 <strong>UINIO-Monitor</strong>屏幕显示出现异常，可以尝试通过调整如下的选项进行修复：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 只针对 ST7735、ST7789、ILI9341 有效，如果显示屏上红色与蓝色发生互换，那么可以重新调整其颜色顺序（只能启用一个选项）*/</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> TFT_RGB_ORDER TFT_RGB     <span class="comment">// 颜色顺序 Red-Green-Blue</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> TFT_RGB_ORDER TFT_BGR     <span class="comment">// 颜色顺序 Blue-Green-Red</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果显示的颜色发生反转（白色显示为黑色），可以尝试注释下面当中的其中一项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_INVERSION_ON</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_INVERSION_OFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义显示类型（仅针对 ST7735 有效），如果屏幕不能正确显示图形（例如颜色错误、镜像、边缘杂散像素），那么可以尝试下面这些选项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_INITB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_GREENTAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_GREENTAB2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_GREENTAB3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_GREENTAB128        <span class="comment">// 仅 128 x 128 分辨率显示有效</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_GREENTAB160x80     <span class="comment">// 仅 160 x 80 分辨率显示有效</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_ROBOTLCD           <span class="comment">// 只针对某些 RobotLCD 开发板</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_REDTAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_BLACKTAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7735_REDTAB160x80       <span class="comment">// 用于 24 像素偏移的 160 × 80 分辨率显示屏</span></span></span><br></pre></td></tr></table></figure><h2 id="开始上手">开始上手</h2><p><strong>Arduino IDE</strong> 的【库管理器】可以直接安装<strong>TFT_eSPI</strong> 库，安装完成之后就可以在 Arduino草图代码当中包含 <code>#include &lt;TFT_eSPI.h&gt;</code>头文件，下面代码展示了 <strong>TFT_eSPI</strong> 库的基本使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TFT_eSPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TFT_eSPI tft = <span class="built_in">TFT_eSPI</span>();                 <span class="comment">// 创建 TFT_eSPI 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  tft.<span class="built_in">init</span>();                              <span class="comment">// 重置然后初始化 TFT 显示相关的寄存器</span></span><br><span class="line">  tft.<span class="built_in">setRotation</span>(<span class="number">0</span>);                      <span class="comment">// 调整屏幕方向，参数为 1 表示旋转 90° 度，为 2 表示旋转 180° 度，为 3 表示旋转 270° 度</span></span><br><span class="line">  tft.<span class="built_in">fillScreen</span>(TFT_BLACK);               <span class="comment">// 设置 TFT 屏幕的背景颜色</span></span><br><span class="line">  tft.<span class="built_in">setTextColor</span>(TFT_WHITE, TFT_BLACK);  <span class="comment">// 设置 TFT 屏幕显示文本字体的颜色以及显示背景色</span></span><br><span class="line">  <span class="comment">/* ... 其它 TFT_eSPI 配置代码 ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... 需要循环执行的 TFT_eSPI 显示控制代码 ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="颜色模式">颜色模式</h2><p><strong>TFT_eSPI</strong> 库所采用的颜色模式为<strong>RGB565</strong>，即每一个像素占据着 <code>2 Byte</code>个字节的数据量（即 2 个字节的无符号整型数据），其中红色占据<code>5 bit</code> 位，绿色占据 <code>6 bit</code> 位，蓝色占据<code>5 bit</code> 位。<strong>TFT_eSPI</strong> 库提供了一个便捷的<code>color565()</code> 方法，可以将普通的 RGB 颜色转换为 RGB565模式的颜色：</p><table><colgroup><col style="width: 19%"><col style="width: 39%"><col style="width: 41%"></colgroup><thead><tr class="header"><th style="text-align: center;">归属类与返回值</th><th style="text-align: center;">API 函数</th><th style="text-align: center;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>uint16_t TFT_eSPI::</code></td><td style="text-align: center;"><code>color565(uint8_t r, uint8_t g, uint8_t b)</code></td><td style="text-align: center;">用于将普通 RGB 颜色转换为 RGB565模式的颜色。</td></tr></tbody></table><p>下面的示例代码，通过 <code>color565()</code>函数将<strong>红</strong>、<strong>黄</strong>、<strong>蓝</strong>、<strong>绿</strong>4 种 RGB 颜色，分别转换为了 RGB565 模式的颜色值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> RGB_Red = tft.<span class="built_in">color565</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">uint16_t</span> RGB_Yellow = tft.<span class="built_in">color565</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">uint16_t</span> RGB_Blue = tft.<span class="built_in">color565</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">uint16_t</span> RGB_Green = tft.<span class="built_in">color565</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在 <strong>TFT_eSPI</strong> 库安装目录下的 <code>TFT_eSPI.h</code>源文件里，已经预定义了如下一系列的默认颜色，代码当中可以直接进行使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_BLACK       0x0000      <span class="comment">/*   0,   0,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_NAVY        0x000F      <span class="comment">/*   0,   0, 128 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_DARKGREEN   0x03E0      <span class="comment">/*   0, 128,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_DARKCYAN    0x03EF      <span class="comment">/*   0, 128, 128 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_MAROON      0x7800      <span class="comment">/* 128,   0,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_PURPLE      0x780F      <span class="comment">/* 128,   0, 128 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_OLIVE       0x7BE0      <span class="comment">/* 128, 128,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_LIGHTGREY   0xD69A      <span class="comment">/* 211, 211, 211 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_DARKGREY    0x7BEF      <span class="comment">/* 128, 128, 128 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_BLUE        0x001F      <span class="comment">/*   0,   0, 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_GREEN       0x07E0      <span class="comment">/*   0, 255,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_CYAN        0x07FF      <span class="comment">/*   0, 255, 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_RED         0xF800      <span class="comment">/* 255,   0,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_MAGENTA     0xF81F      <span class="comment">/* 255,   0, 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_YELLOW      0xFFE0      <span class="comment">/* 255, 255,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_WHITE       0xFFFF      <span class="comment">/* 255, 255, 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_ORANGE      0xFDA0      <span class="comment">/* 255, 180,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_GREENYELLOW 0xB7E0      <span class="comment">/* 180, 255,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_PINK        0xFE19      <span class="comment">/* 255, 192, 203 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_BROWN       0x9A60      <span class="comment">/* 150,  75,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_GOLD        0xFEA0      <span class="comment">/* 255, 215,   0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_SILVER      0xC618      <span class="comment">/* 192, 192, 192 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_SKYBLUE     0x867D      <span class="comment">/* 135, 206, 235 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFT_VIOLET      0x915C      <span class="comment">/* 180,  46, 226 */</span></span></span><br></pre></td></tr></table></figure><h2 id="文本显示">文本显示</h2><p>下面表格当中的函数用于控制<code>TFT_eSP::print/printf/println()</code>系列文本输出函数（可以自动换行）的坐标系统：</p><table><colgroup><col style="width: 47%"><col style="width: 52%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void setCursor(int16_t x, int16_t y)</code></td><td style="text-align: left;">为 <code>tft.print()</code> 设置文本光标的<code>(x, y)</code> 坐标位置。</td></tr><tr class="even"><td style="text-align: left;"><code>void setCursor(int16_t x, int16_t y, uint8_t font)</code></td><td style="text-align: left;">为 <code>tft.print()</code> 设置文本光标的<code>(x, y)</code> 坐标位置和字体。</td></tr><tr class="odd"><td style="text-align: left;"><code>int16_t getCursorX(void)</code></td><td style="text-align: left;">获取当前 <code>tft.print()</code>文本光标在 <code>x</code> 轴的坐标位置。</td></tr><tr class="even"><td style="text-align: left;"><code>int16_t getCursorY(void)</code></td><td style="text-align: left;">获取当前 <code>tft.print()</code>文本光标在 <code>y</code> 轴的坐标位置。</td></tr></tbody></table><p>而接下来表格当中的这些方法，则用于控制<code>TFT_eSP::drawXxx()</code>系列文本输出函数（无法自动换行）的参考基准点：</p><table><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>uint8_t getTextDatum(void)</code></td><td style="text-align: left;">获取文本输出基准点。</td></tr><tr class="even"><td style="text-align: left;"><code>void setTextDatum(uint8_t d)</code></td><td style="text-align: left;">设置文本输出基准点。</td></tr></tbody></table><p>上面表格当中的 <code>setTextDatum(uint8_t d)</code> 函数的参数<code>d</code> 表示基准点的位置，可供选择的枚举参数有如下这些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TL_DATUM    0  <span class="comment">// 基准点位于输出文本的左上角（Top left）位置，默认参数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_DATUM    1  <span class="comment">// 基准点位于输出文本的中间顶部（Top Centre）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TR_DATUM    2  <span class="comment">// 基准点位于输出文本的右侧顶部（Top Right）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ML_DATUM    3  <span class="comment">// 基准点位于输出文本的左侧中间（Middle Left）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CL_DATUM    3  <span class="comment">// 同上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MC_DATUM    4  <span class="comment">// 基准点位于输出文本横向与纵向的中间（Middle Centre）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CC_DATUM    4  <span class="comment">// 同上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MR_DATUM    5  <span class="comment">// 基准点位于输出文本的右侧中间（Middle Right）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR_DATUM    5  <span class="comment">// 同上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BL_DATUM    6  <span class="comment">// 基准点位于输出文本的底部左侧（Bottom Left）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BC_DATUM    7  <span class="comment">// 基准点位于输出文本的底部中间（Bottom Centre）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BR_DATUM    8  <span class="comment">// 基准点位于输出文本的底部右侧（Bottom Right）位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L_BASELINE  9  <span class="comment">// 左侧字符基准线（Left Character Baseline）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_BASELINE 10  <span class="comment">// 中间字符基准线（Centre Character Baseline）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R_BASELINE 11  <span class="comment">// 右侧字符基准线（Right Character Baseline）</span></span></span><br></pre></td></tr></table></figure><p>除此之外，<strong>TFT_eSPI</strong>库还提供了如下一系列文本输出相关的辅助函数：</p><table><colgroup><col style="width: 37%"><col style="width: 62%"></colgroup><thead><tr class="header"><th style="text-align: left;">API 方法</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void setTextFont(uint8_t f)</code></td><td style="text-align: left;">设置当前所要显示文本的字体。</td></tr><tr class="even"><td style="text-align: left;"><code>void setTextSize(uint8_t s)</code></td><td style="text-align: left;">设置文本放大倍数（自定义字体无效），参数<code>s</code> 的取值范围介于 1 ~ 7 之间。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setTextColor(uint16_t c)</code></td><td style="text-align: left;">设置字体颜色（背景为透明）。</td></tr><tr class="even"><td style="text-align: left;"><code>void setTextColor(uint16_t c, uint16_t b)</code></td><td style="text-align: left;">设置字体的颜色以及其背景色。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setTextWrap(bool wrapX, bool wrapY)</code></td><td style="text-align: left;">设置文本是否自动换行。</td></tr><tr class="even"><td style="text-align: left;"><code>void setTextPadding(uint16_t x_width)</code></td><td style="text-align: left;">设置填充宽度（以像素为单位），将会擦除之前的文本内容。</td></tr><tr class="odd"><td style="text-align: left;"><code>void getTextPadding(void)</code></td><td style="text-align: left;">获取填充宽度（以像素为单位）。</td></tr></tbody></table><p>下面的示例代码，会向 <strong>UINIO-Monitor</strong>屏幕<strong>从上至下</strong>依次打印 <code>Hello UinIO.com</code>字符串内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TFT_eSPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TFT_eSPI tft = <span class="built_in">TFT_eSPI</span>();  <span class="comment">// 创建 TFT_eSPI 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  tft.<span class="built_in">init</span>();                              <span class="comment">// 重置然后初始化 TFT 显示相关的寄存器</span></span><br><span class="line">  tft.<span class="built_in">setRotation</span>(<span class="number">0</span>);                      <span class="comment">// 调整屏幕方向，参数为 1 表示旋转 90° 度，为 2 表示旋转 180° 度，为 3 表示旋转 270° 度</span></span><br><span class="line">  tft.<span class="built_in">fillScreen</span>(TFT_BLACK);               <span class="comment">// 设置 TFT 屏幕的背景颜色</span></span><br><span class="line">  tft.<span class="built_in">setTextColor</span>(TFT_WHITE, TFT_BLACK);  <span class="comment">// 设置 TFT 屏幕显示文本字体的颜色以及显示背景色</span></span><br><span class="line">  tft.<span class="built_in">setTextSize</span>(<span class="number">2</span>);                      <span class="comment">// 设置文本字体的放大倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* print/f/ln 系列文本打印函数 ... */</span></span><br><span class="line">  tft.<span class="built_in">println</span>(<span class="string">&quot;Hello UinIO.com&quot;</span>);                <span class="comment">// 换行打印字符串</span></span><br><span class="line">  tft.<span class="built_in">printf</span>(<span class="string">&quot;Hello UinIO.com\n&quot;</span>);               <span class="comment">// 格式化打印字符串</span></span><br><span class="line">  tft.<span class="built_in">print</span>(<span class="string">&quot;Hello UinIO.com&quot;</span>);                  <span class="comment">// 直接打印字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* drawXxx() 系列文本绘制函数 */</span></span><br><span class="line">  tft.<span class="built_in">drawString</span>(<span class="string">&quot;Hello UinIO.com&quot;</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">2</span>);   <span class="comment">// 绘制字符串</span></span><br><span class="line">  tft.<span class="built_in">drawFloat</span>(<span class="number">2023.12</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">90</span>);              <span class="comment">// 绘制符点数</span></span><br><span class="line">  tft.<span class="built_in">drawNumber</span>(<span class="number">610000</span>, <span class="number">0</span>, <span class="number">115</span>);                <span class="comment">// 绘制数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... 需要循环执行的 TFT_eSPI 显示控制代码 ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义字体">自定义字体</h2><p><strong>TFT_eSPI</strong> 库在其安装目录<code>TFT_eSPI\Tools\Create_Smooth_Font\Create_font</code>下面提供了处理自定义字体的 <strong>Create_font</strong>工具，其中包含有如下源文件和目录：</p><ul><li><code>data</code> 目录：用于存放 <code>.ttf</code> 以及<code>.otf</code> 字体文件。</li><li><code>FontFiles</code> 目录：保存的是转换处理之后所获得的<code>.vlw</code> 字体文件。</li><li><code>Create_font.pde</code> 工程文件：用于将自定义字体，从 Unicode编码转换为 <code>.vlw</code> 格式的字体文件（后续需要再进一步转换为<code>.h</code> 文件）。</li></ul><h3 id="processing-生成-.vlw-字体文件">Processing 生成 .vlw字体文件</h3><p><a href="https://processing.org/download"><strong>Processing</strong></a>是一款用于图像处理的开源编程语言与开发环境，通过其可以打开位于<strong>TFT_eSPI</strong> 库安装目录<code>TFT_eSPI\Tools\Create_Smooth_Font\Create_font</code>下面，用于制作<strong>自定义字体</strong>的 Processing 工程文件<code>Create_font.pde</code>：</p><p><img src="/Project/UINIO-Monitor/Processing-1.png"></p><p>将下面的代码复制到 <code>Create_font.pde</code> 的用户配置参数注释<code>USER CONFIGURED PARAMETERS</code>所在的位置，并且替换掉原来的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; USER CONFIGURED PARAMETERS START HERE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">fontNumber</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 字体编号，值为 -1 表示使用下面的 fontName 设置，&gt;=0 则表示使用系统字体编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">fontName</span> <span class="operator">=</span> <span class="string">&quot;SourceHanSansSC-Bold&quot;</span>;  <span class="comment">// 自定义字体文件的名称</span></span><br><span class="line"><span class="comment">// String fontType = &quot;.ttf&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fontType</span> <span class="operator">=</span> <span class="string">&quot;.otf&quot;</span>;   <span class="comment">// 自定义字体文件的后缀</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="variable">fontSize</span> <span class="operator">=</span> <span class="number">14</span>;        <span class="comment">// 字体的像素大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">displayFontSize</span> <span class="operator">=</span> <span class="number">14</span>;  <span class="comment">// Processing 草图弹出窗口的字体大小（可以和上面的 fontSize 不同）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前所使用 Unicode 编码的起始码与结束码（适用于字符较少的英文或拉丁字体）*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] unicodeBlocks = &#123;</span><br><span class="line">  <span class="number">0x0021</span>, <span class="number">0x007E</span>, <span class="comment">// 该 Unicode 块包含了常见的符号与所有的大小写英文字母</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入需要生成相应字体的字符的编码值（适用于中文字体）*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] specificUnicodes = &#123;</span><br><span class="line">  <span class="number">0x6210</span>, <span class="number">0x90fd</span>, <span class="comment">// 中文汉字 &quot;成都&quot; 的 Unicode 编码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//                       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; USER CONFIGURED PARAMETERS END HERE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><p>接下来，就可以根据下面列出的步骤，依次进行相关的处理和操作：</p><ol type="1"><li>使用<a href="http://www.jsons.cn/unicode">在线中文转 Uinicode工具</a>，获得当前所需中文汉字的 Unicode 编码，然后将转换结果当中的<code>\u</code> 替换为 <code>0x</code>，最后将结果填写到<code>Create_font.pde</code> 工程源文件的<code>specificUnicodes()</code> 函数里。</li><li>紧接着把<strong>思源黑体</strong>的字体文件<code>SourceHanSansSC-Bold.otf</code> 复制到<code>TFT_eSPI\Tools\Create_Smooth_Font\Create_font</code> 路径下面的<code>data</code> 目录，同时把 <code>Create_font.pde</code> 里的<code>fontName</code> 变量修改为字体的文件名称<code>SourceHanSansSC-Bold</code>，而 <code>fontType</code> 变量修改为<code>.otf</code>。</li><li>完成上述步骤之后，点击 <strong>Processing</strong>工具顶部的【运行】按钮，就会弹出下面的提示框，展示当前生成完毕的字体内容。</li></ol><p><img src="/Project/UINIO-Monitor/Processing-2.png"></p><p>与此同时，就会在<code>TFT_eSPI\Tools\Create_Smooth_Font\Create_font</code> 路径下面的<code>FontFiles</code> 目录里，发现刚才已经转换完成了的<code>SourceHanSansSC-Bold14.vlw</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspace\Workspace_Arduino\libraries\TFT_eSPI\Tools\Create_Smooth_Font\Create_font\FontFiles</span><br><span class="line">λ <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">SourceHanSansSC-Bold14.vlw  System_Font_List.txt</span><br></pre></td></tr></table></figure><h3 id="将-.vlw-转换为-.h-头文件">将 .vlw 转换为 .h 头文件</h3><p>接下来，继续通过<a href="https://tomeko.net/online_tools/file_to_hex.php?lang=zh">在线文件十六进制转换器</a>,或者该网站上提供的 <code>bin2hex.exe</code> 程序，把前面生成的<code>SourceHanSansSC-Bold14.vlw</code>文件转换为<strong>十六进制</strong>的格式：</p><p><img src="/Project/UINIO-Monitor/Processing-3.png"></p><p>此时可以打开 <strong>Arduino IDE</strong>新建一个草图工程，接着在工程文件的根目录再新建一个<code>font_chengdu.h</code>头文件（用于保存上述十六进制编码），把上面获得的十六进制编码拷贝到下面的<code>font_chengdu</code> 数组变量当中，就成功创建出了可供<strong>TFT_eSPI</strong> 库使用的 <code>font_chengdu.h</code>字体头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pgmspace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> font_chengdu[] PROGMEM = &#123;</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x62</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0xFD</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xBF</span>, <span class="number">0xE9</span>, <span class="number">0x3E</span>, <span class="number">0xE3</span>, <span class="number">0x57</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC2</span>, <span class="number">0xF8</span>, <span class="number">0x2C</span>, <span class="number">0xD7</span>, <span class="number">0xFF</span>, <span class="number">0x5A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4A</span>, <span class="number">0xA3</span>, <span class="number">0xA3</span>, <span class="number">0xA3</span>, <span class="number">0xA3</span>,</span><br><span class="line">  <span class="number">0xA3</span>, <span class="number">0xE8</span>, <span class="number">0xFE</span>, <span class="number">0xA3</span>, <span class="number">0xAF</span>, <span class="number">0xFE</span>, <span class="number">0xAD</span>, <span class="number">0x42</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0xFF</span>, <span class="number">0x4B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x95</span>, <span class="number">0xFF</span>, <span class="number">0x25</span>,</span><br><span class="line">  <span class="number">0x05</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0xFF</span>, <span class="number">0xA8</span>, <span class="number">0x83</span>, <span class="number">0x83</span>, <span class="number">0x63</span>, <span class="number">0x76</span>, <span class="number">0xFF</span>, <span class="number">0x4A</span>, <span class="number">0x58</span>, <span class="number">0xFF</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x76</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xBD</span>, <span class="number">0x57</span>, <span class="number">0xFF</span>, <span class="number">0x6F</span>, <span class="number">0xC4</span>, <span class="number">0xFD</span>, <span class="number">0x20</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x82</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>, <span class="number">0xB7</span>, <span class="number">0x2E</span>, <span class="number">0xFF</span>, <span class="number">0xC4</span>, <span class="number">0xFF</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8F</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0xEB</span>, <span class="number">0xB1</span>, <span class="number">0x03</span>, <span class="number">0xF5</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9D</span>, <span class="number">0xFF</span>, <span class="number">0x13</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xFA</span>, <span class="number">0xA5</span>, <span class="number">0x00</span>, <span class="number">0xC3</span>, <span class="number">0xFF</span>, <span class="number">0xA8</span>, <span class="number">0x00</span>, <span class="number">0x59</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0x5B</span>, <span class="number">0x95</span>, <span class="number">0xFF</span>,</span><br><span class="line">  <span class="number">0x8B</span>, <span class="number">0x44</span>, <span class="number">0xF8</span>, <span class="number">0xFF</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>, <span class="number">0x6C</span>, <span class="number">0x06</span>, <span class="number">0xF3</span>, <span class="number">0xCF</span>, <span class="number">0x6E</span>, <span class="number">0xFF</span>, <span class="number">0xE4</span>, <span class="number">0x89</span>, <span class="number">0xF5</span>,</span><br><span class="line">  <span class="number">0xFD</span>, <span class="number">0xFC</span>, <span class="number">0xDB</span>, <span class="number">0x3D</span>, <span class="number">0xFF</span>, <span class="number">0x58</span>, <span class="number">0x5D</span>, <span class="number">0xFF</span>, <span class="number">0x8D</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x43</span>, <span class="number">0xFF</span>, <span class="number">0xF1</span>, <span class="number">0x4C</span>, <span class="number">0x74</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFB</span>, <span class="number">0x19</span>, <span class="number">0x2C</span>, <span class="number">0xD8</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7A</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5C</span>, <span class="number">0xA4</span>,</span><br><span class="line">  <span class="number">0x56</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xDB</span>, <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x1E</span>, <span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5B</span>,</span><br><span class="line">  <span class="number">0x6E</span>, <span class="number">0xFF</span>, <span class="number">0xBA</span>, <span class="number">0x68</span>, <span class="number">0xB1</span>, <span class="number">0xE2</span>, <span class="number">0xE1</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xED</span>, <span class="number">0x4A</span>, <span class="number">0x00</span>, <span class="number">0xD7</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0x7C</span>, <span class="number">0xDF</span>, <span class="number">0xE6</span>, <span class="number">0x93</span>, <span class="number">0xCD</span>, <span class="number">0xFF</span>, <span class="number">0x55</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x87</span>, <span class="number">0xAB</span>,</span><br><span class="line">  <span class="number">0xF9</span>, <span class="number">0x17</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x00</span>, <span class="number">0xBD</span>, <span class="number">0xF1</span>, <span class="number">0x08</span>, <span class="number">0x34</span>, <span class="number">0x73</span>, <span class="number">0x76</span>, <span class="number">0xFF</span>, <span class="number">0xC7</span>, <span class="number">0xFE</span>, <span class="number">0xDB</span>, <span class="number">0x4D</span>,</span><br><span class="line">  <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x10</span>, <span class="number">0xFA</span>, <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xAB</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>,</span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0x2C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4A</span>, <span class="number">0xE7</span>, <span class="number">0xF2</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x7B</span>, <span class="number">0xFD</span>,</span><br><span class="line">  <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x99</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x01</span>, <span class="number">0xC4</span>, <span class="number">0xE0</span>, <span class="number">0x05</span>,</span><br><span class="line">  <span class="number">0x9F</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x94</span>, <span class="number">0x53</span>, <span class="number">0x94</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x00</span>, <span class="number">0x67</span>, <span class="number">0xFF</span>, <span class="number">0x31</span>, <span class="number">0x33</span>, <span class="number">0xF6</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0x87</span>, <span class="number">0x3F</span>, <span class="number">0x87</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0xFF</span>, <span class="number">0x51</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0xDF</span>, <span class="number">0xC5</span>, <span class="number">0x91</span>, <span class="number">0xD7</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0xFF</span>, <span class="number">0x94</span>, <span class="number">0x53</span>, <span class="number">0x94</span>,</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0x33</span>, <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0xC1</span>, <span class="number">0xF7</span>, <span class="number">0x8E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x23</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x33</span>,</span><br><span class="line">  <span class="number">0xDF</span>, <span class="number">0xC3</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0xE3</span>, <span class="number">0x55</span>, <span class="number">0x00</span>, <span class="number">0x3E</span>, <span class="number">0xA7</span>, <span class="number">0x22</span>, <span class="number">0xCE</span>, <span class="number">0xB4</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0xE6</span>, <span class="number">0x80</span>, <span class="number">0x9D</span>, <span class="number">0xE6</span>, <span class="number">0xBA</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xBB</span>, <span class="number">0x91</span>, <span class="number">0xE4</span>,</span><br><span class="line">  <span class="number">0xBD</span>, <span class="number">0x93</span>, <span class="number">0x20</span>, <span class="number">0x42</span>, <span class="number">0x6F</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x6F</span>, <span class="number">0x75</span>, <span class="number">0x72</span>, <span class="number">0x63</span>, <span class="number">0x65</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0x6E</span>, <span class="number">0x53</span>, <span class="number">0x61</span>, <span class="number">0x6E</span>, <span class="number">0x73</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x2D</span>, <span class="number">0x42</span>, <span class="number">0x6F</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x01</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="显示自定义字体">显示自定义字体</h3><p>在刚才新建的 Arduino 草图工程源代码里边，通过预处理命令<code>#include</code> 包含上面建立的 <code>font_chengdu.h</code>字体头文件，然后使用 <code>loadFont()</code> 函数加载字体，再分别通过<code>print()</code> 和 <code>drawString()</code>函数向屏幕输出思源黑体的<strong>成都</strong>，最后在使用完成之后调用<code>unloadFont()</code> 函数卸载字体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TFT_eSPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font_chengdu.h&quot;</span>  <span class="comment">// 包含自定义字库头文件</span></span></span><br><span class="line"></span><br><span class="line">TFT_eSPI tft = <span class="built_in">TFT_eSPI</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 初始化 TFT_eSPI 设置 */</span></span><br><span class="line">  tft.<span class="built_in">init</span>();</span><br><span class="line">  tft.<span class="built_in">setRotation</span>(<span class="number">0</span>);</span><br><span class="line">  tft.<span class="built_in">fillScreen</span>(TFT_BLACK);</span><br><span class="line">  tft.<span class="built_in">setTextColor</span>(TFT_WHITE);</span><br><span class="line"></span><br><span class="line">  tft.<span class="built_in">loadFont</span>(font_chengdu);     <span class="comment">// 加载 font_chengdu 字库</span></span><br><span class="line"></span><br><span class="line">  tft.<span class="built_in">print</span>(<span class="string">&quot;成都&quot;</span>);               <span class="comment">// 第 1 行输出汉字</span></span><br><span class="line">  tft.<span class="built_in">drawString</span>(<span class="string">&quot;成都&quot;</span>, <span class="number">0</span>, <span class="number">16</span>);   <span class="comment">// 第 2 行输出汉字</span></span><br><span class="line">  tft.<span class="built_in">unloadFont</span>();               <span class="comment">// 卸载字库资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="tft_ewidget-图形界面库">TFT_eWidget 图形界面库</h2><p><strong>TFT_eSPI</strong> 库的作者还提供了一个简单小巧的 <a href="https://github.com/Bodmer/TFT_eWidget">TFT_eWidget</a>图形界面库，不过 Arduino 当中通常使用 <strong>LVGL</strong> 结合<strong>TFT_eSPI</strong>来绘制图形界面，所以该库的运用并不广泛，本文就不再赘述，有需要的朋友可以直接参考开源项目当中的说明文档。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/uinika/UINIO-Monitor&quot;&gt;&lt;strong&gt;UINIO-Monitor&lt;/strong&gt;&lt;/a&gt;
同时拼接有 &lt;code&gt;128×64&lt;/code&gt; 分辨率 &lt;strong&gt;SSD1315&lt;/strong&gt; 驱动的
0.96 英寸 OLED 显示屏，&lt;code&gt;160×80&lt;/code&gt; 分辨率
&lt;strong&gt;ST7735&lt;/strong&gt; 驱动的 0.96 英寸 LCD
显示屏，&lt;code&gt;240×240&lt;/code&gt; 分辨率 &lt;strong&gt;ST7789&lt;/strong&gt; 驱动的 1.3
英寸 LCD 显示屏。以及采用相同驱动芯片，但是分辨率分别为
&lt;code&gt;240×320&lt;/code&gt; 与 &lt;code&gt;240×280&lt;/code&gt; 的 2.4 英寸以及 1.69 英寸
LCD 显示屏。所有屏幕全部板载有 &lt;code&gt;0.5mm&lt;/code&gt; 间距的
&lt;strong&gt;FPC&lt;/strong&gt; 柔性排线连接器，同时还引出 &lt;code&gt;2.54mm&lt;/code&gt;
间距的直插排针，便于通过杜邦线快速搭建实验电路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-Monitor/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前由我设计制作并且开源出来的 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32C3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32C3&lt;/strong&gt;&lt;/a&gt;
和 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32S3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32S3&lt;/strong&gt;&lt;/a&gt;
两款核心板，分别基于乐鑫科技的 &lt;strong&gt;ESP32-C3&lt;/strong&gt; (RISC-V) 与
&lt;strong&gt;ESP32-S3&lt;/strong&gt; (Xtensa) 微控制器（更多玩法可以参考之前撰写的
&lt;a href=&quot;http://uinio.com/Project/Arduino-ESP32/&quot;&gt;《基于 UINIO-MCU-ESP32
的 Arduino 进阶教程》&lt;/a&gt;
一文）。而本篇文章就会采用这两款核心板，以及乐鑫官方的
&lt;strong&gt;Arduino-ESP32&lt;/strong&gt; 板级支持包，结合 &lt;a href=&quot;https://github.com/olikraus/u8g2&quot;&gt;&lt;strong&gt;U8G2&lt;/strong&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Bodmer/TFT_eSPI&quot;&gt;&lt;strong&gt;TFT_eSPI&lt;/strong&gt;&lt;/a&gt;
两款开源显示库，帮助大家快速上手 &lt;strong&gt;UINIO-Monitor&lt;/strong&gt; 系列里的
5 款显示屏。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="Arduino" scheme="http://www.uinio.com/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>基于 UINIO-MCU-ESP32 的 Arduino 进阶教程</title>
    <link href="http://www.uinio.com/Project/Arduino-ESP32/"/>
    <id>http://www.uinio.com/Project/Arduino-ESP32/</id>
    <published>2023-04-30T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.327Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/espressif/arduino-esp32"><strong>Arduino-ESP32</strong></a>是由<strong>乐鑫科技</strong>在 <strong>GitHub</strong>开源社区推出的一款基于 <strong>Arduino IDE</strong>的<strong>板级支持包</strong>（<strong>BSP</strong>，Board SupportPackage），除了兼容大部分通用的 <a href="https://www.arduino.cc/reference/en/"><strong>ArduinoAPI</strong></a> 之外，还能够支持 <strong>ESP32</strong>系列芯片一些独有的特性化<strong>API</strong>。由于几年以前已经撰写过一篇基于标准 Arduino API的<a href="http://uinio.com/Embedded/Arduino/">《玩转 ArduinoUno、Mega、ESP 开源硬件》</a>，所以本篇文章不再赘述相关内容，而是结合<code>U8G2</code>、<code>AsyncTimer</code>、<code>RBD_BUTTON</code>、<code>LiquidCrystal_I2C</code>、<code>ESP32SPISlave</code>、<code>Servo</code>、<code>SdFat</code>等常用第三方库，通过分析注释典型的示例代码，分门别类的介绍了各种片上资源外设的实例化运用。</p><p><img src="/Project/Arduino-ESP32/logo.png"></p><p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>是当前市场上比较流行的两款物联网主控芯片方案，它们分别基于开源的<strong>RISC-V</strong> 内核，以及商业化的 <strong>Xtensa</strong>内核，并且同时支持 WiFi 与 Bluetooth无线连接。由于日常工作当中经常使用到这两款微控制器，所以特意设计了 <a href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>和 <a href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>两款核心板，关于它们硬件电路设计方面的相关内容，可以进一步参考本篇文章的姊妹篇<a href="http://uinio.com/Project/UINIO-MCU-ESP32/">《UINIO-MCU-ESP32核心板电路设计》</a>。由于本文属于 Arduino进阶性质的教程，阅读时需要具备一定的嵌入式开发经验，萌新可以阅读笔者更早之前撰写的<a href="http://uinio.com/Embedded/Arduino/">《玩转 Arduino Uno、Mega、ESP开源硬件》</a>。</p><span id="more"></span><h1 id="arduino-ide-2-开发环境">Arduino IDE 2 开发环境</h1><p><strong>Arduino IDE 2</strong> 相较于之前的 <code>1.8.19</code>版本，提供了更加友好的用户界面，新增了<code>自动补全</code>、<code>内置调试器</code>、<code>Arduino Cloud 同步</code>等功能，拥有一个改进的侧边栏，使得常用的功能更加易于访问，详细用法可以查阅<strong>Arduino</strong> 官方提供的<a href="https://docs.arduino.cc/software/ide-v2">《<strong>Arduino IDE 2Tutorials</strong>》</a>：</p><p><img src="/Project/Arduino-ESP32/0.png"></p><blockquote><p><strong>注意</strong>：<strong>Arduino IDE</strong> 创建的以<code>.ino</code>作为后缀名的源代码文件，被称为<strong>草图</strong>（Sketche）文件。</p></blockquote><h1 id="arduino-esp32-库概览">Arduino-ESP32 库概览</h1><p><strong>乐鑫科技</strong>在 <strong>GitHub</strong> 开源社区推出的 <a href="https://github.com/espressif/arduino-esp32"><strong>Arduino-ESP32</strong></a>板级支持包，目前已经更新到 <code>2.0.11</code> 版本，通过向<strong>Arduino IDE</strong>的【开发板管理器】添加如下的<code>开发板管理器地址</code>，就可以完成<strong>Arduino-ESP32</strong> 板级支持包的安装：</p><ul><li><strong>稳定版本链接</strong>：<code>https://espressif.github.io/arduino-esp32/package_esp32_index.json</code></li><li><strong>开发版本链接</strong>：<code>https://espressif.github.io/arduino-esp32/package_esp32_dev_index.json</code></li></ul><p><strong>Arduino-ESP32</strong> 提供了对于<strong>ESP32</strong>、<strong>ESP32-S2</strong>、<strong>ESP32-C3</strong>、<strong>ESP32-S3</strong>系列芯片的支持，各个片上外设的具体兼容情况可以参见下表：</p><p><img src="/Project/Arduino-ESP32/1.png"></p><blockquote><p><strong>注意</strong>：所有 ESP32 系列芯片都支持 SPI 以太网，其中RMII 只有 ESP32 能够支持。</p></blockquote><p><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/index.html">《<strong>ESP32Arduino 核心文档</strong>》</a> 当中提供了如下这些 API的使用说明，具体内容可以点击下面表格当中的链接逐一查阅：</p><table><colgroup><col style="width: 25%"><col style="width: 24%"><col style="width: 25%"><col style="width: 24%"></colgroup><tbody><tr class="odd"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/adc.html">模数转换（ADC）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ble.html">低功耗蓝牙（BLE）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/bluetooth.html">传统蓝牙（Bluetooth）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/dac.html">数模转换（DAC）</a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/deepsleep.html">深度休眠（DeepSleep）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/espnow.html">短距离无线通信（ESP-NOW）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ethernet.html">以太网（Ethernet）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/gpio.html">通用输入输出（GPIO）</a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/hall_sensor.html">霍尔传感器（HallSensor）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/i2c.html">内部集成电路总线（I²C）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/i2s.html">集成电路内置音频总线（I²S）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/insights.html">远程诊断（ESPInsights）</a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html">LED控制（LEDC，LED Control）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/preferences.html">Preferences</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/pulse_counter.html">脉冲计数器（PulseCounter）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/rainmaker.html">ESPRainmaker</a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/reset_reason.html">复位原因（ResetReason）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/rmt.html">红外收发器（RMT）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sdio.html">SDIO</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sdmmc.html">SDMMC</a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/sigmadelta.html">二阶<span class="math inline">\(\Sigma\Delta\)</span> 信号调制*</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/spi.html">串行外设接口（SPI）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html">定时器（Timer）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/touch.html">触摸TOUCH</a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb.html">通用串行总线（USBAPI）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb_cdc.html">USB通信设备类（USB CDC）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb_msc.html">USB大容量存储类 API（USB MSC）</a></td><td style="text-align: left;"><a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html">无线Wi-Fi</a></td></tr></tbody></table><p>安装完成 <a href="https://www.wch.cn/products/CH343.html"><strong>CH343P</strong></a>的 USB 转串口驱动程序之后，就可以将 <strong>UINIO-MCU-ESP32</strong>核心板连接至电脑，再打开 <strong>Arduino IDE</strong>选择【<strong>ESP32C3 Dev Module</strong>】或者【<strong>ESP32S3 DevModule</strong>】开发板，以及相应的 USB端口，就可以完成全部的开发连接准备：</p><p><img src="/Project/Arduino-ESP32/2.png"></p><p>接下来，编写如下的代码，以 <code>115200</code> 波特率向<strong>Arduino IDE</strong> 的【串口监视器】打印字符串<code>Welcome to UinIO.com</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数只调用一次 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>); <span class="comment">// 设置波特率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该函数会循环执行 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Welcome to UinIO.com&quot;</span>); <span class="comment">// 向串口打印字符串</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>Arduino IDE</strong>的【串口监视器】当中正确打印出了如下结果，就表明当前的开发环境已经搭建成功了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Welcome to UinIO.com</span><br><span class="line">Welcome to UinIO.com</span><br><span class="line">Welcome to UinIO.com</span><br><span class="line">... .. ...</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：笔者设计的 <a href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>和 <a href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>两款开源硬件在本文后续内容当中。都将会被统称为<strong>UINIO-MCU-ESP32</strong>，如果没有进行特殊说明，那么所有示例代码都同时兼容两款核心板。</p></blockquote><h1 id="led-定时闪烁阻塞-非阻塞">LED 定时闪烁（阻塞 &amp; 非阻塞）</h1><p><strong>发光二极管</strong>（<strong>LED</strong>，Light EmittingDiode）在正向导通之后就会发光，对于直插式发光二极管（长脚为<strong>正</strong>，短脚为<strong>负</strong>），其<strong>红色</strong>和<strong>黄色</strong>的正向压降为<code>2.0V ~ 2.2V</code>，而<strong>绿色</strong>、<strong>白色</strong>、<strong>蓝色</strong>产生的正向压降为<code>3.0V ~ 3.2V</code>，额定工作电流介于 <code>5mA ~ 20mA</code>范围之间。接下来以红色发光二极管为例，介绍其限流电阻的计算方法。</p><p>首先，红色 LED 正常工作时产生的压降约为 <code>2.0V</code>，而 ESP32引脚输出的高电平为 <code>3.3V</code>，此时限流电阻上流过的电压等于<code>3.3 - 2.0 = 1.3V</code>，而红色发光二极管的额定电流约为<code>10mA</code>，所以这个<strong>限流电阻</strong>的取值应当为 <span class="math inline">\(\frac{1.3V}{0.01A} =130Ω\)</span>，这里近似的取电阻标称值为<code>120Ω</code>，并且将其连接到 <strong>Arduino-MCU-ESP32</strong> 的<strong>GPIO0</strong> 引脚，具体的电路连接关系如下图所示：</p><p><img src="/Project/Arduino-ESP32/3.png"></p><blockquote><p><strong>注意</strong>：<strong>ESP32</strong>系列芯片<strong>高电平</strong>信号的最低电压值为<code>3.3V × 0.8 = 2.64V</code>，而<strong>低电平</strong>信号的最高电压值为<code>3.3V × 0.1 = 0.33V</code>。</p></blockquote><ul><li><code>pinMode(pin, mode)</code>：配置引脚工作模式，其中<code>mode</code> 参数可选的值有<code>INPU</code>、<code>OUTPUT</code>、<code>INPUT_PULLUP</code>、<code>INPUT_PULLDOWN</code>；</li><li><code>digitalWrite(pin, value)</code>：设置数字输出引脚的电平状态，其中<code>value</code> 参数可选的值是 <code>HIGH</code> 或者<code>LOW</code>；</li><li><code>delay(ms)</code>：延时函数，其参数 <code>ms</code>的单位为<strong>毫秒</strong>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT); <span class="comment">// 配置该引脚为输出状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, LOW);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用 <code>delay()</code>延时函数会阻塞后续任务的执行，所以这里改用如下两个API，通过循环计算时间差值的方式来实现 LED 灯的闪烁：</p><ul><li><code>millis()</code>：程序当前运行的<strong>毫秒</strong>数；</li><li><code>micros()</code>：程序当前运行的<strong>微秒</strong>数；</li></ul><p>下面的示例代码通过 <strong>UINIO-MCU-ESP32</strong> 的<code>GPIO0</code> 引脚控制一个 LED 灯，每间隔 1秒循环不断的进行闪烁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>;            <span class="comment">// LED 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime = <span class="number">0</span>;     <span class="comment">// 前一次 LED 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  LED_Status = HIGH;</span><br><span class="line">  prevTime = <span class="built_in">millis</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime = <span class="built_in">millis</span>(); <span class="comment">// 开始进行测试时刻的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 两次 LED 状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime - prevTime &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status = LED_Status == HIGH ? LOW : HIGH; <span class="comment">// 切换 LED 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, Status);</span><br><span class="line">    LED_Status = Status;</span><br><span class="line">    prevTime = curTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要控制多个 LED的闪烁，则需要将电路连接关系修改为下面的样子，此时控制引脚需要变更为<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO1</code> 和<code>GPIO2</code>：</p><p><img src="/Project/Arduino-ESP32/4.png"></p><p>注意需要同步修改代码当中控制引脚变量 <code>LED_Pin_x</code>的值，其它的功能代码只需要进行相应的复制粘贴即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin_1 = <span class="number">1</span>;            <span class="comment">// 将 LED 1 的控制引脚设置为 GPIO1</span></span><br><span class="line"><span class="type">int</span> LED_Status_1 = <span class="number">0</span>;         <span class="comment">// LED 1 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime_1 = <span class="number">0</span>;  <span class="comment">// 前一次 LED 1 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin_2 = <span class="number">2</span>;            <span class="comment">// 将 LED 2 的控制引脚设置为 GPIO2</span></span><br><span class="line"><span class="type">int</span> LED_Status_2 = <span class="number">0</span>;         <span class="comment">// LED 2 目前的点亮状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prevTime_2 = <span class="number">0</span>;  <span class="comment">// 前一次 LED 2 发光状态改变的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* LED 1 状态设置 */</span></span><br><span class="line">  pinMode(LED_Pin_1, OUTPUT);</span><br><span class="line">  digitalWrite(LED_Pin_1, HIGH);</span><br><span class="line">  LED_Status_1 = HIGH;</span><br><span class="line">  prevTime_1 = millis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 2 状态设置 */</span></span><br><span class="line">  pinMode(LED_Pin_2, OUTPUT);</span><br><span class="line">  digitalWrite(LED_Pin_2, HIGH);</span><br><span class="line">  LED_Status_2 = HIGH;</span><br><span class="line">  prevTime_2 = millis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime_1 = millis();  <span class="comment">// LED 1 开始进行测试时刻的时间</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> curTime_2 = millis();  <span class="comment">// LED 2 开始进行测试时刻的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 1 两次状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime_1 - prevTime_1 &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status_1 = LED_Status_1 == HIGH ? LOW : HIGH;  <span class="comment">// 切换 LED 1 的状态</span></span><br><span class="line"></span><br><span class="line">    digitalWrite(LED_Pin_1, Status_1);</span><br><span class="line">    LED_Status_1 = Status_1;</span><br><span class="line">    prevTime_1 = curTime_1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 2 两次状态变化的间隔时间为 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime_2 - prevTime_2 &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="type">int</span> Status_2 = LED_Status_2 == HIGH ? LOW : HIGH;  <span class="comment">// 切换 LED 2 的状态</span></span><br><span class="line"></span><br><span class="line">    digitalWrite(LED_Pin_2, Status_2);</span><br><span class="line">    LED_Status_2 = Status_2;</span><br><span class="line">    prevTime_2 = curTime_2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按键控制-与-rbd_button-库">按键控制 与 RBD_BUTTON 库</h1><p>本示例需要将 <strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO3</code>和 <code>GPIO4</code> 分别连接至 <strong>LED</strong>和<strong>按键</strong>：</p><p><img src="/Project/Arduino-ESP32/5.png"></p><p>由于按键的控制引脚被配置为<strong>输入上拉</strong><code>INPUT_PULLUP</code>，所以当按键被按下时<strong>低电平</strong>有效，读取引脚的电平状态需要使用到如下的API：</p><ul><li><code>digitalRead(pin)</code>：读取指定输入引脚 <code>pin</code>的电平状态，返回值是 <code>HIGH</code> 或者 <code>LOW</code>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;    <span class="comment">// LED 控制引脚</span></span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>; <span class="comment">// LED 当前状态</span></span><br><span class="line"><span class="type">int</span> Switch_Pin = <span class="number">4</span>; <span class="comment">// 按键控制引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(Switch_Pin, INPUT_PULLUP); <span class="comment">// 配置按键控制引脚为输入上拉</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);</span><br><span class="line">  LED_Status = HIGH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> Switch_Status = <span class="built_in">digitalRead</span>(Switch_Pin); <span class="comment">// 读取按键引脚的状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当按键被接下时执行的代码 */</span></span><br><span class="line">  <span class="keyword">if</span>(Switch_Status == LOW) &#123;</span><br><span class="line">    LED_Status = !LED_Status;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码的运行结果，可以发现按键对于 LED亮灭状态的控制并不准确，这是由于按键在按下时，触点的接触不够稳定所导致。在这里我们可以方便的借助<a href="https://github.com/alextaujenis/RBD_Button"><strong>RBD_BUTTON</strong></a>这款第三方库来消除这种抖动。接下来在 <strong>Arduino IDE</strong>当中安装 <strong>RBD_Button</strong> 以及关联的<strong>RBD_Timer</strong> 依赖库，由于该库所提供的<code>Button</code>类位于 <strong>C++</strong> 的<code>RBD</code>命名空间当中，所以其构造函数的调用形式应当书写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RBD::Button <span class="title">constructor</span><span class="params">(pin,[input, input_pullup, input_pulldown])</span></span></span><br></pre></td></tr></table></figure><p><code>Button</code>类当中提供了如下一系列可以用于消除按键抖动的方法：</p><ul><li><code>button.isPressed()</code>：当按键被按下或开启时返回<code>true</code>，否则返回 <code>false</code>；</li><li><code>button.isReleased()</code>：当按键弹起或者释放时返回<code>true</code>，否则返回 <code>false</code>；</li><li><code>button.onPressed()</code>：当按钮被按下（已经去除抖动）一次以后返回<code>true</code>，接下来必须释放按钮，并且再次按下才能够返回<code>true</code>；</li><li><code>button.onReleased()</code>：当按钮被释放（已经去除抖动）一次以后返回<code>true</code>，接下来必须按下按钮，并且再次释放才能够返回<code>true</code>；</li><li><code>button.setDebounceTimeout(value)</code>：设置消除抖动的时间，参数的单位为毫秒；</li></ul><p>修改前面的示例代码，加入按键消抖的处理逻辑，可以看到在消除抖动错误的同时，代码的书写也得到了极大简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Button.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;    <span class="comment">// LED 控制引脚</span></span><br><span class="line"><span class="type">int</span> LED_Status = <span class="number">0</span>; <span class="comment">// LED 当前状态</span></span><br><span class="line"><span class="type">int</span> Switch_Pin = <span class="number">4</span>; <span class="comment">// 按键控制引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function">RBD::Button <span class="title">button</span><span class="params">(Switch_Pin, INPUT_PULLUP)</span></span>; <span class="comment">// 创建 button 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  button.<span class="built_in">setDebounceTimeout</span>(<span class="number">20</span>); <span class="comment">// 设置按键消抖延迟时间为 20 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 当按键被按下时候的处理逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span>(button.<span class="built_in">onPressed</span>()) &#123;</span><br><span class="line">    LED_Status = !LED_Status;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于-pwm-的-ledc">基于 PWM 的 LEDC</h1><p><strong>LED 发光二极管</strong>的正常工作电压介于<code>1.8V ~ 2.0V</code>之间，由于该电压变化区间的取值范围较小，难以通过电压大小来控制 LED的亮度。而<strong>脉冲宽度调制</strong>（<strong>PWM</strong>，PulseWidthModulation）则另辟蹊径，通过改变输出方波的<strong>占空比</strong>来控制LED 的亮灭频率，从而达到调整亮度的目的。</p><p><img src="/Project/Arduino-ESP32/6.png"></p><p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 各拥有<code>6</code> 和 <code>8</code> 个 <strong>LEDC</strong>通道，分别用于产生独立的 PWM 波形信号，最大精度为 <strong>14</strong>位。<strong>Arduino-ESP32</strong> 提供了专门的 <a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ledc.html"><strong>LED控制 API</strong></a>（LEDC，LED Control），可以方便的以 PWM 方式来控制LED 的亮度，具体的 API 方法可以参考下面的列表：</p><table><colgroup><col style="width: 43%"><col style="width: 56%"></colgroup><thead><tr class="header"><th style="text-align: left;">API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>uint32_t ledcSetup(uint8_t channel, uint32_t freq, uint8_t resolution_bits);</code></td><td style="text-align: left;">用于设置 LEDC通道的<strong>频率</strong>和<strong>分辨率</strong>；</td></tr><tr class="even"><td style="text-align: left;"><code>void ledcWrite(uint8_t chan, uint32_t duty);</code></td><td style="text-align: left;"><strong>设置</strong>指定 LEDC通道的<strong>占空比</strong>；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint32_t ledcRead(uint8_t chan);</code></td><td style="text-align: left;"><strong>获取</strong>指定 LEDC通道的<strong>占空比</strong>；</td></tr><tr class="even"><td style="text-align: left;"><code>uint32_t ledcReadFreq(uint8_t chan);</code></td><td style="text-align: left;"><strong>获取</strong>指定 LEDC通道的<strong>频率</strong>；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint32_t ledcWriteTone(uint8_t chan, uint32_t freq);</code></td><td style="text-align: left;">用于在指定频率上将 LEDC 通道设置为<code>50%</code> 占空比的 PWM <strong>音调</strong>；</td></tr><tr class="even"><td style="text-align: left;"><code>uint32_t ledcWriteNote(uint8_t chan, note_t note, uint8_t octave);</code></td><td style="text-align: left;">用于将 LEDC通道设置为指定的<strong>音符</strong>；</td></tr><tr class="odd"><td style="text-align: left;"><code>void ledcAttachPin(uint8_t pin, uint8_t chan);</code></td><td style="text-align: left;">用于将指定的 <strong>GPIO引脚</strong>绑定至 <strong>LEDC 通道</strong>;</td></tr><tr class="even"><td style="text-align: left;"><code>void ledcDetachPin(uint8_t pin);</code></td><td style="text-align: left;">用于取消指定的 <strong>GPIO引脚</strong>与 <strong>LEDC 通道</strong>的绑定;</td></tr><tr class="odd"><td style="text-align: left;"><code>uint32_t ledcChangeFrequency(uint8_t chan, uint32_t freq, uint8_t bit_num);</code></td><td style="text-align: left;">用于动态改变 LEDC通道的<strong>频率</strong>；</td></tr><tr class="even"><td style="text-align: left;"><code>void analogWrite(uint8_t pin, int value);</code></td><td style="text-align: left;">用于在指定 GPIO引脚上写入<strong>模拟值</strong>(PWM 波形信号)，该接口兼容 Arduino官方的 <code>analogWrite()</code> 函数；</td></tr><tr class="odd"><td style="text-align: left;"><code>void analogWriteResolution(uint8_t bits);</code></td><td style="text-align: left;">用于设置所有 <code>analogWrite()</code>通道的<strong>分辨率</strong>；</td></tr><tr class="even"><td style="text-align: left;"><code>void analogWriteFrequency(uint32_t freq);</code></td><td style="text-align: left;">用于设置所有 <code>analogWrite()</code>通道的<strong>频率</strong>；</td></tr></tbody></table><p>下面的示例代码将 <strong>LEDC</strong> 配置为 <code>0</code>通道，工作频率为 <code>5000</code> 赫兹，精度为 <code>12</code>位（即将一个<strong>周期</strong>划分为 <span class="math inline">\(2^{12}\)</span> 等分）。如果需要将其占空比调整为<code>50%</code>，那么高电平就需要占据 <span class="math inline">\(2^{12} \div 2 = 2^{12 - 1} = 2^{11}\)</span>等分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> GPIO = <span class="number">4</span>;                                 <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line">  <span class="type">int</span> Channel = <span class="number">0</span>;                              <span class="comment">// 指定 LEDC 通道 0</span></span><br><span class="line">  <span class="type">int</span> Frequency = <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>); <span class="comment">// 配置 LEDC 为 0 通道、频率为 5000 赫兹、精度为 12 位</span></span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Frequency == <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;LEDC 配置失败&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;LEDC 配置成功&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO, Channel);   <span class="comment">// 绑定 GPIO4 引脚与通道 0</span></span><br><span class="line">  <span class="built_in">ledcWrite</span>(Channel, <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">11</span>)); <span class="comment">// 将通道 0 的占空比调整为 50%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来再利用 LEDC 和 PWM实现一个呼吸灯效果，具体策略为每秒钟调整占空比 <code>50</code> 次，假设<code>T</code> 为呼吸周期，那么 LED 从熄灭到最高亮度需要经过的时间为<span class="math inline">\(\frac{T}{2}\)</span>（即半个呼吸周期）。这样每半个周期就需要进行<span class="math inline">\(50 \times \frac{T}{2}\)</span>次占空比调整，而 <code>count</code> 表示占空比为 <code>100%</code>时候的等分数量，<code>step</code> 就是每次占空比调整所需要增加的步进值<span class="math inline">\(step = \frac{count}{50 \times \frac{T}{2}} =2 \times \frac{count}{50 \times T}\)</span>，当占空比超过<code>Count</code> 时，就需要逐步将 <code>Step</code> 步进值递减至<code>0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GPIO4 = <span class="number">4</span>;    <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line"><span class="type">int</span> Channel = <span class="number">1</span>;  <span class="comment">// 指定 LEDC 通道 1</span></span><br><span class="line"><span class="type">int</span> Duty = <span class="number">0</span>;     <span class="comment">// 当前信号的占空比</span></span><br><span class="line"><span class="type">int</span> Count = <span class="number">0</span>;    <span class="comment">// 占空比为 100% 时的等分数量</span></span><br><span class="line"><span class="type">int</span> Step = <span class="number">0</span>;     <span class="comment">// 占空比的步进值</span></span><br><span class="line"><span class="type">int</span> Breath = <span class="number">3</span>;   <span class="comment">// 每次呼吸的时间长度，单位为秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>);      <span class="comment">// 配置 LEDC 为 1 通道、频率为 1000 赫兹、精度为 12 位</span></span><br><span class="line">  Count = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">12</span>);                <span class="comment">// 获取占空比为 100% 时候的等分数量</span></span><br><span class="line">  Step = <span class="number">2</span> * Count / (<span class="number">50</span> * Breath);  <span class="comment">// 每次占空比调整所需要增加的步进值</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO4, Channel);     <span class="comment">// 绑定 GPIO4 引脚与通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcWrite</span>(Channel, Duty);          <span class="comment">// 每次循环都改变一次 PWM 信号的占空比</span></span><br><span class="line">  Duty += Step;                      <span class="comment">// 步进值递增</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当占空比高于 100% 等分数量的时候 */</span></span><br><span class="line">  <span class="keyword">if</span> (Duty &gt; Count) &#123;</span><br><span class="line">    Duty = Count;                    <span class="comment">// 将占空比 Duty 限制为 100% 等分数量</span></span><br><span class="line">    Step = -Step;                    <span class="comment">// 修改步进值为负数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 当占空比小于 0 等分数量的时候 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Duty &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Duty = <span class="number">0</span>;                        <span class="comment">// 将占空比设置为 0</span></span><br><span class="line">    Step = -Step;                    <span class="comment">// 修改步进值为负数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">30</span>);                         <span class="comment">// 等待 30 毫秒再进行下一次的占空比调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码当中的 <code>delay()</code> 函数会阻塞<strong>UINIO-MCU-ESP32</strong> 的后续代码运行，下面通过<code>prevTime</code> 和 <code>curTime</code>两个变量来循环计算时间差值，实现一个非阻塞式的呼吸灯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GPIO4 = <span class="number">4</span>;     <span class="comment">// 指定 GPIO 引脚 4</span></span><br><span class="line"><span class="type">int</span> Channel = <span class="number">1</span>;   <span class="comment">// 指定 LEDC 通道 1</span></span><br><span class="line"><span class="type">int</span> Duty = <span class="number">0</span>;      <span class="comment">// 当前信号的占空比</span></span><br><span class="line"><span class="type">int</span> Count = <span class="number">0</span>;     <span class="comment">// 占空比为 100% 时的等分数量</span></span><br><span class="line"><span class="type">int</span> Step = <span class="number">0</span>;      <span class="comment">// 占空比的步进值</span></span><br><span class="line"><span class="type">int</span> Breath = <span class="number">3</span>;    <span class="comment">// 每次呼吸的时间长度，单位为秒</span></span><br><span class="line"><span class="type">int</span> prevTime = <span class="number">0</span>;  <span class="comment">// 记录前一次调整占空比的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ledcSetup</span>(Channel, <span class="number">5000</span>, <span class="number">12</span>);      <span class="comment">// 配置 LEDC 为 1 通道、频率为 1000 赫兹、精度为 12 位</span></span><br><span class="line">  Count = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">12</span>);                <span class="comment">// 获取占空比为 100% 时候的等分数量</span></span><br><span class="line">  Step = <span class="number">2</span> * Count / (<span class="number">50</span> * Breath);  <span class="comment">// 每次占空比调整所需要增加的步进值</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(GPIO4, Channel);     <span class="comment">// 绑定 GPIO4 引脚与通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> curTime = <span class="built_in">millis</span>();            <span class="comment">// 记录执行到此处的当前时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断距离上一次占空比调整是否超过 30 毫秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (curTime - prevTime &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">ledcWrite</span>(Channel, Duty);        <span class="comment">// 每次循环都改变一次 PWM 信号的占空比</span></span><br><span class="line">    Duty += Step;                    <span class="comment">// 步进值递增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当占空比高于 100% 等分数量的时候 */</span></span><br><span class="line">    <span class="keyword">if</span> (Duty &gt; Count) &#123;</span><br><span class="line">      Duty = Count;                   <span class="comment">// 将占空比 Duty 限制为 100% 等分数量</span></span><br><span class="line">      Step = -Step;                   <span class="comment">// 修改步进值为负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当占空比小于 0 等分数量的时候 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Duty &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      Duty = <span class="number">0</span>;                      <span class="comment">// 将占空比设置为 0</span></span><br><span class="line">      Step = -Step;                  <span class="comment">// 修改步进值为负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    prevTime = curTime;              <span class="comment">// 更新时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="软件定时器-与-asynctimer-库">软件定时器 与 AsyncTimer 库</h1><p><strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 分别拥有<code>2</code> 个和 <code>4</code>个<strong>硬件定时器</strong>，虽然它们的精度较高，但是数量着实有限。在一些对于精度要求不高的场合，可以考虑使用诸如<a href="https://github.com/Aasim-A/AsyncTimer"><strong>AsyncTimer</strong></a>这样的第三方库来作为<strong>软件定时器</strong>使用，它适用于一些对于精度要求不高的场合（精度为毫秒级别），具体的使用步骤如下面所示：</p><ol type="1"><li>首先，在 <strong>Arduino IDE</strong>的【<strong>库管理器</strong>】当中安装 <code>AsyncTimer</code>库；</li><li>然后，在工程代码当中包含头文件<code>#include &lt;AsyncTimer.h&gt;</code>；</li><li>接下来，声明定时器变量 <code>AsyncTimer timer</code>；</li><li>最后，在 <code>void loop()</code> 函数当中调用<code>t.handle()</code>；</li></ol><p>下面的示例代码，会通过 <strong>AsyncTimer</strong> 提供的<code>setTimeout()</code> 函数，分别延时 <code>3</code> 秒和<code>5</code> 秒向串口打印提示信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以普通函数方式使用 setTimeout() */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 normal 函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id1 = timer.<span class="built_in">setTimeout</span>(task, <span class="number">3000</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Timeout ID 1：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以 Lambda 函数方式使用 setTimeout() */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id2 = timer.<span class="built_in">setTimeout</span>([]()&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 lambda 函数&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Timeout ID 2：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timeout ID 1：62510</span></span><br><span class="line"><span class="comment">   Timeout ID 2：36048</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数 */</span></span><br></pre></td></tr></table></figure><p>同样的，可以通过类似的方式调用 <strong>AsyncTimer</strong> 的<code>setInterval()</code>函数，周期性的不断重复向串口打印提示信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以普通函数方式使用 setInterval() */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 normal 函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id1 = timer.<span class="built_in">setInterval</span>(task, <span class="number">500</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Interval ID 1：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以 Lambda 函数方式使用 setInterval() */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> id2 = timer.<span class="built_in">setInterval</span>([]()&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;调用 lambda 函数&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">800</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Interval ID 2：&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(id2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interval ID 1：62510</span></span><br><span class="line"><span class="comment">   Interval ID 2：36048</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   调用 lambda 函数</span></span><br><span class="line"><span class="comment">   调用 normal 函数</span></span><br><span class="line"><span class="comment">   ... ... ... ... */</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：注意每次调用 <code>setTimeout()</code> 和<code>setInterval()</code> 之后返回的 ID 值都并不相同。</p></blockquote><p>接下来，结合前面介绍的 <strong>RBD_Button</strong> 和<strong>AsyncTimer</strong> 两个第三方库，让一个 LED在刚开始启动的时候，每间隔 1秒钟进行闪烁，而在按下按键之后，再切换至间隔 3秒进行闪烁，再次按下按键则切换回间隔 1秒进行闪烁，这里依然沿用之前的按键与 LED 实验电路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;RBD_Button.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">3</span>;       <span class="comment">// LED GPIO</span></span><br><span class="line"><span class="type">int</span> switch_Pin = <span class="number">4</span>;    <span class="comment">// 按键 GPIO</span></span><br><span class="line"><span class="type">int</span> LED_Status = HIGH; <span class="comment">// 设定 LED 初始状态为点亮</span></span><br><span class="line"><span class="type">int</span> blink = <span class="number">1</span>;         <span class="comment">// 设定 LED 闪烁的间隔时间</span></span><br><span class="line"><span class="type">int</span> taskID = <span class="number">0</span>;        <span class="comment">// 定时任务 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义带有消抖功能的按键，低电平有效 */</span></span><br><span class="line"><span class="function">RBD::Button <span class="title">button</span><span class="params">(switch_Pin, INPUT_PULLUP)</span></span>;</span><br><span class="line">AsyncTimer timer;      <span class="comment">// 声明定时器变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换 LED 状态的定时器任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_LED_Status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LED_Status = !LED_Status;  <span class="comment">// 切换 LED 的亮灭状态</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, LED_Status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);                                    <span class="comment">// 设置 LED 引脚为输出模式</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);                                 <span class="comment">// 执行 LED 的点亮操作</span></span><br><span class="line">  button.<span class="built_in">setDebounceTimeout</span>(<span class="number">20</span>);                               <span class="comment">// 设置按键消抖延时为 20 毫秒</span></span><br><span class="line">  taskID = timer.<span class="built_in">setInterval</span>(change_LED_Status, blink * <span class="number">1000</span>); <span class="comment">// 创建周期性重复执行的定时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>(); <span class="comment">// 启用 AsyncTimer 定时器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断按键状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (button.<span class="built_in">onPressed</span>()) &#123;</span><br><span class="line">    blink = blink == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">1</span>;              <span class="comment">// 如果当前 LED 闪烁间隔为 1 秒，那么就将其修改为 3 秒，反之亦然</span></span><br><span class="line">    timer.<span class="built_in">changeDelay</span>(taskID, blink * <span class="number">1000</span>); <span class="comment">// 执行定时器 LED 闪烁间隔时间的修改操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="adc-模数转换">ADC 模数转换</h1><p><strong>模数转换器</strong>（ADC，Analog to DigitalConverter）是一种常见外设，用于将模拟信号转换为便于 ESP32微控制器，读取与处理的数字信号。</p><ul><li><strong>ESP32-C3</strong> 集成有两个 <strong>12</strong>位的<strong>逐次逼近寄存器型</strong>（<strong>SAR</strong>, SuccessiveApproximation Register）ADC，一共支持 <strong>6</strong>个模拟通道输入，其中 <strong>ADC1</strong> 支持 <strong>5</strong>个模拟通道输入（已工厂校准），而<strong>ADC2</strong> 支持<strong>1</strong> 个模拟通道输入（未工厂校准）；</li><li><strong>ESP32-S3</strong> 同样集成有两个 <strong>12</strong>位<strong>逐次逼近寄存器型</strong> ADC，一共拥有 <strong>20</strong>个模拟输入通道，乐鑫官方推荐优先使用 <strong>ADC1</strong>；</li></ul><p><strong>Arduino-ESP32</strong> 当中针对 ADC外设，提供了如下一系列通用的 API 函数：</p><table><colgroup><col style="width: 36%"><col style="width: 63%"></colgroup><thead><tr class="header"><th style="text-align: left;">Arduino 通用的 ADC API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>uint16_t analogRead(uint8_t pin);</code></td><td style="text-align: left;">获取指定引脚或者 ADC 通道的原始值。</td></tr><tr class="even"><td style="text-align: left;"><code>uint32_t analogReadMilliVolts(uint8_t pin);</code></td><td style="text-align: left;">获取指定引脚或者 ADC通道的原始值（以毫伏为单位）。</td></tr><tr class="odd"><td style="text-align: left;"><code>void analogReadResolution(uint8_t bits);</code></td><td style="text-align: left;">设置 <code>analogRead()</code>返回值的分辨率，<strong>ESP32S3</strong> 默认为 <strong>13</strong>位（从 <code>0</code> 到 <code>8191</code>），其它型号默认为<strong>12</strong> 位（从 <code>0</code> 到 <code>4095</code>）。</td></tr><tr class="even"><td style="text-align: left;"><code>void analogSetClockDiv(uint8_t clockDiv);</code></td><td style="text-align: left;">设置 ADC 时钟的分频器，范围为<code>0 ~ 255</code>，默认值为 <code>1</code>。</td></tr><tr class="odd"><td style="text-align: left;"><code>void analogSetAttenuation(adc_attenuation_t attenuation);</code></td><td style="text-align: left;">设置全部通道的衰减系数，共拥有<code>ADC_ATTEN_DB_0</code>、<code>ADC_ATTEN_DB_2_5</code>、<code>ADC_ATTEN_DB_6</code>、<code>ADC_ATTEN_DB_11</code>四个选项。</td></tr><tr class="even"><td style="text-align: left;"><code>void analogSetPinAttenuation(uint8_t pin, adc_attenuation_t attenuation);</code></td><td style="text-align: left;">设置指定引脚或者 ADC 通道的衰减系数。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool adcAttachPin(uint8_t pin);</code></td><td style="text-align: left;">将 GPIO 引脚关联至 ADC，关联成功返回<code>true</code>，否则返回 <code>false</code>。</td></tr></tbody></table><table><colgroup><col style="width: 25%"><col style="width: 37%"><col style="width: 37%"></colgroup><thead><tr class="header"><th style="text-align: center;">ADC 衰减系数</th><th style="text-align: center;">ESP32-C3 可测量输入电压范围</th><th style="text-align: center;">ESP32-S3 可测量输入电压范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>ADC_ATTEN_DB_0</code></td><td style="text-align: center;">0 mV ~ 750 mV</td><td style="text-align: center;">0 mV ~ 950 mV</td></tr><tr class="even"><td style="text-align: center;"><code>ADC_ATTEN_DB_2_5</code></td><td style="text-align: center;">0 mV ~ 1050 mV</td><td style="text-align: center;">0 mV ~ 1250 mV</td></tr><tr class="odd"><td style="text-align: center;"><code>ADC_ATTEN_DB_6</code></td><td style="text-align: center;">0 mV ~ 1300 mV</td><td style="text-align: center;">0 mV ~ 1750 mV</td></tr><tr class="even"><td style="text-align: center;"><code>ADC_ATTEN_DB_11</code></td><td style="text-align: center;">0 mV ~ 2500 mV</td><td style="text-align: center;">0 mV ~ 3100 mV</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>ESP32S3</strong> 的最高采样分辨率为<strong>13</strong> 位，由于计数范围从 <code>0</code>开始进行计数，所以其最大计数值为 <span class="math inline">\(2^{13} - 1= 8191\)</span>，同理 <strong>ESP32C3</strong> 的最大计数值等于 <span class="math inline">\(2^{12} - 1 = 4095\)</span>。</p></blockquote><table><colgroup><col style="width: 37%"><col style="width: 62%"></colgroup><thead><tr class="header"><th style="text-align: left;">ESP32 专用的 ADC API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void analogSetWidth(uint8_t bits);</code></td><td style="text-align: left;">设置硬件采样分辨率，取值范围为<code>9 ~ 12</code>，默认值是 <code>12</code>；</td></tr><tr class="even"><td style="text-align: left;"><code>void analogSetVRefPin(uint8_t pin);</code></td><td style="text-align: left;">设置需要进行 ADC 校准的引脚。</td></tr><tr class="odd"><td style="text-align: left;"><code>int hallRead();</code></td><td style="text-align: left;">读取连接至 <code>36</code>（SVP）和<code>39</code>（SVN）引脚的霍尔传感器 ADC 值。</td></tr></tbody></table><p>接下来通过 ADC 完成一个实验，使用<strong>电位器</strong>调整<strong>UINIO-MCU-ESP32</strong> 的 ADC引脚所读取到的输入电压，然后根据这个输入电压的大小，调节 GPIO引脚输出信号的占空比，从而达到调整 LED亮度的目的，<strong>UINIO-MCU-ESP32</strong>的电路连接关系如下图所示：</p><p><img src="/Project/Arduino-ESP32/7.png"></p><p>可以看到，这里把 <strong>UINIO-MCU-ESP32</strong> 的<code>GPIO2</code> 引脚连接至电位器，而 <code>GPIO1</code> 作为 LED发光二极管的控制引脚，接着编写并且上传如下的控制逻辑代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> taskId = <span class="number">0</span>;          <span class="comment">// 定时任务 ID</span></span><br><span class="line">AsyncTimer timer;        <span class="comment">// 通过定时器，关联 LED 与 电位器</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin  = <span class="number">1</span>;        <span class="comment">// LED 连接的 GPIO</span></span><br><span class="line"><span class="type">int</span> LED_Channel = <span class="number">0</span>;     <span class="comment">// 指定输出 PWM 信号的 LEDC 通道</span></span><br><span class="line"><span class="type">int</span> Potential_Pin = <span class="number">2</span>;   <span class="comment">// 电位器连接的 GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 亮度调整函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeBrightness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> value = <span class="built_in">analogRead</span>(Potential_Pin);               <span class="comment">// 读取电位器所连接 GPIO 引脚的原始值</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> voltage = <span class="built_in">analogReadMilliVolts</span>(Potential_Pin);  <span class="comment">// 读取电位器所连接 GPIO 引脚的电压值</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(voltage);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> duty = value / <span class="number">4095.0</span> * <span class="number">1024</span>; <span class="comment">// 计算占空比，此处的常量 4095.0 必须为浮点类型（电位器为最小值 0 时，占空比也为 0，LED 熄灭；当电位器为最大值 4095 时，占空比为 1024，LED 最亮）</span></span><br><span class="line">  <span class="built_in">ledcWrite</span>(LED_Channel, duty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="built_in">analogReadResolution</span>(<span class="number">12</span>);              <span class="comment">// 设置 ADC 读取分辨率为 12 位，即读取到的最大值为 4096</span></span><br><span class="line">  <span class="built_in">analogSetAttenuation</span>(ADC_11db);        <span class="comment">// 设置 ADC 的衰减值为 11 分贝</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ledcSetup</span>(LED_Channel, <span class="number">1000</span>, <span class="number">10</span>);      <span class="comment">// 设置 LEDC 通道的频率为 1000Hz，分辨率精度为 10</span></span><br><span class="line">  <span class="built_in">ledcAttachPin</span>(LED_Pin, LED_Channel);   <span class="comment">// 关联 LEDC 通道与 LED 控制引脚</span></span><br><span class="line"></span><br><span class="line">  taskId = timer.<span class="built_in">setInterval</span>(changeBrightness, <span class="number">20</span>);  <span class="comment">// 每间隔 20 毫秒改变一次 LED 亮度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="i²c-总线主从通信">I²C 总线主从通信</h1><p><strong>内部集成电路总线</strong>（I²C，Inter-IntegratedCircuit）是一种<strong>低速串行通信协议</strong>（标准模式<code>100 Kbit/s</code>，快速模式 <code>400 Kbit/s</code>），采用<code>SDA</code>（串行数据线）和<code>SCL</code>（串行时钟线）两线制结构（需要使用<strong>上拉电阻</strong>），分别可以连接多个设备，每个设备都拥有唯一的<strong>7</strong> 位地址（最多 <strong>128</strong>个设备）。<strong>Arduino-ESP32</strong> 的 I²C 库实现了 <a href="https://www.arduino.cc/reference/en/language/functions/communication/wire/">ArduinoWire</a> 官方库当中的如下一系列 API 函数：</p><table><colgroup><col style="width: 35%"><col style="width: 64%"></colgroup><thead><tr class="header"><th style="text-align: left;">I²C 通用 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool begin();</code></td><td style="text-align: left;">基于默认参数配置 I²C外设，正确初始化之后返回 <code>true</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>bool setPins(int sdaPin, int sclPin);</code></td><td style="text-align: left;">用于定义 <code>SDA</code> 和<code>SCL</code> 引脚，两个参数的默认值分别为 <code>GPIO21</code> 和<code>GPIO22</code>。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool setClock(uint32_t frequency);</code></td><td style="text-align: left;"><strong>设置</strong> I²C总线的<strong>时钟频率</strong>，默认为 <code>100KHz</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>uint32_t getClock();</code></td><td style="text-align: left;"><strong>获取</strong> I²C总线的<strong>时钟频率</strong>。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setTimeOut(uint16_t timeOutMillis);</code></td><td style="text-align: left;"><strong>设置</strong> I²C总线<strong>超时时间</strong>（毫秒）。</td></tr><tr class="even"><td style="text-align: left;"><code>void setTimeOut(uint16_t timeOutMillis);</code></td><td style="text-align: left;"><strong>获取</strong> I²C总线<strong>超时时间</strong>（毫秒）。</td></tr><tr class="odd"><td style="text-align: left;"><code>size_t write(const uint8_t *, size_t);</code></td><td style="text-align: left;">将数据写入到总线缓冲区，返回值为写入数据的大小。</td></tr><tr class="even"><td style="text-align: left;"><code>bool end();</code></td><td style="text-align: left;">完成 I²C通信并且释放之前所有被分配的外设资源。</td></tr></tbody></table><p><strong>Arduino-ESP32</strong> 当中的 I²C总线可以分别运行于<strong>主设备</strong>（I²C MasterMode）和<strong>从设备</strong>（I²C SlaveMode）两种不同的工作模式：</p><p><strong>I²C主设备模式</strong>：该模式用于向<strong>从设备</strong>发起通信，由<strong>主设备</strong>发出时钟信号，并且负责发起与<strong>从设备</strong>的通信。</p><p><img src="/Project/Arduino-ESP32/8.png"></p><p><strong>I²C从设备模式</strong>：时钟信号依然由<strong>主设备</strong>产生，如果 I²C地址与<strong>从设备</strong>匹配，那么这个<strong>从设备</strong>就会响应<strong>主设备</strong>。</p><p><img src="/Project/Arduino-ESP32/9.png"></p><h2 id="i²c-主设备模式">I²C 主设备模式</h2><p>下面的表格展示了 I²C总线工作在<strong>主设备模式</strong>下时所使用到的 API：</p><table><colgroup><col style="width: 40%"><col style="width: 59%"></colgroup><thead><tr class="header"><th style="text-align: left;">I²C 主设备模式 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool begin(int sdaPin, int sclPin, uint32_t frequency)</code></td><td style="text-align: left;">指定 I²C 总线的 <code>SDA</code> 和<code>SCL</code> 引脚，以及通信频率。</td></tr><tr class="even"><td style="text-align: left;"><code>void beginTransmission(uint16_t address)</code></td><td style="text-align: left;">开始启动与指定 I²C地址<strong>从设备</strong>的通信。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint8_t endTransmission(bool sendStop);</code></td><td style="text-align: left;">将数据写入至缓冲区以后，使用该函数把数据发送给<strong>从设备</strong>，参数<code>sendStop</code> 用于使能 I²C 总线停止信号。</td></tr><tr class="even"><td style="text-align: left;"><code>uint8_t requestFrom(uint16_t address, uint8_t size, bool sendStop)</code></td><td style="text-align: left;">要求<strong>从设备</strong>向<strong>主设备</strong>发送响应数据。</td></tr></tbody></table><p>上述 API 函数的基本使用步骤如下面的列表所示：</p><ol type="1"><li><code>#include "Wire.h"</code>，包含 <code>Wire.h</code>头文件；</li><li><code>Wire.begin()</code>，开始配置 I²C 总线；</li><li><code>Wire.beginTransmission(I2C_DEV_ADDR)</code>，指定 I²C<strong>从设备</strong>地址，开始进行数据传输；</li><li><code>Wire.write(x)</code>，把数据写入到缓冲区；</li><li><code>Wire.endTransmission(true)</code>，将缓冲区的全部数据写入至<strong>从设备</strong>；</li><li><code>Wire.requestFrom(I2C_DEV_ADDR, SIZE)</code>，请求读取指定<strong>从设备</strong>的数据；</li><li><code>Wire.readBytes(temp, error)</code>，开始读取<strong>从设备</strong>响应的数据；</li></ol><p>下面是一个如何在<strong>主设备模式</strong>下使用 I²C总线的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Address 0x55</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">begin</span>();</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Serial.<span class="built_in">setDebugOutput</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 向从设备写入数据 */</span></span><br><span class="line">  Wire.<span class="built_in">beginTransmission</span>(I2C_Address);</span><br><span class="line">  Wire.<span class="built_in">printf</span>(<span class="string">&quot;Hello UinIO.com! %u&quot;</span>, i++); <span class="comment">// 通过 I²C 总线发送数据</span></span><br><span class="line">  <span class="type">uint8_t</span> error = Wire.<span class="built_in">endTransmission</span>(<span class="literal">true</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;endTransmission: %u\n&quot;</span>, error);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取从设备 16 字节的响应数据 */</span></span><br><span class="line">  <span class="type">uint8_t</span> bytesReceived = Wire.<span class="built_in">requestFrom</span>(I2C_Address, <span class="number">16</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;requestFrom: %u\n&quot;</span>, bytesReceived);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果接收到的字节数据大于 0 */</span></span><br><span class="line">  <span class="keyword">if</span>((<span class="type">bool</span>)bytesReceived)&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp[bytesReceived];</span><br><span class="line">    Wire.<span class="built_in">readBytes</span>(temp, bytesReceived);</span><br><span class="line">    <span class="built_in">log_print_buf</span>(temp, bytesReceived);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i²c-从设备模式">I²C 从设备模式</h2><p>下面的表格展示了 I²C总线工作在<strong>从设备模式</strong>下时所使用到的 API：</p><table><colgroup><col style="width: 51%"><col style="width: 48%"></colgroup><thead><tr class="header"><th style="text-align: left;">I²C 从设备模式 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool Wire.begin(uint8_t addr, int sdaPin, int sclPin, uint32_t frequency)</code></td><td style="text-align: left;">在<strong>从设备</strong>模式下，必须通过传递<strong>从设备</strong>的地址来调用<code>begin()</code> 函数。</td></tr><tr class="even"><td style="text-align: left;"><code>void onReceive( void (*)(int) )</code></td><td style="text-align: left;">定义<strong>从设备</strong>接收<strong>主设备</strong>数据的回调函数。</td></tr><tr class="odd"><td style="text-align: left;"><code>void onRequest( void (*)(void) )</code></td><td style="text-align: left;">定义<strong>从设备</strong>请求<strong>主设备</strong>数据的回调函数。</td></tr><tr class="even"><td style="text-align: left;"><code>size_t slaveWrite(const uint8_t *, size_t)</code></td><td style="text-align: left;">接收到响应数据之前，该函数用于向<strong>从设备</strong>的缓冲区写入数据。</td></tr></tbody></table><p>上述 API 函数的基本使用步骤如下面的列表所示：</p><ol type="1"><li><code>#include "Wire.h"</code>，包含 <code>Wire.h</code>头文件；</li><li><code>Wire.onReceive(onReceive)</code> 和<code>Wire.onRequest(onRequest)</code>，创建两个回调函数来<strong>接收</strong>或者<strong>请求</strong>主设备的数据；</li><li><code>Wire.begin((uint8_t)I2C_DEV_ADDR);</code>，使用指定的地址配置I²C 总线；</li><li><code>Wire.slaveWrite((uint8_t *)message, strlen(message));</code>，预先向<strong>从设备</strong>的缓冲区写入数据；</li></ol><p>下面是一个如何在<strong>从设备工模式</strong>下使用 I²C总线的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DEV_ADDR 0x55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Wire.<span class="built_in">print</span>(i++);</span><br><span class="line">  Wire.<span class="built_in">print</span>(<span class="string">&quot; Packets.&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;onRequest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onReceive</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;onReceive[%d]: &quot;</span>, len);</span><br><span class="line">  <span class="comment">/* 判断是否存在可用的数据 */</span></span><br><span class="line">  <span class="keyword">while</span>(Wire.<span class="built_in">available</span>())&#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(Wire.<span class="built_in">read</span>()); <span class="comment">// 读取并且打印 I²C 总线数据到串口</span></span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Serial.<span class="built_in">setDebugOutput</span>(<span class="literal">true</span>);</span><br><span class="line">  Wire.<span class="built_in">onReceive</span>(onReceive);</span><br><span class="line">  Wire.<span class="built_in">onRequest</span>(onRequest);</span><br><span class="line">  Wire.<span class="built_in">begin</span>((<span class="type">uint8_t</span>)I2C_DEV_ADDR); <span class="comment">// 将从设备注册到 I²C 总线</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IDF_TARGET_ESP32</span></span><br><span class="line">  <span class="type">char</span> message[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(message, <span class="number">64</span>, <span class="string">&quot;%u Packets.&quot;</span>, i++);</span><br><span class="line">  Wire.<span class="built_in">slaveWrite</span>((<span class="type">uint8_t</span> *)message, <span class="built_in">strlen</span>(message));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="主从设备通信实例">主从设备通信实例</h2><p>接下来，以 <strong>UINIO-MCU-ESP32S3</strong> 作为主设备，而<strong>UINIO-MCU-ESP32C3</strong> 作为从设备（I²C 地址为<code>55</code>），两者的 <code>SDA</code> 和 <code>SCK</code>都分别指定为为 <code>GPIO5</code> 和 <code>GPIO6</code>，并且在从设备的<code>GPIO8</code> 上面连接一枚 LED：</p><p><img src="/Project/Arduino-ESP32/10.png"></p><p><strong>UINIO-MCU-ESP32S3</strong> 作为主设备，每间隔 2秒就会向从设备 <strong>UINIO-MCU-ESP32C3</strong>发送一个递增的数值，<strong>从设备</strong>接收到<strong>主设备</strong>的数据之后LED 就会闪烁 0.5 秒，并且在收到的数值后面添加 <code>已经被接收</code>字样，然后返回给<strong>主设备</strong>打印至串口，具体的示例代码如下面所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UINIO-MCU-ESP32S3 主设备程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">1</span>;        <span class="comment">// 发送给从设备的数值</span></span><br><span class="line"><span class="type">int</span> address = <span class="number">55</span>;      <span class="comment">// 从设备 I²C 地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 设置 SDA 为 GPIO5，而 SCK 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将主设备添加至 I²C 总线 */</span></span><br><span class="line">  <span class="keyword">if</span> (Wire.<span class="built_in">begin</span>()) &#123;  <span class="comment">//</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;加入 I²C 总线成功&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;加入 I²C 总线失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 向从设备发送数据 */</span></span><br><span class="line">  <span class="type">char</span> data[<span class="number">32</span>];</span><br><span class="line">  <span class="built_in">itoa</span>(number++, data, <span class="number">10</span>);  <span class="comment">// 将整型数值 number 转换为字符串 data</span></span><br><span class="line"></span><br><span class="line">  Wire.<span class="built_in">beginTransmission</span>(address);      <span class="comment">// 开始向指定的从设备传输数据</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(data);                     <span class="comment">// 开始写入 number 数值字符串</span></span><br><span class="line">  <span class="type">int</span> result = Wire.<span class="built_in">endTransmission</span>();  <span class="comment">// 结束数据传输</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断传输是否出现错误 */</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;传输错误：%d\r\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">// 如果传输状态不为 0，那么就无需再执行后续的数据接收步骤，直接返回结束</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);   <span class="comment">// 延时 100 毫秒，给从设备处理并且响应数据留出足够时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接收从设备发送的数据 */</span></span><br><span class="line">  <span class="type">int</span> length = Wire.<span class="built_in">requestFrom</span>(address, <span class="number">32</span>);  <span class="comment">// 发起对于从设备数据的请求，最多不超过 32 字节数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果接收到了数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;主设备接收的数据大小：&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(length);      <span class="comment">// 打印接收到的数据大小</span></span><br><span class="line"></span><br><span class="line">    Wire.<span class="built_in">readBytes</span>(data, <span class="number">32</span>);    <span class="comment">// 读取接收缓冲区的数据</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(data);        <span class="comment">// 打印接收缓冲区的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把从设备发送回来的数据，以 16 进制格式打印出来 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; <span class="number">32</span>; index++) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;%2X, &quot;</span>, data[index]);</span><br><span class="line">      <span class="keyword">if</span> (index % <span class="number">8</span> == <span class="number">7</span>) &#123;</span><br><span class="line">        Serial.<span class="built_in">println</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  主设备接收的数据大小：32</span></span><br><span class="line"><span class="comment">  5674 已经被接收</span></span><br><span class="line"><span class="comment">  35, 36, 37, 34, 20, E5, B7, B2,</span></span><br><span class="line"><span class="comment">  E7, BB, 8F, E8, A2, AB, E6, 8E,</span></span><br><span class="line"><span class="comment">  A5, E6, 94, B6,  0,  0,  0,  0,</span></span><br><span class="line"><span class="comment">   0,  0,  0,  0,  0,  0,  0,  0,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果<strong>主设备</strong> <code>requestFrom()</code> 所指定的<code>quantity</code>参数的数据量，大于<strong>从设备</strong>发送过来的数据量，那么多出的空间将会由<code>0xff</code> 进行填充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UINIO-MCU-ESP32C3 从设备程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AsyncTimer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LED_Pin = <span class="number">8</span>;  <span class="comment">// 指定 LED 引脚</span></span><br><span class="line"><span class="type">int</span> address = <span class="number">55</span>; <span class="comment">// 从设备 I²C 地址</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">32</span>];  <span class="comment">// 数据接收缓冲区</span></span><br><span class="line"></span><br><span class="line">AsyncTimer timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 接收主设备数据的回调函数，参数 length 表示主机发送过来的数据量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onReceive</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> size = Wire.<span class="built_in">readBytes</span>(buffer, <span class="number">32</span>); <span class="comment">// 读取主设备发送过来的数据到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      buffer[size] = <span class="number">0</span>;                    <span class="comment">// 将缓冲区数据转换为以结束符 0 结尾的字符串</span></span><br><span class="line">      <span class="built_in">digitalWrite</span>(LED_Pin, HIGH);         <span class="comment">// 点亮 LED</span></span><br><span class="line">      timer.<span class="built_in">setTimeout</span>([]() &#123;</span><br><span class="line">        <span class="built_in">digitalWrite</span>(LED_Pin, LOW);        <span class="comment">// 500 毫秒以后熄灭 LED</span></span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向主设备发送数据的回调函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">strcat</span>(buffer, <span class="string">&quot; 已经被接收&quot;</span>);  <span class="comment">// 在主设备的数据结尾添加字符串 OK</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(buffer);            <span class="comment">// 将数据发送回主设备</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(<span class="number">0</span>);                 <span class="comment">// 发送字符串结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_Pin, OUTPUT);</span><br><span class="line">  Wire.<span class="built_in">onReceive</span>(onReceive);</span><br><span class="line">  Wire.<span class="built_in">onRequest</span>(onRequest);</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);   <span class="comment">// 设置 SDA 为 GPIO5，而 SCK 为 GPIO6</span></span><br><span class="line">  Wire.<span class="built_in">begin</span>(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.<span class="built_in">handle</span>();      <span class="comment">// 必须调用该函数才能启动 AsyncTimer 软件定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pcf8574-驱动-1602-液晶屏">PCF8574 驱动 1602 液晶屏</h1><p><strong>1602 字符型液晶显示屏</strong>，一共可以显示 2行内容，每一行可以显示 16个字符，屏幕驱动芯片采用了<strong>日立</strong>的<strong>HD44780</strong>，由于该屏幕在使用时需要占用大量 GPIO引脚。所以需要借助德州仪器的 <strong>PCF8574</strong> 八位 GPIO扩展器（工作电压介于 <code>2.5V ~ 5.5V</code> 范围），将其转换为两线制的I²C 总线协议。</p><p><img src="/Project/Arduino-ESP32/11.png"></p><blockquote><p><strong>注意</strong>：<strong>PCF8574</strong> 的 I²C 地址默认为<code>0x27</code>，可以通过 <code>0Ω</code> 电阻调整<strong>PCF8574</strong> 模组<code>A0</code>、<code>A1</code>、<code>A2</code> 位置的通断来修改其 I²C地址。除此之外，还可以通过 <strong>PCF8574</strong>模组上面的电位器，调整 1602 液晶显示屏的对比度。</p></blockquote><p><a href="https://github.com/mrkaleArduinoLib/LiquidCrystal_I2C"><strong>LiquidCrystal_I2C</strong></a>是一款兼容 <strong>HD44780</strong> 和 <strong>PCF8574</strong> 的 LCD屏幕驱动库，使用时需要将其工程 <code>src</code> 目录下的<code>LiquidCrystal_I2C.cpp</code> 和 <code>LiquidCrystal_I2C.h</code>文件拷贝至 <strong>Arduino IDE</strong> 的草图根目录，然后通过<code>#include "LiquidCrystal_I2C.h"</code> 语句将其包含至 Arduino草图源文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LiquidCrystal_I2C <span class="title">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">16</span>, <span class="number">2</span>)</span></span>;     <span class="comment">// I²C 地址为 0x27，LCD 屏幕为 16 列 2 行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);                   <span class="comment">// 配置 I²C 总线的 SDA 为 GPIO5，而 SCL 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  LCD.<span class="built_in">init</span>();                           <span class="comment">// 初始化 LCD</span></span><br><span class="line">  LCD.<span class="built_in">backlight</span>();                      <span class="comment">// 开启 LCD 背光</span></span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Hello UinIO.com&quot;</span>);         <span class="comment">// 光标默认位于第 1 行第 1 列</span></span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">1</span>);                  <span class="comment">// 将光标切换至第 2 行的第 1 列</span></span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Welcome to UinIO.com !&quot;</span>);  <span class="comment">// 字符数超过 16，超出长度的部分不会显示</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将显示内容修改为 Welcome To UinIO.com ! */</span></span><br><span class="line">  <span class="comment">// LCD.setCursor(8, 1);        // 将光标切换至第 2 行的第 8 列</span></span><br><span class="line">  <span class="comment">// LCD.write(&#x27;T&#x27;);             // 把小写字母 t 替换为大写字母 T</span></span><br><span class="line">  <span class="comment">// LCD.setCursor(9, 1);        // 将光标切换至第 2 行的第 9 列</span></span><br><span class="line">  <span class="comment">// LCD.write(&#x27;O&#x27;);             // 把小写字母 o 替换为大写字母 O</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// /* 清除屏幕内容 */</span></span><br><span class="line">  <span class="comment">// LCD.clear();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 滚动字符显示 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    LCD.<span class="built_in">scrollDisplayLeft</span>();  <span class="comment">// 每一次向左滚动 1 个字符</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">500</span>);              <span class="comment">// 延时 0.5 秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：需要将 <strong>PCF8574</strong> 模块上丝印为<code>SDA</code> 和 <code>SCL</code> 的引脚，分别连接至<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO5</code> 和<code>GPIO6</code> 引脚。</p></blockquote><h1 id="外部中断-自旋锁">外部中断 &amp; 自旋锁</h1><p><strong>中断</strong>（Interrupt）是指计算机运行过程当中，如果出现某些意外情况需要干预时，程序能够自动停止当前正在运行的代码，转而处理这个新出现的情况，处理完毕之后再返回之前的程序继续执行。在<strong>Arduino-ESP32</strong>当中使用外部中断时，需要注意到以下情况：</p><ul><li><code>delay()</code>函数依赖于中断，在中断服务程序当中无法调用；</li><li><code>micros()</code> 函数刚开始会正常工作，但是可能会在<code>1 ~ 2</code> 毫秒之后出现异常行为；</li><li><code>millis()</code>函数依赖于中断计数器，其返回值在中断服务程序当中不会增加；</li><li><code>delayMicroseconds()</code>并不会使用到中断计数器，因而能够在中断服务程序当中正常工作；</li></ul><p><strong>ESP32-Arduino</strong>里的<strong>中断服务程序</strong>（ISR， Interrupt ServiceRoutines）是一种没有<strong>参数</strong>和<strong>返回值</strong>的特殊函数（如果代码中同时使用到多个中断服务程序，那么它们将会按照优先级的顺序进行执行），<strong>ESP32-Arduino</strong>库支持以如下方式，在指定的引脚上面启用或者关闭外部中断服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(pin), ISR, mode)  <span class="comment">// 开启中断，并且添加中断服务程序</span></span><br><span class="line"><span class="built_in">detachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(pin))             <span class="comment">// 关闭中断</span></span><br></pre></td></tr></table></figure><ul><li><code>pin</code>: 发生外部中断的 GPIO 引脚编号；</li><li><code>ISR</code>:发生外部中断时候，自动调用的中断服务函数（无参数，无返回值）；</li><li><code>mode</code>: 中断触发方式，取值可以为<strong>LOW</strong>（低电平触发）、<strong>CHANGE</strong>（状态变化触发）、<strong>RISING</strong>（上升沿触发）、<strong>FALLING</strong>（下降沿触发）四个常量当中的一个；</li></ul><p>接下来使用中断服务程序，完成一个当按键按下的时候，LED发光二极管熄灭，而在按键弹起时 LED 点亮的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> byte LED = <span class="number">5</span>;     <span class="comment">// LED 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> byte Button = <span class="number">6</span>;  <span class="comment">// BUTTON 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">switchPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 当 BUTTON 对应的 GPIO 引脚呈现高电平状态*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(BUTTON) == HIGH) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED, HIGH);  <span class="comment">// LED 点亮</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(LED, LOW);   <span class="comment">// LED 熄灭</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED, OUTPUT);           <span class="comment">// 将 LED 对应的 GPIO 引脚设置为输出模式</span></span><br><span class="line">  <span class="built_in">pinMode</span>(BUTTON, INPUT_PULLUP);  <span class="comment">// 将 BUTTON 对应的 GPIO 引脚设置为输入上拉模式</span></span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(BUTTON), switchPressed, CHANGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是在中断服务程序里控制 LED的亮灭状态，如果需要使用一个<strong>全局变量</strong>，在中断服务程序与主程序之间传递数据，那么必须要将其声明为<code>volatile</code>类型，从而确保该全局变量总是被正确的更新，例如下面代码当中的<code>number</code> 变量就使用了 <code>volatile</code>关键字进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num = number;</span><br><span class="line">  Serial.<span class="built_in">println</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在下面这份示例代码当中，如果程序执行到注释的位置发生了中断，那么变量<code>number 1</code> 的值将不会得到更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果程序执行到这个位置发生了中断，那么变量 number 1 的值不会被更新</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  Serial.<span class="built_in">println</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要确保 <code>number 1</code>的值正常更新，就必须短暂的禁用中断。<strong>ESP32-Arduino</strong>支持手动<strong>使能</strong> <code>interrupts()</code>和<strong>失能</strong> <code>noInterrupts()</code> 中断服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">noInterrupts</span>();  <span class="comment">// 失能中断</span></span><br><span class="line">  <span class="comment">/* 此处放置临界的时间敏感代码 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">interrupts</span>();    <span class="comment">// 使能中断</span></span><br><span class="line">  <span class="comment">/* 其它代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以修改前面的示例代码，通过使用 <code>interrupts()</code> 和<code>noInterrupts()</code>函数，使得程序即使执行到注释位置发生中断，也仍然可以确保变量 number1被正确的更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">noInterrupts</span>();  <span class="comment">// 失能中断</span></span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="comment">/******</span></span><br><span class="line"><span class="comment">    即使程序执行到这个位置发生了中断，依然可以确保变量 number1 会被正确的更新</span></span><br><span class="line"><span class="comment">  ******/</span></span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  <span class="built_in">interrupts</span>();    <span class="comment">// 使能中断</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(num1);</span><br><span class="line">  Serial.<span class="built_in">println</span>(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>两款微控制器都拥有两个计算核心，即使禁用了当前核心的中断服务，另外一个核心也同样可能访问到<strong>临界区</strong>（访问共用资源的程序片段）的资源，所以就需要在禁用中断的同时，对临界区的资源进行上锁。由<strong>ESP-IDF</strong> 提供的<code>portMUX_INITIALIZER_UNLOCKED</code><strong>自旋锁</strong>，同样可以应用在 <strong>ESP32-Arduino</strong>的草图代码当中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> number2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IRAM_ATTR <span class="type">void</span> <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(&amp;mux);  <span class="comment">// 中断函数访问临界资源开始</span></span><br><span class="line">  number1++;</span><br><span class="line">  number2++;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(&amp;mux);   <span class="comment">// 中断函数访问临界资源结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);      <span class="comment">// 主函数访问临界资源开始</span></span><br><span class="line">  <span class="type">int</span> num1 = number1;</span><br><span class="line">  <span class="type">int</span> num2 = number2;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);       <span class="comment">// 主函数访问临界资源结束</span></span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(num1);</span><br><span class="line">  Serial.<span class="built_in">println</span>(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上述代码当中的 <code>IRAM_ATTR</code>关键字，同样是由 <strong>ESP-IDF</strong>所提供，用于把这段代码保存至芯片内部的RAM（<strong>IRAM</strong>）里面（否则放置到Flash），从而提高中断服务程序的响应速度，建议<strong>ESP32-Arduino</strong>的中断服务程序都使用该关键字进行声明。</p></blockquote><h1 id="测量-pwm-的频率-占空比">测量 PWM 的频率 &amp; 占空比</h1><p>本示例将会基于 <strong>UINIO-MCU-ESP32</strong>实现一个频率与占空比的测量功能。首先，需要开启指定 GPIO引脚的外部中断，当每一次触发中断的时候，都记录下信号<strong>上升沿</strong>与<strong>下降沿</strong>发生的时间（单位为<code>微秒</code>）。然后，在中断服务程序里使用<code>digitalRead()</code>函数，判断当前属于高电平还是低电平。最后，记录前一次<strong>上升沿</strong>、<strong>下降沿</strong>产生的时间，并且在下一个<strong>上升沿</strong>中断发生时进行如下一系列计算：</p><ul><li><strong>脉冲宽度</strong>：脉冲<strong>高电平</strong>信号的持续时间，即下图中的<span class="math inline">\(t_4 - t_3\)</span>；</li><li><strong>脉冲周期</strong>：两个<strong>相临</strong>脉冲信号之间的时间间隔，即下图里的<span class="math inline">\(t_7 - t_5\)</span>；</li><li><strong>占空比</strong>：一个脉冲周期内，<strong>高电平</strong>信号持续时间占据整个周期时间的比值，即<span class="math inline">\(\frac{1}{脉冲周期}\)</span>；</li><li><strong>脉冲频率</strong>：单位时间内产生的<strong>脉冲个数</strong>，即<span class="math inline">\(\frac{脉冲宽度}{脉冲周期}\)</span>；</li></ul><p><img src="/Project/Arduino-ESP32/12.png"></p><p>这里同样将 1602 液晶屏 I²C 总线的 <code>SDA</code> 和<code>SCL</code>，分别连接到 <strong>UINIO-MCU-ESP32</strong> 的<code>GPIO5</code> 和 <code>GPIO6</code>引脚，同时把<strong>信号发生器</strong>的输出探头连接至<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO8</code> 引脚：</p><p><img src="/Project/Arduino-ESP32/13.png"></p><p>当信号发生器输出频率为 <code>1000Hz</code>，占空比为 <code>50%</code>的方波信号时，下面的代码就可以使得 <strong>UINIO-MCU-ESP32</strong> 在1602 屏幕上显示出<strong>频率</strong> <code>Freq: 1000.0</code>和<strong>占空比</strong> <code>Duty: 0.5</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> PWM_Pin = <span class="number">8</span>;                         <span class="comment">// 输入 PWM 信号的 GPIO 引脚</span></span><br><span class="line"><span class="function">LiquidCrystal_I2C <span class="title">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">16</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> RisingTime = <span class="number">0</span>;   <span class="comment">// 上升沿发生的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> FallingTime = <span class="number">0</span>;  <span class="comment">// 下降沿发生的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面两个变量是 loop() 和 changeISR() 函数都会访问到的临界资源 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> Duty = <span class="number">0</span>;                <span class="comment">// 脉冲信号的占空比</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">double</span> Frequency = <span class="number">0</span>;           <span class="comment">// 脉冲信号的频率</span></span><br><span class="line"></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> Now = <span class="built_in">micros</span>();                      <span class="comment">// 每一次发生中断，都记录其发生的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断指定 GPIO 引脚的高低电平状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(PWM_Pin)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中断函数访问临界区变量开始 */</span></span><br><span class="line">    <span class="built_in">portENTER_CRITICAL_ISR</span>(&amp;mux);</span><br><span class="line">    <span class="keyword">auto</span> period = Now - RisingTime;         <span class="comment">// 周期等于当前中断发生的时间减去之前上升沿的时间</span></span><br><span class="line">    Frequency = <span class="number">1e6</span> / (<span class="type">double</span>)period;       <span class="comment">// 因为是以微秒作为单位，所以这里使用 1e6</span></span><br><span class="line">    <span class="keyword">auto</span> width = FallingTime - RisingTime;  <span class="comment">// 脉冲宽度等于上升沿减去下降沿的出现时间</span></span><br><span class="line">    Duty = width / (<span class="type">double</span>)period;          <span class="comment">// 占空比等于脉冲宽度除以周期</span></span><br><span class="line">    <span class="built_in">portEXIT_CRITICAL_ISR</span>(&amp;mux);</span><br><span class="line">    <span class="comment">/* 中断函数访问临界区变量结束 */</span></span><br><span class="line"></span><br><span class="line">    RisingTime = Now;   <span class="comment">// 将本次中断发生的时间，保存为前一次上升沿发生的时间</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FallingTime = Now;  <span class="comment">// 将本次中断发生的时间，保存为前一次下降沿发生的时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 设置 1602 液晶屏的 I²C 总线 */</span></span><br><span class="line">  Wire.<span class="built_in">setPins</span>(<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 指定 SDA 为 GPIO5，SCL 为 GPIO6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 1602 液晶显示屏 */</span></span><br><span class="line">  LCD.<span class="built_in">init</span>();</span><br><span class="line">  LCD.<span class="built_in">backlight</span>();</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Freq: &quot;</span>);</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(<span class="string">&quot;Duty: &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将输入 PWM 的 GPIO 设置为输入模式，并且绑定至引脚电平发生变化时，就会触发的中断处理函数 */</span></span><br><span class="line">  <span class="built_in">pinMode</span>(PWM_Pin, INPUT);</span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(PWM_Pin), changeISR, CHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 每间隔 1 秒读取频率与占空比的全局变量 */</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 主函数访问临界区变量开始 */</span></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="type">double</span> DutyValue = Duty;</span><br><span class="line">  <span class="type">double</span> FrequencyValue = Frequency;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="comment">/* 主函数访问临界区变量结束 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1602 液晶屏幕显示频率与占空比数值 */</span></span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(FrequencyValue);</span><br><span class="line">  LCD.<span class="built_in">setCursor</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">  LCD.<span class="built_in">print</span>(DutyValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时器-timer-信号量-semaphore">定时器 Timer &amp; 信号量Semaphore</h1><p><strong>ESP32-C3</strong> 芯片内置有 2 个 <code>54</code>位<strong>通用定时器</strong>（具有 <code>16</code>位<strong>预分频器</strong>和 <code>54</code>位可自动重载的<strong>向上/向下计数器</strong>）。 而<strong>ESP32-S3</strong> 则内置有 4 个 <code>54</code>位<strong>通用定时器</strong>（具有 <code>16</code>位<strong>预分频器</strong>和 <code>54</code>位可自动重载的<strong>向上/向下计数器</strong>）。</p><p><img src="/Project/Arduino-ESP32/14.png"></p><p><strong>ESP32</strong> 的通用定时器以 <strong>APB</strong> 时钟<code>APB_CLK</code> 作为基本时钟源（该时钟频率由 <code>CPU_CLK</code>的时钟（即微控制器当前的运行频率）决定，其中 <strong>ESP32-C3</strong>为 <code>160 MHz</code>，而 <strong>ESP32-S3</strong> 为<code>240 MHz</code>），而 16 位<strong>预分频器</strong>（取值范围为<code>1 ~ 65536</code>）的作用就是对 <strong>APB</strong>时钟进行分频，从而产生<strong>时基计数器时钟</strong><code>TB_CLK</code>（每经过 1 个周期向上或者向下进行计数）。</p><blockquote><p><strong>注意</strong>：所谓<strong>分频</strong>就是将信号频率降低到原来的<span class="math inline">\(\frac{1}{N}\)</span>，称为 <strong>N分频</strong>。</p></blockquote><p>已知 <span class="math inline">\(CPU\_CLK_{C3} = 160MHz\)</span>，而<span class="math inline">\(CPU\_CLK_{S3} =240MHz\)</span>，假设每一次计数的时间间隔为 <code>10</code>微秒，那么所需的频率等于其倒数 <span class="math inline">\(\frac{1}{10\mu S} = 0.1MHz\)</span>，此时 <strong>ESP32-C3</strong> 和<strong>ESP32-S3</strong> 的分频系数应当分别被设置为：</p><p><span class="math display">\[\begin{cases}\frac{CPU\_CLK\_{C3}}{0.1MHz} = \frac{160}{0.1} = 1600 \\\frac{CPU\_CLK\_{S3}}{0.1MHz} = \frac{240}{0.1} = 2400\end{cases}\]</span></p><p>换而言之，如果计数周期为 <code>1</code> 微秒，那么<strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong>的分频系数应当分别被设置为 <code>160</code> 和<code>240</code>。<strong>Arduino-ESP32</strong>封装有一系列定时器相关的 <a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html"><strong>API</strong></a>，它们的基本使用步骤如下面所示：</p><ol type="1"><li>初始化硬件定时器，确定时钟频率以及计数方向；</li><li>绑定定时器中断服务程序；</li><li>设置定时器的计数值；</li><li>开始启动定时器；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个定时器指针变量 */</span></span><br><span class="line"><span class="type">hw_timer_t</span>* timer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">onTimer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 定时器中断服务程序 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器，将 ESP32-C3 的计数周期设置为 1 微秒 */</span></span><br><span class="line">timer = timerBegin(<span class="number">0</span>, <span class="number">160</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绑定定时器与中断服务程序 */</span></span><br><span class="line">timerAttachInterrupt(timer, onTimer，<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数至 1000000 次的时候触发中断，即每间隔 1 秒触发一次中断 */</span></span><br><span class="line">timerAlarmWrite(timer，<span class="number">1000000</span>，<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启定时器 */</span></span><br><span class="line">timerAlarmEnable(timer);</span><br></pre></td></tr></table></figure><p>可以看到在定时器的整个使用过程当中，最为重要的就是定时器初始化函数<code>timerBegin()</code>。如果定时器初始化成功，那么其返回值为一个<code>timer</code> 结构体，反之则会返回<code>NULL</code>。除此之外，该函数的第 1 个参数 <code>num</code>是<strong>定时器编号</strong>，第 2 个参数 <code>divider</code>是<strong>定时器分频系数</strong>，第 3 个参数 <code>countUp</code>则是<strong>定时器计数方向</strong>，更多关于<strong>Arduino-ESP32</strong> 当中定时器的 API 可以参考下面的表格：</p><table><colgroup><col style="width: 71%"><col style="width: 28%"></colgroup><thead><tr class="header"><th style="text-align: left;">API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>hw_timer_t * timerBegin(uint8_t num, uint16_t divider, bool countUp)</code></td><td style="text-align: left;">配置定时器；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerEnd(hw_timer_t *timer)</code></td><td style="text-align: left;">结束定时器；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint32_t timerGetConfig(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器配置；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerSetConfig(hw_timer_t *timer, uint32_t config)</code></td><td style="text-align: left;">配置已经初始化的定时器；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerAttachInterrupt(hw_timer_t *timer, void (*fn)(void), bool edge)</code></td><td style="text-align: left;">添加定时器中断服务程序；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerDetachInterrupt(hw_timer_t *timer)</code></td><td style="text-align: left;">拆除定时器中断服务程序；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerStart(hw_timer_t *timer)</code></td><td style="text-align: left;">开始定时器计数；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerStop(hw_timer_t *timer)</code></td><td style="text-align: left;">停止定时器计数；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerRestart(hw_timer_t *timer)</code></td><td style="text-align: left;">重启定时器计数；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerWrite(hw_timer_t *timer, uint64_t val)</code></td><td style="text-align: left;">设置定时器的计数值；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerSetDivider(hw_timer_t *timer, uint16_t divider)</code></td><td style="text-align: left;">设置定时器的分频系数；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerSetCountUp(hw_timer_t *timer, bool countUp)</code></td><td style="text-align: left;">设置定时器的计数方向；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerSetAutoReload(hw_timer_t *timer, bool autoreload)</code></td><td style="text-align: left;">设置定时器计数值的自动重载；</td></tr><tr class="even"><td style="text-align: left;"><code>bool timerStarted(hw_timer_t *timer)</code></td><td style="text-align: left;">判断定时器是否在运行；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint64_t timerRead(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的计数值；</td></tr><tr class="even"><td style="text-align: left;"><code>uint64_t timerReadMicros(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的计数（微秒）；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint64_t timerReadMilis(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的计数（毫秒）；</td></tr><tr class="even"><td style="text-align: left;"><code>double timerReadSeconds(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的计数（秒）；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint16_t timerGetDivider(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的分频系数；</td></tr><tr class="even"><td style="text-align: left;"><code>bool timerGetCountUp(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的计数方向；</td></tr><tr class="odd"><td style="text-align: left;"><code>bool timerGetAutoReload(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器计数值的自动重载状态；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerAlarmEnable(hw_timer_t *timer)</code></td><td style="text-align: left;">使能定时器告警事件的生成；</td></tr><tr class="odd"><td style="text-align: left;"><code>void timerAlarmDisable(hw_timer_t *timer)</code></td><td style="text-align: left;">失能定时器告警事件的生成；</td></tr><tr class="even"><td style="text-align: left;"><code>void timerAlarmWrite(hw_timer_t *timer, uint64_t alarm_value, bool autoreload)</code></td><td style="text-align: left;">设置定时器的自动加载与告警值；</td></tr><tr class="odd"><td style="text-align: left;"><code>bool timerAlarmEnabled(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的告警状态；</td></tr><tr class="even"><td style="text-align: left;"><code>uint64_t timerAlarmRead(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的告警值；</td></tr><tr class="odd"><td style="text-align: left;"><code>uint64_t timerAlarmReadMicros(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的告警值（微秒）；</td></tr><tr class="even"><td style="text-align: left;"><code>double timerAlarmReadSeconds(hw_timer_t *timer)</code></td><td style="text-align: left;">获取定时器的告警值（秒）；</td></tr></tbody></table><p><strong>信号量</strong>（<strong>Semaphore</strong>[ˈseməfɔːr]）用于解决并发任务当中的<strong>互斥</strong>与<strong>同步</strong>问题。可以简单的将其理解为一个<strong>队列</strong>（只需要关注该队列当中元素的个数），也可以将其理解为一个整型的全局变量（用于记录信号个数）。而<strong>二值信号量</strong>则表示的是一种只存在两种状态的队列（<code>有信号</code>或者<code>无信号</code>），使用时通过检测信号是否存在，再来决定是否处理相关的任务。相比于全局变量，二值信号量可以等待信号，并且保证操作的原子化，通常应用于中断服务程序与主任务之间的状态同步，其基本使用方法如下面的示例所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ISR</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 中断任务</span></span><br><span class="line">  发送信号()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( 接收信号() ) &#123;</span><br><span class="line">    <span class="comment">// 执行处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <strong>Arduino-ESP32</strong> 在底层是基于嵌入式实时操作系统 <a href="https://www.freertos.org/zh-cn-cmn-s/"><strong>FreeRTOS</strong></a>构建，该操作系统提供有一系列<a href="https://www.freertos.org/zh-cn-cmn-s/a00113.html">信号量API</a>，因而在 <strong>Arduino-ESP32</strong>当中同样可以直接进行调用：</p><table><colgroup><col style="width: 63%"><col style="width: 36%"></colgroup><thead><tr class="header"><th style="text-align: left;">API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>SemaphoreHandle_t xSemaphoreCreateBinary()</code></td><td style="text-align: left;">创建一个二进制信号量，并返回一个可以引用该信号量的句柄。</td></tr><tr class="even"><td style="text-align: left;"><code>xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait )</code></td><td style="text-align: left;">获取信号量。</td></tr><tr class="odd"><td style="text-align: left;"><code>xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore, signed BaseType_t *pxHigherPriorityTaskWoken)</code></td><td style="text-align: left;">在中断服务程序里获取信号量。</td></tr><tr class="even"><td style="text-align: left;"><code>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</code></td><td style="text-align: left;">释放信号量。</td></tr><tr class="odd"><td style="text-align: left;"><code>xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore, signed BaseType_t *pxHigherPriorityTaskWoken)</code></td><td style="text-align: left;">在中断服务程序里释放信号量。</td></tr></tbody></table><p>在下面的示例代码当中，通过结合使用定时器中断和二值信号量，每间隔<code>1</code> 秒钟打印中断被触发的次数 <code>Count</code> 以及时间<code>Time</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> Count = <span class="number">0</span>;                         <span class="comment">// 中断触发的次数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> Time = <span class="number">0</span>;                <span class="comment">// 中断触发的时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">hw_timer_t</span>* Timer1 = <span class="literal">NULL</span>;                      <span class="comment">// 定时器 1 全局指针变量</span></span><br><span class="line">portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t timerSemaphore;      <span class="comment">// 声明全局信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器中断服务程序，每间隔 1 秒被执行一次 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">onTimer1</span><span class="params">()</span> &#123;</span><br><span class="line">  portENTER_CRITICAL_ISR(&amp;timerMux);</span><br><span class="line">  Count++;          <span class="comment">// 中断触发次数自增 1</span></span><br><span class="line">  Time = micros();  <span class="comment">// 获取当前微秒时间</span></span><br><span class="line">  portEXIT_CRITICAL_ISR(&amp;timerMux);</span><br><span class="line"></span><br><span class="line">  xSemaphoreGiveFromISR(timerSemaphore, <span class="literal">NULL</span>);   <span class="comment">// 完成中断次数与时间的赋值之后就发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  timerSemaphore = xSemaphoreCreateBinary();     <span class="comment">// 创建二值信号量</span></span><br><span class="line">  Timer1 = timerBegin(<span class="number">0</span>, <span class="number">240</span>, <span class="literal">true</span>);             <span class="comment">// 初始化定时器，分频系数为 240，即每间隔 1 微秒计数一次</span></span><br><span class="line">  timerAttachInterrupt(Timer1, onTimer1, <span class="literal">true</span>);  <span class="comment">// 添加定时器中断服务程序</span></span><br><span class="line">  timerAlarmWrite(Timer1, <span class="number">1000000</span>, <span class="literal">true</span>);        <span class="comment">// 每间隔 1 秒循环触发中断</span></span><br><span class="line">  timerAlarmEnable(Timer1);                      <span class="comment">// 启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 检测二值信号，如果检测到，就会立即执行 */</span></span><br><span class="line">  <span class="keyword">if</span> (xSemaphoreTake(timerSemaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line"></span><br><span class="line">    portENTER_CRITICAL(&amp;timerMux);</span><br><span class="line">    <span class="keyword">auto</span> count = Count;</span><br><span class="line">    <span class="keyword">auto</span> time = Time;</span><br><span class="line">    portEXIT_CRITICAL(&amp;timerMux);</span><br><span class="line"></span><br><span class="line">    Serial.println(count);</span><br><span class="line">    Serial.println(time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hc-sr04-超声波模组">HC-SR04 超声波模组</h1><p>新款的 <strong>HC-SR04</strong> 超声波模组采用了<strong>RCWL-9206</strong> 作为测距解调芯片，其工作电压范围介于<code>3V ~ 5.5V</code> 之间，工作电流为<code>2.2mA ~ 3mA</code>，同时支持<strong>GPIO</strong>、<strong>UART</strong>、<strong>I²C</strong>三种通信方式，更多的性能参数可以参考下面的表格：</p><p><img src="/Project/Arduino-ESP32/15.png"></p><p><strong>HC-SR04</strong>超声波模组引脚接口的功能定义，如下面的表格所示：</p><p><img src="/Project/Arduino-ESP32/16.png"></p><p>通过配置模组上的电阻 <span class="math inline">\(R_4\)</span> 和<span class="math inline">\(R_5\)</span> 可以选择<strong>HC-SR04</strong> 的引脚通信模式：</p><p><img src="/Project/Arduino-ESP32/17.png"></p><p>由 <strong>UINIO-MCU-ESP32</strong> 发射一个持续时间至少<code>10us</code> 的脉冲信号到 <strong>HC-SR04</strong> 的<code>Trig</code> 引脚；此时 <strong>HC-SR04</strong> 会连续发送出 8 个<code>40KHz</code> 频率的超声波信号，并且 <strong>HC-SR04</strong> 的<code>Echo</code> 引脚会切换为高电平；如果超声波信号没有响应，那么<code>Echo</code> 引脚就会在维持 <code>38ms</code>的高电平之后，重新切换为低电平状态：</p><p><img src="/Project/Arduino-ESP32/18.webp"></p><p>如果超声波信号被物体反射，那么 <code>Echo</code>引脚就会从高电平切换至低电平，从而产生出一个脉冲信号，这个脉冲的宽度就是超声波从<strong>发射</strong>到被物体<strong>反射</strong>回来的间隔时间，即经过超声波探头与物体之间<strong>2</strong> 倍距离所耗费的时间：</p><p><img src="/Project/Arduino-ESP32/19.webp"></p><p>根据超声波在空气当中的传输速度，就可以计算出超声波探头与物体之间的距离（两次测量的间隔时间不能低于<code>200</code> 毫秒）：</p><p><span class="math display">\[超声波探头与物体之间的距离 = 超声波传输速度 \times\frac{脉冲宽度时间}{2}\]</span></p><p>由于环境温度会对超声波信号的传输速度造成影响，如果需要更加精确的测量距离，那么就必须把温度的因素纳入考量范围，并且进行相应的温度补偿：</p><table><thead><tr class="header"><th style="text-align: center;">环境温度</th><th style="text-align: center;">超声波典型传输速度</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>0℃</code></td><td style="text-align: center;"><code>330.45</code> 米每秒</td></tr><tr class="even"><td style="text-align: center;"><code>20℃</code></td><td style="text-align: center;"><code>342.62</code> 米每秒</td></tr><tr class="odd"><td style="text-align: center;"><code>40℃</code></td><td style="text-align: center;"><code>354.85</code> 米每秒</td></tr></tbody></table><p><strong>Arduino</strong> 官方库当中提供的 <a href="https://www.arduino.cc/reference/en/language/functions/advanced-io/pulsein/"><code>pulseIn()</code></a>函数可以用于读取脉冲信号的持续时间（以微秒为单位），其中参数<code>pin</code> 是需要用于读取脉冲信号的<strong>UINIO-MCU-ESP32</strong> 引脚编号，而参数 <code>value</code>则用于指定脉冲的类型（<strong>高电平脉冲</strong> <code>HIGH</code>或者<strong>低电平脉冲</strong> <code>LOW</code>），可选的参数<code>timeout</code> 则用于设置脉冲读取的超时时间（单位为微秒，默认为<code>1000</code>，即 <code>1</code> 秒钟）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulseIn(pin, value, timeout)</span><br></pre></td></tr></table></figure><p>这里把 <strong>UINIO-MCU-ESP32S3</strong> 的 <code>GPIO8</code> 和<code>GPIO9</code> 分别作为 HC-SR04 超声波模组的 <code>Echo</code> 和<code>Trig</code> 引脚，然后以 <strong>GPIO</strong>通信方式，通过上面的 <code>pulseIn()</code> 函数读取 HC-SR04传感器的数据，并且计算出以<strong>厘米</strong>作为单位的距离值，最后打印到波特率为<code>115200</code> 的串口上面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">8</span>;  <span class="comment">// 指定 Echo 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">9</span>;  <span class="comment">// 指定 Trig 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  pinMode(Trig_Pin, OUTPUT);</span><br><span class="line">  pinMode(Echo_Pin, INPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 向 Trig 引脚发送 15us 脉冲，发出超声波信号 */</span></span><br><span class="line">  digitalWrite(Trig_Pin, HIGH);</span><br><span class="line">  delayMicroseconds(<span class="number">15</span>);             <span class="comment">// 延时 15 微秒</span></span><br><span class="line">  digitalWrite(Trig_Pin, LOW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取 Echo 引脚高电平脉冲的时间长度 */</span></span><br><span class="line">  <span class="keyword">auto</span> time = pulseIn(Echo_Pin, HIGH);</span><br><span class="line">  <span class="type">double</span> distance = time * <span class="number">0.01715</span>;  <span class="comment">// 根据脉冲时间求解出距离，单位为厘米</span></span><br><span class="line">  Serial.println(distance);</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">200</span>);                        <span class="comment">// 确保两次测量的间隔时间不低于 200 毫秒。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上述代码当中的 <code>pulseIn()</code> 和 <code>delay()</code>函数在运行时都是<strong>阻塞式</strong>的，会严重的迟滞其它任务的执行时间，接下来会以<strong>非阻塞式</strong>的中断方式来实现相同功能，有所不同的是，这次会把结果显示到1602 液晶屏幕上面：</p><ol type="1"><li>首先，需要把外部中断 <code>change</code> 添加至连接到超声波传感器<code>Echo</code> 的 GPIO 引脚，然后使用硬件定时器每间隔<code>500</code> 毫秒向超声波模组的 <code>Trig</code> 引脚发送<code>15</code> 微秒的脉冲，即每 1 秒钟进行两次测量。</li><li>然后，在发生上升沿中断的时候，记录下当前时间 <span class="math inline">\(t_1\)</span>（超声波发送出去的时间）；而发生下降沿中断的时候，也记录下当前时间<span class="math inline">\(t_2\)</span>（接受到超声波信号反射的时间），与此同时发送出一个二值信号量。</li><li>最后，当 <code>loop()</code> 函数在接收到信号量之后，根据获取到的<span class="math inline">\(t_1\)</span> 与 <span class="math inline">\(t_2\)</span>的数值，就可以计算出物体与超声波探头之间的距离，并且显示在 1602屏幕上面。</li></ol><p>接下来，同样把 <strong>UINIO-MCU-ESP32S3</strong> 的<code>GPIO5</code> 和 <code>GPIO6</code> 引脚，作为 1602 液晶显示屏 I²C总线的 <code>SDA</code> 和 <code>SCL</code>。而 <code>GPIO8</code> 和<code>GPIO9</code> 分别作为 HC-SR04 超声波模组的 <code>Echo</code> 和<code>Trig</code> 引脚：</p><p><img src="/Project/Arduino-ESP32/20.png"></p><p>下面代码同样是以 <strong>GPIO</strong> 通信方式读取 HC-SR04传感器的数据，并且以非阻塞式方式计算出以<strong>毫米</strong>作为单位的距离值，最后将该值显示到1602 液晶屏幕上面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LiquidCrystal_I2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">8</span>;   <span class="comment">// 指定 Echo 连接的 GPIO 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">9</span>;   <span class="comment">// 指定 Trig 连接的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Distance = <span class="number">0</span>;                                 <span class="comment">// 探头与被测物体的间隔距离（单位为毫米）</span></span><br><span class="line"><span class="type">hw_timer_t</span>* Timer1 = <span class="literal">NULL</span>;                        <span class="comment">// 声明一个硬件定时器</span></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义自旋锁变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> StartTime = <span class="number">0</span>;             <span class="comment">// 超声波开始发射的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> EndTime = <span class="number">0</span>;               <span class="comment">// 接收到超声波反射的时间</span></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t semaphore;             <span class="comment">// 二值信号量</span></span><br><span class="line"></span><br><span class="line">LiquidCrystal_I2C <span class="title function_">LCD</span><span class="params">(<span class="number">0x27</span>, <span class="number">20</span>, <span class="number">4</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬件定时器中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">TrigerPulse</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(Trig_Pin, HIGH);</span><br><span class="line">  delayMicroseconds(<span class="number">15</span>);              <span class="comment">// 提供 15 微秒的脉冲信号</span></span><br><span class="line">  digitalWrite(Trig_Pin, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo 引脚状态变化中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">EchoChange</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> now = micros();                <span class="comment">// 获取当前微秒时间</span></span><br><span class="line">  <span class="keyword">auto</span> state = digitalRead(Echo_Pin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 访问临界区资源 */</span></span><br><span class="line">  portENTER_CRITICAL_ISR(&amp;mux);</span><br><span class="line">  <span class="comment">/* 如果 Echo 引脚为高电平，表示超声波已经发出 */</span></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    StartTime = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EndTime = now;</span><br><span class="line">  &#125;</span><br><span class="line">  portEXIT_CRITICAL_ISR(&amp;mux);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 Echo 引脚为低电平，表示已经接收到超声波反射 */</span></span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    xSemaphoreGiveFromISR(semaphore, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(Trig_Pin, OUTPUT);</span><br><span class="line">  pinMode(Echo_Pin, INPUT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 1602 液晶屏的 I²C 总线 */</span></span><br><span class="line">  Wire.setPins(<span class="number">5</span>, <span class="number">6</span>);      <span class="comment">// 指定 SDA 为 GPIO5，SCL 为 GPIO6</span></span><br><span class="line">  LCD.init();</span><br><span class="line">  LCD.backlight();         <span class="comment">// 打开 1602 液晶屏背光</span></span><br><span class="line">  LCD.print(<span class="string">&quot;Distance:&quot;</span>);  <span class="comment">// 显示 1602 液晶屏第 1 行内容</span></span><br><span class="line"></span><br><span class="line">  semaphore = xSemaphoreCreateBinary();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 硬件定时器 */</span></span><br><span class="line">  Timer1 = timerBegin(<span class="number">0</span>, <span class="number">240</span>, <span class="literal">true</span>);                <span class="comment">// 把 UINIO-MCU-ESP32S3 分频系数设置为 240，即每 1 微秒进行 1 次计数</span></span><br><span class="line">  timerAttachInterrupt(Timer1, TrigerPulse, <span class="literal">true</span>);  <span class="comment">// 添加硬件定时器中断服务程序</span></span><br><span class="line">  timerAlarmWrite(Timer1, <span class="number">500000</span>, <span class="literal">true</span>);            <span class="comment">// 每间隔 500 微秒触发 1 次</span></span><br><span class="line"></span><br><span class="line">  attachInterrupt(digitalPinToInterrupt(Echo_Pin), EchoChange, CHANGE);  <span class="comment">// 添加 Echo 引脚状态变化中断服务程序</span></span><br><span class="line">  timerAlarmEnable(Timer1);                                              <span class="comment">// 启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断二值信号量 */</span></span><br><span class="line">  <span class="keyword">if</span> (xSemaphoreTake(semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    portENTER_CRITICAL(&amp;mux);</span><br><span class="line">    <span class="keyword">auto</span> time = EndTime - StartTime;  <span class="comment">// 计算出脉冲宽度对应的时间</span></span><br><span class="line">    portEXIT_CRITICAL(&amp;mux);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> distance = time * <span class="number">0.1715</span>;  <span class="comment">// 根据脉冲宽度时间，计算出距离（单位为毫米）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 由于超声波传感器的有效测量距离为 3500 毫米以内，所以这里只处理低于该数值的距离数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">3500</span>) &#123;</span><br><span class="line">      <span class="comment">/* 判断本次计算出的距离，与之前计算的距离是否一致，防止数据刷新过快导致 1602 屏幕闪烁 */</span></span><br><span class="line">      <span class="type">int</span> distance_now = (<span class="type">int</span>)distance;</span><br><span class="line">      <span class="keyword">if</span> (distance_now != Distance) &#123;</span><br><span class="line">        LCD.setCursor(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        LCD.<span class="built_in">printf</span>(<span class="string">&quot;%d mm   &quot;</span>, distance_now);  <span class="comment">// 将距离值显示到 1602 屏幕</span></span><br><span class="line">        Distance = distance_now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="伺服舵机-esp32servo-库">伺服舵机 &amp; ESP32Servo 库</h1><p>航模玩家经常使用到的<strong>舵机</strong>，本质上是一种低成本的<strong>伺服电机</strong>（Servomotor）系统。其工作原理是通过内部的控制电路接收PWM脉冲宽度调制信号，然后控制内置电机转动，内置电机带动一系列的<strong>减速齿轮</strong>组把扭矩传递至<strong>输出轴</strong>和<strong>舵盘</strong>。<strong>输出轴</strong>会与用于反馈角度位置的<strong>电位器</strong>相互连接，当舵盘转动的时候，同时会带动<strong>电位器</strong>输出一个电压信号，反馈至舵机内部的控制电路，然后控制电路根据其位置决定舵机转动的<code>角度</code>或者<code>速度</code>。</p><p><img src="/Project/Arduino-ESP32/21.png"></p><p>根据控制电路的不同，可以将舵机划分为<strong>数字舵机</strong>和<strong>模拟舵机</strong>两种类型。而根据旋转角度的不同，也可以将其进一步划分为<code>180°</code> 舵机和 <code>360°</code> 舵机两种类型：</p><ul><li><code>180°</code> 舵机：可以通过脉冲宽度调制 PWM信号控制旋转角度（从 <code>0°</code> 度到 <code>180°</code> 度）。</li><li><code>360°</code> 舵机：可以 <code>360°</code>度转动，只能调节<strong>转动速度</strong>，不能调节<strong>转动角度</strong>。</li></ul><p>舵机的<strong>控制信号</strong>是一个周期为 <code>20</code> 毫秒的PWM 信号，其中脉冲宽度介于 <code>0.5 ~ 2.5</code>毫秒范围之间，与其对应的线性旋转角度为<code>0° ~ 180°</code>。换而言之，舵机会根据 PWM信号的脉冲宽度，将输出轴旋转到一个指定的角度上面：</p><p><img src="/Project/Arduino-ESP32/22.png"></p><p>在接下来的列表当中，分别介绍了舵机非常重要的 4 个性能参数：</p><ol type="1"><li><strong>力矩</strong>：用于表示<strong>力</strong>对物体作用时所产生<strong>转动效应大小</strong>的物理量（即<strong>力</strong><code>F</code> 与<strong>力臂</strong> <code>r</code>的乘积），其单位为<strong>牛顿·米</strong>（<code>N·m</code>）。</li><li><strong>失速力矩</strong>：指<strong>转动轴</strong>在被外力锁定的情况下，以目标温升作为约束，可以连续输出力矩的最大值，有时候也将其称为<strong>堵转力矩</strong>（<code>堵转力矩</code>通常高于<code>额定力矩</code>）。该参数的单位为<strong>千克·厘米</strong>（<code>Kg·cm</code>），即舵机发生堵转的时候，<code>1</code>厘米的力臂所能够提起的最大质量。</li><li><strong>动作死区</strong>：该参数用于描述舵机的旋转精度，因为舵机内部的基准电路会产生周期为<code>20</code> 微秒，脉冲宽度为 <code>1.5</code>微秒的基准信号。通过内置的比较器，将控制信号与这个基准信号进行比较，从而判断出旋转的角度。但是舵机在实际工作当中，难以<strong>完全精确</strong>的控制角度，而比较器的存在又势必会导致舵机在停止点附近往复振荡，因而就需要舵机的控制电路将这个误差值吸收掉，这就是动作死区。常见小型舵机的死区时间为<code>5</code> 微秒（对应角度为 <code>0.45°</code>度），即如果想将舵机旋转 <code>45°</code> 度，其真正的停止位置会介于<code>45° ± 0.45°</code> 范围之间。</li><li><strong>反应转速</strong>：舵机在无负载的情况下，转动<code>60°</code> 度所需要的时间。</li></ol><p><img src="/Project/Arduino-ESP32/23.png"></p><p>下面的两个表格，分别展示了采用<strong>塑料</strong>齿轮和传动轴的通用型<strong>SG90</strong>微型舵机（上图左）的性能参数，以及采用<strong>金属</strong>齿轮和传动轴的通用型<strong>MG996R</strong> 小型舵机（上图右）的性能参数：</p><table><thead><tr class="header"><th style="text-align: left;">SG90 舵机性能参数</th><th style="text-align: left;">参数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>旋转角度</strong></td><td style="text-align: left;"><code>180° (± 15°)</code></td></tr><tr class="even"><td style="text-align: left;"><strong>工作电压</strong></td><td style="text-align: left;"><code>4.8 V ~ 6 V</code> (典型值为<code>5 V</code>)</td></tr><tr class="odd"><td style="text-align: left;"><strong>空载电流</strong></td><td style="text-align: left;"><code>10 mA</code></td></tr><tr class="even"><td style="text-align: left;"><strong>转动电流</strong></td><td style="text-align: left;"><code>100 mA ~ 250 mA</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>堵转电流</strong></td><td style="text-align: left;"><code>360 mA</code></td></tr><tr class="even"><td style="text-align: left;"><strong>失速力矩</strong></td><td style="text-align: left;"><code>1.7 Kg·cm</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>转动速度</strong></td><td style="text-align: left;"><code>0.12 秒 / 60°</code></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">MG996R 舵机性能参数</th><th style="text-align: left;">参数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>旋转角度</strong></td><td style="text-align: left;"><code>180° (± 10°)</code></td></tr><tr class="even"><td style="text-align: left;"><strong>工作电压</strong></td><td style="text-align: left;"><code>4.8 V ~ 6 V</code> (典型值为<code>5 V</code>)</td></tr><tr class="odd"><td style="text-align: left;"><strong>空载电流</strong></td><td style="text-align: left;"><code>10 mA</code></td></tr><tr class="even"><td style="text-align: left;"><strong>转动电流</strong></td><td style="text-align: left;"><code>170 mA ~ 400 mA</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>堵转电流</strong></td><td style="text-align: left;"><code>1.3 A ~ 1.5 A</code></td></tr><tr class="even"><td style="text-align: left;"><strong>失速力矩</strong></td><td style="text-align: left;"><code>13 Kg·cm</code></td></tr><tr class="odd"><td style="text-align: left;"><strong>转动速度</strong></td><td style="text-align: left;"><code>0.2 秒 / 60°</code></td></tr></tbody></table><p><a href="https://github.com/madhephaestus/ESP32Servo"><strong>ESP32Servo</strong></a>库实现了 <strong>Arduino</strong> 官方舵机驱动库 <a href="https://www.arduino.cc/reference/en/libraries/servo/"><strong>Servo</strong></a>的全部功能，可以直接在 <strong>Arduino IDE</strong>的【库管理器】当中搜索安装，其主要 API 如下面的表格所示：</p><table><colgroup><col style="width: 12%"><col style="width: 87%"></colgroup><thead><tr class="header"><th style="text-align: left;">API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>Servo</code></td><td style="text-align: left;">用于操作连接到<strong>UINIO-MCU-ESP32</strong> 引脚的舵机对象。</td></tr><tr class="even"><td style="text-align: left;"><code>int attach(pin, min, max)</code></td><td style="text-align: left;">将指定的 GPIO 引脚关联到 1 个 <strong>LEDC通道</strong>，并且返回通道编号（如果失败返回 <code>0</code>）。其中参数<code>min</code> 的最小取值为 <code>500</code>（默认值为<code>544us</code>），而 <code>max</code> 的最大取值为<code>2500</code>（默认值为 <code>2400us</code>）。</td></tr><tr class="odd"><td style="text-align: left;"><code>void write()</code></td><td style="text-align: left;">指定舵机的旋转角度（<code>0°~180°</code>）。</td></tr><tr class="even"><td style="text-align: left;"><code>void writeMicroseconds()</code></td><td style="text-align: left;">以<code>微秒</code>作为单位设置脉冲宽度（必须设置）。</td></tr><tr class="odd"><td style="text-align: left;"><code>int read()</code></td><td style="text-align: left;">获取之前写入舵机的<strong>旋转角度</strong>（<code>0°~180°</code>）。</td></tr><tr class="even"><td style="text-align: left;"><code>int readMicroseconds()</code></td><td style="text-align: left;">获取之前写入舵机的<strong>脉冲宽度</strong>（以<code>微秒</code>为单位）。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool attached()</code></td><td style="text-align: left;">如果舵机对象 <code>Servo</code> 成功绑定至<strong>UINIO-MCU-ESP32</strong> 的 GPIO 引脚，那么就会返回<code>true</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>void detach()</code></td><td style="text-align: left;">停止绑定 <code>Servo</code> 对象到 GPIO引脚，并且释放对于 LEDC 通道的占用。</td></tr><tr class="odd"><td style="text-align: left;"><code>setTimerWidth(value)</code></td><td style="text-align: left;">设置 PWM 定时器输出的脉冲宽度。</td></tr><tr class="even"><td style="text-align: left;"><code>int readTimerWidth()</code></td><td style="text-align: left;">获取 PWM 定时器输出的脉冲宽度。</td></tr></tbody></table><p>在使用上面表格当中的 <code>void write()</code>函数指定舵机旋转角度的时候，传入的参数值会遵循如下的自动转换规则：</p><table><thead><tr class="header"><th style="text-align: left;">API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>&lt; 0</code></td><td style="text-align: left;"><code>0</code></td></tr><tr class="even"><td style="text-align: left;"><code>0 - 180</code></td><td style="text-align: left;"><code>value</code> (以度数为单位)</td></tr><tr class="odd"><td style="text-align: left;"><code>181 - 499</code></td><td style="text-align: left;"><code>180</code></td></tr><tr class="even"><td style="text-align: left;"><code>500 - (min-1)</code></td><td style="text-align: left;"><code>min</code></td></tr><tr class="odd"><td style="text-align: left;"><code>min - max</code></td><td style="text-align: left;"><code>value</code> (以微秒为单位)</td></tr><tr class="even"><td style="text-align: left;"><code>(max + 1) - 2500</code></td><td style="text-align: left;"><code>max</code></td></tr></tbody></table><p>下面的伪代码简洁的演示了 <strong>ESP32Servo</strong>库的基本使用步骤，以及相关的重要 API 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo Servo_1;                                <span class="comment">// 声明 Servo 对象</span></span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;                             <span class="comment">// 舵机 0° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;                            <span class="comment">// 舵机 180° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Servo_1_Pin = <span class="number">15</span>;                         <span class="comment">// 声明需要绑定到 Servo 对象的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">ESP32PWM::allocateTimer(<span class="number">1</span>);                   <span class="comment">// 指定生成 PWM 信号所使用的定时器</span></span><br><span class="line">Servo_1.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 指定 PWM 信号的频率</span></span><br><span class="line">Servo_1.attach(Servo_1_Pin, Min_Us, Max_Us);  <span class="comment">// 将 Servo 对象绑定到指定的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">Servo_1.write(postion);                       <span class="comment">// 发出 PWM 信号，让舵机旋转 0° ~ 180° 度</span></span><br><span class="line"></span><br><span class="line">Servo_1.detach();                             <span class="comment">// 停止绑定 Servo 对象到 GPIO 引脚，并且释放对 LEDC 通道的占用</span></span><br></pre></td></tr></table></figure><p><strong>ESP32Servo</strong> 库的底层运用了<strong>定时器</strong>和<strong>LEDC</strong> 来控制 PWM 信号的生成，其中<strong>ESP32-C3</strong> 拥有 4 个<strong>定时器</strong>与 6 个独立的<strong>PWM 通道</strong>，而 <strong>ESP32-S3</strong> 同样拥有 4个<strong>定时器</strong>以及 8 个独立的 <strong>PWM通道</strong>，具体可以参见下面的示意图：</p><p><img src="/Project/Arduino-ESP32/24.png"></p><p>舵机通常拥有 <code>PWM</code>、<code>VCC</code>、<code>GND</code>三路外接引脚，其中 <code>VCC</code> 需要连接到一个独立的 <code>5V</code>电源（确保工作电流稳定），而舵机的 <code>GND</code> 引脚需要与<strong>UINIO-MCU-ESP32</strong> 的 <code>GND</code>形成<strong>共地</strong>连接（作为 PWM 信号的电平基准），除此之外的<code>PWM</code> 则是属于用来输入 PWM 控制信号的引脚：</p><p><img src="/Project/Arduino-ESP32/25.png"></p><p>例如 <strong>SG90</strong> 和 <strong>MG996R</strong>型舵机的<strong>黄/橙色</strong>、<strong>红色</strong>、<strong>棕色</strong>杜邦线，就分别对应着舵机的<code>PWM</code>、<code>VCC</code>、<code>GND</code> 引脚。接下来，通过<strong>UINIO-MCU-ESP32</strong> 控制两个 <strong>SG90</strong>微型舵机，分别将两个舵机的 <code>PWM</code> 信号线连接至<strong>UINIO-MCU-ESP32</strong> 的 <code>GPIO9</code> 和<code>GPIO10</code> 引脚：</p><p><img src="/Project/Arduino-ESP32/26.png"></p><p>下面的这份示例代码，可以使得两个 <strong>SG90</strong> 微型舵机分别从<code>0°</code> 旋转到 <code>180°</code> 度，以及从 <code>180°</code>旋转到 <code>0°</code> 度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明 Servo 对象 */</span></span><br><span class="line">Servo Servo_1;</span><br><span class="line">Servo Servo_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要绑定到 Servo 对象的 GPIO 引脚 */</span></span><br><span class="line"><span class="type">int</span> Servo_1_Pin = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> Servo_2_Pin = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;   <span class="comment">// 舵机 0° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;  <span class="comment">// 舵机 180° 度时发出的脉冲宽度（单位为微秒）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Postion = <span class="number">-1</span>;   <span class="comment">// 声明舵机位置变量</span></span><br><span class="line"><span class="type">bool</span> UP = <span class="literal">true</span>;     <span class="comment">// 用于判断 Postion 变量是向上还是向下进行计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  ESP32PWM::allocateTimer(<span class="number">1</span>);                   <span class="comment">// 指定使用 1 号定时器生成 PWM 信号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置舵机 1 的 PWM 控制信号 */</span></span><br><span class="line">  Servo_1.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 设置 PWM 信号频率为 50 Hz</span></span><br><span class="line">  Servo_1.attach(Servo_1_Pin, Min_Us, Max_Us);  <span class="comment">// 把 Servo 对象绑定至指定 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置舵机 2 的 PWM 控制信号 */</span></span><br><span class="line">  Servo_2.setPeriodHertz(<span class="number">50</span>);                   <span class="comment">// 设置 PWM 信号频率为 50 Hz</span></span><br><span class="line">  Servo_2.attach(Servo_2_Pin, Min_Us, Max_Us);  <span class="comment">// 把 Servo 对象绑定至指定 GPIO 引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 基于当前位置判断 Postion 变量是向上还是向下计数 */</span></span><br><span class="line">  <span class="keyword">if</span> (Postion == <span class="number">181</span>) &#123;</span><br><span class="line">    UP = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Postion == <span class="number">-1</span>) &#123;</span><br><span class="line">    UP = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据 UP 变量的计数方向，对 Postion 变量进行加减 1 */</span></span><br><span class="line">  <span class="keyword">if</span> (UP) &#123;</span><br><span class="line">    Postion++;  <span class="comment">// 如果 Postion 变量是向上计数，那么每次执行角度就加 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Postion--;  <span class="comment">// 如果 Postion 变量是向下计数，那么每次执行角度就减 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Servo_1.write(Postion);        <span class="comment">// 让舵机 1 从 0° 旋转到 180° 度</span></span><br><span class="line">  Servo_2.write(<span class="number">180</span> - Postion);  <span class="comment">// 让舵机 2 从 180° 旋转到 0° 度</span></span><br><span class="line"></span><br><span class="line">  delay(<span class="number">15</span>);  <span class="comment">// 每间隔 15 毫秒执行一次 loop 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：由于 <strong>UINIO-MCU-ESP32C3</strong>采用了两线制 SPI 的 <strong>DIO</strong>模式，因而在运行上述示例程序的时候，需要将 <strong>Arduino IDE</strong>的 【Flash Mode】设置为 <code>DIO</code>模式，否则会导致舵机程序无法正常工作。除此之外，因为<strong>UINIO-MCU-ESP32C3</strong> 的第<code>GPIO11</code>、<code>GPIO12</code>、<code>GPIO13</code>引脚已经被用作 Flash 的 SPI 电源和信号引脚，所以无法用于控制舵机。</p></blockquote><h1 id="由多份源文件组成的草图工程">由多份源文件组成的草图工程</h1><p>本节内容将会综合运用之前介绍过的 <strong>SG90</strong> 舵机和<strong>HC-SR04</strong> 超声波模组，基于<strong>UINIO-MCU-ESP32S3</strong> 实现一个能够自动打开盒盖的<code>UINIO-Auto-Box</code>智能收纳盒子项目，这里假设盒盖关闭时候舵机的角度为 <code>0°</code>度，而盒盖打开时候舵机的角度为 <code>90°</code>度。当用手遮挡住超声波探头的时候，舵机旋转 <code>90°</code>度打开盒盖。而当手离开之后，舵机就会回到 <code>0°</code>度位置，表示已经自动关闭盒盖。</p><p><img src="/Project/Arduino-ESP32/27.png"></p><ul><li>把 <strong>SG90</strong> 舵机的 <code>VCC</code> 引脚连接到<strong>UINIO-MCU-ESP32S3</strong> 的 <code>5V</code> 引脚，而<code>PWM</code> 引脚连接到 <code>GPIO7</code> 引脚，除此之外两者的<code>GND</code> 相互连接形成共地关系。</li><li>把 <strong>HC-SR04</strong> 舵机的 <code>VCC</code> 引脚连接到<strong>UINIO-MCU-ESP32S3</strong> 的 <code>3V3</code> 引脚，而<code>Trig</code> 引脚连接至 <code>GPIO6</code>，<code>Echo</code>引脚连接至 <code>GPIO5</code>，同样 <code>GND</code>相互连接形成共地关系。</li></ul><p>打开 <strong>Arduino IDE</strong> 新建一个名为<code>UINIO-Auto-Box</code> 的草图工程，其主程序会被自动命名为<code>UINIO-Auto-Box.ino</code>，然后手动添加<strong>超声波传感器</strong>相关的<code>Sonar.h</code> 与 <code>Sonar.cpp</code>源文件，<strong>盒盖</strong>控制相关的 <code>Cover.h</code> 与<code>Cover.cpp</code> 源文件，以及<strong>舵机</strong>控制相关的<code>Servo.h</code> 与 <code>Servo.cpp</code>源文件，最后生成的工程结构如下面所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspace\UINIO-Auto-Box</span><br><span class="line">λ <span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 1458  7月 25 17:37 Cover.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  394  7月 25 17:37 Cover.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  492  7月 25 17:37 Servo.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  183  7月 25 17:37 Servo.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 2446  7月 25 17:37 Sonar.cpp</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089  275  7月 25 17:37 Sonar.h</span><br><span class="line">-rw-r--r-- 1 UinIO.com 1049089 1459  7月 25 17:37 UINIO-Auto-Box.ino</span><br></pre></td></tr></table></figure><ul><li><strong>C/C++</strong> 的全局变量可以定义在 <code>.cpp</code>源文件当中，然后在对应的 <code>.h</code> 头文件当中将其声明为<code>extern</code> 外部变量。</li><li><strong>Arduino IDE</strong> 会自动为 <code>.ino</code>草图文件添加依赖的头文件，而在 <code>.h</code> 和 <code>.cpp</code>源文件当中使用<strong>信号量</strong>相关的方法时，就需要手动包含源文件<code>#include &lt;freertos/FreeRTOS.h&gt;</code> 和<code>#include &lt;freertos/semphr.h&gt;</code>，并且<code>#include &lt;freertos/FreeRTOS.h&gt;</code> 必须放置在<code>&lt;freertos/semphr.h&gt;</code>之前。而在使用<strong>定时器</strong>相关的方法时，则需要手动包含源文件<code>#include &lt;esp32-hal-timer.h&gt;</code>。</li><li>必须将 <strong>Arduino IDE</strong> 的【工具】设置为<code>Events Run On: "Core 0"</code> 和<code>Arduino Runs On: "Core 1"</code>，才能够正确的运行本节的示例程序。</li></ul><blockquote><p><strong>注意</strong>：由于 <strong>UINIO-MCU-ESP32C3</strong> 属于RISC-V架构的<strong>单核</strong>微控制器，所以无法正常运行本节的示例程序。如果强行上传示例程序，串口会打印出错误信息：<code>Guru Meditation Error: Core 0 panic'ed (Load access fault). Exception was unhandled.</code>。</p></blockquote><h2 id="uinio-auto-box.ino">UINIO-Auto-Box.ino</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== 主程序 ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sonar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cover.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;  <span class="comment">// 定义全局自旋锁变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开盒盖的函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openCover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> send = <span class="literal">false</span>;     <span class="comment">// 用于判断本次是否向舵机发送命令</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL</span>(&amp;mux);</span><br><span class="line">  <span class="comment">/* 如果 OpenTime 等于 0 表示盒盖没有打开 */</span></span><br><span class="line">  <span class="keyword">if</span> (OpenTime == <span class="number">0</span>) &#123;</span><br><span class="line">    send = <span class="literal">true</span>;         <span class="comment">// 可以向舵机发送打开盒盖的命令</span></span><br><span class="line">  &#125;</span><br><span class="line">  OpenTime = <span class="built_in">micros</span>();   <span class="comment">// 更新当前盒盖打开的时间</span></span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL</span>(&amp;mux);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断当前是否需要向舵机发送命令 */</span></span><br><span class="line">  <span class="keyword">if</span> (send) &#123;</span><br><span class="line">    MyServo.<span class="built_in">write</span>(<span class="number">90</span>);  <span class="comment">// 向舵机发送打开盒盖的信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭盒盖的函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closeCover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyServo.<span class="built_in">write</span>(<span class="number">0</span>);      <span class="comment">// 向舵机发送关闭盒盖的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Servo_Init</span>();             <span class="comment">// 初始化舵机</span></span><br><span class="line">  <span class="built_in">Sonar_Init</span>(&amp;mux);         <span class="comment">// 初始化超声波模组</span></span><br><span class="line">  <span class="built_in">Cover_Detect_Init</span>(&amp;mux);  <span class="comment">// 初始化盒盖关闭</span></span><br><span class="line">  <span class="built_in">closeCover</span>();             <span class="comment">// 盒盖初始状态为关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 循环检测打开盒盖的信号 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(Open_Semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开盒盖&quot;</span>);</span><br><span class="line">    <span class="built_in">openCover</span>();           <span class="comment">// 打开盒盖</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环检测关闭盒盖的信号 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(Close_Semaphore, <span class="number">0</span>) == pdTRUE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;关闭盒盖&quot;</span>);</span><br><span class="line">    <span class="built_in">closeCover</span>();          <span class="comment">// 关闭盒盖</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cover.h-与-cover.cpp">Cover.h 与 Cover.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Cover.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/FreeRTOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/semphr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;esp32-hal-timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头文件中使用 extern 关键字将全局变量声明为可供 UINIO-Auto-Box.ino 主程序调用的外部变量 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> OpenTime;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> SemaphoreHandle_t Close_Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover_Detect_Init</span><span class="params">(portMUX_TYPE* mux)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Cover.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Cover.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">hw_timer_t</span>* CoverTimer = <span class="literal">NULL</span>;               <span class="comment">// 关闭盒盖的定时器</span></span><br><span class="line"><span class="type">static</span> portMUX_TYPE* _mux = <span class="literal">NULL</span>;            <span class="comment">// 用于接收全局自旋锁的变量</span></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t Close_Semaphore;  <span class="comment">// 关闭盒盖的信号量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> OpenTime = <span class="number">0</span>;         <span class="comment">// 打开盒盖的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 盒盖关闭检测 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">detectCoverClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(_mux);</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">micros</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果前当时间 now 减去打开盒盖的时间大于或等于 4 秒（即障碍物离开超声波传感器已经 4 秒以上），</span></span><br><span class="line"><span class="comment">     并且 OpenTime 不等于 0（即盒盖处于开启状态）*/</span></span><br><span class="line">  <span class="keyword">if</span> (OpenTime != <span class="number">0</span> &amp;&amp; (now - OpenTime) &gt;= <span class="number">4000000</span>) &#123;</span><br><span class="line">    OpenTime = <span class="number">0</span>;                                  <span class="comment">// 让 OpenTime 变量重新归零</span></span><br><span class="line">    <span class="built_in">xSemaphoreGiveFromISR</span>(Close_Semaphore, <span class="literal">NULL</span>);  <span class="comment">// 发送关闭盒盖的信号</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(_mux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 盒盖开关检测的初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover_Detect_Init</span><span class="params">(portMUX_TYPE* mux)</span> </span>&#123;</span><br><span class="line">  _mux = mux;                                  <span class="comment">// 接收全局自旋锁变量，同步临界区资源访问</span></span><br><span class="line">  Close_Semaphore = <span class="built_in">xSemaphoreCreateBinary</span>();  <span class="comment">// 定义二值信号量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定义硬件定时器，每 500 毫秒执行 1 次盒盖关闭检测程序 */</span></span><br><span class="line">  CoverTimer = <span class="built_in">timerBegin</span>(<span class="number">2</span>, <span class="number">80</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAttachInterrupt</span>(CoverTimer, detectCoverClose, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmWrite</span>(CoverTimer, <span class="number">500000</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmEnable</span>(CoverTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="servo.h-与-servo.cpp">Servo.h 与 Servo.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Servo.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Servo MyServo;  <span class="comment">// 声明舵机对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Servo_Init</span><span class="params">()</span></span>;     <span class="comment">// 将舵机初始化函数声明为外部变量</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Servo.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//舵机部分</span></span><br><span class="line">Servo MyServo;</span><br><span class="line"><span class="type">int</span> Min_Us = <span class="number">500</span>;    <span class="comment">// 单位为微秒</span></span><br><span class="line"><span class="type">int</span> Max_Us = <span class="number">2500</span>;   <span class="comment">// 单位为微秒</span></span><br><span class="line"><span class="type">int</span> Servo_Pin = <span class="number">7</span>;  <span class="comment">// 声明需要绑定到 Servo 对象的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 舵机初始化函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Servo_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ESP32PWM::<span class="built_in">allocateTimer</span>(<span class="number">1</span>);                 <span class="comment">// 指定生成 PWM 信号所使用的定时器</span></span><br><span class="line">  MyServo.<span class="built_in">setPeriodHertz</span>(<span class="number">50</span>);                 <span class="comment">// 指定 PWM 信号的频率为 50Hz</span></span><br><span class="line">  MyServo.<span class="built_in">attach</span>(Servo_Pin, Min_Us, Max_Us);  <span class="comment">// 将 MyServo 对象绑定到指定的 GPIO 引脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sonar.h-与-sonar.cpp">Sonar.h 与 Sonar.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Sonar.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;esp32-hal-timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/semphr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/FreeRTOS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> SemaphoreHandle_t Open_Semaphore;  <span class="comment">// 将打开盒盖的信号量声明为外部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sonar_Init</span><span class="params">(portMUX_TYPE* mux)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Sonar.cpp ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sonar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> SemaphoreHandle_t Open_Semaphore;  <span class="comment">// 声明打开盒盖的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Echo_Pin = <span class="number">5</span>;  <span class="comment">// 指定 Echo 引脚</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Trig_Pin = <span class="number">6</span>;  <span class="comment">// 指定 Trig 引脚</span></span><br><span class="line"><span class="type">int</span> Distance = <span class="number">0</span>;        <span class="comment">// 距离变量（厘米）</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> portMUX_TYPE* _mux = <span class="literal">NULL</span>;      <span class="comment">// 用于接收全局自旋锁的变量</span></span><br><span class="line"><span class="type">hw_timer_t</span>* SonarTimer = <span class="literal">NULL</span>;         <span class="comment">// 硬件定时器指针变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> StartTime = <span class="number">0</span>;  <span class="comment">// 发出超声波的时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> EndTime = <span class="number">0</span>;    <span class="comment">// 接收到超声波的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬件定时器中断服务程序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">Ping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(Trig_Pin, HIGH);</span><br><span class="line">  <span class="built_in">delayMicroseconds</span>(<span class="number">15</span>);               <span class="comment">// 通过延时 15 微秒产生脉冲信号</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Trig_Pin, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Echo 引脚的中断服务程序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">changeISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">micros</span>();  <span class="comment">//当前时间</span></span><br><span class="line">  <span class="keyword">auto</span> state = <span class="built_in">digitalRead</span>(Echo_Pin);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">portENTER_CRITICAL_ISR</span>(_mux);</span><br><span class="line">  <span class="comment">/* 如果 state 变量为低电平，表示刚刚发送出超声波 */</span></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    StartTime = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EndTime = now;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 state 变量为低电平，表示已经收到超声波响应 */</span></span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    <span class="keyword">auto</span> time = EndTime - StartTime;                <span class="comment">// 计算出脉冲宽度时间</span></span><br><span class="line">    <span class="keyword">auto</span> distance = time * <span class="number">0.01715</span>;                 <span class="comment">// 计算出实际距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当检测到的距离小于 10cm 的时候 */</span></span><br><span class="line">    <span class="keyword">if</span> (distance &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="built_in">xSemaphoreGiveFromISR</span>(Open_Semaphore, <span class="literal">NULL</span>);  <span class="comment">// 向主程序发送打开盒盖的信号</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">portEXIT_CRITICAL_ISR</span>(_mux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化超声波测距模块 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sonar_Init</span><span class="params">(portMUX_TYPE* mux)</span> </span>&#123;</span><br><span class="line">  _mux = mux;                                 <span class="comment">// 接收全局自旋锁变量，同步临界区资源访问</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Trig_Pin, OUTPUT);                  <span class="comment">// 配置 Trig 引脚的工作模式</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Echo_Pin, INPUT);                   <span class="comment">// 配置 Echo 引脚的工作模式</span></span><br><span class="line">  Open_Semaphore = <span class="built_in">xSemaphoreCreateBinary</span>();  <span class="comment">// 创建打开盒盖的信号量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 测距定时器，每 200 毫秒检测一次距离 */</span></span><br><span class="line">  SonarTimer = <span class="built_in">timerBegin</span>(<span class="number">0</span>, <span class="number">80</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAttachInterrupt</span>(SonarTimer, Ping, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">timerAlarmWrite</span>(SonarTimer, <span class="number">200000</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">attachInterrupt</span>(<span class="built_in">digitalPinToInterrupt</span>(Echo_Pin), changeISR, CHANGE);  <span class="comment">// 添加 Echo 引脚的中断服务程序</span></span><br><span class="line">  <span class="built_in">timerAlarmEnable</span>(SonarTimer);                                         <span class="comment">// 开始反复进行周期性的检测</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spi-总线主从通信">SPI 总线主从通信</h1><h2 id="spi-总线协议原理">SPI 总线协议原理</h2><p><strong>串行外设接口</strong>（<strong>SPI</strong>，SerialPeripheralInterface）是一种高速、全双工、同步通信总线，其优点在于支持全双工通信（可以同时进行数据的接收与发送），数据传输速率相对I²C总线更加迅速，不过其缺点在于没有应答机制（无法判断数据是否准确收发）。</p><p>SPI总线通信协议只允许<strong>一个主设备</strong>，但是可以存在<strong>多个从设备</strong>，其一共拥有着四条物理信号线：</p><ul><li><strong>SCLK</strong> (SerialClock)：用于主设备向从设备传输时钟信号，也被称作 <code>SCK</code>；</li><li><strong>MOSI</strong> (Master Output SlaveInput)：<code>主设备</code><strong>输出</strong>，<code>从设备</code><strong>输入</strong>，也称为<strong>SDO</strong> (Slave Device Output)；</li><li><strong>MISO</strong> (Master Input SlaveOutput)：<code>主设备</code><strong>输入</strong>，<code>从设备</code><strong>输出</strong>，也称为<strong>SDI</strong> (Slave Device Input)；</li><li><strong>CS</strong> (ChipSelect)：片选信号线，由主设备控制（<strong>低电平</strong>有效），用于选择当前需要通信的从设备，也被称作<strong>SS</strong> (Slave Select)；</li></ul><p>除了 <strong>CS/SS</strong> 片选信号线需要每一台 <code>从设备</code>都与 <code>主设备</code> 进行单独连接之外，其它的<strong>SCLK/SCK</strong>、<strong>MOSI/SDO</strong>、<strong>MISO/SDI</strong>三条信号线都分别各自连接到一起：</p><p><img src="/Project/Arduino-ESP32/28.png"></p><p>SPI总线上的主设备与从设备都分别内置有<strong>串行移位寄存器</strong>，主设备向该寄存器写入<code>1</code> 个字节数据，就会进行一次数据传输：</p><p><img src="/Project/Arduino-ESP32/29.png"></p><ol type="1"><li>将指定<strong>从设备</strong>的 <code>CS</code>片选信号线拉低，开始与其进行通信。</li><li><strong>主设备</strong>发出 <code>SCLK</code>时钟信号，开始准备对<strong>从设备</strong>进行读写操作（时钟信号是<code>高电平</code>还是<code>低电平</code>有效，称为<strong>时钟极性</strong>）。</li><li><strong>主设备</strong>把待发送的数据写入到<strong>发送缓冲区</strong>，然后通过过<code>串行移位寄存器</code>，将数据从<code>MOSI</code>信号线逐位发送给<strong>从设备</strong>；同时<strong>主设备</strong>也可以把<code>MISO</code>信号线上待接收的<strong>从设备</strong>数据，同样通过<code>串行移位寄存器</code>逐位移动到<strong>接收缓冲区</strong>。</li><li><strong>从设备</strong>也会把自己<code>串行移位寄存器</code>里的内容，通过<code>MISO</code>信号线返回给<strong>主设备</strong>；并且同样也可以通过<code>MOSI</code>信号线接收<strong>主设备</strong>发送过来的数据（数据是在时钟信号的上升沿还是下降沿处理，称为<strong>时钟相位</strong>）。</li><li>每经过 1 个 <code>SCLK</code> 时钟脉冲，SPI 总线上就可以接收或者发送<code>1bit</code> 数据。</li></ol><p>在上述 SPI通信过程当中，<strong>时钟极性</strong>和<strong>时钟相位</strong>是非常重要的两个概念：</p><ul><li><strong>时钟极性 CPOL</strong>（<strong>C</strong>lock<strong>Pol</strong>arity）：表示 SPI 总线空闲时，时钟线<code>SCLK</code> 处于高电平还是低电平；如果<code>CPOL = 0</code>，那么时钟信号在总线空闲时处于<strong>低电平</strong>；如果<code>CPOL = 1</code>，那么时钟信号在总线空闲时则处于<strong>高电平</strong>；</li><li><strong>时钟相位 CPHA</strong>（<strong>C</strong>lock<strong>Pha</strong>se）：表示处理 SPI 总线数据采样的时间点，如果<code>CPHA = 0</code>，那么在时钟信号 <code>SCLK</code> 的第 1个跳变沿<strong>采样</strong>，第 2个跳变沿<strong>被改变</strong>；如果<code>CPHA = 0</code>，那么在时钟信号 SCLK 的第 1个跳变沿<strong>被改变</strong>，第 2个跳变沿<strong>采样</strong>；</li></ul><p><img src="/Project/Arduino-ESP32/30.png"></p><blockquote><p><strong>注意</strong>：上图当中的<strong>红色竖线</strong>代表<strong>数据采样</strong>（Sampled）的位置，而蓝色代表<strong>数据被改变</strong>（Launched）的位置。</p></blockquote><p>根据 SPI总线的<strong>时钟极性</strong>与<strong>时钟相位</strong>，可以划分出四种不同的SPI总线通信工作模式，它们分别定义了在时钟信号的哪个边沿<strong>采样信号</strong>，哪个边沿<strong>改变信号</strong>：</p><table><thead><tr class="header"><th style="text-align: center;">模式</th><th style="text-align: center;">时钟极性与相位</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Mode 0</strong></td><td style="text-align: center;"><code>CPOL = 0</code>，<code>CPHA = 0</code></td></tr><tr class="even"><td style="text-align: center;"><strong>Mode 1</strong></td><td style="text-align: center;"><code>CPOL = 0</code>，<code>CPHA = 1</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>Mode 2</strong></td><td style="text-align: center;"><code>CPOL = 1</code>，<code>CPHA = 0</code></td></tr><tr class="even"><td style="text-align: center;"><strong>Mode 3</strong></td><td style="text-align: center;"><code>CPOL = 1</code>，<code>CPHA = 1</code></td></tr></tbody></table><p><img src="/Project/Arduino-ESP32/31.png"></p><p><img src="/Project/Arduino-ESP32/32.png"></p><p>除此之外，在 SPI串行通信过程当中，当前是<strong>最高有效位</strong>（<strong>MSB</strong>，MostSignificantBit）优先传输，还是<strong>最低有效位</strong>（<strong>LSB</strong>，LeastSignificantBit）优先传输是非常重要的两个关键因素，收发双方必须保持传输时序的一致：</p><ul><li><strong>最低有效位 (LSB) 优先</strong>：传输一个字节的时候从<strong>低位</strong>先进行传输；</li><li><strong>最高有效位 (MSB)优先</strong>：传输一个字节的时候从<strong>高位</strong>先进行传输；</li></ul><blockquote><p><strong>注意</strong>：SPI 通信涉及的所有 API函数都不能放置到中断服务程序当中，否则将会导致程序报错。</p></blockquote><h2 id="esp32c3-esp32s3-的-spi-外设">ESP32C3 &amp; ESP32S3 的 SPI外设</h2><p>由于乐鑫早期的 <strong>ESP32</strong> 芯片（例如<code>ESP32-D0WD-V3</code>、<code>ESP32-D2WD</code>、<code>ESP32-S0WD</code>、<code>ESP32-U4WDH</code>），分别使用了<strong>HSPI</strong> 和 <strong>VSPI</strong> 来指代 <code>SPI2</code>和 <code>SPI3</code> 外设：</p><p><img src="/Project/Arduino-ESP32/33.png"></p><p>官方的 <strong>Arduino-ESP32</strong>库出于兼容性考虑延续了这种叫法，它们默认的 GPIO引脚编号，如下面的表格所示：</p><table style="width:100%;"><colgroup><col style="width: 11%"><col style="width: 29%"><col style="width: 29%"><col style="width: 16%"><col style="width: 13%"></colgroup><thead><tr class="header"><th style="text-align: center;">分类</th><th style="text-align: center;">主机输入从机输出引脚</th><th style="text-align: center;">主机输出从机输入引脚</th><th style="text-align: center;">时钟引脚</th><th style="text-align: center;">片选引脚</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>VSPI</strong></td><td style="text-align: center;"><code>MISO = 19</code></td><td style="text-align: center;"><code>MOSI = 23</code></td><td style="text-align: center;"><code>SCLK = 18</code></td><td style="text-align: center;"><code>CS = 5</code></td></tr><tr class="even"><td style="text-align: center;"><strong>HSPI</strong></td><td style="text-align: center;"><code>MISO = 12</code></td><td style="text-align: center;"><code>MOSI = 13</code></td><td style="text-align: center;"><code>SCLK = 14</code></td><td style="text-align: center;"><code>CS = 15</code></td></tr></tbody></table><p><strong>ESP32-C3</strong> 芯片集成有<code>SPI0</code>、<code>SPI1</code>、<code>SPI2</code> 三个 SPI总线控制器，因为 <code>SPI0</code> 和 <code>SPI1</code> 主要用于访问外部Flash 以及 PSRAM，所以仅有 <code>SPI2</code> 可以供用户配置使用（即<strong>GP-SPI2</strong>）。</p><p><img src="/Project/Arduino-ESP32/34.png"></p><p>而 <strong>ESP32-S3</strong> 芯片集成有<code>SPI0</code>、<code>SPI1</code>、<code>SPI2</code>、<code>SPI3</code>四个 SPI 总线控制器，同样因为 <code>SPI0</code> 和 <code>SPI1</code>被用于访问外部 Flash 以及 PSRAM，所以仅有<code>SPI2</code>、<code>SPI3</code> 可以供用户配置使用（即<strong>GP-SPI2</strong> 和 <strong>GP-SPI3</strong>）。</p><p><img src="/Project/Arduino-ESP32/35.png"></p><p>观察上述 <strong>ESP32-C3</strong> 和 <strong>ESP32-S3</strong> 的SPI 系统框图可以发现，两者都将 <code>GP-SPI2</code> 称为<strong>FSPI</strong>（Fast SPI），因而在随后的主设备 SPI官方库示例代码当中，宏定义里才会出现 <code>#define VSPI FSPI</code>这样的语句。</p><blockquote><p><strong>注意</strong>：<strong>ESP32-C3</strong> 与<strong>ESP32-S3</strong>工作在<strong>主设备模式下</strong>的时钟频率都可以达到<code>80 MHz</code>，而工作在<strong>从设备模式</strong>下的时钟频率也可以达到<code>60 MHz</code>。</p></blockquote><h2 id="主设备-spi-官方库">主设备 SPI 官方库</h2><p><strong>Arduino-ESP32</strong> 封装的 SPI库已经提供了<strong>主设备</strong> SPI 总线通信的支持，使用时只需要包含<code>&lt;SPI.h&gt;</code> 头文件即可，相关的方法都已经被封装至<code>SPIClass</code> 类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPIClass *vspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);</span><br><span class="line">SPIClass *hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);</span><br></pre></td></tr></table></figure><p><strong>Arduino-ESP32</strong> 内部已经定义有一个<code>SPIClass SPI = new SPIClass(VSPI)</code>，可以在代码当中直接使用<code>SPI</code> 对象控制总线通信，下面的伪代码展示了 SPI主设备通信的基本过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SPIClass *SPI = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);  <span class="comment">// 创建 SPI 对象</span></span><br><span class="line">SPI-&gt;<span class="built_in">begin</span>();                        <span class="comment">// 使用默认引脚初始化 SPI 总线</span></span><br><span class="line"><span class="built_in">pinMode</span>(SPI-&gt;<span class="built_in">pinSS</span>()，OUTPUT);       <span class="comment">// 把片选引脚设置为数字输出模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 SPI 总线工作参数，时钟频率、高低位优先、时钟的极性与相位，然后开始 SPI 数据传输 */</span></span><br><span class="line">SPI-&gt;<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(spiClk，MSBFIRST，SPI_MODE0));</span><br><span class="line"><span class="built_in">digitalWrite</span>(SPI-&gt;<span class="built_in">pinSS</span>(), LOW);     <span class="comment">// 拉低片选信号</span></span><br><span class="line">SPI-&gt;<span class="built_in">transfer</span>(data);                 <span class="comment">// 开始传输数据</span></span><br><span class="line"><span class="built_in">digitalwrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), HIGH);    <span class="comment">// 拉高片选信号</span></span><br><span class="line"><span class="comment">/* 结束 SPI 数据传输 */</span></span><br><span class="line">SPI-&gt;<span class="built_in">endTransaction</span>();</span><br><span class="line"></span><br><span class="line">SPI-&gt;<span class="built_in">end</span>(); <span class="comment">// 释放当前 SPI 总线的资源占用</span></span><br></pre></td></tr></table></figure><p>下面的代码详细展示了 <strong>UINIO-MCU-ESP32S3</strong> 使用<strong>Arduino-ESP32</strong> 库进行 SPI 主设备通信的整个步骤，由于<strong>UINIO-MCU-ESP32C3</strong> 只存在一个 <code>HSPI</code>可以供用户配置使用，运行下面代码会导致<code>'VSPI' was not declared in this scope</code> 错误的出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALTERNATE_PINS  <span class="comment">// 预处理命令，用于判断是否启用自定义引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果预定义有 ALTERNATE_PINS，就使用自定义引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALTERNATE_PINS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MISO 2</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MOSI 4</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SCLK 0</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SS   33</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MISO 26</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MOSI 27</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SCLK 25</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SS   32</span></span><br><span class="line"><span class="comment">/* 否则就使用 VSPI 和 HSPI 对应的默认引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MISO MISO</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_MOSI MOSI</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SCLK SCK</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI_SS   SS</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MISO 12</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_MOSI 13</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SCLK 14</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HSPI_SS   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自动判断 IDF 编译的目标芯片是 ESP32-S2 还是 ESP32-S3 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> VSPI FSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> spiClk = <span class="number">1000000</span>;  <span class="comment">// 定义 SPI 总线的时钟频率为 1 MHz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明 SPIClass 类型的初始化指针 */</span></span><br><span class="line">SPIClass *vspi = <span class="literal">NULL</span>;</span><br><span class="line">SPIClass *hspi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 分别使用 HSPI 和 VSPI 初始化 SPIClass 实例 */</span></span><br><span class="line">  vspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(VSPI);</span><br><span class="line">  hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALTERNATE_PINS</span></span><br><span class="line">  vspi-&gt;<span class="built_in">begin</span>();  <span class="comment">// 初始化 VSPI，默认引脚 SCLK = 18, MISO = 19, MOSI = 23, SS = 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  vspi-&gt;<span class="built_in">begin</span>(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS);  <span class="comment">// 使用自定义引脚初始化 VSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALTERNATE_PINS</span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>();  <span class="comment">// 初始化 HSPI，默认引脚 SCLK = 14, MISO = 12, MOSI = 13, SS = 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS);  <span class="comment">// 使用自定义引脚初始化 HSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 VSPI 和 HSPI 的片选引脚为数字输出 */</span></span><br><span class="line">  <span class="built_in">pinMode</span>(vspi-&gt;<span class="built_in">pinSS</span>(), OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(hspi-&gt;<span class="built_in">pinSS</span>(), OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 通过 VSPI 和 HSPI 发送测试数据 */</span></span><br><span class="line">  <span class="built_in">spiCommand</span>(vspi, <span class="number">0b01010101</span>);</span><br><span class="line">  <span class="built_in">spiCommand</span>(hspi, <span class="number">0b11001100</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spiCommand</span><span class="params">(SPIClass *spi, byte data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//use it as you would the regular arduino SPI API</span></span><br><span class="line">  spi-&gt;<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(spiClk, MSBFIRST, SPI_MODE0));</span><br><span class="line">  <span class="built_in">digitalWrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), LOW);   <span class="comment">// 拉低片选引脚，准备传输数据</span></span><br><span class="line">  spi-&gt;<span class="built_in">transfer</span>(data);               <span class="comment">// 进行数据传输</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(spi-&gt;<span class="built_in">pinSS</span>(), HIGH);  <span class="comment">// 拉高片选引脚，结束数据传输</span></span><br><span class="line">  spi-&gt;<span class="built_in">endTransaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍一下 <strong>Arduino-ESP32</strong> 当中 SPI内置的相关方法，首先 <code>SPISettings</code> 类用于配置 SPI总线通信端口的相关参数（默认的<strong>时钟频率</strong><code>clock</code> 为 <code>1MHz</code>、<strong>传输顺序</strong><code>bitOrder</code> 为<code>高位优先</code>、<strong>时钟的极性与相位</strong>模式<code>dataMode</code> 为 <code>MODE0</code>）：</p><table><colgroup><col style="width: 42%"><col style="width: 57%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPISettings 构造函数</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)</code></td><td style="text-align: left;">SPI总线配置参数的载体，三个参数的默认值分别为<code>1000000</code>、<code>SPI_MSBFIRST</code>、<code>SPI_MODE0</code>。</td></tr></tbody></table><p>除此之外，<strong>Arduino-ESP32</strong> 库还通过<code>SPIClass</code> 类，提供了丰富的 SPI通信相关的工具函数，具体如下面的表格所示：</p><table><colgroup><col style="width: 58%"><col style="width: 41%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPIClass 中的主要 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void begin(int8_t sck=-1, int8_t miso=-1, int8_t mosi=-1, int8_t ss=-1)</code></td><td style="text-align: left;">初始化 SPI 总线。</td></tr><tr class="even"><td style="text-align: left;"><code>void end()</code></td><td style="text-align: left;">结束 SPI 总线的资源占用。</td></tr><tr class="odd"><td style="text-align: left;"><code>void beginTransaction(SPISettings settings)</code></td><td style="text-align: left;">使用 <code>SPISettings</code>作为参数，开始进行 SPI 总线通信。</td></tr><tr class="even"><td style="text-align: left;"><code>void endTransaction(void)</code></td><td style="text-align: left;">结束 SPI 总线通信。</td></tr><tr class="odd"><td style="text-align: left;"><code>int8_t pinSS()</code></td><td style="text-align: left;">返回 SPI 片选引脚。</td></tr></tbody></table><table><colgroup><col style="width: 44%"><col style="width: 55%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPIClass 中的 Transfer API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void transfer(void * data, uint32_t size)</code></td><td style="text-align: left;">发送 <code>size</code> 个字节的<code>data</code> 数据，但是并不会接收数据。</td></tr><tr class="even"><td style="text-align: left;"><code>uint8_t transfer(uint8_t data)</code></td><td style="text-align: left;">发送 1 个字节的 <code>data</code>数据，同时接收 1 个字节的数据。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint16_t transfer16(uint16_t data)</code></td><td style="text-align: left;">发送 2 个字节的 <code>data</code>数据，同时接收 2 个字节的数据。</td></tr><tr class="even"><td style="text-align: left;"><code>uint32_t transfer32(uint32_t data)</code></td><td style="text-align: left;">发送 4 个字节的 <code>data</code>数据，同时接收 4 个字节的数据。</td></tr><tr class="odd"><td style="text-align: left;"><code>void transferBytes(const uint8_t * data, uint8_t * out, uint32_t size)</code></td><td style="text-align: left;">接收 <code>size</code>个字节到<strong>读取缓冲区</strong> <code>data</code>，或者发送<code>size</code> 个字节到<strong>输出缓冲区</strong><code>out</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>void transferBits(uint32_t data, uint32_t * out, uint8_t bits)</code></td><td style="text-align: left;">接收 <code>size</code>位数据到<strong>读取缓冲区</strong> <code>data</code>，或者发送<code>size</code> 位数据到<strong>输出缓冲区</strong><code>out</code>。</td></tr></tbody></table><table><colgroup><col style="width: 39%"><col style="width: 60%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPIClass 中的 Write API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>void write(uint8_t data)</code></td><td style="text-align: left;">发送 1 个字节的 <code>data</code>数据，但是不会接收数据。</td></tr><tr class="even"><td style="text-align: left;"><code>void write16(uint16_t data)</code></td><td style="text-align: left;">发送 2 个字节的 <code>data</code>数据，但是不会接收数据。</td></tr><tr class="odd"><td style="text-align: left;"><code>void write32(uint32_t data)</code></td><td style="text-align: left;">发送 4 个字节的 <code>data</code>数据，但是不会接收数据。</td></tr><tr class="even"><td style="text-align: left;"><code>void writeBytes(const uint8_t * data, uint32_t size)</code></td><td style="text-align: left;">发送 <code>size</code> 个字节的<code>data</code> 数据，但是不会接收数据。</td></tr><tr class="odd"><td style="text-align: left;"><code>void writePattern(const uint8_t * data, uint8_t size, uint32_t repeat)</code></td><td style="text-align: left;">循环发送 <code>size</code> 个字节的<code>data</code> 数据 <code>repeat</code> 次，但是不会接收数据。</td></tr><tr class="even"><td style="text-align: left;"><code>void writePixels(const void * data, uint32_t size)</code></td><td style="text-align: left;">请参考用户目录<code>USER\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.9\libraries\SPI\src</code>下面的源码。</td></tr></tbody></table><h2 id="从设备-spi-第三方库">从设备 SPI 第三方库</h2><p>由于 <strong>Arduino-ESP32</strong> 官方库只支持把<strong>ESP32</strong> 芯片作为 <strong>SPI主设备</strong>来使用，并未提供 <strong>SPI 从设备</strong>通信相关的API，需要在 <strong>Arduino IDE</strong> 当中安装第三方库 <a href="https://github.com/hideakitai/ESP32SPISlave"><strong>ESP32SPISlave</strong></a>。由于该库目前仅支持诸如<code>ESP32-D0WD-V3</code>、<code>ESP32-D2WD</code>、<code>ESP32-S0WD</code>、<code>ESP32-U4WDH</code>等较老型号的 <strong>ESP32</strong> 系列，暂不支持相对较新的<strong>ESP32-C3</strong> 与 <strong>ESP32-S3</strong> 芯片。如果在<strong>Arduino IDE</strong>当中选择以这两款芯片作为主控的开发板，那么就会导致编译错误的出现。所以在接下来的示例当中，都会以乐鑫官方采用<strong>ESP32-D0WD</strong> 主控的 <strong>ESP32-DevKitC</strong>开发板作为 SPI 总线从设备：</p><p><img src="/Project/Arduino-ESP32/36.png"></p><p><strong>ESP32SPISlave</strong> 库可以支持以阻塞式等待的方式访问 SPI传输事务队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">       HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">       VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 阻塞等待，直至接收到主设备的传输事务 */</span></span><br><span class="line">  slave.<span class="built_in">wait</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果主设备的传输事务已经结束，那么从设备 available() 就会返回传输的结果数量，并且自动更新 spi_slave_rx_buf 接收缓冲区 */</span></span><br><span class="line">  <span class="keyword">while</span> (slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对应的，也能够支持以<strong>轮询</strong>的方式访问 SPI传输事务队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">    HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">    VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(VSPI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 如果当前队列当中没有剩余的传输事务 */</span></span><br><span class="line">  <span class="keyword">if</span> (slave.<span class="built_in">remained</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    slave.<span class="built_in">queue</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);  <span class="comment">// 那么就向队列新添加 1 个事务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果主设备的传输事务已经结束，那么从设备 available() 就会返回传输的结果数量，并且自动更新 spi_slave_rx_buf 接收缓冲区 */</span></span><br><span class="line">  <span class="keyword">while</span> (slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是以<strong>任务</strong>的方式访问 SPI 传输事务队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave slave;  <span class="comment">// 定义 SPI 总线从设备通信对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">32</span> &#125;;  <span class="comment">// 定义缓冲区大小</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_tx_buf[BUFFER_SIZE];        <span class="comment">// 定义发送缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> spi_slave_rx_buf[BUFFER_SIZE];        <span class="comment">// 定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> CORE_TASK_SPI_SLAVE&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> CORE_TASK_PROCESS_BUFFER&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskHandle_t task_handle_wait_spi = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> TaskHandle_t task_handle_process_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_wait_spi</span><span class="params">(<span class="type">void</span>* pvParameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">ulTaskNotifyTake</span>(pdTRUE, portMAX_DELAY);</span><br><span class="line">    slave.<span class="built_in">wait</span>(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);  <span class="comment">// 阻塞等待，直至接收到主设备的传输事务</span></span><br><span class="line">    <span class="built_in">xTaskNotifyGive</span>(task_handle_process_buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_process_buffer</span><span class="params">(<span class="type">void</span>* pvParameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">ulTaskNotifyTake</span>(pdTRUE, portMAX_DELAY);</span><br><span class="line">    slave.<span class="built_in">pop</span>();  <span class="comment">// 操作数据接收缓冲区</span></span><br><span class="line">    <span class="built_in">xTaskNotifyGive</span>(task_handle_wait_spi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式，即 SPI 时钟的极性与相位</span></span><br><span class="line">  <span class="comment">/* 指定 SPI 引脚，可以选择默认的 HSPI 和 VSPI，也可以进行自定义</span></span><br><span class="line"><span class="comment">    HSPI = CS: 15, CLK: 14, MOSI: 13, MISO: 12 -&gt; default</span></span><br><span class="line"><span class="comment">    VSPI = CS:  5, CLK: 18, MOSI: 23, MISO: 19 */</span></span><br><span class="line">  slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(task_wait_spi, <span class="string">&quot;task_wait_spi&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_handle_wait_spi, CORE_TASK_SPI_SLAVE);</span><br><span class="line">  <span class="built_in">xTaskNotifyGive</span>(task_handle_wait_spi);</span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(task_process_buffer, <span class="string">&quot;task_process_buffer&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_handle_process_buffer, CORE_TASK_PROCESS_BUFFER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来的一系列表格当中，展示了 <strong>ESP32SPISlave</strong>库当中提供的一系列 API 函数：</p><table><colgroup><col style="width: 70%"><col style="width: 29%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPI 总线配置 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool begin(const uint8_t spi_bus = HSPI)</code></td><td style="text-align: left;">使用默认的 <code>HSPI</code> 或者<code>VSPI</code> 作为 SPI 通信引脚。</td></tr><tr class="even"><td style="text-align: left;"><code>bool begin(const uint8_t spi_bus, const int8_t sck,</code><br><code>const int8_t miso, const int8_t mosi, const int8_t ss)</code></td><td style="text-align: left;">自定义 SPI 通信引脚。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setDataMode(const uint8_t m)</code></td><td style="text-align: left;">设置 SPI 数据模式（SPI时钟的极性与相位）。</td></tr><tr class="even"><td style="text-align: left;"><code>void setSpiMode(const uint8_t m)</code></td><td style="text-align: left;">设置 SPI 工作模式。</td></tr><tr class="odd"><td style="text-align: left;"><code>void setSlaveFlags(const uint32_t flags)</code></td><td style="text-align: left;">设置从设备标记。</td></tr><tr class="even"><td style="text-align: left;"><code>void setQueueSize(const int n)</code></td><td style="text-align: left;">设置队列大小。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool end()</code></td><td style="text-align: left;">结束 SPI 传输。</td></tr></tbody></table><table><colgroup><col style="width: 49%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPI 传输事务 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool wait(uint8_t* rx_buf, const size_t size)</code></td><td style="text-align: left;">阻塞式等待传输事务，<strong>只接收不发送</strong>，成功返回<code>true</code>，失败返回 <code>false</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>bool wait(uint8_t* rx_buf, const uint8_t* tx_buf, const size_t size)</code></td><td style="text-align: left;">阻塞式等待传输事务，<strong>即接收也发送</strong>，成功返回<code>true</code>，失败返回 <code>false</code>。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool queue(uint8_t* rx_buf, const size_t size)</code></td><td style="text-align: left;">添加传输事务，只接收不发送，成功返回<code>true</code>，失败返回 <code>false</code>。</td></tr><tr class="even"><td style="text-align: left;"><code>bool queue(uint8_t* rx_buf, const uint8_t* tx_buf, const size_t size)</code></td><td style="text-align: left;">添加传输事务，即接收也发送，成功返回<code>true</code>，失败返回 <code>false</code>。</td></tr><tr class="odd"><td style="text-align: left;"><code>void yield()</code></td><td style="text-align: left;">等待主设备处理完毕所有传输事务，如果<code>yield</code> 完成，则更新全部缓冲区。</td></tr></tbody></table><table><colgroup><col style="width: 17%"><col style="width: 82%"></colgroup><thead><tr class="header"><th style="text-align: left;">SPI 传输结果信息 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>size_t available() const</code></td><td style="text-align: left;">如果主设备的传输事务已经结束，那么从设备的<code>available()</code> 就会返回传输的结果数量，并且自动更新<code>spi_slave_rx_buf</code> 接收缓冲区。</td></tr><tr class="even"><td style="text-align: left;"><code>size_t remained() const</code></td><td style="text-align: left;">判断传输队列当中剩余的事务数量。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint32_t size() const</code></td><td style="text-align: left;">从传输队列当中接收到的字节数量。</td></tr><tr class="even"><td style="text-align: left;"><code>void pop()</code></td><td style="text-align: left;">获取从设备接收缓冲区当中的数据。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：SPI 传输涉及的 API中都以<strong>传输事务</strong>作为基础，当主设备拉低片选线，并且时钟线上发出脉冲信号时，就开始了1 次全双工的 SPI 传输事务。每一个时钟脉冲都意味着主设备通过<code>MOSI</code> 线发送 <code>1</code>个数据位到从设备，并且同时从设备通过 <code>MISO</code> 线返回<code>1</code>个数据位。当传输事务结束之后，主设备就会拉高片选线。每一次 SPI总线传输事务，主设备与从设备所能传输的最大数据量为 <code>64</code>字节，如果需要传输更大的数据，则必须借助 <strong>DMA</strong>方式进行。</p></blockquote><h2 id="主-从设备-spi-通信实例">主 &amp; 从设备 SPI 通信实例</h2><p>本小节将会基于 SPI 总线实现<strong>UINIO-MCU-ESP32S3</strong>（主设备）与<strong>ESP32-DevKitC</strong>（从设备）之间的相互通信，把两块核心板的<strong>HSPI</strong>/<strong>SPI2</strong> 按照下图关系相互连接，即<strong>UINIO-MCU-ESP32S3</strong> 的<code>SCLK = 21</code>、<code>MISO = 20</code>、<code>MOSI = 19</code>、<code>SS = 18</code>与 <strong>ESP32-DevKitC</strong> 的<code>SCLK = 14</code>，<code>MISO = 12</code>，<code>MOSI = 13</code>，<code>SS = 15</code>一一对应连接。同时两者的 <code>GND</code>也要连接到一起，从而形成共地连接关系：</p><p><img src="/Project/Arduino-ESP32/37.png"></p><p>让主设备每间隔 <code>1</code>秒钟，向从设备发送小写英文字符串，从设备接收之后将其转换为大写形式再返还给主设备，主设备将接收到的大写字符串打印至<strong>Arduino IDE</strong> 的【串口监视器】。接下来，分别在<strong>Arduino IDE</strong> 当中新建 3 份草图源文件，它们分别是用于 SPI主设备的 <code>SPIMaster.ino</code>、从设备（采用阻塞等待处理方式）的<code>SPISlaveWait.ino</code>、从设备（采用队列处理方式）的<code>SPISlaveQueue.ino</code>：</p><h3 id="spimaster.ino">SPIMaster.ino</h3><p>采用 <strong>UINIO-MCU-ESP32S3</strong> 作为 SPI 主设备，基于<strong>Arduino-ESP32</strong> 官方库提供的 SPI 通信 API与从设备进行数据交互。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPIMaster.ino（主设备） ==========*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK 5000000      <span class="comment">// 时钟信号频率，从设备时钟频率最高只能达到 10MHz</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Hspi = <span class="built_in">SPIClass</span>(HSPI);  <span class="comment">// 定义 SPIClass 对象</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> txBuffer[<span class="number">64</span>];        <span class="comment">// 声明发送缓冲区，非 DMA 方式最大传输 64 字节</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer[<span class="number">64</span>];        <span class="comment">// 声明接收缓冲区，非 DMA 方式最大传输 64 字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Hspi.<span class="built_in">begin</span>(<span class="number">21</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>);     <span class="comment">// 使用 GPIO21、GPIO20、GPIO19、GPIO18 初始化 HSPI 控制器</span></span><br><span class="line">  <span class="built_in">pinMode</span>(Hspi.<span class="built_in">pinSS</span>(), OUTPUT);  <span class="comment">// 将 HSPI 的片选信号线设置为数字输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每 1 次循环就是 1 次 SPI 传输事务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> temporary = <span class="number">97</span> + count++ % <span class="number">26</span>;   <span class="comment">// 定义一个字符串，ASCII 码 97 代表小写字母 a（每次都会依次从 a 循环发送至 z）</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(temporary);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(txBuffer, temporary, <span class="number">56</span>);      <span class="comment">// 写入 56 个小写字母到从设备的发送缓冲区</span></span><br><span class="line">  txBuffer[<span class="number">56</span>] = <span class="string">&#x27;~&#x27;</span>;                   <span class="comment">// 在 56 个小写字母的最后再加上 1 条波浪线</span></span><br><span class="line">  <span class="built_in">memset</span>(rxBuffer, <span class="number">0</span>, <span class="number">64</span>);              <span class="comment">// 把接收缓冲区清零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 开始传输事务 */</span></span><br><span class="line">  Hspi.<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(SPI_CLK, MSBFIRST, SPI_MODE0));  <span class="comment">// 配置 SPI 总线参数</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Hspi.<span class="built_in">pinSS</span>(), LOW);                                   <span class="comment">// 拉低片选信号线</span></span><br><span class="line">  Hspi.<span class="built_in">transferBytes</span>(txBuffer, rxBuffer, <span class="number">57</span>);                        <span class="comment">// 主设备向从设备发送 57 字节的数据</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(Hspi.<span class="built_in">pinSS</span>(), HIGH);                                  <span class="comment">// 拉高片选信号线</span></span><br><span class="line">  Hspi.<span class="built_in">endTransaction</span>();</span><br><span class="line">  <span class="comment">/* 结束传输事务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 发送数据的同时，也在接收从设备发回的数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">57</span>; i++) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>((<span class="type">char</span>)rxBuffer[i]);  <span class="comment">// 向串口打印接收到的从设备字符数据</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                        <span class="comment">// 延时 1 秒钟之后再重复上述过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spislavewait.ino">SPISlaveWait.ino</h3><p>采用 <strong>ESP32-DevKitC</strong> 作为 SPI 从设备，基于<strong>ESP32SPISlave</strong> 库提供的 <code>wait()</code>方法，以阻塞等待的方式与主设备进行通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPISlaveWait.ino（） ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave Slave;  <span class="comment">// 声明从设备对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义接收与发送的缓冲区最大空间为 64 字节 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">64</span> &#125;;</span><br><span class="line"><span class="type">uint8_t</span> txBuffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> rxBuffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Slave.<span class="built_in">setDataMode</span>(SPI_MODE0);  <span class="comment">// 设置 SPI 总线工作模式（时钟极性与相位）</span></span><br><span class="line">  Slave.<span class="built_in">begin</span>(HSPI);             <span class="comment">// 初始化 SPI 总线资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Slave.<span class="built_in">wait</span>(rxBuffer, txBuffer, BUFFER_SIZE);  <span class="comment">// 以阻塞等待的方式处理 SPI 数据</span></span><br><span class="line">  <span class="type">char</span> temporary = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断传输结果数量 */</span></span><br><span class="line">  <span class="keyword">while</span> (Slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> length = Slave.<span class="built_in">size</span>();       <span class="comment">// 获取主设备发送过来的数据长度</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      temporary = rxBuffer[i];</span><br><span class="line">      txBuffer[i] = temporary - <span class="number">32</span>;  <span class="comment">// 把字符的 ASIIC 编码减去 32，从而将其变为大写形式</span></span><br><span class="line">      Serial.<span class="built_in">print</span>(temporary);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">    Slave.<span class="built_in">pop</span>();                     <span class="comment">// 处理完缓冲区数据之后，必须将本次 SPI 传输事务弹出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">starWait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spislavequeue.ino">SPISlaveQueue.ino</h3><p>采用 <strong>ESP32-DevKitC</strong> 作为 SPI 从设备，基于<strong>ESP32SPISlave</strong> 库提供的 <code>queue()</code>方法与主设备进行通信，由于队列方式只能同时处理 <strong>3</strong> 个 SPI传输任务。所以从设备需要初始化出 3个传输任务，然后逐一用于处理数据的收发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SPISlaveQueue.ino ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP32SPISlave.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ESP32SPISlave Slave;  <span class="comment">// 定义从设备对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ESP32SPISlave 的队列方式只能同时处理 3 个 SPI 传输任务 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> BUFFER_SIZE&#123; <span class="number">64</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 1 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer0[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer0[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 2 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer1[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer1[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第 3 个 SPI 传输任务的收发缓冲区 */</span></span><br><span class="line"><span class="type">uint8_t</span> rxBuffer2[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> txBuffer2[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Slave.<span class="built_in">setDataMode</span>(SPI_MODE0);</span><br><span class="line">  Slave.<span class="built_in">begin</span>(HSPI);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 同时启动 3 个 SPI 总线传输任务 */</span></span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer0, txBuffer0, BUFFER_SIZE);</span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer1, txBuffer1, BUFFER_SIZE);</span><br><span class="line">  Slave.<span class="built_in">queue</span>(rxBuffer2, txBuffer2, BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理接收缓冲区的数据，然后写入到发送缓冲区 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleBuffer</span><span class="params">(<span class="type">uint8_t</span>* rx_buffer, <span class="type">uint8_t</span>* tx_buffer, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> temporary = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环将接收缓冲区当中的 ASCII 字符编码减去 32 转换为大写，然后再写入至发送缓冲区 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    temporary = rx_buffer[i];</span><br><span class="line">    tx_buffer[i] = temporary - <span class="number">32</span>;</span><br><span class="line">    Serial.<span class="built_in">print</span>(temporary);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">starQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> index = <span class="number">0</span>;  <span class="comment">// 处理 SPI 传输任务的缓冲区序号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断当前是否存在传输数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (Slave.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> length = Slave.<span class="built_in">size</span>();  <span class="comment">// 获取主设备发送过来的数据长度</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断缓冲区队列顺序 */</span></span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">      <span class="comment">/* 处理第 1 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer0, txBuffer0, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer0, txBuffer0, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/* 处理第 2 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer1, txBuffer1, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer1, txBuffer1, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">/* 处理第 3 个缓冲区 */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">handleBuffer</span>(rxBuffer2, txBuffer2, length);</span><br><span class="line">        Slave.<span class="built_in">queue</span>(rxBuffer2, txBuffer2, BUFFER_SIZE);  <span class="comment">// 将该传输事务添加到队列</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = (index + <span class="number">1</span>) % <span class="number">3</span>;  <span class="comment">// 采用取余的方式让 index 从 0 到 2 不断循环</span></span><br><span class="line">    Slave.<span class="built_in">pop</span>();              <span class="comment">// 把本次的 SPI 传输任务弹出处理队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">starQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于-spi-操作-sd-存储卡">基于 SPI 操作 SD 存储卡</h1><p>本节内容介绍的这款 <strong>SD 存储卡模组</strong>，可以使得<strong>UINIO-MCU-ESP32</strong> 通过 SPI 接口以及文件系统读写 SD存储卡（同时支持普通 <strong>Micro SD</strong> 和高速 <strong>MicroSDHC</strong> 存储卡）。该款模组还板载有电平转换芯片，可以同时兼容<code>5V</code> 和 <code>3.3V</code> 规格的电平信号。而自带的<strong>3.3V 线性稳压器</strong>，也可以使其分别工作于 <code>5V</code>和 <code>3.3V</code> 电源下。</p><p><img src="/Project/Arduino-ESP32/38.png"></p><p>这款 <strong>SD 存储卡模组</strong> 一共拥有六个外接引脚，它们分别是<code>GND</code>，<code>VCC</code>，<code>MISO</code>，<code>MOSI</code>，<code>SCK</code>，<code>CS</code>，具体的引脚排列顺序可以参考下图：</p><p><img src="/Project/Arduino-ESP32/39.png"></p><h2 id="arduino-esp32-提供的-sd-库">Arduino-ESP32 提供的 SD 库</h2><p>笔者目前使用 <strong>Arduino-ESP32</strong> 库的 <code>2.0.11</code>版本，已经基于 SPI 总线通信，提供了对于 SD卡操作的支持（可以支持中文文件名，以及 <strong>UTF-8</strong>编码的文件内容），使用时只需要在 Arduino 草图源文件当中包含<code>SPI.h</code> 和 <code>SD.h</code> 头文件即可。由于截止到 2023 年 8月为止，该库依然还处于开发状态，官方并未提供详尽的 API文档说明，只是提供了一份比较典型的 SD卡读写示例代码。接下来就基于这份代码，以自定义 SPI通信引脚的方式，读写一颗文件系统为 <strong>FAT32</strong>，存储容量为<code>32GB</code> 的 TF 存储卡：</p><p><img src="/Project/Arduino-ESP32/40.png"></p><p>首先把 <strong>UINIO-MCU-ESP32</strong> 的引脚<code>SS = GPIO0</code>、<code>SCLK = GPIO1</code>、<code>MOSI = GPIO2</code>、<code>MISO = GPIO3</code>分别与读卡器模块的<code>CS</code>、<code>SCK</code>、<code>MOSI</code>、<code>MISO</code>引脚相互连接，然后再将读卡器模组的 <code>VCC</code> 和 <code>GND</code>分别接入至 <strong>UINIO-MCU-ESP32</strong> 的 <code>5V</code> 和<code>GND</code> 电源，最后就可以下载并且运行这份参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SD.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 列出目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *dirname, <span class="type">uint8_t</span> levels)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;列出目录: %s\n&quot;</span>, dirname);</span><br><span class="line"></span><br><span class="line">  File root = fs.<span class="built_in">open</span>(dirname);</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开目录发生错误！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!root.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;这不是一个目录！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  File file = root.<span class="built_in">openNextFile</span>();</span><br><span class="line">  <span class="keyword">while</span> (file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  目录 : &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(file.<span class="built_in">name</span>());</span><br><span class="line">      <span class="keyword">if</span> (levels) &#123;</span><br><span class="line">        <span class="built_in">listDir</span>(fs, file.<span class="built_in">path</span>(), levels - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  文件: &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(file.<span class="built_in">name</span>());</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;  尺寸: &quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(file.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    file = root.<span class="built_in">openNextFile</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 建立目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;新建目录: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">mkdir</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录建立成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录建立错误！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 移除目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDir</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;移除目录: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">rmdir</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录移除成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;目录移除错误！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 读取目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在读取文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件读取失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;读取到的文件内容: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (file.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(file.<span class="built_in">read</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 写入目录 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;写入文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path, FILE_WRITE);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件写入失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (file.<span class="built_in">print</span>(message)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件写入失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 向文件末尾追加内容 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">appendFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;追加到文件: %s\n&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path, FILE_APPEND);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件追加失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (file.<span class="built_in">print</span>(message)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;内容追加成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;内容追加失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 重命名文件 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">renameFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;重新命名文件 %s 为 %s\n&quot;</span>, path1, path2);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">rename</span>(path1, path2)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件重命名成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件重命名失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 删除文件 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFile</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;删除文件: %s\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="built_in">remove</span>(path)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件删除成功！&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;文件删除失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== 测试文件输入输出 ==========*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFileIO</span><span class="params">(fs::FS &amp;fs, <span class="type">const</span> <span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">  File file = fs.<span class="built_in">open</span>(path);</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> buf[<span class="number">512</span>];</span><br><span class="line">  <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> start = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="type">uint32_t</span> end = start;</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    len = file.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> flen = len;</span><br><span class="line">    start = <span class="built_in">millis</span>();</span><br><span class="line">    <span class="keyword">while</span> (len) &#123;</span><br><span class="line">      <span class="type">size_t</span> toRead = len;</span><br><span class="line">      <span class="keyword">if</span> (toRead &gt; <span class="number">512</span>) &#123;</span><br><span class="line">        toRead = <span class="number">512</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      file.<span class="built_in">read</span>(buf, toRead);</span><br><span class="line">      len -= toRead;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">millis</span>() - start;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;读取 %u 字节花费了 %u 毫秒\n&quot;</span>, flen, end);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件读取失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  file = fs.<span class="built_in">open</span>(path, FILE_WRITE);</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;打开文件写入失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  start = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++) &#123;</span><br><span class="line">    file.<span class="built_in">write</span>(buf, <span class="number">512</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">millis</span>() - start;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;写入 %u 字节花费了 %u 毫秒\n&quot;</span>, <span class="number">2048</span> * <span class="number">512</span>, end);</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  SPIClass *hspi = <span class="keyword">new</span> <span class="built_in">SPIClass</span>(HSPI);  <span class="comment">// 初始化 HSPI 总线</span></span><br><span class="line">  hspi-&gt;<span class="built_in">begin</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);              <span class="comment">// 指定 SPI 通信引脚（SCLK, MISO, MOSI, SS）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SD.begin(指定 GPIO0 为片选引脚，使用 HSPI 控制器，频率为 4 MHz，SD 卡挂载点，最大文件数量，如果为空是否进行格式化) */</span></span><br><span class="line">  <span class="keyword">if</span> (!SD.<span class="built_in">begin</span>(<span class="number">0</span>, *hspi, <span class="number">4000000</span>, <span class="string">&quot;/SD&quot;</span>, <span class="number">5</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;存储卡挂载失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint8_t</span> cardType = SD.<span class="built_in">cardType</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cardType == CARD_NONE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;未检测到 SD 卡！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;SD 卡类型: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cardType == CARD_MMC) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;MMC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardType == CARD_SD) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;SDSC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cardType == CARD_SDHC) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;SDHC 存储卡&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;未知类型卡&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> cardSize = SD.<span class="built_in">cardSize</span>() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;SD 卡容量: %lluMB\n&quot;</span>, cardSize);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">createDir</span>(SD, <span class="string">&quot;/成都&quot;</span>);</span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">removeDir</span>(SD, <span class="string">&quot;/成都&quot;</span>);</span><br><span class="line">  <span class="built_in">listDir</span>(SD, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">writeFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;您好，&quot;</span>);</span><br><span class="line">  <span class="built_in">appendFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;电子技术博客 UinIO.com！\n&quot;</span>);</span><br><span class="line">  <span class="built_in">readFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">deleteFile</span>(SD, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">renameFile</span>(SD, <span class="string">&quot;/网站.txt&quot;</span>, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">readFile</span>(SD, <span class="string">&quot;/UinIO.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">testFileIO</span>(SD, <span class="string">&quot;/成都.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;全部容量: %lluMB\n&quot;</span>, SD.<span class="built_in">totalBytes</span>() / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;已经使用的容量: %lluMB\n&quot;</span>, SD.<span class="built_in">usedBytes</span>() / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上述代码下载执行之后，测试用的 SD 卡上面会生成一个内容为<code>您好，电子技术博客 UinIO.com！</code> 的文件<code>UinIO.txt</code>，以及通过文件输入输出写入了内容为空的<code>成都.txt</code> 文件，同时会以 <code>115200</code>波特率向串口打印如下一系列执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SD 卡类型: SDHC 存储卡</span><br><span class="line">SD 卡容量: 29822MB</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line">新建目录: /成都</span><br><span class="line">目录建立成功！</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line">  目录 : 成都</span><br><span class="line">移除目录: /成都</span><br><span class="line">目录移除成功！</span><br><span class="line"></span><br><span class="line">列出目录: /</span><br><span class="line">  目录 : System Volume Information</span><br><span class="line">列出目录: /System Volume Information</span><br><span class="line">  文件: IndexerVolumeGuid  尺寸: 76</span><br><span class="line">  文件: WPSettings.dat  尺寸: 12</span><br><span class="line">  文件: 成都.txt  尺寸: 1048576</span><br><span class="line">  文件: UinIO.txt  尺寸: 41</span><br><span class="line"></span><br><span class="line">写入文件: /网站.txt</span><br><span class="line">文件写入成功！</span><br><span class="line">追加到文件: /网站.txt</span><br><span class="line">内容追加成功！</span><br><span class="line">正在读取文件: /网站.txt</span><br><span class="line">读取到的文件内容: 您好，电子技术博客 UinIO.com！</span><br><span class="line">删除文件: /UinIO.txt</span><br><span class="line">文件删除成功！</span><br><span class="line">重新命名文件 /网站.txt 为 /UinIO.txt</span><br><span class="line">文件重命名成功！</span><br><span class="line">正在读取文件: /UinIO.txt</span><br><span class="line">读取到的文件内容: 您好，电子技术博客 UinIO.com！</span><br><span class="line">读取 1048576 字节花费了 2383 毫秒</span><br><span class="line">写入 1048576 字节花费了 2515 毫秒</span><br><span class="line">全部容量: 29802MB</span><br><span class="line">已经使用的容量: 1MB</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：如果串口打印出的调试内容提示<code>存储卡挂载失败！</code>，那么可以将这片 SD卡拔出之后重新插入，然后按下 <strong>UINIO-MCU-ESP32</strong>核心板上面的 <strong>RESET</strong> 按钮，重新执行上述程序。</p></blockquote><h2 id="第三方提供的-sdfat-库">第三方提供的 SdFat 库</h2><p>因为 <strong>ESP32-Arduino</strong> 官方库的 SD 卡相关 API暂时还不够完善，所以本节内容将会介绍功能更加丰富的 <a href="https://github.com/greiman/SdFat">SdFat</a> 库，可以同时支持<strong>SD</strong>、<strong>SDHC</strong>、<strong>SDXC</strong>类型的存储卡，以及<strong>FAT16</strong>、<strong>FAT32</strong>、<strong>exFAT</strong>文件系统。该库的 API 文档可以访问 <a href="https://github.com/greiman/SdFat/releases">SdFat 源文件</a> 的<code>\doc</code> 目录下，压缩文件 <code>html.zip</code> 当中的<code>index.html</code>。总体上来看，<strong>SdFat</strong> 库是通过<code>SdFat32</code>、<code>SdExFat</code>、<code>SdFs</code>三个类来分别代表不同的存储卡文件系统：</p><ol type="1"><li><code>SdFs</code> 类：用于支持 <strong>FAT16</strong> 和<strong>FAT32</strong> 以及 <strong>exFAT</strong>文件系统，对应的文件类为 <code>FsFile</code>；</li><li><code>SdFat32</code> 类：用于支持 <strong>FAT16</strong> 和<strong>FAT32</strong> 文件系统，对应的文件类为<code>File32</code>；</li><li><code>SdExFat</code> 类：用于支持 <strong>exFAT</strong>文件系统，对应的文件类为 <code>ExFile</code>；</li></ol><p>该库可以方便的通过 <strong>Arduino IDE</strong>的【库管理器】进行安装，安装之后需要修改 Arduino 项目文件夹<code>libraries\SdFat\src</code> 下的 <code>SdFatConfig.h</code>头文件，将宏定义 <code>#define USE_UTF8_LONG_NAMES</code> 的值修改为<code>1</code>，即采用 <strong>UTF-8</strong>格式编码所有字符串，从而能够自由的使用中文字符。除此之外，通过修改<code>SdFatConfig.h</code> 头文件中 <code>SPI_DRIVER_SELECT</code>宏定义的值，还可以选择当前是使用 <strong>SPI 硬件总线</strong>（使用 SPI控制器默认的引脚）还是 <strong>SPI 软件总线</strong>（自定义 SPI通信引脚）：</p><ul><li><code>0</code>：如果存在优化的自定义 SPI驱动程序，则使用它，否则使用标准库驱动程序。</li><li><code>1</code>：总是使用标准库驱动程序。</li><li><code>2</code>：总是使用 SoftSpiDriver 模板类的外部 SPI驱动程序。</li><li><code>3</code>：总是使用从 SdSpiBaseClass 类派生的外部 SPI驱动程序。</li></ul><p>接下来，我们把 <code>SdFatConfig.h</code> 头文件里的<code>SPI_DRIVER_SELECT</code> 配置为 <code>2</code>，而<code>#define USE_UTF8_LONG_NAMES</code> 的值配置为<code>1</code>，同时依然将 <strong>UINIO-MCU-ESP32</strong> 的<code>SS = GPIO0</code>、<code>SCLK = GPIO1</code>、<code>MOSI = GPIO2</code>、<code>MISO = GPIO3</code>与读卡器模块的<code>CS</code>、<code>SCK</code>、<code>MOSI</code>、<code>MISO</code>引脚连接，而读卡器模块的 <code>VCC</code> 和 <code>GND</code> 则分别接入<strong>UINIO-MCU-ESP32</strong> 的 <code>5V</code> 和 <code>GND</code>进行供电，最后就可以编写并且执行如下的参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SdFat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_FAT_TYPE 0  <span class="comment">// 0 表示遵循 SdFatConfig.h 里的配置、1 表示 FAT16/FAT32、2 表示 exFAT、3 表示 FAT16/FAT32 和 exFAT</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 SPI 通信引脚的编号为常量 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_SS   = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_SCLK = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_MOSI = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> SOFT_MISO = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">SoftSpiDriver&lt;SOFT_MISO, SOFT_MOSI, SOFT_SCLK&gt; softSpi;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件 SPI 总线，可以忽略 Speed 参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_DEDICATED_SPI</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> SD_CONFIG SdSpiConfig(SOFT_SS, DEDICATED_SPI, SD_SCK_MHZ(0), &amp;softSpi)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> SD_CONFIG SdSpiConfig(SOFT_SS, SHARED_SPI, SD_SCK_MHZ(0), &amp;softSpi)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_FAT_TYPE == 0</span></span><br><span class="line">  SdFat sd;</span><br><span class="line">  File file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 1</span></span><br><span class="line">  SdFat32 sd;</span><br><span class="line">  File32 file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 2</span></span><br><span class="line">  SdExFat sd;</span><br><span class="line">  ExFile file;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SD_FAT_TYPE == 3</span></span><br><span class="line">  SdFs sd;</span><br><span class="line">  FsFile file;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> Invalid SD_FAT_TYPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待 USB 串行接口就绪 */</span></span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;请输入任意字符开始测试：&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待控制台输入 */</span></span><br><span class="line">  <span class="keyword">while</span> (!Serial.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用上面的宏定义 SD_CONFIG 配置 SPI 总线 */</span></span><br><span class="line">  <span class="keyword">if</span> (!sd.<span class="built_in">begin</span>(SD_CONFIG)) &#123;</span><br><span class="line">    sd.<span class="built_in">initErrorHalt</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在 SD 存储卡上面创建并且打开一个 电子技术博客.txt 文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!file.<span class="built_in">open</span>(<span class="string">&quot;电子技术博客.txt&quot;</span>, O_RDWR | O_CREAT)) &#123;</span><br><span class="line">    sd.<span class="built_in">errorHalt</span>(<span class="built_in">F</span>(<span class="string">&quot;文件创建或者打开失败！&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">println</span>(<span class="built_in">F</span>(<span class="string">&quot;欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。&quot;</span>));  <span class="comment">// 向上面创建的 .txt 文件写入内容</span></span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">rewind</span>();                <span class="comment">// 将文件当前的操作位置初始为零</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (file.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">write</span>(file.<span class="built_in">read</span>());  <span class="comment">// 读取并且打印 .txt 当中的内容到串口</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="built_in">F</span>(<span class="string">&quot;SD 存储卡写入完成！&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>UINIO-MCU-ESP32</strong>开始运行上述代码之后，可以打开一个第三方的串口上位机程序（例如<strong>VOFA+</strong> 或者<strong>COMTransmit</strong>），首先将其波特率设置为<code>115200</code>，然后手动向串口上位机的【发送窗口】输入<code>test</code> 并且按下发送，此时 <strong>UINIO-MCU-ESP32</strong>就会自动向 SD存储卡写入内容：<code>欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。</code>，同时串口上位机的【接收窗口】会打印出如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ESP-ROM:esp32s3-20210327</span><br><span class="line">Build:Mar 27 2021</span><br><span class="line">rst:0x1 (POWERON),boot:0x8 (SPI_FAST_FLASH_BOOT)</span><br><span class="line">SPIWP:0xee</span><br><span class="line">mode:DIO, clock div:1</span><br><span class="line">load:0x3fce3808,len:0x44c</span><br><span class="line">load:0x403c9700,len:0xbe4</span><br><span class="line">load:0x403cc700,len:0x2a68</span><br><span class="line">entry 0x403c98d4</span><br><span class="line"></span><br><span class="line">请输入任意字符开始测试：</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">欢迎访问 UinIO.com，获取技术分享文章，以及更多有趣的开源项目。</span><br><span class="line">SD 存储卡写入完成！</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<strong>DSPI</strong>（<strong>DualSPI</strong>）常用于 SPI 总线通信的 Flash 存储器，由于 Flash存储器无需使用全双工通信，所以 <strong>DSPI</strong> 将<code>MOSI</code> 和 <code>MISO</code>都作为并行数据传输线，从而工作在半双工模式下，可以达到在单个时钟周期内，双倍提升数据传输速率的目的。</p></blockquote><h1 id="借用-freertos-的多任务与互斥量">借用 FreeRTOS的多任务与互斥量</h1><p><strong>FreeRTOS</strong>是一款适用于微控制器和小型微处理器的嵌入式实时操作系统（<strong>RTOS</strong>，Real-timeOperatingSystem），其提供了<code>任务</code>与<code>通知</code>、<code>队列</code>、<code>流缓冲区</code>、<code>消息缓冲区</code>、<code>信号量</code>/<code>互斥锁</code>、<code>软件定时器</code>、<code>事件组</code>等丰富特性，可以协助开发人员在资源受限的嵌入式场景下，实现稳定可靠的实时任务调度与协作。当<strong>Arduino IDE</strong> 成功安装 <strong>Arduino-ESP32</strong>之后，就会在如下目录里发现 <strong>ESP32-C3</strong> 和<strong>ESP32-S3</strong> 源码实现都内嵌有<strong>FreeRTOS</strong>。</p><ul><li><strong>ESP32C3 内嵌的FreeRTOS</strong>：<code>C:\Users\Hank\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32c3\include\freertos</code>；</li><li><strong>ESP32S3 内嵌的FreeRTOS</strong>：<code>C:\Users\Hank\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32s3\include\freertos</code>；</li></ul><p>相应的，<strong>Arduino-ESP32</strong> 当中所使用的<strong>FreeRTOS</strong> 都会通过头文件 <code>FreeRTOSConfig.h</code>来进行配置，其位置位于 <strong>Arduino-ESP32</strong>用户安装目录的如下路径：</p><ul><li><strong>ESP32C3 的<code>FreeRTOSConfig.h</code></strong>：<code>Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32c3\include\freertos\include\esp_additions\freertos\FreeRTOSConfig.h</code>；</li><li><strong>ESP32S3 的<code>FreeRTOSConfig.h</code></strong>：<code>Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\sdk\esp32s3\include\freertos\include\esp_additions\freertos\FreeRTOSConfig.h</code>；</li></ul><p>例如 <strong>Arduino-ESP32</strong> 当中的 <code>loop()</code>函数，就是通过在 <strong>FreeRTOS</strong> 当中创建一个优先级为<code>1</code> 的任务来进行执行的。也正是因为如此，我们同样可以在Arduino 草图代码当中引入 FreeRTOS 相关的头文件来使用其相关的特性。</p><blockquote><p><strong>注意</strong>：当前本文使用的 <strong>Arduino-ESP32</strong>版本为 <code>2.0.11</code>，其内嵌的 <strong>FreeRTOS</strong> 版本为<code>V10.4.x</code>。</p></blockquote><h2 id="多任务处理">多任务处理</h2><p>当 <strong>Arduino IDE</strong> 安装了 <strong>Arduino-ESP32</strong>之后，菜单栏的上【工具】下就会出现一系列配置选项。对于<strong>UINIO-MCU-ESP32S3</strong>这样的多核微控制器，就可以发现如下两条配置项：</p><ul><li><strong>Arduino Runs On</strong>：指定用于运行 <strong>Arduino核心</strong>的微控制器内核；</li><li><strong>Events Run On</strong>：指定用于运行 <strong>Arduino事件</strong>的微控制器内核；</li></ul><p>上述两个配置项的<strong>值</strong>可以分别被指定为<code>Core 0</code> 和 <code>Core 1</code>，除此之外，由于<strong>Arduino-ESP32</strong> 库在底层实现上，使用了嵌入式实时操作系统<strong>FreeRTOS</strong>，所以在 Arduino草图代码也可以通过包含如下两个头文件，以使用其提供的多任务处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>Arduino-ESP32</strong> 当中可以通过<code>xTaskCreatePinnedToCore()</code>函数创建一个任务，如果任务创建成功，则会返回<code>pdPASS</code>，否则表示创建失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskFunction_t pvTaskCode,     <span class="comment">// 指向任务入口函数的指针，该函数会不断运行，其原型为 void task( void* param )</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,     <span class="comment">// 任务的描述性名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">short</span> usStackDepth,   <span class="comment">// 分配用于任务堆栈的字数(非字节)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *pvParameters,            <span class="comment">// 传递给创建任务的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxPriority,        <span class="comment">// 创建任务执行的优先级 0 ~ 24，空闲任务的优先级为 0，而 loop 函数的优先级为 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t *pvCreatedTask,   <span class="comment">// 用于传递创建任务的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BaseType_t xCoreID       <span class="comment">// 值 0 或者 1 表示任务运行的微控制器内核编号，值 tskNO_AFFINITY 表示可以运行于任意的内核</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure><p>任务创建之后，就可以通过 <code>vTaskDelete()</code>函数结束并且删除掉一个任务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskDelete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t pxTask <span class="comment">// 需要删除的任务句柄，直接传递 NULL 会导致当前调用任务被删除</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure><p>除此之外，还可以利用 <code>uxTaskPriorityGet()</code> 返回参数任务<code>XTask</code> 的优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle_t xTask  <span class="comment">// 需要查询的任务句柄，直接传递 NULL 会返回调用任务的优先级</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure><p>以及使用 <code>XPortGetCoreID()</code>返回当前任务运行于哪一个微控制器内核：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t IRAM ATTR <span class="title">XPortGetCoreID</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>在接下来的示例代码当中，通过直接包含 FreeRTOS 配置文件<code>FreeRTOSConfig.h</code> 的方式（也可以采用分别包含<code>FreeRTOS.h</code> 和 <code>task.h</code>两个头文件的方式），展示了如何基于采用 <strong>ESP32-S3</strong>多核微控制器的 <strong>UINIO-MCU-ESP32S3</strong> 进行多任务的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task1</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> value = *((<span class="type">int</span>*)parameter); <span class="comment">// 获取整型指针参数的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务运行在：Core %d\n&quot;</span>, core);     <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务接收到的参数为: %d\n&quot;</span>, value);  <span class="comment">// 打印当前任务接收到的参数</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task2</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-2 任务运行在：Core %d\n&quot;</span>, core); <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 1，运行在 ESP32-S3 的 Core 0，优先级为 15 */</span></span><br><span class="line">  TaskHandle_t handle1;  <span class="comment">// 任务句柄</span></span><br><span class="line">  <span class="type">int</span> parameter = <span class="number">2023</span>;  <span class="comment">// 任务参数</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task1, <span class="string">&quot;Task-1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;parameter, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 2，运行在 ESP32-S3 的 Core 1，优先级为 15 */</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task2, <span class="string">&quot;Task-2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();  <span class="comment">// 获取运行的微控制器内核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务运行在：Core %d\n&quot;</span>, core);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = <span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务的优先级为: %d\n&quot;</span>, priority);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>); <span class="comment">// 一个任务里的 delay() 函数不会影响到其它任务的运行，即虽然该任务延时 2 秒，但是其它任务依然按照正常速度执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码下载到 <strong>UINIO-MCU-ESP32S3</strong>上面，核心板就会每间隔 2 秒，以 <code>115200</code> 波特率向<strong>Arduino IDE</strong> 的串口监视器打印如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task-1 任务运行在：Core 0</span><br><span class="line">Task-1 任务接收到的参数为: 2023</span><br><span class="line">Task-2 任务运行在：Core 1</span><br><span class="line">loop 函数任务运行在：Core 1</span><br><span class="line">loop 函数任务的优先级为: 1</span><br></pre></td></tr></table></figure><h2 id="互斥锁机制">互斥锁机制</h2><p><strong>FreeRTOS</strong> 提供的<a href="https://www.freertos.org/zh-cn-cmn-s/Real-time-embedded-RTOS-mutexes.html"><strong>互斥锁</strong></a>机制是一种包含有优先级继承机制的二进制信号量，之前介绍过的<strong>二进制信号量</strong>可以用于实现任务与任务，以及任务与中断之间的同步。而<strong>互斥锁</strong>则有助于更好的实现资源的互斥访问，它就像是保护互斥资源的一个令牌，当任务需要访问资源时，必须首先获取这个令牌；而在使用完资源之后，则必须返回这个令牌，从而使得其它任务能够继续访问该资源。</p><p><strong>Arduino-ESP32</strong> 可以通过<code>xSemaphoreCreateMutex()</code>函数创建一个互斥锁，执行之后就会返回这个互斥锁的句柄：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>在创建信号量之后，接下来就可以通过 <code>xSemaphoreTake()</code>函数获取互斥锁信号量，如果获取成功就返回<code>pdTRUE</code>，如果获取失败则返回 <code>pdFALSE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreTake</span>(</span><br><span class="line">    SemaphoreHandle_t xSemaphore,  <span class="comment">// 获取到的信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait        <span class="comment">// 等待信号量可用的节拍时间，指定为 portMAX_DELAY 会导致任务无限期阻塞（即没有超时）</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>除此之外，互斥锁信号量可以通过 <code>xSemaphoreGive()</code>函数进行释放，信号量释放成功就返回<code>pdTRUE</code>，如果发生错误则返回 <code>pdFALSE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreGive</span>(</span><br><span class="line">    SemaphoreHandle_t xSemaphore   <span class="comment">// 待释放的信号量句柄</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>下面的伪代码，简单明了的展示了互斥锁信号量的典型使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">xSemaphoreTake</span>(xSemaphore, xTicksToWait) ) &#123;</span><br><span class="line">  <span class="comment">// ... ... ...</span></span><br><span class="line">  <span class="comment">// 开始处理临界资源</span></span><br><span class="line">  <span class="comment">// ... ... ...</span></span><br><span class="line">  <span class="built_in">xSemaphoreGive</span>(xSemaphore); <span class="comment">// 释放互斥锁信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的示例代码当中，通过使用互斥信号量确保了 <code>Task-1</code> 和<code>Task-2</code> 两个任务，对于互斥资源变量 <code>number</code>的同步访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">xSemaphoreHandle xSemaphore;  <span class="comment">// 声明互斥锁信号量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;               <span class="comment">// 定义互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2，用于打印互斥资源 number 的值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task1</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> value = *((<span class="type">int</span>*)parameter);  <span class="comment">// 获取整型指针参数的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务运行在：Core %d\n&quot;</span>, core);     <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-1 任务接收到的参数为: %d\n&quot;</span>, value);  <span class="comment">// 打印当前任务接收到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaphore, portMAX_DELAY)) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;互斥资源 number 的值为: %d\n&quot;</span>, number);  <span class="comment">// 打印互斥资源 number</span></span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务 2，用于对互斥资源 number 进行自增 1 操作 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task2</span><span class="params">(<span class="type">void</span>* parameter)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值小于 200 就继续执行任务 */</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Task-2 任务运行在：Core %d\n&quot;</span>, core);  <span class="comment">// 打印当前任务运行在哪一个微控制内核</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取互斥锁信号量 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaphore, portMAX_DELAY)) &#123;</span><br><span class="line">      number++;                <span class="comment">// 互斥资源 number 自增 1</span></span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaphore);  <span class="comment">// 释放互斥资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数值大于 200 就退出任务执行 */</span></span><br><span class="line">  <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);  <span class="comment">// 结束当前任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  xSemaphore = <span class="built_in">xSemaphoreCreateMutex</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 1，运行在 ESP32-S3 的 Core 0，优先级为 15 */</span></span><br><span class="line">  TaskHandle_t handle1;  <span class="comment">// 任务句柄</span></span><br><span class="line">  <span class="type">int</span> parameter = <span class="number">2023</span>;  <span class="comment">// 任务参数</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task1, <span class="string">&quot;Task-1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;parameter, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务 2，运行在 ESP32-S3 的 Core 1，优先级为 15 */</span></span><br><span class="line">  <span class="built_in">xTaskCreatePinnedToCore</span>(Task2, <span class="string">&quot;Task-2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> core = <span class="built_in">xPortGetCoreID</span>();  <span class="comment">// 获取运行的微控制器内核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务运行在：Core %d\n&quot;</span>, core);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = <span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;loop 函数任务的优先级为: %d\n&quot;</span>, priority);</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);  <span class="comment">// 一个任务里的 delay() 函数不会影响到其它任务的运行，即虽然该任务延时 2 秒，但是其它任务依然按照正常速度执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不能在<strong>中断服务程序</strong>当中使用FreeRTOS 的互斥锁信号量。</p></blockquote><h1 id="基于-wifi-传输数据">基于 WIFI 传输数据</h1><p><strong>Arduino-ESP32</strong> 提供了一系列 <a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html">WIFI相关的 API</a>，支持 802.11b/g/n 无线局域网标准，可以用于<strong>扫描WIFI 接入点</strong>，也支持<strong>WPA2</strong>、<strong>WPA3</strong> 等 WIFI安全模式，除此之外还提供了 WIFI 的 <strong>STA</strong> 和<strong>AP</strong> 两种工作模式：</p><p><img src="/Project/Arduino-ESP32/41.png"></p><p><strong>Wi-Fi 客户端</strong>模式，也被称为 <strong>STA</strong>模式（Station mode），这种模式支持把 ESP32 连接到一个 WIFI 接入点。</p><p><img src="/Project/Arduino-ESP32/42.png"></p><p><strong>Wi-Fi 接入点</strong>模式，也被称为 <strong>AP</strong>模式（Access Point mode），这种模式下 ESP32被配置为一个接入点，可以通过提供 Wi-Fi 局域网接收其它设备的连接。</p><h2 id="wifi-相关-api-函数概览">WIFI 相关 API 函数概览</h2><table><colgroup><col style="width: 62%"><col style="width: 37%"></colgroup><thead><tr class="header"><th style="text-align: left;">通用 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>wifi_event_id_t onEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX)</code></td><td style="text-align: left;">注册一个 WIFI 事件回调函数。</td></tr><tr class="even"><td style="text-align: left;"><code>void removeEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX)</code></td><td style="text-align: left;">移除一个 WIFI 事件回调函数。</td></tr><tr class="odd"><td style="text-align: left;"><code>setHostname(const char *hostname)</code></td><td style="text-align: left;">设置 DHCP 客户端标识。</td></tr><tr class="even"><td style="text-align: left;"><code>const char *getHostname()</code></td><td style="text-align: left;">获取 DHCP 客户端标识。</td></tr><tr class="odd"><td style="text-align: left;"><code>static void useStaticBuffers(bool bufferMode)</code></td><td style="text-align: left;">设置 Wi-Fi缓冲区的内存分配方式，<code>true</code> 为静态，而 <code>false</code>为动态。</td></tr><tr class="even"><td style="text-align: left;"><code>bool setDualAntennaConfig(uint8_t gpio_ant1, uint8_t gpio_ant2, wifi_rx_ant_t rx_mode, wifi_tx_ant_t tx_mode)</code></td><td style="text-align: left;">配置双天线功能，仅支持带有 RF 开关的 ESP32使用。</td></tr></tbody></table><table><colgroup><col style="width: 82%"><col style="width: 17%"></colgroup><thead><tr class="header"><th style="text-align: left;">AP 模式 WIFI 相关 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>WiFi.softAP(ssid, password)</code></td><td style="text-align: left;">启动 Wi-Fi 作为接入点。</td></tr><tr class="even"><td style="text-align: left;"><code>bool softAP(const char* ssid, const char* passphrase = NULL, int channel = 1, int ssid_hidden = 0, int max_connection = 4, bool ftm_responder = false)</code></td><td style="text-align: left;">配置 Wi-Fi 的 AP 特性</td></tr><tr class="odd"><td style="text-align: left;"><code>bool softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet)</code></td><td style="text-align: left;">用于配置静态 IP、网关、子网。</td></tr><tr class="even"><td style="text-align: left;"><code>bool softAPdisconnect(bool wifioff = false)</code></td><td style="text-align: left;">强制断开 AP 连接。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint8_t softAPgetStationNum()</code></td><td style="text-align: left;">返回当前连接到 AP 的客户端数量。</td></tr><tr class="even"><td style="text-align: left;"><code>IPAddress softAPIP()</code></td><td style="text-align: left;">获取 AP 的 IPv4 地址。</td></tr><tr class="odd"><td style="text-align: left;"><code>IPAddress softAPBroadcastIP()</code></td><td style="text-align: left;">获取 AP 的 IPv4 广播地址。</td></tr><tr class="even"><td style="text-align: left;"><code>IPAddress softAPNetworkID()</code></td><td style="text-align: left;">获取 AP 网络的 ID。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint8_t softAPSubnetCIDR()</code></td><td style="text-align: left;">获取 AP 网络的子网 CIDR。</td></tr><tr class="even"><td style="text-align: left;"><code>IPAddress softAPSubnetMask()</code></td><td style="text-align: left;">获取 AP 网络的子网掩码。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool softAPenableIpV6()</code></td><td style="text-align: left;">启用 IPv6 支持。</td></tr><tr class="even"><td style="text-align: left;"><code>IPv6Address softAPIPv6()</code></td><td style="text-align: left;">获取 IPv6 地址。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool softAPsetHostname(const char * hostname)</code></td><td style="text-align: left;">设置 AP 的主机名称。</td></tr><tr class="even"><td style="text-align: left;"><code>const char * softAPgetHostname()</code></td><td style="text-align: left;">获取 AP 的主机名称。</td></tr><tr class="odd"><td style="text-align: left;"><code>uint8_t* softAPmacAddress(uint8_t* mac)</code></td><td style="text-align: left;">设置或者获取 AP 的 MAC 地址。</td></tr><tr class="even"><td style="text-align: left;"><code>String softAPSSID(void) const</code></td><td style="text-align: left;">获取 AP 网络的 SSID。</td></tr></tbody></table><table><colgroup><col style="width: 72%"><col style="width: 27%"></colgroup><thead><tr class="header"><th style="text-align: left;">STA 模式 WIFI 相关 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>wl_status_t begin(const char* ssid, const char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);</code></td><td style="text-align: left;">启动 Wi-Fi 连接。</td></tr><tr class="even"><td style="text-align: left;"><code>bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = (uint32_t)0x00000000, IPAddress dns2 = (uint32_t)0x00000000)</code></td><td style="text-align: left;">配置 IP 地址、网关、子网、DNS 信息。</td></tr><tr class="odd"><td style="text-align: left;"><code>IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)</code></td><td style="text-align: left;"><code>IPAddress</code> 格式由 4个字节进行定义。</td></tr><tr class="even"><td style="text-align: left;"><code>bool reconnect()</code></td><td style="text-align: left;">重新连接 Wi-Fi。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool disconnect(bool wifioff = false, bool eraseap = false)</code></td><td style="text-align: left;">强制断开 Wi-Fi 连接。</td></tr><tr class="even"><td style="text-align: left;"><code>bool isConnected();</code></td><td style="text-align: left;">获取 Wi-Fi 连接状态。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool setAutoReconnect(bool autoReconnect)</code></td><td style="text-align: left;">设置连接丢失时，是否开启自动重新连接。</td></tr><tr class="even"><td style="text-align: left;"><code>bool getAutoReconnect()</code></td><td style="text-align: left;">获取连接丢失时，自动重连的设置状态。</td></tr><tr class="odd"><td style="text-align: left;"><code>bool setMinSecurity(wifi_auth_mode_t minSecurity)</code></td><td style="text-align: left;">设置 AP 连接的最低安全性，默认为<code>WIFI_AUTH_WPA2_PSK</code>。</td></tr></tbody></table><table><colgroup><col style="width: 75%"><col style="width: 24%"></colgroup><thead><tr class="header"><th style="text-align: left;">WiFiMulti 相关 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>bool addAP(const char* ssid, const char *passphrase = NULL)</code></td><td style="text-align: left;">添加多个 AP 接入点。</td></tr><tr class="even"><td style="text-align: left;"><code>uint8_t run(uint32_t connectTimeout=5000)</code></td><td style="text-align: left;">开始运行 WiFiMulti。</td></tr></tbody></table><table><colgroup><col style="width: 81%"><col style="width: 18%"></colgroup><thead><tr class="header"><th style="text-align: left;">WiFiScan 相关 API</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>int16_t scanNetworks(bool async = false, bool show_hidden = false, bool passive = false, uint32_t max_ms_per_chan = 300, uint8_t channel = 0)</code></td><td style="text-align: left;">开始扫描可用的 WiFi 网络。</td></tr><tr class="even"><td style="text-align: left;"><code>int16_t scanComplete()</code></td><td style="text-align: left;">采用异步模式获取扫描状态。</td></tr><tr class="odd"><td style="text-align: left;"><code>void scanDelete()</code></td><td style="text-align: left;">删除 RAM 当中的最后一次扫描结果。</td></tr><tr class="even"><td style="text-align: left;"><code>bool getNetworkInfo(uint8_t networkItem, String &amp;ssid, uint8_t &amp;encryptionType, int32_t &amp;RSSI, uint8_t* &amp;BSSID, int32_t &amp;channel)</code></td><td style="text-align: left;">获取扫描到的 WIFI 网络信息。</td></tr></tbody></table><p>提供了 WIFI 接入点，并且运行了一个 Web服务器，<code>http://192.168.4.1/H</code> 去打开 LED on or<code>http://192.168.4.1/L</code></p><h2 id="使用-httpclient-发起-get-请求">使用 HttpClient 发起 GET请求</h2><p><strong>ESP32-Arduino</strong> 内嵌有一个开源的 <a href="http://github.com/amcewen/HttpClient">HttpClient</a>库，可以方便的与 Web 服务器进行交互。下面的示例代码会通过 WIFI局域网，不断的向 <code>http://www.uinio.com</code> 地址发起一个<strong>HTTP GET</strong> 请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiMulti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">WiFiMulti wifiMulti;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;===== 开始 [SETUP] 配置 =====&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 延时等待 5 秒 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> t = <span class="number">5</span>; t &gt; <span class="number">0</span>; t--) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在运行 [SETUP]，请等待 %d... 秒\n&quot;</span>, t);</span><br><span class="line">    Serial.flush();</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;SSID&quot;</span>, <span class="string">&quot;Password&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 等待 WIFI 连接成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((wifiMulti.run() == WL_CONNECTED))</span><br><span class="line">    HTTPClient http;</span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;准备 [HTTP] 请求...\n&quot;</span>);</span><br><span class="line">    http.begin(<span class="string">&quot;http://www.uinio.com&quot;</span>);  <span class="comment">// 准备向 UinIO.com 发起 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;开始 [HTTP] GET 请求...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> HttpCode = http.GET();  <span class="comment">// 开始连接，发送 HTTP 协议头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当 HTTP 状态码为负值时表示出现错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] GET 请求成功，响应状态码为: %d\n&quot;</span>, HttpCode);  <span class="comment">// 打印 HTTP 请求响应状态码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 GET 请求获取到的内容 */</span></span><br><span class="line">      <span class="keyword">if</span> (HttpCode == HTTP_CODE_OK) &#123;</span><br><span class="line">        String payload = http.getString();</span><br><span class="line">        Serial.println(payload);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] GET 请求失败，错误信息为: %s\n&quot;</span>, http.errorToString(HttpCode).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    http.end();  <span class="comment">// 结束 HTTPClient 服务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">6000</span>);   <span class="comment">// 延时 6 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配合-arduinojson-发起-post-请求">配合 ArduinoJson 发起 POST请求</h2><p>除此之外，配合第三方 JSON 解析库 <a href="https://arduinojson.org/">ArduinoJson</a> 使用，还可以方便的以<strong>POST</strong> 方式传输 JSON格式的数据。下面的示例代码，将会携带一个包含有 <code>data</code> 属性的JSON 对象参数，向远程服务器的 <code>http://192.168.1.1:8080/test</code>接口发起一个 <strong>HTTP POST</strong>请求，并且将响应的结果打印出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiMulti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HTTPClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ArduinoJson.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">WiFiMulti wifiMulti;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;===== 开始 [SETUP] 配置 =====&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 延时等待 5 秒 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> t = <span class="number">5</span>; t &gt; <span class="number">0</span>; t--) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;正在运行 [SETUP]，请等待 %d... 秒\n&quot;</span>, t);</span><br><span class="line">    Serial.flush();</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;SSID&quot;</span>, <span class="string">&quot;Password&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 等待 WIFI 连接成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((wifiMulti.run() == WL_CONNECTED)) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;准备 [HTTP] 请求...\n&quot;</span>);</span><br><span class="line">    http.begin(<span class="string">&quot;http://192.168.1.1:8080/test&quot;</span>);  <span class="comment">// 准备向 UinIO.com 发起 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    Serial.print(<span class="string">&quot;开始 [HTTP] POST 请求...\n&quot;</span>);</span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String serializeResult;</span><br><span class="line">    DynamicJsonDocument <span class="title function_">JsonParameter</span><span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">    JsonParameter[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;电子技术博客 UinIO.com&quot;</span>;</span><br><span class="line">    serializeJson(JsonParameter, serializeResult);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> HttpCode = http.POST((<span class="type">uint8_t</span>*)serializeResult.c_str(), serializeResult.length());  <span class="comment">// 开始连接，发送 HTTP 协议头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当 HTTP 状态码为负值时表示出现错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] POST 请求成功，响应状态码为: %d\n&quot;</span>, HttpCode);  <span class="comment">// 打印 HTTP 请求响应状态码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 GET 请求获取到的内容 */</span></span><br><span class="line">      <span class="keyword">if</span> (HttpCode == HTTP_CODE_OK) &#123;</span><br><span class="line">        String payload = http.getString();</span><br><span class="line">        Serial.println(payload);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;当前 [HTTP] POST 请求失败，错误信息为: %s\n&quot;</span>, http.errorToString(HttpCode).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    http.end();  <span class="comment">// 结束 HTTPClient 服务</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">6000</span>);   <span class="comment">// 延时 6 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/espressif/arduino-esp32&quot;&gt;&lt;strong&gt;Arduino-ESP32&lt;/strong&gt;&lt;/a&gt;
是由&lt;strong&gt;乐鑫科技&lt;/strong&gt;在 &lt;strong&gt;GitHub&lt;/strong&gt;
开源社区推出的一款基于 &lt;strong&gt;Arduino IDE&lt;/strong&gt;
的&lt;strong&gt;板级支持包&lt;/strong&gt;（&lt;strong&gt;BSP&lt;/strong&gt;，Board Support
Package），除了兼容大部分通用的 &lt;a href=&quot;https://www.arduino.cc/reference/en/&quot;&gt;&lt;strong&gt;Arduino
API&lt;/strong&gt;&lt;/a&gt; 之外，还能够支持 &lt;strong&gt;ESP32&lt;/strong&gt;
系列芯片一些独有的特性化
&lt;strong&gt;API&lt;/strong&gt;。由于几年以前已经撰写过一篇基于标准 Arduino API
的&lt;a href=&quot;http://uinio.com/Embedded/Arduino/&quot;&gt;《玩转 Arduino
Uno、Mega、ESP 开源硬件》&lt;/a&gt;，所以本篇文章不再赘述相关内容，而是结合
&lt;code&gt;U8G2&lt;/code&gt;、&lt;code&gt;AsyncTimer&lt;/code&gt;、&lt;code&gt;RBD_BUTTON&lt;/code&gt;、&lt;code&gt;LiquidCrystal_I2C&lt;/code&gt;、&lt;code&gt;ESP32SPISlave&lt;/code&gt;、&lt;code&gt;Servo&lt;/code&gt;、&lt;code&gt;SdFat&lt;/code&gt;
等常用第三方库，通过分析注释典型的示例代码，分门别类的介绍了各种片上资源外设的实例化运用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/Arduino-ESP32/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESP32-C3&lt;/strong&gt; 和 &lt;strong&gt;ESP32-S3&lt;/strong&gt;
是当前市场上比较流行的两款物联网主控芯片方案，它们分别基于开源的
&lt;strong&gt;RISC-V&lt;/strong&gt; 内核，以及商业化的 &lt;strong&gt;Xtensa&lt;/strong&gt;
内核，并且同时支持 WiFi 与 Bluetooth
无线连接。由于日常工作当中经常使用到这两款微控制器，所以特意设计了 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32C3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32C3&lt;/strong&gt;&lt;/a&gt;
和 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32S3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32S3&lt;/strong&gt;&lt;/a&gt;
两款核心板，关于它们硬件电路设计方面的相关内容，可以进一步参考本篇文章的姊妹篇&lt;a href=&quot;http://uinio.com/Project/UINIO-MCU-ESP32/&quot;&gt;《UINIO-MCU-ESP32
核心板电路设计》&lt;/a&gt;。由于本文属于 Arduino
进阶性质的教程，阅读时需要具备一定的嵌入式开发经验，萌新可以阅读笔者更早之前撰写的&lt;a href=&quot;http://uinio.com/Embedded/Arduino/&quot;&gt;《玩转 Arduino Uno、Mega、ESP
开源硬件》&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="Arduino" scheme="http://www.uinio.com/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>常见 LDO 线性稳压芯片的对比选型</title>
    <link href="http://www.uinio.com/Electronics/LDO/"/>
    <id>http://www.uinio.com/Electronics/LDO/</id>
    <published>2023-04-09T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:49.889Z</updated>
    
    <content type="html"><![CDATA[<p><strong>稳压器</strong>（VoltageRegulator）是一种在电源电压或者负载电流发生变化的时候，依然能够提供稳定输出电压的元件。常见的稳压器主要分为<strong>线性稳压器</strong>和<strong>开关稳压器</strong>两种。其中，<strong>开关稳压器</strong>是通过重复切换输出级的开关状态，并配合其它储能元件来产生指定的输出电压。而<strong>线性稳压器</strong>则是通过获取输出电压反馈，然后经由<strong>误差放大器</strong>组成的控制电路，动态的调节输入与输出之间的电压差，进而实现动态稳压的目的，其主要特点是输入电压<span class="math inline">\(V_{IN}\)</span> 大于输出电压 <span class="math inline">\(V_{OUT}\)</span>。</p><p><img src="/Electronics/LDO/logo.png"></p><p>近几年<strong>低压差稳压器</strong>（<strong>LDO</strong>，LowDropoutRegulator）被广泛应用在微控制器电路当中，其主要特点在于输入电压与输出电压之间的压差<span class="math inline">\(V_{DROPOUT}\)</span>非常小（通常在几十毫伏到几百毫伏范围）。在上述的 <strong>LDO</strong>原理示意图当中，绿色的<strong>误差放大器</strong>通过改变内部的<strong>可变电阻</strong>，就能够达到了稳定<strong>输出电压</strong><span class="math inline">\(V_{OUT}\)</span> 的目的（其中 <span class="math inline">\(RDS_{ON}\)</span> 包含了 <strong>LDO</strong>内部的<code>调整元件电阻</code>、<code>片内互连电阻</code>、<code>引脚电阻</code>、<code>线焊电阻</code>）。</p><span id="more"></span><h2 id="经典线性稳压器-1117-系列">经典线性稳压器 1117 系列</h2><p><strong>AMS</strong> 公司（Advanced Monolithic Systems）的 <a href="http://www.advanced-monolithic.com/pdf/ds1117.pdf"><strong>AMS1117</strong></a>是一款比较经典的线性稳压器。除此之外，<a href="https://www.ti.com.cn/product/cn/TLV1117"><strong>德州仪器TLV1117</strong></a>、<a href="https://www.onsemi.cn/products/power-management/linear-regulators-ldo/ncp1117"><strong>安森美NCP1117</strong></a>、<a href="http://www.microne.com.cn/ProductDetail.aspx?id=87"><strong>微盟电子ME1117</strong></a>、<a href="https://www.jscj-elec.com/uploads/pdf/20221010/SCJT1117B-A%20Series%20Rev-1.4.pdf"><strong>长晶科技CJT1117</strong></a> 也推出了类似命名的 Pin-to-Pin产品。<strong>SOT-223</strong> 是 <strong>1117</strong>系列芯片的典型封装形式，下面的示意图对其引脚的功能进行了说明：</p><p><img src="/Electronics/LDO/0.png"></p><p>而下面的原理图是<strong>固定电压输出</strong>版本<strong>1117</strong> 的典型应用电路，这里推荐使用 <code>10uF</code>的<strong>钽电容</strong>作为<strong>旁路电容</strong> <span class="math inline">\(C_1\)</span>，以及 <code>10uF</code>的<strong>钽电容</strong>作为<strong>输出电容</strong> <span class="math inline">\(C_2\)</span>：</p><p><img src="/Electronics/LDO/1.png"></p><p>而下面的原理图则是<strong>可调电压输出</strong>版本<strong>1117</strong> 的典型应用电路，其输出电压公式为 <span class="math inline">\(V_{OUT} = V_{REF} \times (1 + \frac{R_2}{R_1}) +I_{ADJ} \times R_2\)</span>。公式当中的 <span class="math inline">\(I_{ADJ}\)</span>（约<code>50uA</code>）通常可以被忽略，因为其值远远小于 <span class="math inline">\(R_1\)</span> 上面的电流（约<code>2mA ~ 10mA</code>）。</p><p><img src="/Electronics/LDO/2.png"></p><h3 id="输出电压精度">输出电压精度</h3><p><strong>1117</strong>系列线性稳压器的输出电压精度，通常为标称电压值的 <span class="math inline">\(\pm 1.5 \%\)</span> 左右，即如果标称输出电压为<code>3.3V</code>，那么实际的输出电压应当介于 <code>3.25V ~ 3.35V</code>之间：</p><table><thead><tr class="header"><th style="text-align: center;">元件型号</th><th style="text-align: center;">空载输出电压</th><th style="text-align: center;">满载输出电压</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>AMS1117</strong></td><td style="text-align: center;"><code>3.33V</code></td><td style="text-align: center;"><code>3.3V</code></td></tr><tr class="even"><td style="text-align: center;"><strong>TLV1117</strong></td><td style="text-align: center;"><code>3.27V</code></td><td style="text-align: center;"><code>3.26V</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>NCP1117</strong></td><td style="text-align: center;"><code>3.31V</code></td><td style="text-align: center;"><code>3.3V</code></td></tr><tr class="even"><td style="text-align: center;"><strong>ME1117</strong></td><td style="text-align: center;"><code>3.28V</code></td><td style="text-align: center;"><code>3.26V</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>CJT1117</strong></td><td style="text-align: center;"><code>3.32V</code></td><td style="text-align: center;"><code>3.32V</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>空载输出</strong>是指稳压器在输出电流为<code>0mA</code> 时的输出电压值，而<strong>满载输出</strong>则是指 1117芯片在输出电流为 <code>800mA</code> 时的输出电压值。</p></blockquote><h3 id="输出纹波控制">输出纹波控制</h3><p><strong>输出纹波</strong>用于衡量线性稳压器输出电压的平稳程度，是一个叠加在直流稳定值之上的交流分量。通常只需要把这种纹波控制在<code>20mV</code> 以内，就能够满足正常的使用。</p><table><thead><tr class="header"><th style="text-align: center;">元件型号</th><th style="text-align: center;">空载输出电压纹波</th><th style="text-align: center;">满载输出电压纹波</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>AMS1117</strong></td><td style="text-align: center;"><code>17.6mV</code></td><td style="text-align: center;"><code>19.2mV</code></td></tr><tr class="even"><td style="text-align: center;"><strong>TLV1117</strong></td><td style="text-align: center;"><code>16.2mV</code></td><td style="text-align: center;"><code>18.4mV</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>NCP1117</strong></td><td style="text-align: center;"><code>15.8mV</code></td><td style="text-align: center;"><code>16.8mV</code></td></tr><tr class="even"><td style="text-align: center;"><strong>ME1117</strong></td><td style="text-align: center;"><code>16.7mV</code></td><td style="text-align: center;"><code>17.6mV</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>CJT1117</strong></td><td style="text-align: center;"><code>16.2mV</code></td><td style="text-align: center;"><code>16.8mV</code></td></tr></tbody></table><h3 id="动态电压波动">动态电压波动</h3><p>因为线性稳压器的后级负载通常是动态变化的，所以就会导致其输出电压发生波动，这种波动是衡量线性稳压器性能一个非常重要的参数。</p><table><thead><tr class="header"><th style="text-align: center;">元件型号</th><th style="text-align: center;">波动电压大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>AMS1117</strong></td><td style="text-align: center;"><code>344mV</code></td></tr><tr class="even"><td style="text-align: center;"><strong>TLV1117</strong></td><td style="text-align: center;"><code>94mV</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>NCP1117</strong></td><td style="text-align: center;"><code>134mV</code></td></tr><tr class="even"><td style="text-align: center;"><strong>ME1117</strong></td><td style="text-align: center;"><code>216mV</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>CJT1117</strong></td><td style="text-align: center;"><code>172mV</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：通常 <strong>1117</strong>系列的<strong>输出电容</strong>都会要求使用<strong>钽电容</strong>，而非相同容值的<strong>陶瓷电容</strong>，这是因为钽电容的<strong>寄生电阻</strong>较大，而陶瓷电容的寄生电阻较小。换而言之<strong>1117</strong>系列的电源环路稳定性，非常依赖于拥有更大寄生电阻的钽电容，从而提升其动态响应性能。</p></blockquote><h3 id="选型总结">选型总结</h3><ul><li>通常情况下 <strong>1117</strong> 系列的最大输出电流为<code>1A</code>，但是当在 <code>5V</code> 转 <code>3.3V</code>且输出电流为 <code>800mA</code> 的时候，芯片的发热温度将会达到<code>130°C</code> 左右，所以尽量不要让 <strong>1117</strong> 去负载高于<code>1W</code> 的功率；</li><li>由于 <strong>1117</strong> 系列的 <strong>SOT-223</strong>封装体积较大，比较浪费 PCB布线空间，并且不能使用陶瓷电容作为滤波电容，同时静态电流也比较大（毫安级别），因而不适用于低功耗场景，加之假货与翻新件泛滥成灾，所以工程实践当中已经较少被使用到；</li></ul><h2 id="低压差线性稳压器-ldo">低压差线性稳压器 LDO</h2><p><strong>低压差稳压器</strong>（<strong>LDO</strong>，Low DropoutRegulator）相对于传统的<strong>线性稳压器</strong>而言，输入与输出之间的电压差更小。传统的<strong>78xx</strong> 系列线性稳压器，其输入电压至少要比输出电压高出<code>2V ~ 3V</code>。即便是要求更低一些的 <strong>1117</strong>系列，其压差也至少应在 <code>1V</code> 以上。这种情况对于<code>5V</code> 转 <code>3.3V</code> 的场景，其输入与输出之间的压差仅有<code>1.7V</code>，显然无法满足正常工作的要求，因此 LDO低压差稳压器应运而生，下面表格展示市场上常见的三款 LDO芯片的性能参数：</p><table><thead><tr class="header"><th style="text-align: center;">LDO 型号</th><th style="text-align: center;">封装形式</th><th style="text-align: center;">静态电流</th><th style="text-align: center;">输出纹波</th><th style="text-align: center;">动态响应</th><th style="text-align: center;">输出精度</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>XC6206</strong></td><td style="text-align: center;">SOT-23-3</td><td style="text-align: center;"><code>1.4uA</code></td><td style="text-align: center;"><code>&lt; 5mV</code></td><td style="text-align: center;"><code>680mV</code></td><td style="text-align: center;"><code>0.6%</code></td></tr><tr class="even"><td style="text-align: center;"><strong>ME6206</strong></td><td style="text-align: center;">SOT-23-3</td><td style="text-align: center;"><code>8.3uA</code></td><td style="text-align: center;"><code>&lt; 5mV</code></td><td style="text-align: center;"><code>11.6mV</code></td><td style="text-align: center;"><code>0.9%</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>ME6211</strong></td><td style="text-align: center;">SOT-23-5</td><td style="text-align: center;"><code>36.9mA</code></td><td style="text-align: center;"><code>&lt; 5mV</code></td><td style="text-align: center;"><code>18.2mV</code></td><td style="text-align: center;"><code>0.6%</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：当上述芯片的输出电流为 <code>100mA</code>的时候，发热温度约等于 <code>55°C</code>，而当输出电流达到<code>200mA</code> 的时候，则发热温度也将会达到<code>76°C</code>，高于这个温度就需要考虑加装散热装置，并且选用更加有利于散热的PCB 布局。</p></blockquote><ul><li>对于 <strong>SOT-23</strong> 封装的 LDO 线性稳压芯片，在<code>5V</code> 转 <code>3.3V</code> 的情况下，最大输入电流应当控制在<code>200mA</code> 以内。如果需要使用更大的输出电流，则可以考虑使用<strong>1117</strong> 系列；</li><li><strong>特瑞仕</strong>的 <strong>XC6206</strong>静态电流较小，适合低功耗场景，但是需要注意它的动态响应和纹波都比较大；</li><li><strong>微盟电子</strong>的 <strong>ME6211</strong> 和<strong>ME6206</strong>系列性价比较高，小批量采购不容易购买到假货；</li><li><strong>SOT-23-5</strong> 封装的 LDO 元件相比于<strong>SOT-23-3</strong> 多出一个 <code>ENABLE</code>控制引脚（关断之后电流较小），如果需要控制输出就选择<strong>SOT-23-5</strong> 封装，如果希望更小的封装，则可以选择<strong>SOT-23-3</strong> 封装；</li></ul><h2 id="特瑞仕-xc6206-系列">特瑞仕 XC6206 系列</h2><p><a href="https://product.torex.com.cn/cn/series/xc6206"><strong>特瑞仕XC6206</strong></a> 系列是一款高精度低功耗的 LDO线性稳压芯片，即使在输出电流较大的情况下，其输入与输出之间的<strong>压差</strong>依然较小。其常见的<strong>SOT-23-3</strong> 封装通常拥有<code>输入</code>、<code>输出</code>、<code>接地</code>三个引脚，内部包含有<strong>限流电路</strong>、<strong>驱动三极管</strong>、<strong>高精度参考电压源</strong>、<strong>误差校正电路</strong>等单元电路：</p><p><img src="/Electronics/LDO/3.png"></p><p><strong>XC6206</strong>系列稳压芯片的主要性能参数如下面的表格所示：</p><table><colgroup><col style="width: 17%"><col style="width: 82%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">参数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>最大输出电流</strong></td><td style="text-align: center;"><code>200mA (3.0V type)</code></td></tr><tr class="even"><td style="text-align: center;"><strong>输入输出压差</strong></td><td style="text-align: center;"><code>250mV @ 100mA (3.0V type)</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>最大工作电压</strong></td><td style="text-align: center;"><code>6.0V</code></td></tr><tr class="even"><td style="text-align: center;"><strong>输出电压范围</strong></td><td style="text-align: center;"><code>1.2V ~ 5.0V</code>（<code>0.1V</code> 递进）</td></tr><tr class="odd"><td style="text-align: center;"><strong>输出精度</strong></td><td style="text-align: center;"><span class="math inline">\(\pm2\%@V_{OUT}\ge1.5V\)</span>、<span class="math inline">\(\pm30mV@V_{OUT}&lt;1.5V\)</span>、<span class="math inline">\(\pm1\% @V_{OUT}\ge2.0V\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>低功耗</strong></td><td style="text-align: center;">典型值为 <code>1.0 μA</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>输出电容类型</strong></td><td style="text-align: center;">可以兼容低 ESR 的陶瓷电容</td></tr><tr class="even"><td style="text-align: center;"><strong>保护措施</strong></td><td style="text-align: center;">内置限流电路</td></tr><tr class="odd"><td style="text-align: center;"><strong>工作环境温度</strong></td><td style="text-align: center;">-40℃ ~ 85℃</td></tr></tbody></table><p><strong>XC6206</strong>系列可以选用较低<strong>等效串联电阻</strong>（ESR，Equivalent SeriesResistance）的陶瓷电容，并且可以通过内部的限流电路提供输出引脚的短路保护，其典型应用电路如下面的原理图所示：</p><p><img src="/Electronics/LDO/4.png"></p><h2 id="微盟电子-me6206-系列">微盟电子 ME6206 系列</h2><p><a href="http://www.microne.com.cn/"><strong>微盟电子</strong></a>推出的<strong>ME6206</strong>系列是一款低功耗低压差、高纹波抑制率，并且具有过流与短路保护的 CMOS降压型稳压芯片，该系列元件具有较低的<strong>静态偏置电流</strong>（典型值为<code>8.0μA</code>），可以在输入输出电压差极小情况下，提供约<code>300mA</code> 的输出电流，并且仍然能够保持良好的调整率。</p><table><colgroup><col style="width: 22%"><col style="width: 77%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">参数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>高精度输出电压</strong></td><td style="text-align: center;"><code>±2%</code></td></tr><tr class="even"><td style="text-align: center;"><strong>输出电压</strong></td><td style="text-align: center;"><code>1.5V ~ 5.0V</code>，步长为<code>0.1V</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>最大工作电压</strong></td><td style="text-align: center;"><code>6V</code></td></tr><tr class="even"><td style="text-align: center;"><strong>静态偏置电流典型值</strong></td><td style="text-align: center;"><code>8.0μA</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>带载能力</strong></td><td style="text-align: center;">当 <span class="math inline">\(V_{in}=4.3V\)</span> 且 <span class="math inline">\(V_{out}=3.3V\)</span> 的时候，输出电流 <span class="math inline">\(I_{out}=300mA\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>输入输出电压差</strong></td><td style="text-align: center;">输出电流为 <code>90mA</code> 时的压差为<code>0.2V</code>，而输出电流为 <code>200mA</code> 时的压差为<code>0.4V</code></td></tr></tbody></table><p><strong>ME6206</strong> 系列稳压芯片的常用封装形式为<strong>SOT-23-3</strong>，其典型应用电路如下图所示：</p><p><img src="/Electronics/LDO/5.png"></p><blockquote><p><strong>注意</strong>：上述原理图当中的 <strong>VIN</strong>表示电压输入引脚，<strong>VOUT</strong> 表示电压输出引脚，而<strong>VSS</strong> 则表示的是接地引脚。</p></blockquote><h2 id="微盟电子-me6211-系列">微盟电子 ME6211 系列</h2><p><a href="http://www.microne.com.cn/"><strong>微盟电子</strong></a>推出的<strong>ME6211</strong>系列，同样是一款高精度、高纹波抑制比、低噪声，快速响应的 CMOS低压差线性稳压器，该芯片内置有<code>参考电压源</code>、<code>误差修正电路</code>、<code>限流电路</code>、<code>相位补偿电路</code>、<code>低内阻 MOSFET</code>，可以达到高纹波抑制、低输出噪声、超快速响应的性能指标：</p><table><colgroup><col style="width: 21%"><col style="width: 78%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">参数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>最大输出电流</strong></td><td style="text-align: center;">当 <span class="math inline">\(V_{in}=5V\)</span> 且 <span class="math inline">\(V_{out}=3.3V\)</span> 的时候，输出电流 <span class="math inline">\(I_{out}=500mA\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>输入输出电压差</strong></td><td style="text-align: center;">输出电流为 <code>100mA</code> 时压差为<code>100mV</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>工作电压范围</strong></td><td style="text-align: center;"><code>2V ～ 6.0V</code></td></tr><tr class="even"><td style="text-align: center;"><strong>输出电压范围</strong></td><td style="text-align: center;"><code>1.2V ～ 5.0V</code>，步长为<code>0.1V</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>输出精度</strong></td><td style="text-align: center;"><code>±2％</code></td></tr><tr class="even"><td style="text-align: center;"><strong>静态电流</strong></td><td style="text-align: center;">典型值为 <code>50uA</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>关断电流</strong></td><td style="text-align: center;">典型值为 <code>0.1uA</code></td></tr><tr class="even"><td style="text-align: center;"><strong>纹波抑制比</strong></td><td style="text-align: center;">例如 ME6211C33 为<code>70dB@1KHz</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>输出噪声</strong></td><td style="text-align: center;"><code>50uVrms</code></td></tr><tr class="even"><td style="text-align: center;"><strong>输入稳定性</strong></td><td style="text-align: center;">典型值为 <code>0.05％</code></td></tr></tbody></table><p><strong>ME6211</strong>系列兼容体积相对于<strong>钽电容</strong>更加小巧的<strong>陶瓷电容</strong>，并且无需再额外使用<code>0.1μF</code>的旁路电容，可以进一步节省物料成本。除此之外，<strong>ME6211</strong>系列常用的封装形式为<strong>SOT-23-5</strong>，其典型应用电路如下图所示：</p><p><img src="/Electronics/LDO/6.png"></p><blockquote><p><strong>注意</strong>：上图当中的 <strong>VIN</strong>是电压输入引脚，<strong>VOUT</strong> 是电压输出引脚，<strong>VSS</strong> 属于接地引脚，<strong>CE</strong>则是使能引脚（高电平），而 <strong>NC</strong> 引脚无需进行连接。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;稳压器&lt;/strong&gt;（Voltage
Regulator）是一种在电源电压或者负载电流发生变化的时候，依然能够提供稳定输出电压的元件。常见的稳压器主要分为&lt;strong&gt;线性稳压器&lt;/strong&gt;和&lt;strong&gt;开关稳压器&lt;/strong&gt;两种。其中，&lt;strong&gt;开关稳压器&lt;/strong&gt;是通过重复切换输出级的开关状态，并配合其它储能元件来产生指定的输出电压。而&lt;strong&gt;线性稳压器&lt;/strong&gt;则是通过获取输出电压反馈，然后经由&lt;strong&gt;误差放大器&lt;/strong&gt;组成的控制电路，动态的调节输入与输出之间的电压差，进而实现动态稳压的目的，其主要特点是输入电压
&lt;span class=&quot;math inline&quot;&gt;&#92;(V_{IN}&#92;)&lt;/span&gt; 大于输出电压 &lt;span class=&quot;math inline&quot;&gt;&#92;(V_{OUT}&#92;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/LDO/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;近几年&lt;strong&gt;低压差稳压器&lt;/strong&gt;（&lt;strong&gt;LDO&lt;/strong&gt;，Low
Dropout
Regulator）被广泛应用在微控制器电路当中，其主要特点在于输入电压与输出电压之间的压差
&lt;span class=&quot;math inline&quot;&gt;&#92;(V_{DROPOUT}&#92;)&lt;/span&gt;
非常小（通常在几十毫伏到几百毫伏范围）。在上述的 &lt;strong&gt;LDO&lt;/strong&gt;
原理示意图当中，绿色的&lt;strong&gt;误差放大器&lt;/strong&gt;通过改变内部的&lt;strong&gt;可变电阻&lt;/strong&gt;，就能够达到了稳定&lt;strong&gt;输出电压&lt;/strong&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(V_{OUT}&#92;)&lt;/span&gt; 的目的（其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(RDS_{ON}&#92;)&lt;/span&gt; 包含了 &lt;strong&gt;LDO&lt;/strong&gt;
内部的
&lt;code&gt;调整元件电阻&lt;/code&gt;、&lt;code&gt;片内互连电阻&lt;/code&gt;、&lt;code&gt;引脚电阻&lt;/code&gt;、&lt;code&gt;线焊电阻&lt;/code&gt;）。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="电源" scheme="http://www.uinio.com/tags/%E7%94%B5%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>快速上手 UINIO-Logic-24MHz 逻辑分析仪</title>
    <link href="http://www.uinio.com/Project/UINIO-Logic-24MHz/"/>
    <id>http://www.uinio.com/Project/UINIO-Logic-24MHz/</id>
    <published>2023-03-19T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.369Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/uinika/UINIO-Logic-24MHz"><strong>UINIO-Logic-24MHz</strong></a>是一款同时兼容<strong>赛普拉斯</strong>（已经被英飞凌收购）<code>CY7C68013A</code>和<strong>芯佰微电子</strong> <code>CBM9002A</code> 两款 USB控制器的开源逻辑分析仪，可以同时采集 8个通道的数字信号，单个通道的最大采样频率为<code>24Mhz</code>，可以支持高达 <code>5.5V</code> 的逻辑电平（大于<code>2V</code> 视为高电平，低于 <code>0.8V</code>视为低电平）。即可以采用 <a href="https://sigrok.org/wiki/Downloads"><strong>Sigrok PulseView</strong></a>（可以实时下载固件），也可以采用 <a href="https://www.saleae.com/zh/downloads/"><strong>SaleaeLogic</strong></a>（需提前烧录固件）作为逻辑分析仪的上位机程序。</p><p><img src="/Project/UINIO-Logic-24MHz/logo.png"></p><p><strong>逻辑分析仪</strong>（LogicAnalyzer）作为一种非常重要的数字信号分析仪器，虽然市场上已经存在有 <a href="https://dreamsourcelab.cn/product/dslogic-series/">DSLogic</a>或者 <a href="https://usd.saleae.com/products/saleae-logic-pro-16">Saleae</a>等功能强大的商业化产品，但是在日常的微控制器与数字信号总线开发过程当中，如果不是用于调试<code>PCIE</code>、<code>USB3.0</code> 等高速信号，一台小巧可靠的<strong>24MHz</strong>采样率逻辑分析仪，就已经足以应付大多数的开发场景。因而笔者在自己的 <a href="https://github.com/uinika"><strong>GitHub</strong></a>当中，开源了这款逻辑分析仪的全部 <strong>KiCad</strong> 原理图以及<strong>PCB</strong>版图，希望能够对于广大电子工程师的工作有所帮助。</p><span id="more"></span><h1 id="uinio-logic-24mhz-参数简介">UINIO-Logic-24MHz 参数简介</h1><p><a href="https://github.com/uinika/UINIO-Logic-24MHz"><strong>UINIO-Logic-24MHz</strong></a>是一款<strong>硬件电路</strong>、<strong>固件程序</strong>、<strong>上位机软件</strong>均开源的逻辑分析仪，可以完成一百余种总线协议的解析工作，最高可以支持到<strong>24Mhz</strong> 采样频率 <strong>8</strong>个采样通道，其中每个通道支持的<strong>输入电压</strong>介于<code>-0.5V ~ 5.25V</code> 之间，其中<strong>低电平</strong>范围为<code>-0.5V ~ 0.8V</code>，而<strong>高电平</strong>范围为<code>2V ~ 5.25V</code>，本项目所涉及到的全部开源工具如下面列表所示：</p><ol type="1"><li><strong>硬件电路</strong>：<a href="https://github.com/uinika/UINIO-Logic-24MHz">UINIO-Logic-24MHz</a>；</li><li><strong>固件程序</strong>：<a href="https://sigrok.org/download/binary/sigrok-firmware-fx2lafw/">sigrok-firmware-fx2lafw</a>；</li><li><strong>上位机软件</strong>：<a href="https://sigrok.org/download/binary/pulseview/">PulseView</a>；</li></ol><p>根据<strong>奈奎斯特采样定理</strong>，逻辑分析仪的采样频率至少应当是采样信号频率的<strong>5 到 10 倍</strong>，才可采样出较为完整的原始信号，所以在只开启<code>1</code> 个通道的情况下，使用最高 <code>24Mhz</code>的采样频率，<strong>UINIO-Logic-24MHz</strong> 最高可以采集到<code>5MHz</code> 左右的数字信号。</p><blockquote><p><strong>注意</strong>：由于 <strong>UINIO-Logic-24MHz</strong> 的 USB接口工作在 <strong>USB2.0 高速模式</strong>下，对于 USB接口带宽的需求比较高，而外接 USB扩展坞可能无法支撑如此高的带宽需求，所以请尽量直接连接到计算机的 USB接口上使用。</p></blockquote><h1 id="逻辑分析仪硬件原理分析">逻辑分析仪硬件原理分析</h1><p><strong>UINIO-Logic-24MHz</strong> 采用<strong>赛普拉斯</strong>（Cypress）的 <a href="https://www.infineon.com/cms/en/product/universal-serial-bus/usb-2.0-peripheral-controllers/ez-usb-fx2lp-fx2g2-usb-2.0-peripheral-controller/cy7c68013a-56ltxc/">CY7C68013A</a>作为主控芯片，内部集成有 USB 2.0 收发器、串行接口引擎（SIE）、增强型8051 微控制器，以及可编程的外设接口，其功能逻辑框图如下面所示：</p><p><img src="/Project/UINIO-Logic-24MHz/Circuit1.png"></p><p>通过片上的 <strong>GPIF</strong>（General ProgrammableInterface）与主从设备接口 <strong>FIFO</strong>（拥有 8 位或 16位数据总线），建立起计算机上位软件（例如 PulseView、Saleae Logic等）与逻辑分析仪 <strong>UINIO-Logic-24MHz</strong>采样通道（<code>CH1 ~ CH8</code>）之间的高速信号连接：</p><p><img src="/Project/UINIO-Logic-24MHz/Circuit2.png"></p><p><strong>UINIO-Logic-24MHz</strong> 板载了型号为<strong>AT24CS64-XHM</strong> 的 <code>TSSOP</code> 封装EEPROM，用于下载和存储各类逻辑分析仪的固件：</p><p><img src="/Project/UINIO-Logic-24MHz/Circuit3.png"></p><p><strong>UINIO-Logic-24MHz</strong> 的 8 条采样线，通过<code>100</code> 欧姆的限流电阻，连接至一片同样采用 <code>TSSOP</code>封装的 <strong>74HC245</strong>双向总线缓冲芯片，一方面用于隔离输入与输出，另一方面能够确保采样信号的稳定与完整性：</p><p><img src="/Project/UINIO-Logic-24MHz/Circuit4.png"></p><blockquote><p><strong>注意</strong>：国产<strong>芯佰微电子</strong>的 <a href="https://corebai.com/usb-kongzhiqi/CBM9002A-100IG.html">CBM9002A</a>是一款对标 <code>CY7C68013A</code> 的 Pin to Pin 产品。</p></blockquote><h1 id="使用-zadig-安装-usb-驱动程序">使用 Zadig 安装 USB 驱动程序</h1><p>使用 <strong>UINIO-Logic-24MHz</strong> 之前，需要手动安装<strong>PulseView</strong> 上位机软件，完成之后需要执行其安装目录下的 <a href="https://zadig.akeo.ie/"><strong>Zadig</strong></a>来安装逻辑分析仪的 USB 驱动程序，在开始进一步的操作之前，需要先将<strong>UINIO-Logic-24MHz</strong> 的 USB Type-C 接口连接至计算机：</p><p><img src="/Project/UINIO-Logic-24MHz/Zadig1.png"></p><p>双击执行 <code>zadig.exe</code>之后弹出上图的界面，首先鼠标勾选右侧的【Edit】，然后将设备名称修改为<code>fx2lafw</code>，最后按下【Install Driver】按钮开始安装驱动：</p><p><img src="/Project/UINIO-Logic-24MHz/Zadig2.png"></p><p>稍等片刻，当弹出下面信息提示框的时候，就表明当前的 USB驱动程序已经安装成功：</p><p><img src="/Project/UINIO-Logic-24MHz/Zadig3.png"></p><p>此时在操作系统的<strong>设备管理器</strong>当中，可以看到<strong>UINIO-Logic-24MHz</strong> 的设备名称已经被显示为<code>fx2lafw</code>：</p><p><img src="/Project/UINIO-Logic-24MHz/Zadig4.png"></p><h1 id="开始-pulseview-上位机的使用">开始 PulseView 上位机的使用</h1><p>安装完成 USB 驱动程序之后，保证 <strong>UINIO-Logic-24MHz</strong>稳定的插入计算机，然后打开 <code>PulseView</code> 开始进行 USB的枚举配置，并且将固件<strong>在线写入 EEPROM</strong>，成功后丝印为<code>PA1</code> 的绿色 LED 将会自动亮起：</p><p><img src="/Project/UINIO-Logic-24MHz/PulseView1.png"></p><blockquote><p><strong>注意</strong>：推荐下载使用 <strong>PulseView</strong> 的<code>pulseview-0.4.2-64bit-static-release-installer.exe</code>稳定版本，官方推荐的每晚编译版本<code>pulseview-NIGHTLY-64bit-static-release-installer.exe</code>工作十分不稳定，甚至可能会导致 <strong>UINIO-Logic-24MHz</strong>无法正确的采样信号。</p></blockquote><p><strong>PulseView</strong>的界面非常简单，可以在顶部【菜单栏】选择<strong>采样数量</strong>和<strong>采样频率</strong>，然后点击左上角的【Run】按钮，就可以开始让指定的通道采样数字信号：</p><p><img src="/Project/UINIO-Logic-24MHz/PulseView2.png"></p><blockquote><p><strong>注意</strong>：运行<code>pulseview-0.4.2-64bit-static-release-installer.exe</code>版本之前，需要先下载安装微软官方的 <a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=26999">MicrosoftVisual C++ 2010 SP1 Redistributable Package</a>，否则可能出现运行PulseView 时找不到 <code>msvcr100.dll</code> 动态链接库的错误。</p></blockquote><p><strong>PulseView</strong> 支持一百余种总线通信协议的解析，当<strong>UINIO-Logic-24MHz</strong>采集到有效的数字信号之后，鼠标点击顶部菜单栏上的<code>协议解码器</code>图标，在右侧的弹出窗口当中选择具体的通信协议：</p><p><img src="/Project/UINIO-Logic-24MHz/PulseView3.png"></p><p>例如在这里选择解析 <strong>UART</strong>协议，此时就需要在主窗口区域配置 UART的<code>波特率</code>、<code>数据奇偶校验</code>、<code>停止位</code>等信息，使得<strong>UINIO-Logic-24MHz</strong>能够正确解析出可视化的数据以供开发人员分析：</p><p><img src="/Project/UINIO-Logic-24MHz/PulseView4.png"></p><blockquote><p><strong>注意</strong>：目前 <strong>PulseView</strong>上位机支持的总线通信协议解码器可以查阅<a href="https://sigrok.org/wiki/Protocol_decoders">这个链接</a>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/uinika/UINIO-Logic-24MHz&quot;&gt;&lt;strong&gt;UINIO-Logic-24MHz&lt;/strong&gt;&lt;/a&gt;
是一款同时兼容&lt;strong&gt;赛普拉斯&lt;/strong&gt;（已经被英飞凌收购）&lt;code&gt;CY7C68013A&lt;/code&gt;
和&lt;strong&gt;芯佰微电子&lt;/strong&gt; &lt;code&gt;CBM9002A&lt;/code&gt; 两款 USB
控制器的开源逻辑分析仪，可以同时采集 8
个通道的数字信号，单个通道的最大采样频率为
&lt;code&gt;24Mhz&lt;/code&gt;，可以支持高达 &lt;code&gt;5.5V&lt;/code&gt; 的逻辑电平（大于
&lt;code&gt;2V&lt;/code&gt; 视为高电平，低于 &lt;code&gt;0.8V&lt;/code&gt;
视为低电平）。即可以采用 &lt;a href=&quot;https://sigrok.org/wiki/Downloads&quot;&gt;&lt;strong&gt;Sigrok Pulse
View&lt;/strong&gt;&lt;/a&gt;（可以实时下载固件），也可以采用 &lt;a href=&quot;https://www.saleae.com/zh/downloads/&quot;&gt;&lt;strong&gt;Saleae
Logic&lt;/strong&gt;&lt;/a&gt;（需提前烧录固件）作为逻辑分析仪的上位机程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-Logic-24MHz/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑分析仪&lt;/strong&gt;（Logic
Analyzer）作为一种非常重要的数字信号分析仪器，虽然市场上已经存在有 &lt;a href=&quot;https://dreamsourcelab.cn/product/dslogic-series/&quot;&gt;DSLogic&lt;/a&gt;
或者 &lt;a href=&quot;https://usd.saleae.com/products/saleae-logic-pro-16&quot;&gt;Saleae&lt;/a&gt;
等功能强大的商业化产品，但是在日常的微控制器与数字信号总线开发过程当中，如果不是用于调试
&lt;code&gt;PCIE&lt;/code&gt;、&lt;code&gt;USB3.0&lt;/code&gt; 等高速信号，一台小巧可靠的
&lt;strong&gt;24MHz&lt;/strong&gt;
采样率逻辑分析仪，就已经足以应付大多数的开发场景。因而笔者在自己的 &lt;a href=&quot;https://github.com/uinika&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;
当中，开源了这款逻辑分析仪的全部 &lt;strong&gt;KiCad&lt;/strong&gt; 原理图以及
&lt;strong&gt;PCB&lt;/strong&gt;
版图，希望能够对于广大电子工程师的工作有所帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="MCU" scheme="http://www.uinio.com/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>UINIO-MCU-ESP32 系列核心板电路设计</title>
    <link href="http://www.uinio.com/Project/UINIO-MCU-ESP32/"/>
    <id>http://www.uinio.com/Project/UINIO-MCU-ESP32/</id>
    <published>2023-03-19T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.377Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/uinika/UINIO-MCU-ESP32C3"><strong>UINIO-MCU-ESP32C3</strong></a>和 <a href="https://github.com/uinika/UINIO-MCU-ESP32S3"><strong>UINIO-MCU-ESP32S3</strong></a>两款开源核心板，分别采用了<a href="https://www.espressif.com.cn"><strong>上海乐鑫科技</strong></a>推出的 <strong>ESP32-C3</strong> 以及 <strong>ESP32-S3</strong>微控制器，两者均支持 <strong>2.4GHz Wi-Fi</strong> 与 <strong>Bluetooth5.0</strong>无线网络连接。本文旨在介绍两块核心板各个功能单元的硬件电路设计原理，其中<strong>ESP32-C3</strong> 微控制器基于开源的 <strong>RISC-V</strong>内核架构，拥有 <strong>22</strong> 个 GPIO 接口，主频高达<code>160MHz</code>，板载 <code>384KB</code> 容量的 ROM，以及<code>400KB</code> 容量的 SRAM 和 <code>8KB</code> 容量的 RTCSRAM，支持的数字外设接口有<code>3 × SPI</code>、<code>2 × UART</code>、<code>1 × I²C</code>、<code>1 × I²S</code>，而<strong>模拟外设接口</strong>则采用了<strong>6</strong> 通道的 <code>2 × 12</code> 位 SAR 模/数转换器。</p><p><img src="/Project/UINIO-MCU-ESP32/logo.png"></p><p>稍晚一些推出的 <strong>ESP32-S3</strong> 微控制器则是基于<strong>Cadence</strong> 公司的 <strong>Xtensa Dual-Core 32-bitLX7</strong> 架构，拥有 <strong>45</strong> 个 GPIO 接口，主频高达<code>240MHz</code>，板载有 <code>384KB</code> 容量的 ROM，以及<code>512KB</code> 容量的 SRAM 和 <code>16KB</code> 容量的 RTCSRAM，支持的<strong>数字外设接口</strong>有<code>4 × SPI</code>、<code>3 × UART</code>、<code>2 × I²C</code>、<code>2 × I²S</code>。而<strong>模拟外设接口</strong>采用了<strong>20</strong> 通道的 <code>2 × 12</code> 位 SAR模/数转换器。核心板的 <strong>KiCad</strong> 原理图以及 PCB源文件，可以在我的 <a href="https://github.com/uinika"><strong>GitHub</strong></a>仓库当中进行获取。</p><span id="more"></span><h1 id="uinio-mcu-esp32c3-硬件设计">UINIO-MCU-ESP32C3 硬件设计</h1><p><a href="https://www.espressif.com.cn"><strong>上海乐鑫科技</strong></a>推出的 <strong>ESP32-C3</strong> 微控制器基于 <strong>RISC-V</strong>架构，拥有 <strong>22</strong> 个 GPIO 接口，主频高达<code>160MHz</code>，板载有 <code>384KB</code> 容量的 ROM，以及<code>400KB</code> 容量的 SRAM 和 <code>8KB</code> 容量的 RTCSRAM，支持的数字外设接口有<code>3 × SPI</code>、<code>2 × UART</code>、<code>1 × I²C</code>、<code>1 × I²S</code>，而<strong>模拟外设接口</strong>方面则支持多达6 通道的 <code>2 × 12</code> 位 SAR 模/数转换器。</p><p><strong>ESP32-C3</strong> 的外围电路设计较为简单，仅仅只需要<strong>20</strong> 个左右的贴片电阻、电容、电感，以及<strong>1</strong> 个无源晶振、<strong>1</strong> 个 SPI 接口的 Flash存储芯片。其核心电路主要包括<code>电源</code>、<code>上电时序与复位</code>、<code>Flash 存储器</code>、<code>时钟源</code>、<code>射频天线</code>、<code>UART 串行通信</code>、<code>ADC 模/数转换</code>、<code>Strapping 引脚</code>、<code>GPIO 引脚</code>、<code>UART0 自动下载电路</code>等部分，下面展示了 <strong>ESP32-C3</strong> 官方给出的参考原理图：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/0.png"></p><h2 id="电源管理">电源管理</h2><p><strong>ESP32-C3</strong> 一共拥有 <code>VDDA1</code> 和<code>VDDA2</code>（<strong>模拟电源</strong>）、<code>VDD3P3_RTC</code>（<strong>RTC电源</strong>）、<code>VDD3P3_CPU</code>（<strong>MCU 电源</strong>）四组电源输入引脚，以及一组 <code>VDD_SPI</code>引脚（<strong>电源输入/输出管脚</strong>，由 <code>VDD3P3_CPU</code>通过电阻 <span class="math inline">\(R_{SPI}\)</span>进行供电，因而会相对于 <code>VDD3P3_CPU</code>存在着一定的电压降）。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/1.png"></p><blockquote><p><strong>注意</strong>：当 <code>VDD_SPI</code>无需为外部进行供电时，也可以将其复用为 <code>GPIO11</code>来进行使用。</p></blockquote><h3 id="数字电源">数字电源</h3><p><strong>ESP32-C3</strong> 的典型<strong>工作电压</strong>为<code>3.3V</code>，而<strong>工作电流</strong>则需要达到<code>500mA</code> 及以上。在 <strong>UINIO-MCU-ESP32C3</strong>原理图当中，<strong>ESP32-C3</strong> 的第 <code>11</code> 和<code>17</code> 引脚分别为 <strong>RTC 电源引脚</strong>和 <strong>MCU电源引脚</strong>，工作电压介于 <code>3.0V ~ 3.6V</code>范围之间，并且分别添加了 <code>0.1µF</code> 以及 <code>1µF</code>的对地滤波电容。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/2.png"></p><blockquote><p><strong>注意</strong>：当使用 <code>VDD_SPI</code> 作为外部 Flash存储器的电源时，需要满足该款 Flash存储芯片的最低工作电压要求，通常应当保证其电压值处于 <code>3.0V</code>及以上的值。</p></blockquote><h3 id="模拟电源">模拟电源</h3><p><strong>ESP32-C3</strong> 芯片的第<code>2</code>、<code>3</code>、<code>31</code>、<code>32</code>为模拟电源引脚，工作电压同样介于 <code>3.0V ~ 3.6V</code> 范围。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/3.png"></p><blockquote><p><strong>注意</strong>：当 <strong>ESP32-C3</strong> 工作在<code>TX</code>状态下时，由于瞬时电流较大，可能会导致<strong>电源轨道塌陷</strong>（当<strong>电源</strong>与<strong>地</strong>之间的电流发生变化时，电源路径与接地路径之间的阻抗会产生一个压降，从而导致提供给芯片的工作电压被降低），所以官方建议在电源走线上增加了一个<code>10µF</code> 电容，并且将其与 <code>0.1µF</code>、<code>1µF</code>电容并联起来搭配使用。</p></blockquote><h2 id="上电时序-复位">上电时序 &amp; 复位</h2><h3 id="上电时序">上电时序</h3><p><strong>ESP32-C3</strong> 的上电时序需要遵循：编号为 <code>7</code>的<strong>使能引脚</strong><code>CHIP_EN</code>，上电时间必须晚于<strong>系统电源</strong><code>3.3V</code> 的上电时间。</p><table><colgroup><col style="width: 5%"><col style="width: 81%"><col style="width: 13%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: left;">说明</th><th style="text-align: center;">最小值(微秒)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t_0\)</span></td><td style="text-align: left;"><code>CHIP_EN</code> 管脚上电时间晚于<code>VDDA</code>、<code>VDD3P3</code>、<code>VDD3P3_RTC</code>、<code>VDD3P3_CPU</code>；</td><td style="text-align: center;"><code>50微秒</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t_1\)</span></td><td style="text-align: left;"><code>CHIP_EN</code> 引脚的电平低于 <span class="math inline">\(V_{IL\_{nRST}}\)</span> 的时间；</td><td style="text-align: center;"><code>50微秒</code></td></tr></tbody></table><p><img src="/Project/UINIO-MCU-ESP32/C3/4.png"></p><blockquote><p><strong>注意</strong>：为了确保 <strong>ESP32-C3</strong>在上电时电源的正常供电，<code>CHIP_EN</code> 引脚需要添加 <strong>RC延时电路</strong>（典型取值为<code>R = 10 kΩ</code>，<code>C = 1 µF</code>，具体数值需要根据电源的<strong>上电时序</strong>和芯片的<strong>上电复位时序</strong>进行调整）。</p></blockquote><h3 id="复位">复位</h3><p><strong>ESP32-C3</strong> 可以通过 <code>CHIP_EN</code>引脚进行复位，当 <code>CHIP_EN</code>为低电平的时候，建议<strong>复位电平</strong> <span class="math inline">\(V_{IL\_{nRST}}\)</span> 的取值范围为 <span class="math inline">\((–0.3 \sim 0.25) \times VDD\)</span>伏。除此之外，为了防止外界干扰导致系统重启，建议尽量缩短<code>CHIP_EN</code> 的 PCB 走线，并且添加<strong>上拉电阻</strong><span class="math inline">\(R_2\)</span>以及对地<strong>去耦电容</strong> <span class="math inline">\(C_9\)</span>。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/5.png"></p><blockquote><p><strong>注意</strong>：<strong>ESP32-C3</strong> 的<code>CHIP_EN</code> 引脚不可以处于<strong>浮空</strong>状态。</p></blockquote><h2 id="flash-存储器">Flash 存储器</h2><p><strong>ESP32-C3</strong> 最大支持 <code>16MB</code> 容量的 Flash存储器，可以选择使用 <code>VDD_SPI</code> 引脚输出的电源进行供电。在<strong>UINIO-MCU-ESP32C3</strong> 当中，直接选择将 <strong>LDO线性稳压器</strong>输出的 <code>VDD_3.3V</code> 作为 Flash存储芯片的工作电源。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/6.png"></p><blockquote><p><strong>注意</strong>：如果采用了 <code>VDD_SPI</code>作为电源，那么建议在 SPI 总线引脚上预留一个 <code>0Ω</code>串联电阻的封装位置，用于降低驱动电流、减小串扰、调节时序等后续调试工作。</p></blockquote><h2 id="时钟源">时钟源</h2><p><strong>ESP32-C3</strong>可以使用<strong>外部晶振</strong>和<strong>外部RTC</strong>两个时钟源。</p><h3 id="外部晶振时钟源">外部晶振时钟源</h3><p><strong>ESP32-C3</strong> 只支持 <code>40MHz</code> 晶振（精度为<span class="math inline">\(\pm 10 ppm\)</span>），匹配电容<code>C15</code> 和 <code>C17</code>的取值需要经过测试之后再行确定。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/7.png"></p><h3 id="外部-rtc-时钟源">外部 RTC 时钟源</h3><p><strong>ESP32-C3</strong> 支持将 <code>XTAL_32K_P</code> 和<code>XTAL_32K_N</code> 引脚，连接至外部的 <code>32.768 kHz</code>晶振作为 <strong>RTC 实时时钟</strong>。而<strong>UINIO-MCU-ESP32C3</strong> 为了获得更多的 GPIO 资源，索性直接将<code>XTAL_32K_P</code> 和 <code>XTAL_32K_N</code> 引脚复用为<code>GPIO0</code> 和 <code>GPIO1</code> 进行使用。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/8.png"></p><h2 id="射频天线">射频天线</h2><p><strong>UINIO-MCU-ESP32C3</strong> 在引出射频天线时，预留了<strong>CLC</strong> 结构的 <span class="math inline">\(\pi\)</span><strong>型阻抗匹配网络</strong>（具体参数需要根据实际天线的 PCB布局来测定），以期获得最佳的发射功率：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/9.png"></p><h2 id="strapping-引脚">Strapping 引脚</h2><p><strong>ESP32-C3</strong>在<strong>复位过程</strong>当中（<code>上电复位</code>、<code>RTC 看门狗复位</code>、<code>欠压复位</code>、<code>模拟超级看门狗复位</code>、<code>晶振时钟毛刺检测复位</code>），<strong>Strapping引脚</strong>会将引脚上的电平状态采样并且存储到锁存器当中（锁存值为<code>0</code> 或 <code>1</code>），并且会一直保持到芯片<strong>掉电</strong>或者<strong>关闭</strong>。<strong>ESP32-C3</strong>一共拥有 <code>GPIO2</code>、<code>GPIO8</code>、<code>GPIO9</code> 三个<strong>Strapping 引脚</strong>（可以通过读取<code>GPIO_STRAP_REG</code> 寄存器上的 <code>GPIO_STRAPPING</code>字段，获得这三个引脚上面的状态值）。</p><p>使用<strong>外接上下拉电阻</strong>或者直接经由<strong>GPIO</strong>，可以直接控制复位时 Strapping引脚的电平状态。在复位完成之后，Strapping 引脚会转变为普通引脚。其中<code>GPIO9</code>默认连接内部的上拉电阻，如果该引脚悬空或者连接到外部的高阻抗电路，则锁存值默认为<code>1</code>。<strong>ESP32-C3</strong> 的 Strapping引脚启动模式配置，可以参考下面的表格：</p><table><thead><tr class="header"><th style="text-align: center;">引脚</th><th style="text-align: center;">默认</th><th style="text-align: center;">SPI 启动模式</th><th style="text-align: center;">下载启动模式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>GPIO2</strong></td><td style="text-align: center;">无</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>1</code></td></tr><tr class="even"><td style="text-align: center;"><strong>GPIO8</strong></td><td style="text-align: center;">无</td><td style="text-align: center;">无关</td><td style="text-align: center;"><code>1</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>GPIO9</strong></td><td style="text-align: center;">内部上拉</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>0</code></td></tr></tbody></table><p>下图展示了 <code>CHIP_EN</code> 在上电前后，Strapping引脚的<strong>建立时间</strong> <span class="math inline">\(t_0\)</span>（最少保持 <code>0</code>毫秒）和<strong>保持时间</strong> <span class="math inline">\(t_1\)</span>（最少保持 <code>3</code>毫秒）之间的关系：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/10.png"></p><h2 id="gpio-引脚">GPIO 引脚</h2><p><strong>ESP32-C3</strong> 一共拥有 <strong>22</strong> 个 GPIO引脚，通过配置对应的寄存器，可以为这些引脚指定不同的功能。除了作为数字信号引脚之外，一部分GPIO 引脚也可以配置为 ADC 模拟引脚。所有 GPIO都可以在内部被设置为<strong>上拉</strong>、<strong>下拉</strong>、<strong>高阻</strong>，当GPIO被配置为<strong>输入状态</strong>，则可以通过读取寄存器获取该状态值。已经被设置为<strong>输入状态</strong>的GPIO引脚，可以产生出<code>信号边缘触发</code>或者<code>电平状态触发</code>中断。</p><blockquote><p><strong>注意</strong>：<strong>ESP32-C3</strong> 的数字 GPIO引脚都是<strong>双向</strong>、<strong>非反相</strong>、<strong>三态</strong>的，因而这些引脚也可以被复用为<code>UART</code>、<code>SPI</code> 等其它用途。</p></blockquote><p><strong>ESP32-C3</strong> 的 <strong>IO MUX</strong> 和 <strong>GPIO交换矩阵</strong>用于将信号从外设传输至 GPIO 引脚，两者共同控制着<strong>ESP32-C3</strong> 的输入输出：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/11.png"></p><p>下面的表格展示了所有通过 <strong>IO MUX</strong> 和 <strong>GPIO交换矩阵</strong> 所映射出的引脚功能：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/12.png"></p><blockquote><p><strong>注意</strong>：<code>GPIO12</code> 和 <code>GPIO13</code> 在<strong>Arduino</strong> 的 <strong>QIO</strong> 模式下被复用为<strong>SPI</strong> 总线的 <code>SPIHD</code> 和 <code>SPIWP</code>信号线，为了增加可用的 GPIO 数量，<strong>UINIO-MCU-ESP32C3</strong>采用了两线制 SPI 的 <strong>DIO</strong> 模式，使用时需要注意将 Flash配置为 <strong>DIO</strong> 模式。除此之外，<code>GPIO11</code> 默认为<strong>SPI Flash</strong> 的 <code>VDD_SPI</code>引脚，需要配置之后才能够复用为 <strong>GPIO</strong> 使用。</p></blockquote><p>下面展示了上述表格当中，<strong>复位</strong>一栏各个符号所代表的含义：</p><table><colgroup><col style="width: 10%"><col style="width: 89%"></colgroup><thead><tr class="header"><th style="text-align: center;"> 复位状态序列号 </th><th style="text-align: left;">默认配置说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0</strong></td><td style="text-align: left;">输入关闭，高阻 (<code>IE = 0</code>)</td></tr><tr class="even"><td style="text-align: center;"><strong>1</strong></td><td style="text-align: left;">输入使能，高阻 (<code>IE = 1</code>)</td></tr><tr class="odd"><td style="text-align: center;"><strong>2</strong></td><td style="text-align: left;">输入使能，下拉电阻使能(<code>IE = 1</code>，<code>WPD = 1</code>)</td></tr><tr class="even"><td style="text-align: center;"><strong>3</strong></td><td style="text-align: left;">输入使能，上拉电阻使能(<code>IE = 1</code>，<code>WPU = 1</code>)</td></tr><tr class="odd"><td style="text-align: center;"><strong>4</strong></td><td style="text-align: left;">输出使能，上拉电阻使能(<code>OE = 1</code>, <code>WPU = 1</code>)</td></tr><tr class="even"><td style="text-align: center;"><strong>0*</strong></td><td style="text-align: left;">输入关闭，上拉电阻使能(<code>IE = 0</code>，<code>WPU = 0</code>，<code>USB_WPU = 1</code>)</td></tr><tr class="odd"><td style="text-align: center;"><strong>1*</strong></td><td style="text-align: left;">当 <strong>eFuse</strong> 的<code>EFUSE_DIS_PAD_JTAG</code> 位为 <code>0</code>时(默认值)，引脚复位之后<strong>输入使能</strong>，<strong>上拉电阻使能</strong>(<code>IE = 1</code>，<code>WPU = 1</code>)；<br>而当<code>EFUSE_DIS_PAD_JTAG</code> 被置为 <code>1</code>时，引脚复位之后<strong>输入使能</strong>，且处于高阻状态(<code>IE = 1</code>)。</td></tr></tbody></table><p>在上面表格当中，<strong>说明</strong>一栏里符号所代表的含义如下所示：</p><ul><li><strong>R</strong>：该引脚具有模拟功能；</li><li><strong>G</strong>：该引脚在芯片上电过程当中存在毛刺；</li><li><strong>USB</strong>：<code>GPIO18</code> 和 <code>GPIO19</code>属于 USB 引脚，其上拉电阻由引脚上拉和 USB 上拉共同控制，当其中任意一个为<code>1</code> 时，对应引脚的上拉电阻使能；USB 上拉由<code>USB_SERIAL_JTAG_DP_PULLUP</code> 位进行控制；</li></ul><blockquote><p><strong>注意</strong>：建议将处于<strong>高阻状态</strong>的引脚配置为<code>上拉</code>或者<code>下拉</code>，从而避免不必要的电能消耗。</p></blockquote><h2 id="uart0-自动下载">UART0 自动下载</h2><p>当 <strong>ESP32-C3</strong> 复位完成之后，就可以通过<code>GPIO2</code>、<code>GPIO8</code>、<code>GPIO9</code> 三个Strapping 引脚共同控制 Boot 模式：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/13.png"></p><ul><li>在 <strong>SPI Boot</strong> 模式下，<strong>ESP32-C3</strong>会通过从 SPI Flash存储器当中读取程序进行启动，此模式下可以进一步细分为<strong>常规 Flash启动方式</strong>（支持安全启动，程序运行在 RAM中）和<strong>直接启动方式</strong>（不支持安全启动，程序直接运行在Flash 中）这两种启动方式；</li><li>在 <strong>Download Boot</strong> 模式下，可以通过<code>UART0</code> 或者 <strong>USB</strong> 接口将代码下载至Flash，或者将程序加载至 SRAM 并在 SRAM 当中运行（确保 <code>.bin</code>文件当中地址为 <code>0x42000000</code> 的前两个字为<code>0xaedb041d</code>）；</li></ul><p><strong>UINIO-MCU-ESP32C3</strong> 的 <code>GPIO2</code>在默认情况下，已经在内部被弱上拉为 <code>3.3V</code>高电平（<em>此处存疑，因为根据官方文档，该引脚实际上为输入高阻状态，并非处于高电平，可能文档撰写过程当中存在着谬误，了解该问题的同学可以联系我</em>）；而<code>GPIO8</code> 通过外接上拉电阻 <code>R4</code>也被钳制为高电平。此时 <strong>ESP32-C3</strong>进入【<strong>下载启动模式</strong>】的条件就转变为：当<code>CHIP_EN</code>引脚上面的信号处于<strong>上升沿</strong>的时候，Strapping 引脚<code>GPIO9</code> 必须保持为低电平 <code>0</code>。</p><p><img src="/Project/UINIO-MCU-ESP32/C3/14.png"></p><p>通过上面的原理图可以看到，<code>GPIO9/BOOT</code> 和<code>CHIP_EN</code> 分别连接至 <strong>ESP32-C3</strong> 的集电极，此时USB 转串口芯片 <code>DTR</code> 与 <code>DTR</code> 引脚，以及三极管<strong>Q1</strong> 与 <strong>Q2</strong> 和 <strong>ESP32-C3</strong>的 <code>CHIP_EN</code>、<code>GPIO9</code>引脚之间的逻辑关系如下表所示：</p><table><colgroup><col style="width: 32%"><col style="width: 32%"><col style="width: 35%"></colgroup><thead><tr class="header"><th style="text-align: center;">串口 DTR 和 DTR 状态</th><th style="text-align: center;">三极管 Q1 和 Q2 状态</th><th style="text-align: center;">ESP32-C3 引脚状态</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>DTR = 0</code> 并且<code>RTS = 0</code></td><td style="text-align: center;"><strong>Q1</strong>截止，<strong>Q2</strong> 截止</td><td style="text-align: center;"><code>CHIP_EN = 1</code>、<code>GPIO9 = 1</code></td></tr><tr class="even"><td style="text-align: center;"><code>DTR = 0</code> 并且<code>RTS = 1</code></td><td style="text-align: center;"><strong>Q1</strong>截止，<strong>Q2</strong> 导通</td><td style="text-align: center;"><code>CHIP_EN = 1</code>、<code>GPIO9 = 0</code></td></tr><tr class="odd"><td style="text-align: center;"><code>DTR = 1</code> 并且<code>RTS = 0</code></td><td style="text-align: center;"><strong>Q1</strong>导通，<strong>Q2</strong> 截止</td><td style="text-align: center;"><code>CHIP_EN = 0</code>、<code>GPIO9 = 1</code></td></tr><tr class="even"><td style="text-align: center;"><code>DTR = 1</code> 并且<code>RTS = 1</code></td><td style="text-align: center;"><strong>Q1</strong>截止，<strong>Q2</strong> 截止</td><td style="text-align: center;"><code>CHIP_EN = 1</code>、<code>GPIO9 = 1</code></td></tr></tbody></table><p>概而言之，当 USB 转串口芯片的 <code>DTR</code> 和 <code>RTS</code>同时为 <code>0</code> 或者 <code>1</code> 的时候，三极管<strong>Q1</strong> 和 <strong>Q2</strong> 均处于截止状态，此时<code>CHIP_EN</code> 和 <code>GPIO9</code>的状态由内外部的上下拉电阻决定。而当串口芯片的 <code>DTR</code> 和<code>RTS</code> 不同时为 <code>0</code> 或者 <code>1</code>时，<code>CHIP_EN</code> 与 <code>RTS</code> 的电平状态，以及<code>GPIO9</code> 与 <code>DTR</code> 的电平状态完全相同。这就意味着<code>CHIP_EN</code> 与 <code>IO0</code> 不可能同时为<code>0</code>，然而进入下载模式需要 <code>CHIP_EN</code> 在从<code>0</code> 向 <code>1</code> 跳变时，<code>GPIO9</code>的电平状态持续等于<code>0</code>。为了满足这个条件，<strong>ESP32-C3</strong> 的<code>CHIP_EN</code> 引脚被连接到了一个 <strong>RC充放电</strong>电路上面，具体可以参见 <strong>UINIO-MCU-ESP32C3</strong>的原理图：</p><p><img src="/Project/UINIO-MCU-ESP32/C3/15.png"></p><p>由于电容具有充放电效应，电平状态并不会马上切变为高电平，而是会从<code>0</code> 缓慢上升至 <code>1</code>，在这个过程当中<code>GPIO9</code> 维持低电平 <code>0</code> 状态，即当串口芯片的<code>DTR = 0</code> 并且 <code>RTS = 1</code> 的时候，就可以实现<strong>ESP32-C3</strong> 的自动串口下载。</p><p>除此之外，<strong>UINIO-MCU-ESP32C3</strong> 板载的 <code>SW1</code>和 <code>SW2</code>两颗按键，分别是实现复位功能的【复位按键】，以及实现下载功能的【下载按键】，具体用途可以参考下面的表格：</p><table><colgroup><col style="width: 12%"><col style="width: 57%"><col style="width: 30%"></colgroup><thead><tr class="header"><th style="text-align: center;">按键位号</th><th style="text-align: left;">功能说明</th><th style="text-align: center;">有效值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>SW1</code></td><td style="text-align: left;">按键按下时 <strong>ESP32-C3</strong>开始复位</td><td style="text-align: center;"><strong>低电平</strong> <code>0</code>有效</td></tr><tr class="even"><td style="text-align: center;"><code>SW2</code></td><td style="text-align: left;">按键按下时 <strong>ESP32-C3</strong>进入下载模式</td><td style="text-align: center;"><strong>低电平</strong> <code>0</code>有效</td></tr></tbody></table><h1 id="uinio-mcu-esp32s3-硬件设计">UINIO-MCU-ESP32S3 硬件设计</h1><p><a href="https://www.espressif.com.cn"><strong>上海乐鑫科技</strong></a>推出的 <strong>ESP32-S3</strong> 微控制器基于 <strong>Cadence</strong>公司的 <strong>Xtensa® Dual-Core 32-bit LX7</strong> 架构，拥有<strong>45</strong> 个 GPIO 接口，主频高达 <code>240MHz</code>，板载有<code>384KB</code> 容量的 ROM，以及 <code>512KB</code> 容量的 SRAM 和<code>16KB</code> 容量的 RTC SRAM，支持的<strong>数字外设接口</strong>有<code>4 × SPI</code>、<code>3 × UART</code>、<code>2 × I²C</code>、<code>2 × I²S</code>。而<strong>模拟外设接口</strong>方面则支持多达20 通道的 <code>2 × 12</code> 位 SAR 模/数转换器。</p><p><strong>ESP32-S3</strong> 的核心电路与 <strong>ESP32-C3</strong>非常相似，同样仅需要 <strong>20</strong>个左右的贴片电阻、电容、电感，以及 <strong>1</strong>个无源晶振、<strong>1</strong> 个 SPI 接口的 Flash 存储芯片和<strong>1</strong> 个可选的 PSRAM 存储芯片。下面展示的是<strong>ESP32-S3</strong> 的官方参考原理图（基于<strong>四线制</strong><code>3.3V</code> 工作电压的外部 <strong>Flash</strong> 和<strong>PSRAM</strong> 存储器进行设计）：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/0.png"></p><h2 id="电源">电源</h2><p><strong>ESP32-S3</strong> 的正常工作电压为<code>3.3V</code>，正常工作所需的最大电流在 <code>500mA</code>以上，并且电源入口位置建议添加<strong>静电释放</strong>（ESD，Electro-StaticDischarge）保护元件。整体上看，<strong>ESP32-S3</strong> 与上面介绍的<strong>ESP32-C3</strong>在电路设计方面的整体区别不大，因而本节内容主要介绍两者在<strong>供电电源</strong>、<strong>系统复位</strong>、<strong>Flash与 PSRAM 存储器</strong>、<strong>Strapping 引脚</strong>、<strong>USB自动下载</strong>等方面的主要差别。</p><h3 id="数字电源-1">数字电源</h3><p><strong>ESP32-S3</strong> 的第 <strong>46</strong> 引脚<code>VDD3P3_CPU</code> 属于微控制器的 <strong>VDD</strong>数字电源引脚，其工作电压范围为<code>3.0V ~ 3.6V</code>，设计时需要在靠近该引脚的位置添加<code>0.1µF</code> 去耦电容。而第 <strong>29</strong> 引脚<code>VDD_SPI</code> 可以被配置为 <code>1.8V</code> 输出（启动时配置<strong>GPIO45</strong> 的电平状态为 <code>1</code>）或者<code>3.3V</code> 输出（启动时配置 <strong>GPIO45</strong> 的电平状态为<code>0</code>，即默认状态）给外部电路使用，并且添加 <code>0.1µF</code>和 <code>1µF</code> 的去耦电容。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/1.png"></p><ul><li>当 <code>VDD_SPI</code> 处于 <code>1.8V</code> 模式，由<strong>ESP32-S3</strong> 内部的 <strong>Flash VoltageRegulator</strong> 进行供电（最大电流 <code>40mA</code>）；</li><li>当 <code>VDD_SPI</code> 处于 <code>3.3V</code> 模式，由<strong>VDD3P3_RTC</strong> 经过 <span class="math inline">\(R_{SPI}\)</span> 电阻进行供电，因此<code>VDD_SPI</code> 相对于 <code>VDD3P3_RTC</code>会存在一定的电压降；</li></ul><blockquote><p><strong>注意</strong>：<strong>UINIO-MCU-ESP32S3</strong> 的<code>VDD_SPI</code> 串联有一枚 <code>10KΩ</code> 的电阻 <span class="math inline">\(R_6\)</span>，如果采用 <code>3.3V</code>工作电压的 Flash 存储芯片，则需要移除 <span class="math inline">\(R_6\)</span> 电阻，使得 <strong>GPIO45</strong>的电平状态默认为 <code>0</code>。</p></blockquote><h3 id="模拟电源-1">模拟电源</h3><p><strong>ESP32-S3</strong> 的第<strong>2</strong>、<strong>3</strong>、<strong>55</strong>、<strong>56</strong>引脚为 <strong>VDDA</strong> 模拟电源引脚，其工作电压范围为<code>3.0V ~ 3.6V</code>。类似于 <strong>ESP32-C3</strong>，为了防止<code>TX</code>状态下瞬时电流增大导致的<strong>电源轨道塌陷</strong>，所以<strong>UINIO-MCU-ESP32S3</strong> 在 <code>VDD3P3_CPU</code>的电源走线上增加了一枚 <code>10µF</code> 电容，并且将其与<code>1µF</code>、<code>0.1µF</code> 电容并联起来使用。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/2.png"></p><h3 id="rtc-电源">RTC 电源</h3><p><strong>ESP32-S3</strong> 的第 <strong>20</strong> 引脚<code>VDD3P3_RTC</code> 属于 RTC电源引脚，<strong>UINIO-MCU-ESP32S3</strong> 在该引脚位置添加了一枚<code>0.1µF</code> 的去耦电容。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/3.png"></p><h3 id="复位-1">复位</h3><p>不同于 <strong>ESP32-C3</strong> 通过 <code>CHIP_EN</code>引脚进行复位，<strong>ESP32-S3</strong> 的复位引脚被称为<code>CHIP_PU</code>。两者除了命名上的不同，其它参数乃至于使用方法基本一致。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/4.png"></p><h3 id="flash-与-psram">Flash 与 PSRAM</h3><p><strong>ESP32-S3</strong> 支持的片外 <strong>Flash</strong> 和<strong>PSRAM</strong> 最大分别可以达到 <code>1GB</code>存储容量，在元件选型时需要特别注意根据 <code>VDD_SPI</code>的输出电压，选择相应工作电压的 <strong>Flash</strong> 和<strong>PSRAM</strong> 存储器芯片。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/5.png"></p><h2 id="strapping-引脚-1">Strapping 引脚</h2><p><strong>ESP32-S3</strong> 拥有<strong>GPIO0</strong>、<strong>GPIO45</strong>、<strong>GPIO46</strong>、<strong>GPIO3</strong>一共四个 Strapping 引脚，也可以像 <strong>ESP32-C3</strong>那样通过寄存器 <code>GPIO_STRAPPING</code> 读取这几个引脚的状态值。</p><p>在 <strong>ESP32-S3</strong> 的复位过程当中（上电复位、RTC看门狗复位、欠压复位、模拟超级看门狗复位、晶振时钟毛刺检测复位），Strapping引脚会采样当前的电平状态并且存储至<strong>锁存器</strong>（锁存值为<code>0</code> 或 <code>1</code>），并一直保持到芯片掉电或者关闭。</p><ul><li><strong>GPIO0</strong>、<strong>GPIO45</strong>、<strong>GPIO46</strong>默认连接着内部的<strong>弱上下拉</strong>电阻，如果这些引脚没有连接外部电路，或者连接的是高阻抗状态，则内部的弱上下拉状态就会决定其输入电平的默认值；</li><li><strong>GPIO3</strong> 默认处于<strong>浮空状态</strong>，其Strapping 状态可以用于切换内部的 JTAG 信号来源，此时 Strapping值由外部电路进行控制（这时的外部电路不能处于高阻抗状态）；</li></ul><p>下面表格列出了用于选择 JTAG 信号来源的<code>EFUSE_DIS_USB_JTAG</code>、<code>EFUSE_DIS_PAD_JTAG</code>、<code>EFUSE_STRAP_JTAG_SEL</code>全部寄存器配置组合：</p><table><colgroup><col style="width: 29%"><col style="width: 25%"><col style="width: 22%"><col style="width: 22%"></colgroup><thead><tr class="header"><th style="text-align: center;">JTAG 信号源</th><th style="text-align: center;"><code>EFUSE_STRAP_JTAG_SEL</code></th><th style="text-align: center;"><code>EFUSE_DIS_USB_JTAG</code></th><th style="text-align: center;"><code>EFUSE_DIS_PAD_JTAG</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">见后表</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>0</code></td><td style="text-align: center;"><code>0</code></td></tr><tr class="even"><td style="text-align: center;"><strong>USB Serial/JTAG控制器</strong></td><td style="text-align: center;"><code>0</code></td><td style="text-align: center;"><code>0</code></td><td style="text-align: center;"><code>0</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>USB Serial/JTAG控制器</strong></td><td style="text-align: center;">无关</td><td style="text-align: center;"><code>0</code></td><td style="text-align: center;"><code>1</code></td></tr><tr class="even"><td style="text-align: center;"><strong>片上 JTAG 引脚</strong></td><td style="text-align: center;">无关</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>0</code></td></tr><tr class="odd"><td style="text-align: center;">无</td><td style="text-align: center;">无关</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>1</code></td></tr></tbody></table><p>可以通过外部上下拉电阻，或者 GPIO 控制 <strong>ESP32-S3</strong>上电复位时的 Strapping 引脚电平。而在复位放开之后，Strapping引脚就会恢复为普通功能引脚。接下来的表格展示了 <strong>ESP32-S3</strong>全部 Strapping 引脚的配置含义。</p><p>通过配置 <strong>GPIO45</strong> 这个 Strapping引脚的状态，就可以控制 <code>VDD_SPI</code> 的输出电压：</p><table><thead><tr class="header"><th style="text-align: center;">引脚</th><th style="text-align: center;">默认状态</th><th style="text-align: center;">3.3V</th><th style="text-align: center;">1.8V</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>GPIO45</strong></td><td style="text-align: center;">下拉</td><td style="text-align: center;"><code>0</code></td><td style="text-align: center;"><code>1</code></td></tr></tbody></table><p>而通过控制 <strong>GPIO0</strong> 和 <strong>GPIO46</strong> 这两个Strapping 引脚的状态，则可以选择 <strong>ESP32-S3</strong>的系统启动模式：</p><table><thead><tr class="header"><th style="text-align: center;">引脚</th><th style="text-align: center;">默认状态</th><th style="text-align: center;">SPI 启动模式</th><th style="text-align: center;">下载启动模式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>GPIO0</strong></td><td style="text-align: center;">上拉</td><td style="text-align: center;"><code>1</code></td><td style="text-align: center;"><code>0</code></td></tr><tr class="even"><td style="text-align: center;"><strong>GPIO46</strong></td><td style="text-align: center;">下拉</td><td style="text-align: center;">无关</td><td style="text-align: center;"><code>0</code></td></tr></tbody></table><p>当<code>EFUSE_DIS_USB_JTAG = 0</code>、<code>EFUSE_DIS_PAD_JTAG = 0</code>、<code>EFUSE_STRAP_JTAG_SEL=1</code>的时候，则可以通过 <strong>GPIO46</strong> 选择 JTAG 信号的来源：</p><table><colgroup><col style="width: 11%"><col style="width: 8%"><col style="width: 37%"><col style="width: 42%"></colgroup><thead><tr class="header"><th style="text-align: center;">引脚</th><th style="text-align: center;">默认状态</th><th style="text-align: center;">引脚状态值为 0</th><th style="text-align: center;">引脚状态值为 1</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>GPIO46</strong></td><td style="text-align: center;">下拉</td><td style="text-align: center;">JTAG 信号来源于芯片上的 JTAG 引脚</td><td style="text-align: center;">JTAG 信号来源于 USB Serial/JTAG控制器</td></tr></tbody></table><h2 id="gpio-引脚-1">GPIO 引脚</h2><p><strong>ESP32-S3</strong> 一共拥有 <strong>45</strong> 个 GPIO数字引脚，它们可以被分配为 <span class="math inline">\(F_{0 \sim4}\)</span> 这几种不同类型的功能：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/6.png"></p><p>上面表格当中，每一项<strong>数字功能</strong> <span class="math inline">\(F_{0 \sim 4}\)</span> 的含义如下所示：</p><ul><li><strong>O</strong>：仅仅只是<strong>输出</strong>；</li><li><strong>O/T</strong>：包含<strong>输出</strong>与<strong>高抗阻</strong>的组合；</li><li><strong>I/O/T</strong>：包含<strong>输入</strong>、<strong>输出</strong>、<strong>高抗阻</strong>的组合；</li><li><strong>I1</strong>：只是<strong>输入</strong>（如果该引脚分配了<span class="math inline">\(F_{0 \sim 4}\)</span> 以外的功能，则 <span class="math inline">\(F_{0 \sim 4}\)</span> 的输入信号恒为<code>1</code>）；</li><li><strong>I1/O/T</strong>：该功能信号包含<strong>输入</strong>、<strong>输出</strong>、<strong>高抗阻</strong>的组合（如果该引脚分配了<span class="math inline">\(F_{0 \sim 4}\)</span> 以外的功能，则 <span class="math inline">\(F_{0 \sim 4}\)</span> 的输入信号恒为<code>1</code>）；</li><li><strong>I0/O/T</strong>：该功能信号包含<strong>输入</strong>、<strong>输出</strong>、<strong>高抗阻</strong>的组合（如果该引脚分配了<span class="math inline">\(F_{0 \sim 4}\)</span> 以外的功能，则 <span class="math inline">\(F_{0 \sim 4}\)</span> 的输入信号恒为<code>0</code>）；</li></ul><p>而上述表格当中，引脚<strong>复位状态</strong>的具体含义如下所示：</p><ul><li><strong>IE0</strong>：输入关闭；</li><li><strong>IE1</strong>：输入使能；</li><li><strong>IE1,WPD1</strong>：输入使能，内部弱<strong>下拉电阻</strong>使能；</li><li><strong>IE1,WPU1</strong>：输入使能，内部弱<strong>上拉电阻</strong>使能；</li><li><strong>IE1</strong>, 或者 <strong>IE1&amp;WPU1</strong>：当<code>EFUSE_DIS_PAD_JTAG</code> 的 <code>eFuse</code> 位为<code>1</code> 时，芯片复位之后 <code>MTCK</code>浮空（<code>IE1</code>），而 <code>eFuse</code> 位为 <code>0</code>时，芯片复位之后 <code>MTCK</code>连接至内部的弱上拉电阻（<code>IE1</code>&amp;<code>WPU1</code>）。</li></ul><p>上面表格当中，<strong>备注</strong>一栏里各个符号的功能说明如下所示：</p><ul><li><code>R</code>：该引脚具有 RTC 或模拟功能；</li><li><code>G</code>：该引脚在芯片上电过程中存在着毛刺；</li></ul><blockquote><p><strong>注意</strong>：<code>GPIO19 ~ GPIO20</code>的默认驱动电流接近 <code>40mA</code>，除此之外其它引脚的默认驱动电流接近<code>20mA</code>。</p></blockquote><h2 id="uart0-自动下载-1">UART0 自动下载</h2><p>当 <strong>ESP32-S3</strong> 复位完成之后，就可以通过<code>GPIO0</code>、<code>GPIO46</code> 两个 Strapping 引脚共同控制 Boot模式：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/7.png"></p><ul><li>在 <strong>SPI Boot</strong> 模式下，<strong>ESP32-S3</strong>会通过从 SPI Flash存储器当中读取程序进行启动，此模式下可以进一步细分为<strong>常规 Flash启动方式</strong>（支持安全启动，程序运行在 RAM中）和<strong>直接启动方式</strong>（不支持安全启动，程序直接运行在Flash 中）这两种启动方式；</li><li>在 <strong>Download Boot</strong> 模式下，可以通过<strong>UART0</strong> 或者 <strong>USB OTG</strong> 接口将代码下载至Flash 存储器，或者将程序加载至 SRAM 并在 SRAM 当中运行（需要确保<code>.bin</code> 文件里地址为 <code>0x42000000</code> 的前两个字为<code>0xaedb041d</code>）；</li></ul><p><strong>UINIO-MCU-ESP32S3</strong> 的 <code>GPIO46</code>会在复位之后处于<strong>输入和内部弱下拉电阻使能</strong>状态（<code>IE1</code>、<code>WPD1</code>），即电平状态被下拉为<code>0</code>，此时 <strong>ESP32-S3</strong>进入【下载启动模式】的条件就变为：当 <code>CHIP_PU</code>引脚上面的信号处于上升沿的时候，Strapping 引脚 <code>GPIO0</code>必须保持为低电平 <code>0</code>。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/8.png"></p><p>类似于之前介绍的 <strong>UINIO-MCU-ESP32C3</strong>自动下载电路，<strong>ESP32-S3</strong> 的 <code>CHIP_PU</code>引脚也连接有一个 RC 充放电电路，同样利用了电容的充放电效应，在<code>CHIP_PU</code> 从 <code>0</code> 向 <code>1</code>跳变的过程中，将 <code>GPIO0</code> 的电平状态维持为低电平<code>0</code>。这样当串口芯片的 <code>DTR = 0</code> 并且<code>RTS = 1</code> 时，就可以实现 <strong>ESP32-S3</strong>的自动下载。</p><p><img src="/Project/UINIO-MCU-ESP32/S3/9.png"></p><p><strong>UINIO-MCU-ESP32S3</strong> 自动下载电路的不同之处，在于将<strong>UINIO-MCU-ESP32C3</strong> 当中由 <strong>Q1</strong> 和<strong>Q2</strong> 两个 NPN 三极管组成的下载逻辑电路，简化为了一颗<a href="https://www.lrc.cn/"><strong>乐山无线电</strong></a>生产的 <a href="https://www.lrc.cn/Upload/PDF/Product/SWBJ/LMBT3904DW1T1G.pdf"><strong>LMBT3904DW1T1G</strong></a>双 NPN 晶体管阵列芯片，该芯片的内部电路与<strong>UINIO-MCU-ESP32C3</strong> 的下载逻辑电路接法基本保持一致：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/10.png"></p><p>除此之外，<strong>UINIO-MCU-ESP32S3</strong> 同样板载了<code>SW1</code> 和 <code>SW2</code>两颗分别用于实现下载功能和复位功能的按键：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/11.png"></p><p>它们的具体用途，与 <strong>UINIO-MCU-ESP32C3</strong> 上面的两颗按键<code>SW1</code> 和 <code>SW2</code> 完全保持一致：</p><table><colgroup><col style="width: 12%"><col style="width: 57%"><col style="width: 30%"></colgroup><thead><tr class="header"><th style="text-align: center;">按键位号</th><th style="text-align: left;">功能说明</th><th style="text-align: center;">有效值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>SW1</code></td><td style="text-align: left;">按键按下时 <strong>ESP32-C3</strong>开始复位</td><td style="text-align: center;"><strong>低电平</strong> <code>0</code>有效</td></tr><tr class="even"><td style="text-align: center;"><code>SW2</code></td><td style="text-align: left;">按键按下时 <strong>ESP32-C3</strong>进入下载模式</td><td style="text-align: center;"><strong>低电平</strong> <code>0</code>有效</td></tr></tbody></table><h2 id="usb-otg-自动下载">USB OTG 自动下载</h2><p><strong>ESP32-S3</strong> 集成了一颗携带有收发器，并且符合<strong>USB2.0</strong> 规范的全速 <strong>USB On-The-Go</strong>外设（<strong>OTG</strong>），其中 <code>GPIO19</code> 和<code>GPIO20</code> 引脚可以分别用于接入 USB的<strong>差分信号线</strong> <code>D-</code> 和 <code>D+</code>：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/12.png"></p><p>利用 <strong>ESP32-S3</strong> 集成的 USB OTG 外设功能，就可以通过USB 接口直接进行固件的下载，而无需再借助 <strong>CH343P</strong> 这类USB 转串口芯片。<strong>UINIO-MCU-ESP32S3</strong> 为了同时兼容<strong>UART0</strong> 和 <strong>USB OTG</strong>两种下载方式，专门加入了一颗由 <a href="https://run-ic.com/"><strong>江苏润石科技</strong></a>提供的高速低功耗<strong>双刀双掷</strong>（DPDT，Double Pole DoubleThrow）模拟开关 <a href="https://run-ic.com/details/144/23.html"><strong>RS2227XUTQK10</strong></a>，其工作电压在<code>1.8V ~ 5.5V</code> 范围，采用 <code>WQFN-10</code>封装，内部原理与引脚连接如下图所示：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/13.png"></p><p>上图当中的 <code>D+</code> 和 <code>D-</code> 是 <strong>USB差分信号输入引脚</strong>，而 <code>HSD1+</code> 和<code>HSD1-</code>、<code>HSD2+</code> 和 <code>HSD2-</code> 则分别是<strong>USB 差分信号输出引脚</strong>，通过编号为 <code>10</code> 的<code>S</code> 引脚可以选择当前是使用 <strong>HSD1</strong> 还是<strong>HSD2</strong> 进行 USB差分信号输出，下面的表格是该芯片各个引脚功能的真值表：</p><p><img src="/Project/UINIO-MCU-ESP32/S3/14.png"></p><blockquote><p><strong>注意</strong>：通过原理图当中位号为 <code>J1</code>的跳线座，就可以指定 <strong>UINIO-MCU-ESP32S3</strong>当前所使用的下载方式。</p></blockquote><h1 id="pcb-板图布局注意事项">PCB 板图布局注意事项</h1><p>当采用<strong>两层 PCB</strong>进行设计时，可以遵循如下的层功能划分：</p><ol type="1"><li>第 1 层为<strong>顶层</strong>，主要用于放置元件和走线；</li><li>第 2层为<strong>底层</strong>，尽量不要放置元件，走线越少越好，在确保射频与晶振拥有完整地平面的情况下，可以适度走信号线；</li></ol><p>而采用<strong>四层 PCB</strong>进行设计时，则可以遵循下面的层功能划分：</p><ol type="1"><li>第 1 层为<strong>顶层</strong>，用于信号线和放置元件；</li><li>第 2层为<strong>地层</strong>，不走信号线，确保一个完整的地平面；</li><li>第 3 层为<strong>电源层</strong>，铺地平面，将电源走在该层；</li><li>第 4层为<strong>底层</strong>，铺地平面，不建议放置元件，在确保射频与晶振拥有完整地平面的情况下，可以适度走信号线；</li></ol><p><img src="/Project/UINIO-MCU-ESP32/PCB/0.png"></p><ul><li><strong>天线</strong>：PCB 微带天线尽量靠近 PCB边缘进行摆放，并且禁止底部覆铜，同时需要注意外壳对于天线射频性能的影响；</li><li><strong>晶振</strong>：让 <strong>ESP32</strong>主控芯片与晶振保持一定的距离避免相互干扰，周围不能出现电感之类的磁感应元器件；晶振的信号线最好进行<strong>包地</strong>处理，并且尽可能的避免走线出现过孔，同时晶振下方禁止通过高频数字信号；</li><li><strong>射频天线</strong>：射频走线需要做 <code>50Ω</code>的单端阻抗控制，参考平面为第二层，射频走线上的 <span class="math inline">\(\pi\)</span> 型阻抗匹配网络需要呈<strong>Z</strong>字型摆放；射频走线必须保证相邻层拥有完整的地平面，并且走线下方尽可能不要出现任何的走线；射频走线必须远离晶振、DDR、USB转串口等高频元器件；</li><li><strong>Flash 存储器</strong>：SPI总线的时钟与数据走线，最好都进行单独的<strong>包地</strong>处理；</li><li><strong>USB 转 UART</strong>：USB按照差分信号进行走线，保持<strong>平行等长</strong>，拥有完整的参考地平面；而<code>U0TXD</code> 和 <code>U0RXD</code>走线要尽量缩短，并且最好是进行包地处理；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32C3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32C3&lt;/strong&gt;&lt;/a&gt;
和 &lt;a href=&quot;https://github.com/uinika/UINIO-MCU-ESP32S3&quot;&gt;&lt;strong&gt;UINIO-MCU-ESP32S3&lt;/strong&gt;&lt;/a&gt;
两款开源核心板，分别采用了&lt;a href=&quot;https://www.espressif.com.cn&quot;&gt;&lt;strong&gt;上海乐鑫科技&lt;/strong&gt;&lt;/a&gt;
推出的 &lt;strong&gt;ESP32-C3&lt;/strong&gt; 以及 &lt;strong&gt;ESP32-S3&lt;/strong&gt;
微控制器，两者均支持 &lt;strong&gt;2.4GHz Wi-Fi&lt;/strong&gt; 与 &lt;strong&gt;Bluetooth
5.0&lt;/strong&gt;
无线网络连接。本文旨在介绍两块核心板各个功能单元的硬件电路设计原理，其中
&lt;strong&gt;ESP32-C3&lt;/strong&gt; 微控制器基于开源的 &lt;strong&gt;RISC-V&lt;/strong&gt;
内核架构，拥有 &lt;strong&gt;22&lt;/strong&gt; 个 GPIO 接口，主频高达
&lt;code&gt;160MHz&lt;/code&gt;，板载 &lt;code&gt;384KB&lt;/code&gt; 容量的 ROM，以及
&lt;code&gt;400KB&lt;/code&gt; 容量的 SRAM 和 &lt;code&gt;8KB&lt;/code&gt; 容量的 RTC
SRAM，支持的数字外设接口有
&lt;code&gt;3 × SPI&lt;/code&gt;、&lt;code&gt;2 × UART&lt;/code&gt;、&lt;code&gt;1 × I²C&lt;/code&gt;、&lt;code&gt;1 × I²S&lt;/code&gt;，而&lt;strong&gt;模拟外设接口&lt;/strong&gt;则采用了
&lt;strong&gt;6&lt;/strong&gt; 通道的 &lt;code&gt;2 × 12&lt;/code&gt; 位 SAR 模/数转换器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-MCU-ESP32/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;稍晚一些推出的 &lt;strong&gt;ESP32-S3&lt;/strong&gt; 微控制器则是基于
&lt;strong&gt;Cadence&lt;/strong&gt; 公司的 &lt;strong&gt;Xtensa Dual-Core 32-bit
LX7&lt;/strong&gt; 架构，拥有 &lt;strong&gt;45&lt;/strong&gt; 个 GPIO 接口，主频高达
&lt;code&gt;240MHz&lt;/code&gt;，板载有 &lt;code&gt;384KB&lt;/code&gt; 容量的 ROM，以及
&lt;code&gt;512KB&lt;/code&gt; 容量的 SRAM 和 &lt;code&gt;16KB&lt;/code&gt; 容量的 RTC
SRAM，支持的&lt;strong&gt;数字外设接口&lt;/strong&gt;有
&lt;code&gt;4 × SPI&lt;/code&gt;、&lt;code&gt;3 × UART&lt;/code&gt;、&lt;code&gt;2 × I²C&lt;/code&gt;、&lt;code&gt;2 × I²S&lt;/code&gt;。而&lt;strong&gt;模拟外设接口&lt;/strong&gt;采用了
&lt;strong&gt;20&lt;/strong&gt; 通道的 &lt;code&gt;2 × 12&lt;/code&gt; 位 SAR
模/数转换器。核心板的 &lt;strong&gt;KiCad&lt;/strong&gt; 原理图以及 PCB
源文件，可以在我的 &lt;a href=&quot;https://github.com/uinika&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;
仓库当中进行获取。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="MCU" scheme="http://www.uinio.com/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>ARM 调试工具 UINIO-DAPLink 应用详解</title>
    <link href="http://www.uinio.com/Project/UINIO-DAPLink/"/>
    <id>http://www.uinio.com/Project/UINIO-DAPLink/</id>
    <published>2023-01-21T16:00:00.000Z</published>
    <updated>2024-09-03T18:02:50.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ARM Mbed OS</strong>是一款开源免费的物联网操作系统，包含有基于 <strong>ARM Cortex-M</strong>系列微控制器开发智能连接产品所需的全部基础架构。其社区推出的 <a href="https://daplink.io/"><strong>DAP-Link</strong></a>同样是一个开源项目，它支持编程和调试运行在 ARM Cortex微控制器上面的代码，主要运行于拥有 <strong>SWD</strong> 或者<strong>JTAG</strong> 接口的微控制器当中，并且通过 USB 接口在计算机与ARM Cortex微控制器之间创建一个用于调试仿真的通道与桥梁，为开发人员提供了<strong>下载调试</strong>、<strong>串口通信</strong>、<strong>拖拽烧录</strong>等一系列实用功能。</p><p><img src="/Project/UINIO-DAPLink/logo.png"></p><p><strong>DAPLink</strong> 主要由 <a href="https://github.com/ARMmbed/mbed-HDK-Eagle-Projects"><strong>Mbed硬件开发工具包</strong></a> 以及 <a href="https://github.com/ARMmbed/DAPLink"><strong>DAPLink固件</strong></a> 两个开源项目构成，而 <a href="https://github.com/uinika/UINIO-DAPLink"><strong>UINIO-DAPLink</strong></a>则是由我自己设计的一款完全开源的 DAPLink实现，相比于官方原版的硬件电路设计，在引出有 <strong>SWD</strong>调试接口（由 ARM 公司制订）的同时，还引出了 <strong>JTAG</strong>接口（属于 IEEE1149 国际标准）以及<code>5V</code> 和 <code>3.3V</code>电源，并且附带有 <strong>SWD</strong> 至 <strong>JTAG</strong> 转接板的PCB 设计，而固件部分则是基于 ARM官方的最新的原版固件移植而来，全部的原理图与固件程序都已经开源在 <a href="https://github.com/uinika/UINIO-DAPLink"><strong>GitHub</strong></a>。</p><span id="more"></span><h2 id="dap-link-简介">DAP Link 简介</h2><p><strong>DAPLink</strong>调试器可以为开发人员提供如下一系列方便实用的功能：</p><ul><li><strong>CMSIS-DAPv1 HID</strong> - 兼容 CMSIS 的调试通道；</li><li><strong>CMSIS-DAPv2 WinUSB</strong> - 兼容 CMSIS 的调试通道；</li><li><strong>WebUSB CMSIS-DAP HID</strong> - 兼容 CMSIS 的调试通道；</li><li><strong>CDC</strong> - 用于日志、跟踪和终端仿真的虚拟通信端口；</li><li><strong>MSC</strong> - 通过拖拽编程 Flash存储器（根据固件不同，仅⽀持烧录特定型号芯片）；</li></ul><blockquote><p><strong>注意</strong>：目前 DAPLink 已经取代了过去 <strong>ARMMbed</strong> 推出的 <strong>CMSIS-DAP</strong> 开源调试器项目。</p></blockquote><p>如下品牌的 ARM 硬件接口电路（<strong>HIC</strong>，Hardware InterfaceCircuits，即调试器硬件）与 DAPLink 的固件完全兼容：</p><ul><li><a href="https://www.nxp.com/design/microcontrollers-developer-resources/mcu-link-debug-probe:MCU-LINK">恩智浦MCU-LINK</a>，基于 LPC55xx 主控；</li><li><a href="https://www.nuvoton.com/tool-and-software/debugger-and-programmer/1-to-1-debugger-and-programmer/nu-link2-me/">新唐Nu-Link2-Me</a>，基于 M48SSIDAE 主控；</li><li><a href="https://www.maximintegrated.com/en/products/microcontrollers/MAX32625PICO.html">美信MAX32625PICO</a>，基于 MAX32625 主控；</li><li><a href="https://www.segger.com/products/debug-probes/j-link/models/j-link-ob/">SeggerJ-Link OB</a>，基于 Atmel SAM3U 主控芯片；</li><li><a href="https://www.st.com/en/evaluation-tools/stm32-nucleo-boards.html">意法半导体ST-LINK/V2</a>，基于 STM32F103CB 主控；</li><li><a href="http://www.nxp.com/products/software-and-tools/run-time-software/kinetis-software-and-tools/ides-for-kinetis-mcus/opensda-serial-and-debug-adapter:OPENSDA">恩智浦OpenSDA</a>，基于 K20, K22, KL26Z 和 KL27Z 主控；</li><li><a href="https://www.nxp.com/support/developer-resources/hardware-development-tools/lpcxpresso-boards:LPCXPRESSO-BOARDS">恩智浦LPC-Link2 based</a>，基于 LPC11U35 或者 LPC4322 主控；</li></ul><p><strong>DAPLink</strong>主要提供了<strong>拖放编程</strong>、<strong>串口通信</strong>、<strong>调试</strong>三种主要功能：</p><ul><li><strong>拖拽烧录</strong>：通过将 <code>.bin</code> 或者<code>.hex</code> 格式的文件复制或者保存到 DAPLink驱动器，从而实现对目标微控制器的编程。完成以后，驱动器将会重新进行挂载。如果下载出现问题，则驱动器上将会自动生成一个包含有故障信息的<code>FAIL.TXT</code> 文件；</li><li><strong>串口通信</strong>：可以直接与目标 MCU微控制器进行双向串行通信，支持<code>9600</code>、<code>14400</code>、<code>19200</code>、<code>28800</code>、<code>38400</code>、<code>56000</code>、<code>57600</code>、<code>115200</code>等常用波特率；</li><li><strong>下载调试</strong>：可以使用任意支持 CMSIS-DAP 协议的 IDE集成开发环境进行调试，例如 <a href="https://github.com/mbedmicro/pyOCD">pyOCD</a>、<a href="http://www.keil.com/">uVision</a>、<a href="https://www.iar.com/">IAR</a>；</li></ul><p>更新设备固件时，只需要连接上 USB 并且按住重置键，让设备进入Bootloader引导模式，从而开始下载固件。如果下载成功，那么设备将会离开引导模式，并且开始运行新的固件。如果下载失败，则设备将会自动生成显示有错误信息的<code>FAIL.TXT</code> 文件。</p><h2 id="编译-daplink-工程">编译 DAPLink 工程</h2><p><strong>DAPLink</strong> 的固件源代码，使用开源项目构建工具 <a href="https://github.com/project-generator/project_generator">project-generator</a>提供的 <code>progen</code>命令进行构建。除此之外，在编译过程当中还需要使用到如下一系列工具软件：</p><ol type="1"><li>安装 <a href="https://git-scm.com/downloads">Git</a>并将其加入环境变量；</li><li>安装 <a href="https://www.python.org/downloads/">Python 3</a>并将其加入环境变量；</li><li>安装相关的编译器，可以选择标识为 <code>gcc_arm</code> 的 <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNUARM Embedded Toolchain</a> 、标识为 <code>armclang</code> 的 <a href="https://developer.arm.com/tools-and-software/embedded/arm-compiler">ARMCompiler 6</a>，以及标识为 <code>armcc</code> 的 <a href="https://developer.arm.com/tools-and-software/embedded/keil-mdk">KeilMDK</a> 或者 <a href="https://developer.arm.com/tools-and-software/embedded/arm-compiler/downloads/legacy-compilers#arm-compiler-5">ARMCompiler 5</a> 编译器，它们当中的大部分都只支持 Linux 和 Windows操作系统环境；</li><li>安装 <a href="https://www.gnu.org/software/make">GNU Make</a>构建工具，可以组合使用 <a href="https://cmake.org">CMake</a> 以及 <a href="https://ninja-build.org">ninja</a>；</li><li>通过 <code>pip Install virtualenv</code> 命令全局安装 Python虚拟环境 <code>virtualenv</code>；</li></ol><h3 id="准备虚拟环境">准备虚拟环境</h3><p>首先，需要去克隆 <a href="https://github.com/ARMmbed/DAPLink"><strong>DAPLink</strong></a>托管在 Github 上面的开源工程，并且创建出一个 Python 虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/mbedmicro/DAPLink</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> DAPLink</span><br><span class="line"></span><br><span class="line">$ pip install virtualenv</span><br><span class="line"></span><br><span class="line">$ virtualenv venv</span><br></pre></td></tr></table></figure><p>如果当前使用的是 <strong>DAPLink</strong> 的指定 <a href="https://github.com/ARMmbed/DAPLink/releases">Release版本</a>，当把这些版本下载至本地以后，为了避免后续编译过程当中报错，需要将其初始化为一个Git 工程项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git config --global user.name <span class="string">&quot;Hank&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;uinika@outlook.com&quot;</span></span><br><span class="line">$ git commit -m <span class="string">&quot;update&quot;</span></span><br></pre></td></tr></table></figure><p>接下来，就可以激活 Python 虚拟环境，并且更新 <strong>DAPLink</strong>开源工程相关的第三方依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ venv/Scripts/activate       (For Linux)</span><br><span class="line"></span><br><span class="line">$ venv\Scripts\activate.bat   (For Windows)</span><br><span class="line"></span><br><span class="line">(venv) $ pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>除此之外，还需要再额外全局安装 <code>intelhex</code> 和<code>pyelftools</code> 两个 Python 第三方库，避免后续使用 <strong>KeilµVision</strong> 进行编译的时候出现依赖缺失的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install intelhex pyelftools</span><br></pre></td></tr></table></figure><h3 id="构建-keil-µvision-工程">构建 Keil µVision 工程</h3><p>接下来开始构建 <strong>DAPLink</strong> 的项目工程结构，可以使用 <a href="https://github.com/project-generator/project_generator">project-generator</a>提供的 <code>progen</code> 命令或者直接执行<code>tools/progen_compile.py</code> 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python tools/progen_compile.py [-t &lt;tool&gt;] [--clean] [-v] [--parallel] [&lt;project&gt; [&lt;project&gt; ...]]</span><br></pre></td></tr></table></figure><ul><li><code>-t &lt;tool&gt;</code>：选择当前构建所使用的工具链，默认为<code>make_gcc_arm</code>，其它的可选项分别为<code>make_gcc_arm</code>、<code>make_armclang</code>、<code>make_armcc</code>、<code>cmake_gcc_arm</code>、<code>cmake_armclang</code>、<code>cmake_armcc</code>；</li><li><code>--clean</code>:清除现有的编译结果，并且强制重新编译所有文件；</li><li><code>-v</code>: 列出详细信息，该选项会延长编译运行时间；</li><li><code>--parallel</code>: 启用并行编译，加快编译速度；</li><li><code>&lt;project&gt;</code>:等待编译的目标工程，如果缺省将会编译全部工程；</li></ul><p>通过执行下面的命令，可以在 <code>projectfiles/uvision</code>目录下面生成一系列的 <strong>Keil µVision</strong> 工程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ progen generate -t uvision</span><br></pre></td></tr></table></figure><p>当然也可以使用下面这条命令，只生成 <code>stm32f103xb_bl</code> 和<code>stm32f103xb_stm32f103rb_if</code> 两个指定的 <strong>KeilµVision</strong> 工程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ progen generate -f projects.yaml -p stm32f103xb_bl stm32f103xb_stm32f103rb_if -t uvision</span><br></pre></td></tr></table></figure><p>上述命令当中的参数 <code>-f</code> 用于指定工程配置文件，而参数<code>-p</code> 则用于指定工程的名称，最后的 <code>-t</code>则用于指定工程所属的开发环境。</p><h2 id="添加-arm-compiler-version-5">添加 ARM Compiler version 5</h2><p>编译 <strong>DAPLink</strong> 工程所需要使用到的 ARM 编译器版本为<strong>5</strong>，而当前最新版本的 <a href="https://armkeil.blob.core.windows.net/eval/MDK539.EXE">KeilµVision 5.39</a> 包含的编译器版本为 <strong>6</strong>，此时需要下载 <a href="https://armkeil.blob.core.windows.net/eval/MDK536.EXE">KeilµVision 5.36</a>，同时提取其 <code>ARM</code> 目录下的<code>ARMCC</code> 编译器，并将其解压至当前 <strong>KeilµVision</strong> 程序安装目录下的 <code>ARM</code> 文件夹下面：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/1.png"></p><p>启动 <strong>Keil µVision</strong> 开发环境，依次点击菜单栏上面的<code>【Project】-&gt;【Mange】-&gt;【Project Items】</code> 选项：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/2.png"></p><p>选中弹出对话框当中的 <code>【Folders/Extensions】</code> 选项卡，点击<code>Use ARM Compiler</code> 最右侧的按钮（即下图橙色圈出部分）：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/3.png"></p><p>鼠标再点击新弹出界面上的<code>【Add another ARM Compiler Version to List】</code>按钮，将路径定位至刚才放置到 <strong>Keil µVision</strong> 安装目录下的<code>ARMCC</code> 文件夹：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/4.png"></p><p>关闭上述对话框，再使用鼠标点击一次界面上的<code>【Setup Default ARM Compiler Version】</code> 按钮：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/5.png"></p><p>选中 <code>【Use default Compiler Version 5】</code>，将上面的<code>ARMCC</code> 目录设置为当前 <strong>Keil µVision</strong>的默认编译器：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/6.png"></p><p>完成上述操作之后，就可以打开当前 <strong>Keil µVision</strong> 工程的<code>【Target】</code> 选项卡，打开 <code>ARM Compiler</code>下拉菜单，就可以看到相关的编译器选项：</p><p><img src="/Project/UINIO-DAPLink/ARMCC/7.png"></p><h2 id="导入-daplink-工程到-keil-µvision-5">导入 DAPLink 工程到 KeilµVision 5</h2><p>由于当前 <strong>DAPLink</strong> 采用了 <strong>Keil µVision4</strong> 进行构建，所以打开工程的时候会弹出如下的<code>【Using an MDK Version 4 Project】</code> 对话框：</p><p><img src="/Project/UINIO-DAPLink/DAPLink/1.png"></p><p>依次点击弹出界面上的<code>【Migrate to Device Pack】</code>、<code>【Stop Waiting】</code>按钮，最后点击 <code>【是(Y)】</code>：</p><p><img src="/Project/UINIO-DAPLink/DAPLink/2.png"></p><p>选择当前 <strong>UINIO-DAPLink</strong> 所使用的意法半导体<code>STM32F103C8T6</code> 作为目标编译芯片：</p><p><img src="/Project/UINIO-DAPLink/DAPLink/3.png"></p><p>确认把当前以 <code>.uvproj</code> 作为后缀名的 <strong>Keil µVision4</strong> 工程，转换为以 <code>.uvprojx</code> 作为后缀名的<strong>Keil µVision 5</strong> 工程：</p><p><img src="/Project/UINIO-DAPLink/DAPLink/4.png"></p><h2 id="开始下载-daplink-固件">开始下载 DAPLink 固件</h2><p>当使用 <code>progen</code> 执行完成项目构建之后，就会自动在<strong>DAPLink</strong> 工程的 <code>projectfiles\uvision</code>目录下面生成如下两个 <strong>Keil µVision</strong> 工程：</p><ol type="1"><li><code>stm32f103xb_bl</code> 目录：<strong>DAPLink</strong> 的Bootloader 工程，编译后得到 <code>stm32f103xb_bl.hex</code>。</li><li><code>stm32f103xb_stm32f103rb_if</code>目录：<strong>DAPLink</strong> 的 Interface 工程，编译后得到<code>stm32f103xb_stm32f103rb_if.hex</code>。</li></ol><p>首先，计算机需要连接上一台已经下载好固件的 <strong>CMSIS-DAPDebugger</strong> 调试器，并且在 <strong>Keil µVision</strong>当中进行如下一系列设置：</p><p><img src="/Project/UINIO-DAPLink/Firmware/1.png"></p><p><img src="/Project/UINIO-DAPLink/Firmware/2.png"></p><p><img src="/Project/UINIO-DAPLink/Firmware/3.png"></p><p>然后，就可以编译 <strong>DAPLink</strong> 的 Bootloader 工程<code>stm32f103xb_bl</code>，并且将其直接烧录至<strong>UINIO-DAPLink</strong> 当中：</p><p><img src="/Project/UINIO-DAPLink/Firmware/4.png"></p><p>完成 Bootloader 的烧录之后，将 <strong>UINIO-DAPLink</strong>连接至计算机的 USB端口，就会自动在操作系统的<strong>资源管理器</strong>当中挂载出一个<code>MAINTENANCE</code> 盘符：</p><p><img src="/Project/UINIO-DAPLink/Firmware/5.png"></p><p>接下来，开始编译 <strong>DAPLink</strong> 的 Interface 工程<code>stm32f103xb_stm32f103rb_if</code>，完成之后将编译得到的<code>stm32f103xb_stm32f103rb_if.hex</code> 文件拖入<code>MAINTENANCE</code> 盘符。如果此时<strong>资源管理器</strong>当中的<code>MAINTENANCE</code> 盘符自动被更名为<code>DAPLINK</code>，就表示已经成功完成了<strong>UINIO-DAPLink</strong> 的全部固件下载工作：</p><p><img src="/Project/UINIO-DAPLink/Firmware/6.png"></p><blockquote><p><strong>注意</strong>：下载 <strong>DAPLink</strong> 固件所需的<code>stm32f103xb_bl.hex</code><code>stm32f103xb_stm32f103rb_if.hex</code> 固件，已经被放置到 <a href="https://github.com/uinika/UINIO-DAPLink">UINIO-DAPLink</a>开源项目的 <code>Firmware</code> 目录下面，故而大家可以省略前述的<strong>Keil µVision</strong>编译步骤，直接按照上述流程下载固件即可。</p></blockquote><h2 id="配置-daplink-源文件">配置 DAPLink 源文件</h2><p>首先，打开 <code>DAPLink\source\daplink\cmsis-dap</code> 目录下的<code>dap_strings.h</code> 源文件，将其中的<code>#define CMSIS_DAP_PRODUCT_NAME "DAPLink CMSIS-DAP"</code>语句修改为自定义的<code>#define CMSIS_DAP_PRODUCT_NAME "UINIO-CMSIS-DAP"</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CMSIS_DAP_PRODUCT_NAME)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> CMSIS_DAP_PRODUCT_NAME <span class="string">&quot;UINIO-CMSIS-DAP&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后，再打开 <code>DAPLink\source\hic_hal\stm32\stm32f103xb</code>目录下的 <code>IO_Config.h</code> 头文件，根据当前<strong>UINIO-DAPLink</strong> 的引脚连接关系进行如下一系列配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IO_CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IO_CONFIG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;compiler.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;daplink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">COMPILER_ASSERT(DAPLINK_HIC_ID == DAPLINK_HIC_ID_STM32F103XB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// USB control pin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_PORT_ENABLE()    __HAL_RCC_GPIOA_CLK_ENABLE()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_PORT_DISABLE()   __HAL_RCC_GPIOA_CLK_DISABLE()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_PIN              GPIO_PIN_15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_ON()             (USB_CONNECT_PORT-&gt;BSRR = USB_CONNECT_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONNECT_OFF()            (USB_CONNECT_PORT-&gt;BRR  = USB_CONNECT_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connected LED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECTED_LED_PORT           GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECTED_LED_PIN            GPIO_PIN_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECTED_LED_PIN_Bit        6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When bootloader, disable the target port(not used)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POWER_EN_PIN_PORT            GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POWER_EN_PIN                 GPIO_PIN_15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POWER_EN_Bit                 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nRESET OUT Pin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nRESET_PIN_PORT              GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nRESET_PIN                   GPIO_PIN_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nRESET_PIN_Bit               0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SWD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWCLK_TCK_PIN_PORT           GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWCLK_TCK_PIN                GPIO_PIN_13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWCLK_TCK_PIN_Bit            13</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_OUT_PIN_PORT           GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_OUT_PIN                GPIO_PIN_14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_OUT_PIN_Bit            14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_IN_PIN_PORT            GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_IN_PIN                 GPIO_PIN_12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWDIO_IN_PIN_Bit             12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USB status LED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNING_LED_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNING_LED_PIN              GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNING_LED_Bit              9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_HID_LED_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_HID_LED                  GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_HID_LED_Bit              9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_CDC_LED_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_CDC_LED                  GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_CDC_LED_Bit              9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MSC_LED_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MSC_LED                  GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_MSC_LED_Bit              9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="拖拽方式升级-daplink-固件">拖拽方式升级 DAPLink 固件</h2><p><strong>UINIO-DAPLink</strong> 调试器采用意法半导体<code>STM32F103C8T6</code> 作为主控芯片，片上 <strong>Flash</strong>的容量为 <code>64KB</code>。在之前所述的步骤当中，已经为其烧录了<code>stm32f103xb_bl.hex</code> 作为<strong>Bootloader</strong>，因而支持通过拖拽方式升级快速升级<strong>Interface</strong> 固件<code>stm32f103xb_stm32f103rb_if.hex</code>，具体操作步骤如下所示：</p><ol type="1"><li>使用杜邦线将 <strong>UINIO-DAPLink</strong> 调试器的<code>nRST</code> 和 <code>GND</code> 针脚进行短接。</li><li>将 <strong>UINIO-DAPLink</strong> 连接到电脑，资源管理器出现<code>MAINTENANCE</code> 盘符。</li><li>此时可以把 <code>nRST</code> 和 <code>GND</code>引脚的杜邦线连接断开。</li><li>将新版本固件拖动至 <code>MAINTENANCE</code> 盘符，等待<strong>UINIO-DAPLink</strong> 自动更新固件。</li><li>如果 Windows 操作系统的<strong>资源管理器</strong>出现<code>DAPLINK</code> 盘符，就表示已经升级成功。</li></ol><h2 id="在-stm32cubeide-使用-daplink">在 STM32CubeIDE 使用 DAPLink</h2><p>在接下来的内容里，将会基于我所制作的 <a href="https://github.com/uinika/UINIO-MCU-STM32L051K8"><strong>UINIO-MCU-STM32L051K8</strong></a>核心板，在意法半导体提供的最新版本 <a href="https://www.st.com/en/development-tools/stm32cubeide.html"><strong>STM32CubeIDE</strong></a>当中，实现固件的烧录与调试。</p><h3 id="安装-arm-eabi-工具链">安装 arm-eabi 工具链</h3><p>在 <strong>STM32CubeIDE</strong> 当中运用 DAPLink调试与下载程序，需要使用到 <strong>ARM嵌入式应用程序二进制接口</strong>，也就是 <strong>ARMEABI</strong>。包括了 <a href="https://gnutoolchains.com/arm-eabi/"><strong>Windows Toolchain forARM</strong></a> 和 <a href="https://gnutoolchains.com/arm-eabi/openocd/"><strong>OpenOCD</strong></a>两个工具库：</p><ol type="1"><li>首先，需要调用 <code>openocd.exe</code> 开启一个连接到 DAP-Link与目标微控制器的 GDB 调试服务；</li><li>然后，<strong>STM32CubeIDE</strong> 就可以通过<code>arm-none-eabi-gdb.exe</code> 访问这个 GDB 服务；</li></ol><p>下载并且解压上述两个工具库之后，分别将它们的 <code>bin</code>目录添加到操作系统的<strong>环境变量</strong>，再分别执行如下两个命令，测试其是否已经正确的被安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">λ openocd</span><br><span class="line"></span><br><span class="line">Open On-Chip Debugger 0.11.0 (2021-11-18) [https://github.com/sysprogs/openocd]</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">libusb1 09e75e98b4d9ea7909e8837b7a3f00dda4589dc3</span><br><span class="line">For bug reports, <span class="built_in">read</span></span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">embedded:startup.tcl:26: Error: Can<span class="string">&#x27;t find openocd.cfg</span></span><br><span class="line"><span class="string">in procedure &#x27;</span>script<span class="string">&#x27;</span></span><br><span class="line"><span class="string">at file &quot;embedded:startup.tcl&quot;, line 26</span></span><br><span class="line"><span class="string">Info : Listening on port 6666 for tcl connections</span></span><br><span class="line"><span class="string">Info : Listening on port 4444 for telnet connections</span></span><br><span class="line"><span class="string">Error: Debug Adapter has to be specified, see &quot;adapter driver&quot; command</span></span><br><span class="line"><span class="string">embedded:startup.tcl:26: Error:</span></span><br><span class="line"><span class="string">in procedure &#x27;</span>script<span class="string">&#x27;</span></span><br><span class="line"><span class="string">at file &quot;embedded:startup.tcl&quot;, line 26</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ arm-none-eabi-gdb</span><br><span class="line"></span><br><span class="line">GNU gdb (GDB) 10.2.90.20210621-git</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;--host=i686-w64-mingw32 --target=arm-none-eabi&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h3 id="以命令行方式进行调用">以命令行方式进行调用</h3><h4 id="配置-openocd">配置 OpenOCD</h4><p>OpenOCD 命令的调用格式如下面的代码所示，其中的 <code>-f</code>参数表示当前使用的是配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openocd.exe -f interface\调试器接口配置文件 -f target\目标微控制器配置文件</span><br></pre></td></tr></table></figure><p>下面列出了 <code>OpenOCD\share\openocd\scripts\interface</code>目录下的所有配置文件，由于这里使用的是 <strong>DAP-Link</strong>作为调试器，所以通常都是以 <code>cmsis-dap.cfg</code> 作为参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ <span class="built_in">ls</span> OpenOCD\share\openocd\scripts\interface</span><br><span class="line"></span><br><span class="line">altera-usb-blaster.cfg   dummy.cfg          jtag_vpi.cfg      raspberrypi2-native.cfg    ti-icdi.cfg</span><br><span class="line">altera-usb-blaster2.cfg  estick.cfg         kitprog.cfg       raspberrypi-native.cfg     ti-icdi-auto.cfg</span><br><span class="line">arm-jtag-ew.cfg          flashlink.cfg      nds32-aice.cfg    rlink.cfg                  ulink.cfg</span><br><span class="line">at91rm9200.cfg           ft232r/            nulink.cfg        rshim.cfg                  usb-jtag.cfg</span><br><span class="line">buspirate.cfg            ft232r.cfg         opendous.cfg      stlink.cfg                 usbprog.cfg</span><br><span class="line">calao-usb-a9260.cfg      ftdi/              openjtag.cfg      stlink-dap.cfg             vsllink.cfg</span><br><span class="line">cc3200lp.cfg             imx-native.cfg     osbdm.cfg         stlink-v1.cfg              xds110.cfg</span><br><span class="line">chameleon.cfg            jlink.cfg          parport.cfg       stlink-v2.cfg</span><br><span class="line">cmsis-dap.cfg            jtag_dpi.cfg       parport_dlc5.cfg  stlink-v2-1.cfg</span><br><span class="line">dln-2-gpiod.cfg          jtag_hat_rpi2.cfg  picoprobe.cfg     sysfsgpio-raspberrypi.cfg</span><br></pre></td></tr></table></figure><p>接下来例出的是 <code>OpenOCD\share\openocd\scripts\target</code>目录下的全部配置文件，这里需要根据目标 MCU微控制器的型号，酌情选择相应的配置文件作为参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">λ <span class="built_in">ls</span> OpenOCD\share\openocd\scripts\target</span><br><span class="line"></span><br><span class="line">adsp-sc58x.cfg                     bluenrg-x.cfg         lpc13xx.cfg                    samsung_s3c2440.cfg</span><br><span class="line">aduc702x.cfg                       c100.cfg              lpc1549.cfg                    samsung_s3c2450.cfg</span><br><span class="line">aducm3027.cfg                      c100config.tcl        lpc15xx.cfg                    samsung_s3c4510.cfg</span><br><span class="line">aducm3029.cfg                      c100helper.tcl        lpc17xx.cfg                    samsung_s3c6410.cfg</span><br><span class="line">aducm302x.tcl                      c100regs.tcl          lpc1850.cfg                    sharp_lh79532.cfg</span><br><span class="line">aducm360.cfg                       cc2538.cfg            lpc1xxx.cfg                    sim3x.cfg</span><br><span class="line">aducm4050.cfg                      cs351x.cfg            lpc2103.cfg                    smp8634.cfg</span><br><span class="line">aducm4x50.tcl                      davinci.cfg           lpc2124.cfg                    snps_em_sk_fpga.cfg</span><br><span class="line">allwinner_v3s.cfg                  dragonite.cfg         lpc2129.cfg                    snps_hsdk.cfg</span><br><span class="line">alphascale_asm9260t.cfg            dsp56321.cfg          lpc2148.cfg                    spear3xx.cfg</span><br><span class="line">altera_fpgasoc.cfg                 dsp568013.cfg         lpc2294.cfg                    stellaris.cfg</span><br><span class="line">altera_fpgasoc_arria10.cfg         dsp568037.cfg         lpc2378.cfg                    stm32f0x.cfg</span><br><span class="line">am335x.cfg                         efm32.cfg             lpc2460.cfg                    stm32f1x.cfg</span><br><span class="line">am437x.cfg                         em357.cfg             lpc2478.cfg                    stm32f2x.cfg</span><br><span class="line">amdm37x.cfg                        em358.cfg             lpc2900.cfg                    stm32f3x.cfg</span><br><span class="line">ampere_emag.cfg                    eos_s3.cfg            lpc2xxx.cfg                    stm32f4x.cfg</span><br><span class="line">ar71xx.cfg                         epc9301.cfg           lpc3131.cfg                    stm32f7x.cfg</span><br><span class="line">arm_corelink_sse200.cfg            esi32xx.cfg           lpc3250.cfg                    stm32g0x.cfg</span><br><span class="line">armada370.cfg                      exynos5250.cfg        lpc40xx.cfg                    stm32g0x_alt.cfg</span><br><span class="line">at32ap7000.cfg                     faux.cfg              lpc4350.cfg                    stm32g4x.cfg</span><br><span class="line">at91r40008.cfg                     feroceon.cfg          lpc4357.cfg                    stm32g4x_alt.cfg</span><br><span class="line">at91rm9200.cfg                     fm3.cfg               lpc4370.cfg                    stm32h7x.cfg</span><br><span class="line">at91sam3ax_4x.cfg                  fm4.cfg               lpc546xx.cfg                   stm32h7x_dual_bank.cfg</span><br><span class="line">at91sam3ax_8x.cfg                  fm4_mb9bf.cfg         lpc55sxx.cfg                   stm32h7x_dual_core.cfg</span><br><span class="line">at91sam3ax_xx.cfg                  fm4_s6e2cc.cfg        lpc84x.cfg                     stm32l0.cfg</span><br><span class="line">at91sam3nXX.cfg                    gd32e23x.cfg          lpc8nxx.cfg                    stm32l0_dual_bank.cfg</span><br><span class="line">at91sam3sXX.cfg                    gd32vf103.cfg         lpc8xx.cfg                     stm32l1.cfg</span><br><span class="line">at91sam3u1c.cfg                    gp326xxxa.cfg         ls1012a.cfg                    stm32l1x_dual_bank.cfg</span><br><span class="line">at91sam3u1e.cfg                    hi3798.cfg            marvell/                       stm32l4x.cfg</span><br><span class="line">at91sam3u2c.cfg                    hi6220.cfg            max32620.cfg                   stm32l5x.cfg</span><br><span class="line">at91sam3u2e.cfg                    hilscher_netx10.cfg   max32625.cfg                   stm32mp15x.cfg</span><br><span class="line">at91sam3u4c.cfg                    hilscher_netx50.cfg   max3263x.cfg                   stm32u5x.cfg</span><br><span class="line">at91sam3u4e.cfg                    hilscher_netx500.cfg  mc13224v.cfg                   stm32w108xx.cfg</span><br><span class="line">at91sam3uxx.cfg                    icepick.cfg           mdr32f9q2i.cfg                 stm32wbx.cfg</span><br><span class="line">at91sam3XXX.cfg                    imx.cfg               nds32v2.cfg                    stm32wlx.cfg</span><br><span class="line">at91sam4c32x.cfg                   imx21.cfg             nds32v3.cfg                    stm32xl.cfg</span><br><span class="line">at91sam4cXXX.cfg                   imx25.cfg             nds32v3m.cfg                   stm8l.cfg</span><br><span class="line">at91sam4lXX.cfg                    imx27.cfg             nds32v5.cfg                    stm8l152.cfg</span><br><span class="line">at91sam4sd32x.cfg                  imx28.cfg             nhs31xx.cfg                    stm8s.cfg</span><br><span class="line">at91sam4sXX.cfg                    imx31.cfg             npcx.cfg                       stm8s003.cfg</span><br><span class="line">at91sam4XXX.cfg                    imx35.cfg             nrf51.cfg                      stm8s103.cfg</span><br><span class="line">at91sam7a2.cfg                     imx51.cfg             nrf52.cfg                      stm8s105.cfg</span><br><span class="line">at91sam7se512.cfg                  imx53.cfg             nuc910.cfg                     str710.cfg</span><br><span class="line">at91sam7sx.cfg                     imx6.cfg              numicro.cfg                    str730.cfg</span><br><span class="line">at91sam7x256.cfg                   imx6_dual.cfg         omap2420.cfg                   str750.cfg</span><br><span class="line">at91sam7x512.cfg                   imx6_quad.cfg         omap3530.cfg                   str912.cfg</span><br><span class="line">at91sam9.cfg                       imx6sx.cfg            omap4430.cfg                   swj-dp.tcl</span><br><span class="line">at91sam9260.cfg                    imx6ul.cfg            omap4460.cfg                   swj-dp-legacy.tcl</span><br><span class="line">at91sam9260_ext_RAM_ext_flash.cfg  imx7.cfg              omap5912.cfg                   swm050.cfg</span><br><span class="line">at91sam9261.cfg                    imx7ulp.cfg           omapl138.cfg                   test_reset_syntax_error.cfg</span><br><span class="line">at91sam9263.cfg                    imx8m.cfg             or1k.cfg                       test_syntax_error.cfg</span><br><span class="line">at91sam9g10.cfg                    imx8qm.cfg            pic32mm.cfg                    ti_calypso.cfg</span><br><span class="line">at91sam9g20.cfg                    imxrt.cfg             pic32mx.cfg                    ti_cc13x0.cfg</span><br><span class="line">at91sam9g45.cfg                    infineon/             psoc4.cfg                      ti_cc13x2.cfg</span><br><span class="line">at91sam9rl.cfg                     is5114.cfg            psoc5lp.cfg                    ti_cc26x0.cfg</span><br><span class="line">at91sama5d2.cfg                    ixp42x.cfg            psoc6.cfg                      ti_cc26x2.cfg</span><br><span class="line">at91samdXX.cfg                     k1921vk01t.cfg        pxa255.cfg                     ti_cc3220sf.cfg</span><br><span class="line">at91samg5x.cfg                     k40.cfg               pxa270.cfg                     ti_cc32xx.cfg</span><br><span class="line">atheros_ar2313.cfg                 k60.cfg               pxa3xx.cfg                     ti_dm355.cfg</span><br><span class="line">atheros_ar2315.cfg                 ke02.cfg              qualcomm_qca4531.cfg           ti_dm365.cfg</span><br><span class="line">atheros_ar9331.cfg                 ke04.cfg              quark_d20xx.cfg                ti_dm6446.cfg</span><br><span class="line">atheros_ar9344.cfg                 ke06.cfg              quark_x10xx.cfg                ti_k3.cfg</span><br><span class="line">atmega128.cfg                      ke0x.cfg              raspberry.cfg                  ti_msp432.cfg</span><br><span class="line">atmega128rfa1.cfg                  ke1xf.cfg             raspberrypi2.cfg               ti_rm4x.cfg</span><br><span class="line">atsame5x.cfg                       ke1xz.cfg             raspberrypi3.cfg               ti_tms570.cfg</span><br><span class="line">atsaml1x.cfg                       kex.cfg               raspberrypi3_single.cfg        ti_tms570ls1224.cfg</span><br><span class="line">atsamv.cfg                         kinetis_128k.cfg      readme.txt                     ti_tms570ls20xxx.cfg</span><br><span class="line">avr32.cfg                          kinetis_1m.cfg        renesas_r7s72100.cfg           ti_tms570ls3137.cfg</span><br><span class="line">bcm2711.cfg                        kinetis_256k.cfg      renesas_rcar_gen2.cfg          ti-ar7.cfg</span><br><span class="line">bcm281xx.cfg                       kinetis_32k.cfg       renesas_rcar_gen3.cfg          ti-cjtag.cfg</span><br><span class="line">bcm2835.cfg                        kinetis_512k.cfg      renesas_rcar_reset_common.cfg  tmpa900.cfg</span><br><span class="line">bcm2836.cfg                        kinetis_64k.cfg       renesas_rz_g2.cfg              tmpa910.cfg</span><br><span class="line">bcm2837.cfg                        kinetis_generic.cfg   renesas_s7g2.cfg               tnetc4401.cfg</span><br><span class="line">bcm4706.cfg                        kl25.cfg              rk3308.cfg                     u8500.cfg</span><br><span class="line">bcm4718.cfg                        kl46.cfg              rk3399.cfg                     vybrid_vf6xx.cfg</span><br><span class="line">bcm47xx.cfg                        klx.cfg               rm57x.cfg                      xilinx_zynqmp.cfg</span><br><span class="line">bcm5352e.cfg                       ks869x.cfg            rp2040.cfg                     xmc1xxx.cfg</span><br><span class="line">bcm6348.cfg                        kx.cfg                rp2040-core0.cfg               xmc4xxx.cfg</span><br><span class="line">bluefield.cfg                      lpc11xx.cfg           rs14100.cfg                    xmos_xs1-xau8a-10_arm.cfg</span><br><span class="line">bluenrg-lp.cfg                     lpc12xx.cfg           samsung_s3c2410.cfg            zynq_7000.cfg</span><br></pre></td></tr></table></figure><p>这里以<code>STM32L0</code>、<code>STM32F1</code>、<code>STM32F4</code>系列微控制器为例，需要分别使用到如下几条 OpenOCD 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openocd.exe -f interface\cmsis-dap.cfg -f target\stm32l0.cfg</span><br><span class="line">openocd.exe -f interface\cmsis-dap.cfg -f target\stm32f1x.cfg</span><br><span class="line">openocd.exe -f interface\cmsis-dap.cfg -f target\stm32f4x.cfg</span><br></pre></td></tr></table></figure><p>接下来以 <code>STM32L051K8U6</code> 微控制器为例，正确执行 OpenOCD命令之后的效果如下所示，命令行会提示当前提供的 GDB 服务端口为<code>3333</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">λ openocd.exe -f interface\cmsis-dap.cfg -f target\stm32l0.cfg</span><br><span class="line"></span><br><span class="line">Open On-Chip Debugger 0.11.0 (2021-11-18) [https://github.com/sysprogs/openocd]</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">libusb1 09e75e98b4d9ea7909e8837b7a3f00dda4589dc3</span><br><span class="line">For bug reports, <span class="built_in">read</span></span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">Info : auto-selecting first available session transport <span class="string">&quot;swd&quot;</span>. To override use <span class="string">&#x27;transport select &lt;transport&gt;&#x27;</span>.</span><br><span class="line">Info : Listening on port 6666 <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port 4444 <span class="keyword">for</span> telnet connections</span><br><span class="line">Warn : could not <span class="built_in">read</span> product string <span class="keyword">for</span> device 0x058f:0x9540: Entity not found</span><br><span class="line">Info : CMSIS-DAP: SWD  supported</span><br><span class="line">Info : CMSIS-DAP: JTAG supported</span><br><span class="line">Info : CMSIS-DAP: FW Version = 1.0</span><br><span class="line">Info : CMSIS-DAP: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 1 TDO = 1 nTRST = 0 nRESET = 0</span><br><span class="line">Info : CMSIS-DAP: Interface ready</span><br><span class="line">Info : clock speed 300 kHz</span><br><span class="line">Info : SWD DPIDR 0x0bc11477</span><br><span class="line">Info : stm32l0.cpu: Cortex-M0+ r0p1 processor detected</span><br><span class="line">Info : stm32l0.cpu: target has 4 breakpoints, 2 watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> stm32l0.cpu on 3333</span><br><span class="line">Info : Listening on port 3333 <span class="keyword">for</span> gdb connections</span><br></pre></td></tr></table></figure><p>简便起见，也可以将上述命令保存为 Windows 系统下面一个名为<code>OpenOCD stm32l0.bat</code>的批处理文件，方便调试的时候快速进行调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Openocd Runing ... ... ...</span><br><span class="line">openocd.exe -f interface\cmsis-dap.cfg -f target\stm32l0.cfg</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h4 id="配置-stm32cubeide">配置 STM32CubeIDE</h4><p>启动 <strong>OpenOCD</strong> 服务之后，接着在<strong>STM32CubeIDE</strong> 当中新建一个名称叫做<code>Test-STM32L051K8U6</code> 的工程：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/1.png"></p><p>首先，选中 <strong>STM32CubeIDE</strong>左侧的工程名称，点击鼠标右键菜单上的 【<strong>BuildProject</strong>】， 编译生成出一个 <code>Test-STM32L051K8U6.elf</code>二进制文件。点击工具栏上【<strong>Debug</strong>】图标右侧的箭头，点击弹出菜单上的<code>Debug Configrations...</code> 打开调试配置窗口，鼠标双击窗口上的<code>GDB Hardware Debugging</code> 新建一条名为<code>Test-STM32L051K8U6 Debug</code> 的 GDB硬件调试配置，并在自动打开的【Main】选项卡界面进行如下一系列配置：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/2.png"></p><p>切换至【<strong>Debugger</strong>】选项卡，将 GDB 命令修改为<code>D:\Software\Tech\ARMEabi\bin\arm-none-eabi-gdb.exe</code>，并且将连接地址设置为<code>localhost:3333</code>：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/3.png"></p><p>经过上述步骤的配置，鼠标点击【<strong>Debug</strong>】按钮，就已经可以让<strong>STM32CubeIDE</strong> 通过 <strong>UINIO-DAPLink</strong>实现固件的烧录下载，如果需要进入单步调试模式，则可以在【<strong>Startup</strong>】选项卡当中，手动在<code>main</code> 函数位置设置一个断点：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/4.png"></p><h3 id="以-external-tools-方式使用">以 External Tools 方式使用</h3><p>首先，需要在 <strong>STM32CubeIDE</strong> 的 <strong>ExternalTool</strong> 当中添加 OpenOCD，依次点击顶部菜单栏当中的 【<strong>RUN-&gt; External Tools -&gt; External ToolsConfigrations...</strong>】，新建一个名称为<code>Test-STM32L051K8U6 Run</code> 的配置，并且将 OpenOCD命令所在的位置指定为<code>D:\Software\Tech\ARMEabi\OpenOCD\bin\openocd.exe</code>，相应的参数设置为<code>-f interface\cmsis-dap.cfg -f target\stm32l0.cfg</code>：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/5.png"></p><p>打开 <strong>STM32CubeIDE</strong> 的 <strong>DebuggerConfigration</strong> 窗口，鼠标双击左侧的【<strong>LaunchGroup</strong>】新建一个名为 <code>UINIO-DAPLink</code>的<strong>运行组</strong>，然后点击右侧的【<strong>Add...</strong>】按钮：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/6.png"></p><p>此时添加的执行配置策略为：首先执行 <code>OpenOCD</code> 命令开启 GDB服务，然后再通过 <code>arm-none-eabi-gdb</code> 执行调试任务。</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/7.png"></p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/8.png"></p><p>最后，配置完成之后的 <strong>Launch Group</strong>顺序如下图所示：</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/9.png"></p><p>接下来，就可以在 <strong>STM32CubeIDE</strong>顶部工具栏上【Run】和【Debug】按钮的下面，发现上面的配置的<code>UINIO-DAPLink</code><strong>运行组</strong>，点击之后就可以愉快的使用<strong>UINIO-DAPLink</strong> 执行 STM32 微控制器的程序调试工作了。</p><p><img src="/Project/UINIO-DAPLink/STM32CubeIDE/10.png"></p><h2 id="在-keil-µvision-使用-daplink">在 Keil µVision 使用 DAPLink</h2><p>本节内容将会基于 <a href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>核心板，新建一个名称为 <code>test</code> 的 <strong>KeilµVision</strong> 工程，并且点击菜单栏上的<code>【Options for target】-&gt;【Device】</code>，选择当前编译的目标设备为<code>GD32F350RB</code>：</p><p><img src="/Project/UINIO-DAPLink/Keil/1.png"></p><p>接下来，再点击弹出的 <code>【Manage Run-Time Environment】</code>界面上的 <strong>OK</strong> 按钮，完成测试工程的建立：</p><p><img src="/Project/UINIO-DAPLink/Keil/2.png"></p><p>再次打开 <code>【Options for target】</code>，鼠标选择<code>【Output】</code> 选项卡，勾选 <code>Create HEX File</code>选项之后，在 <code>Name of Executable</code>当中把待下载的二进制文件添加上 <code>.hex</code> 后缀名称（否则<strong>Keil µVision</strong> 会默认下载 <code>.axf</code>后缀的二进制文件）：</p><p><img src="/Project/UINIO-DAPLink/Keil/3.png"></p><p>紧接着打开 <code>【Debug】</code> 选项卡，选择<code>CMSIS-DAP Debugger</code>，并且点击 <code>【Settings】</code>按钮：</p><p><img src="/Project/UINIO-DAPLink/Keil/4.png"></p><p>在弹出的对话框中，选择 <strong>UINIO-CMSIS-DAP</strong>（需要提前将<strong>UINIO-DAPLink</strong> 连接到电脑的 USB 端口）：</p><p><img src="/Project/UINIO-DAPLink/Keil/5.png"></p><p>再打开对话框上的 <code>【Flash Download】</code> 选项卡，勾选<code>Reset and Run</code> 之后，点击 <code>【Add】</code>按钮添加片上的 <strong>Flash 编程算法</strong>：</p><p><img src="/Project/UINIO-DAPLink/Keil/6.png"></p><p>至此就完成了 <strong>UINIO-DAPLink</strong> 在 <strong>KeilµVision</strong> 当中的全部配置，接下来就可以添加官方的 ARM标准库，愉快的编写并且下载工程代码了。</p><h2 id="通过-keil-µvision-直接下载-hex">通过 Keil µVision 直接下载HEX</h2><p>如果需要直接烧录已经编译过的 <code>.hex</code> 固件（例如下载 <a href="https://github.com/uinika/UINIO-DAPLink">UINIO-DAPLink</a> 当中<code>Firmware</code> 目录下的<code>stm32f103xb_bl.hex</code>），可以按照前一小节内容所述的步骤，建立一个名为<code>test</code> 的 <strong>Keil µVision</strong> 工程，并将需要下载的<code>.hex</code> 文件拷贝至其 <code>Objects</code> 目录当中，接着在<code>【Options for target】-&gt;【Output】</code> 选项卡下面的<code>Name of Executable</code> 输入框当中，填入当前需要下载的<code>.hex</code> 文件完整名称（下图以 <code>stm32f103xb_bl.hex</code>为例）：</p><p><img src="/Project/UINIO-DAPLink/Keil/7.png"></p><blockquote><p><strong>注意</strong>：通过上述界面当中的<code>【Select Folder Objects...】</code> 按钮，还可以指定除了<code>Objects</code> 之外其它包含有 <code>.hex</code> 固件的目录。</p></blockquote><p>然后，就可以点击 <strong>Keil µVision</strong> 顶部工具栏上的<code>【Download】</code> 按钮，或者直接按下快捷键<code>【F8】</code>，就可以将上面指定的 <code>.hex</code> 文件下载至目标ARM 芯片当中：</p><p><img src="/Project/UINIO-DAPLink/Keil/8.png"></p><blockquote><p><strong>注意</strong>：新建的 <strong>Keil µVision</strong>工程必须参考前面的步骤，配置好目标芯片的型号以及片上 Flash的编程算法。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;ARM Mbed OS&lt;/strong&gt;
是一款开源免费的物联网操作系统，包含有基于 &lt;strong&gt;ARM Cortex-M&lt;/strong&gt;
系列微控制器开发智能连接产品所需的全部基础架构。其社区推出的 &lt;a href=&quot;https://daplink.io/&quot;&gt;&lt;strong&gt;DAP-Link&lt;/strong&gt;&lt;/a&gt;
同样是一个开源项目，它支持编程和调试运行在 ARM Cortex
微控制器上面的代码，主要运行于拥有 &lt;strong&gt;SWD&lt;/strong&gt; 或者
&lt;strong&gt;JTAG&lt;/strong&gt; 接口的微控制器当中，并且通过 USB 接口在计算机与
ARM Cortex
微控制器之间创建一个用于调试仿真的通道与桥梁，为开发人员提供了&lt;strong&gt;下载调试&lt;/strong&gt;、&lt;strong&gt;串口通信&lt;/strong&gt;、&lt;strong&gt;拖拽烧录&lt;/strong&gt;等一系列实用功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Project/UINIO-DAPLink/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAPLink&lt;/strong&gt; 主要由 &lt;a href=&quot;https://github.com/ARMmbed/mbed-HDK-Eagle-Projects&quot;&gt;&lt;strong&gt;Mbed
硬件开发工具包&lt;/strong&gt;&lt;/a&gt; 以及 &lt;a href=&quot;https://github.com/ARMmbed/DAPLink&quot;&gt;&lt;strong&gt;DAPLink
固件&lt;/strong&gt;&lt;/a&gt; 两个开源项目构成，而 &lt;a href=&quot;https://github.com/uinika/UINIO-DAPLink&quot;&gt;&lt;strong&gt;UINIO-DAPLink&lt;/strong&gt;&lt;/a&gt;
则是由我自己设计的一款完全开源的 DAPLink
实现，相比于官方原版的硬件电路设计，在引出有 &lt;strong&gt;SWD&lt;/strong&gt;
调试接口（由 ARM 公司制订）的同时，还引出了 &lt;strong&gt;JTAG&lt;/strong&gt;
接口（属于 IEEE1149 国际标准）以及&lt;code&gt;5V&lt;/code&gt; 和 &lt;code&gt;3.3V&lt;/code&gt;
电源，并且附带有 &lt;strong&gt;SWD&lt;/strong&gt; 至 &lt;strong&gt;JTAG&lt;/strong&gt; 转接板的
PCB 设计，而固件部分则是基于 ARM
官方的最新的原版固件移植而来，全部的原理图与固件程序都已经开源在 &lt;a href=&quot;https://github.com/uinika/UINIO-DAPLink&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Project" scheme="http://www.uinio.com/categories/Project/"/>
    
    
    <category term="Tools" scheme="http://www.uinio.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一枚 NFC 动态标签的天线</title>
    <link href="http://www.uinio.com/Electronics/NFC_Antenna/"/>
    <id>http://www.uinio.com/Electronics/NFC_Antenna/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>近场通信</strong>（<strong>NFC</strong>，Near FieldCommunication）是一种基于<strong>无线射频识别</strong>（<strong>RFID</strong>，RadioFrequency IDentification）技术发展起来的近距离无线通信技术，它们都是通过无线频率的电磁感应耦合传递数据，但是RFID 的传输范围可以达到 <code>1m</code>，而 NFC 的传输范围通常在<code>10cm</code> 以内。NFC 的无线信号频率为<code>13.56MHz</code>，可以兼容<strong>ISO14443</strong>、<strong>ISO15693</strong>、<strong>Felica</strong>等非接触式智能卡规范，数据传输速率可以达到<code>106kbit/s</code>、<code>212 kbit/s</code>、<code>424kbit/s</code>。</p><p><img src="/Electronics/NFC_Antenna/logo.png"></p><p>意法半导体的 NFC 动态标签芯片 <strong>ST25DV-I2C</strong> 和<strong>ST25DV-PWM</strong> 可以通过低功率的 <strong>I²C</strong>总线以及 <code>13.56MHz</code>无线射频访问芯片内置的<strong>EEPROM</strong>（电可擦除只读存储器），同时支持近程的<strong>ISO/IEC 14443 Type A</strong> 和远程的 <strong>ISO/IEC15693</strong> 标准。本文旨在介绍无源 <strong>RFID</strong>的基本原理，以及 <code>13.56MHz</code>感应天线设计的基础知识，文中部分内容参考自意法半导体编号为《<strong>AN2972</strong>》的官方应用笔记（<strong>ApplicationNote</strong>）。</p><span id="more"></span><h2 id="操作方式">操作方式</h2><p>实际电路当中集成动态 NFC 标签芯片是一项非常简单的工作，只需要将其通过<strong>I²C</strong> 总线连接至 MCU 微控制器即可，而动态 NFC 标签芯片在<strong>RF</strong>（射频，RadioFrequency）一端，则还需要连接外部天线才能够正常工作。</p><p><img src="/Electronics/NFC_Antenna/1.png"></p><p>动态 NFC 标签的天线通常是放置于 PCB电路板上的一圈<strong>环形走线</strong>，其阻抗与内部的<strong>调谐电容值</strong>相匹配，进而创建出一个<code>13.56MHz</code> 频率的共振电路，这个调谐频率的基本方程为:</p><p><span class="math display">\[f_{调谐} = \frac{1}{2 \pi \times \sqrt{L_{天线} \times C_{调谐}}}\]</span></p><h2 id="基本原理与方程">基本原理与方程</h2><p>本文接下来的内容当中，<strong>NFC 标签</strong>用于指代安装在 PCB上并与其天线相连接的动态 NFC 标签芯片，而 <strong>NFC读卡器</strong>则是指能够以射频模式与 NFC 标签进行通信的设备。</p><h3 id="无源-rfid-技术">无源 RFID 技术</h3><h4 id="能量传递">能量传递</h4><p>动态 NFC标签芯片通过其<strong>环形天线</strong>，从读卡器产生的磁场中获取运行所需的能量。该过程类似于变压器的<strong>互感</strong>，其中NFC 读卡器相当于<strong>初级绕组</strong>，而 NFC标签则相当于<strong>次级绕组</strong>。从 NFC 读卡器到 NFC标签芯片的能量传输主要取决于如下四个方面：</p><ol type="1"><li>NFC 标签天线的<strong>调谐</strong>程度，接近于 NFC 读卡器的载波频率<code>13.56 MHz</code>；</li><li>NFC 读卡器和 NFC标签天线之间的<strong>距离</strong>与<strong>方向</strong>；</li><li>NFC 读卡器天线与 NFC 标签天线的<strong>尺寸</strong>；</li><li>NFC 读卡器的<strong>功率</strong>；</li></ol><p>下面的示意图展示了在射频模式下，NFC读卡器与标签之间的功率传输机制：</p><p><img src="/Electronics/NFC_Antenna/2.png"></p><p>NFC 读卡器通过电磁场向 NFC 标签传递的能量，取决于 NFC读卡器产生的<strong>磁感线</strong>如何流经 NFC 标签天线。</p><ul><li>双方的 NFC天线保持<strong>平行</strong>时，通信效果<strong>最佳</strong>；</li><li>双方的 NFC天线相互<strong>垂直</strong>时，无法进行有效的通信；</li><li>双方的 NFC天线处于<strong>其它位置</strong>时，通信效果会到一定程度的影响；</li></ul><p><img src="/Electronics/NFC_Antenna/3.png"></p><h4 id="数据传输">数据传输</h4><p>将 NFC 标签放置于 NFC 读卡器的电磁场当中，NFC标签芯片的内置电路就会开始<strong>解调</strong>来自于读卡器的信息：</p><p><img src="/Electronics/NFC_Antenna/4.png"></p><p>通信结束之后，NFC 读卡器会继续为 NFC 标签供电，以使得 NFC标签产生一个应答响应，发送回 NFC 读卡器（动态 NFC标签芯片会通过调节内部的输入阻抗，将应答信号反向散射到 NFC读卡器）。</p><p><img src="/Electronics/NFC_Antenna/5.png"></p><blockquote><p>▶ 整个数据通信过程所涉及的全部标准与协议，都已经嵌入到了 NFC 读卡器与NFC 标签芯片的内部电路当中。</p></blockquote><h3 id="简化等效电路">简化等效电路</h3><p>下面的示意图给出了 NFC 动态标签及其天线的等效电路：</p><p><img src="/Electronics/NFC_Antenna/6.png"></p><ul><li><strong>动态 NFC标签芯片的模型</strong>由一个代表其所<strong>消耗电流</strong>的电阻<span class="math inline">\(R_{chip}\)</span>和一个代表内部<strong>调谐电容</strong>与<strong>内部寄生电容</strong>的<span class="math inline">\(C_{tun}\)</span> 来进行表示；</li><li><strong>环形天线的模型</strong>是由表示环形天线上全部<strong>杂散电容</strong>的<span class="math inline">\(C_{ant}\)</span>，以及表示天线<strong>电阻损耗</strong>的 <span class="math inline">\(R_{ant}\)</span>，和表示环形天线<strong>自感</strong>的<span class="math inline">\(L_{ant}\)</span> 共同组成；</li></ul><p>其中，虽然 <span class="math inline">\(C_{ant}\)</span>、<span class="math inline">\(R_{ant}\)</span>、<span class="math inline">\(L_{ant}\)</span>是一个常量，但是其<strong>总阻抗</strong>具有频率依赖性。即在<strong>自谐振频率</strong>下，天线阻抗的<strong>虚部</strong><span class="math inline">\(Z_{ant}\)</span>为零呈现纯<strong>阻性</strong>；而在低于<strong>自谐振频率</strong>时，天线阻抗的虚部为正值呈现<strong>感性</strong>。当频率低于<strong>自谐振频率</strong>（<span class="math inline">\(Z_{ant} = R_A+j_{XA}\)</span>）的时候，天线的<strong>等效电感</strong> <span class="math inline">\(L_A\)</span> 被定义为 <span class="math inline">\(L_A = \frac{X_A}{\omega}\)</span>。</p><blockquote><p>▶ 低频情况下，杂散电容的影响可以忽略不计 <span class="math inline">\(L_A = L_{ant}\)</span>(自感)。而达到<code>13.56MHz</code> 频率的时候，杂散电容的影响就不能再被忽视 <span class="math inline">\(L_A &gt; L_{ant}\)</span>。</p></blockquote><h3 id="基本方程">基本方程</h3><h4 id="谐振频率">谐振频率</h4><p>下图展示了存在正弦磁场的情况下，安装有<strong>环形天线</strong>的<strong>NFC 动态标签芯片</strong>的等效电路。其中的 <span class="math inline">\(V_{OC}\)</span>表示天线传递的<strong>开路电压</strong>，该电压值取决于<code>磁场强度</code>以及天线的<code>尺寸</code>和<code>匝数</code>。</p><p><img src="/Electronics/NFC_Antenna/7.png"></p><p>NFC 标签的天线阻抗为 <span class="math inline">\(Z_{ant} = R_A + jL_A\omega\)</span>，其中的 <span class="math inline">\(L_A\)</span>表示天线的<strong>电感</strong>。而 NFC 标签芯片的阻抗为 <span class="math inline">\(Z_S = R_S + j \times \frac{1}{CS\omega}\)</span>，其中的 <span class="math inline">\(R_S\)</span>表示的是 NFC 标签芯片的<strong>电流损耗</strong>，而 <span class="math inline">\(C_S\)</span>表示的是<strong>串联等效调谐电容</strong>。</p><blockquote><p>▶ 等效 RLC 电路的谐振频率由条件 <span class="math inline">\(L_A C_S\omega^2 = 1\)</span> 给出，其中 <span class="math inline">\(\omega = 2\pi f\)</span>（此处的 <span class="math inline">\(f\)</span> 表示频率<code>Hz</code>）。</p></blockquote><h4 id="最优天线调谐">最优天线调谐</h4><p>RLC 电路的<strong>总阻抗</strong> <span class="math inline">\(Z_{tot}= Z_{ant} + Z_S\)</span>，当<strong>谐振频率</strong>为 <span class="math inline">\(L_A C_S \omega^2 = 1\)</span> 时，总阻抗降低至<span class="math inline">\(Z_{tot} = R_A +R_S\)</span>，此时天线的总阻抗最小，天线内部的<strong>电流</strong>以及传递给NFC标签芯片的<strong>电压</strong>最大，进而向设备提供的能量也就最大。</p><p><img src="/Electronics/NFC_Antenna/8.png"></p><blockquote><p>▶ 上图展示了三个动态 NFC 标签天线调优的例子，其中的标签<code>#2</code> 为最优的天线调谐。</p></blockquote><h2 id="如何设计-pcb-天线">如何设计 PCB 天线</h2><p><code>13.56MHz</code> 频率下的 NFC天线可以根据需要，被设计成为不同的形状。如前所述，需要重点关注的参数是天线在<code>13.56MHz</code> 频率下的<strong>等效电感</strong> <span class="math inline">\(L_A\)</span>。</p><blockquote><p>▶ 杂散电容非常难进行近似的取值，通常处于以 <code>pF</code>作为单位的范围以内。</p></blockquote><p>接下来的内容会给出计算各种形状天线<strong>自感</strong> <span class="math inline">\(L_{ant}\)</span>的有效公式（不考虑天线杂散电容），以及如何通过意法半导体官方提供的 <a href="https://www.st.com/content/st_com/en/support/resources/edesign.html">eDesignsuite</a>工具来计算<strong>等效电感</strong> <span class="math inline">\(L_A\)</span>。</p><h3 id="圆形天线的电感">圆形天线的电感</h3><p><span class="math display">\[L_{ant} = \mu_0 \times N^{1.9} \times r \times \ln(\frac{r}{r_0})\implies4 \pi \cdot 10^{-7} \times 天线圈数^{1.9} \times 天线半径 \times\ln\bigg(\frac{天线半径}{导线直径}\bigg)\]</span></p><ul><li><code>r</code> 是天线半径，单位为毫米；</li><li><code>r_0</code> 是导线直径，单位为毫米；</li><li><code>N</code> 是天线的圈数；</li><li><span class="math inline">\(\mu_0 = 4 \pi \cdot 10^{-7}H/m\)</span>；</li><li><span class="math inline">\(L\)</span> 的单位为亨利；</li></ul><h3 id="螺旋形天线的电感">螺旋形天线的电感</h3><p><span class="math display">\[L_{ant} = 31.33 \times \mu_0 \times N^2 \times \frac{a^2}{8a + 11c}\implies31.33 \times 4 \pi \cdot 10^{-7} \times 天线匝数^2 \times\frac{平均半径^2}{8\times平均半径 + 11\times绕组厚度}\]</span></p><p><img src="/Electronics/NFC_Antenna/9.png"></p><ul><li><span class="math inline">\(a = \frac{(r_{in} +r_{out})}{2}\)</span> 为平均半径，单位为米；</li><li><span class="math inline">\(c = r_{out} - r_{in}\)</span>是绕组厚度，单位为米；</li><li><span class="math inline">\(\mu_0 = 4 \pi \cdot 10^{-7}H/m\)</span>；</li><li><span class="math inline">\(L\)</span> 的单位为亨利；</li><li><span class="math inline">\(N\)</span>是天线的<strong>匝数</strong>；</li></ul><h3 id="方形天线的电感">方形天线的电感</h3><p><span class="math display">\[L_{ant} = K_1 \times \mu_0 \times N^2 \times \frac{d}{1 + K_2 \times p}\]</span></p><ul><li><span class="math inline">\(d = \frac{(d_{out} +d_{in})}{2}\)</span>，单位为<strong>毫米</strong>，其中 <span class="math inline">\(d_{out}\)</span> 为<strong>外径</strong>，而 <span class="math inline">\(d_{in}\)</span> 为<strong>内径</strong>；</li><li><span class="math inline">\(p = \frac{(d_{out} - d_{in})}{(d_{out} +d_{in})}\)</span>，单位为<strong>毫米</strong>；</li><li><span class="math inline">\(K_1\)</span> 和 <span class="math inline">\(K_2\)</span> 的取值依赖于天线的布局形式：</li></ul><p><img src="/Electronics/NFC_Antenna/10.png"></p><table><thead><tr class="header"><th style="text-align: center;">布局</th><th style="text-align: center;"><span class="math inline">\(K_1\)</span></th><th style="text-align: center;"><span class="math inline">\(K_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>正方形</strong></td><td style="text-align: center;"><code>2.34</code></td><td style="text-align: center;"><code>2.75</code></td></tr><tr class="even"><td style="text-align: center;"><strong>六角形</strong></td><td style="text-align: center;"><code>2.33</code></td><td style="text-align: center;"><code>3.82</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>八角形</strong></td><td style="text-align: center;"><code>2.25</code></td><td style="text-align: center;"><code>3.55</code></td></tr></tbody></table><h3 id="edesignsuite-天线设计工具">eDesignSuite 天线设计工具</h3><p>意法半导体官方提供的 <a href="https://www.st.com/content/st_com/en/support/resources/edesign.html">eDesignsuite</a>在线工具套件，为 NFC 天线设计提供了 <a href="https://eds.st.com/antenna/"><strong>NFC 电感</strong> (NFCInductance)</a> 和 <a href="https://eds.st.com/nfc-tuningcircuit/"><strong>NFC调谐电路</strong> (NFC Tuning Circuit)</a> 两款小工具。只需要输入与 PCB材料和天线尺寸相关的参数，该工具就可以通过计算<strong>自电感</strong>和<strong>杂散电容</strong>来得到天线的<strong>等效电感</strong>。</p><p><img src="/Electronics/NFC_Antenna/11.png"></p><p>上图给出了一个天线等效电感的计算示例，包括了天线的几何参数、导体参数、PCB基板参数。通过计算出的天线等效电感，就可以生成一个天线的原型。接下来，就可以使用网络分析仪测量天线阻抗，或者使用非接触式的方式测量NFC 标签的调谐频率来验证天线设计。</p><h2 id="pcb-布局">PCB 布局</h2><h3 id="动态-nfc-标签芯片与天线之间的连接长度">动态 NFC标签芯片与天线之间的连接长度</h3><p>动态 NFC标签芯片必须尽可能的靠近天线（位于几毫米范围以内），任何额外的布线都会改变天线的特性。</p><h3 id="地平面-电源-信号层">地平面 电源 信号层</h3><p>布局 PCB 上的 NFC天线时，需要注意天线的顶层与底层两个面都不能进行铺铜，并且在天线周围也最好不要存在铜平面；下面的示意图展示了NFC 天线的最优布局：<strong>NFC标签芯片靠近天线，而接地平面远离天线</strong>。</p><p><img src="/Electronics/NFC_Antenna/12.png"></p><p>接下来，展示的是两种错误设计的示例，这两种情况下电磁波不会流经天线，NFC读卡器与动态 NFC 标签的天线之间不会进行能量传递。</p><p><img src="/Electronics/NFC_Antenna/13.png"></p><p>下面同样是一种不推荐的布局示例，因为动态 NFC标签天线周围的环形铺铜会极大的衰减电磁波信号。</p><p><img src="/Electronics/NFC_Antenna/14.png"></p><p>而下面则是一种可以被接受的布局示例，主要是由于此处的天线并没有与地平面发生重叠。</p><p><img src="/Electronics/NFC_Antenna/15.png"></p><blockquote><p>▶ 建议在进行 PCB 布局时，专门为 NFC天线划分出一块周围没有接地层的独立区域。</p></blockquote><h3 id="金属表面">金属表面</h3><p>当 NFC 天线靠近导电层时，其<strong>自感</strong>将会减小，从而造成NFC 标签的调谐频率增加。</p><p><img src="/Electronics/NFC_Antenna/16.png"></p><p>如果设计的 NFC天线必须靠近金属表面进行工作，那么就必须对频率调谐的漂移进行补偿，以获得<code>13.56MHz</code>的正确调谐频率。这里可以通过重新设计一个具有更大等效电感的全新 NFC天线，或者在现有天线基础之上增加一个外部调谐电容来实现补偿。下面的表格，就展示了一个使用<code>74pF</code> 调谐电容进行频率补偿的示例：</p><table><colgroup><col style="width: 25%"><col style="width: 37%"><col style="width: 37%"></colgroup><thead><tr class="header"><th style="text-align: center;">特性</th><th style="text-align: left;">ANT1-M24LR16E</th><th style="text-align: left;">ANT1-M24LR16E加入<code>74pF</code>调谐电容</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">天线尺寸</td><td style="text-align: left;"><code>45 mm x 75 mm</code></td><td style="text-align: left;"><code>45 mm x 75 mm</code></td></tr><tr class="even"><td style="text-align: center;">空气中的频率调谐</td><td style="text-align: left;"><code>13.7 MHz</code></td><td style="text-align: left;"><code>7.5 MHz</code></td></tr><tr class="odd"><td style="text-align: center;">接近金属表面的频率调谐</td><td style="text-align: left;"><code>25 MHz</code></td><td style="text-align: left;"><code>14 MHz</code></td></tr><tr class="even"><td style="text-align: center;">空气中的读取范围</td><td style="text-align: left;"><code>7.5 cm</code></td><td style="text-align: left;"><code>0.5 cm</code></td></tr><tr class="odd"><td style="text-align: center;">接近金属表面的读取范围</td><td style="text-align: left;">未检测到</td><td style="text-align: left;"><code>2.5 cm</code></td></tr><tr class="even"><td style="text-align: center;">状态</td><td style="text-align: left;">天线经过调谐可以暴露在空气中工作</td><td style="text-align: left;">天线可以靠近金属表面进行工作</td></tr></tbody></table><blockquote><p>▶ 天线的重新设计会导致走线匝数的增加，需要注意 PCB上是否预留有足够的空间。如果布局空间无法有效的进行延伸布线，那么就必须采用外部调谐电容作为频率补偿方案。</p></blockquote><h2 id="nfc-天线调谐的检测">NFC 天线调谐的检测</h2><p>如下的这些因素都会影响到 NFC/RFID标签的<strong>调谐频率</strong>：</p><ul><li>天线<strong>等效电感</strong>的计算精度；</li><li>设备主体与天线之间的<strong>连接长度</strong>；</li><li>天线所处的<strong>工作环境</strong>（金属表面、磁性材料）；</li></ul><blockquote><p>▶ 在实际的生产环境当中，往往需要通过专门的仪器来测量 NFC/RFID标签的谐振频率。</p></blockquote><h3 id="采用网络分析仪测试">采用网络分析仪测试</h3><p>动态 NFC标签天线的调谐频率可以使用带有<strong>环形探头</strong>的<strong>网络分析仪</strong>来进行测量。其中的射频电磁场可以由连接环形探头的网络分析仪（设置为<strong>反射模式</strong>，测量<strong>S11回波损耗</strong>）产生。环形探头可以购买成品，或者使用单匝线圈自行绕制，并且将其连接至同轴连接器。这样构建出的环形探头可以根据标签天线的尺寸相应的调整大小，进而达到更优的耦合效果。</p><p><img src="/Electronics/NFC_Antenna/17.png"></p><blockquote><p>▶通过上述的设备配置与连接，可以直接获得当前系统的<strong>谐振频率</strong>。</p></blockquote><p>如下是一个用于实际测量的网络分析仪参数设置列表：</p><ul><li><strong>起始频率</strong>：<code>5 MHz</code>；</li><li><strong>截止频率</strong>：<code>20 MHz</code>；</li><li><strong>输出功率</strong>：<code>- 10 dBm</code>；</li><li><strong>测量</strong>：<code>Reflection 或者 S11</code>；</li><li><strong>格式</strong>：<code>log magnitude</code>；</li></ul><p>将 NFC 天线放置到连接有网络分析仪的环形探头磁场内，由于环形探头与 NFC标签天线相互耦合，从而导致环形探头的阻抗发生变化。当 NFC标签处于谐振频率的时候，环形探头的阻抗电阻达到<strong>最大值</strong>，而电抗恢复到<strong>自谐振值</strong>。环形探头的阻抗接近于<code>50Ω</code>，可以通过 <strong>S11</strong>曲线上面的最小值进行证明。下图展示了某一个天线原型的谐振频率响应曲线：</p><p><img src="/Electronics/NFC_Antenna/18.png"></p><h3 id="采用信号源与示波器测试">采用信号源与示波器测试</h3><p>NFC天线的谐振频率也可以采用<strong>信号发生器</strong>和<strong>示波器</strong>，以及两个<strong>环形天线</strong>来进行测量。测试步骤是将一个<strong>ISO 10373-7</strong>标准的环形天线（如下图所示）与信号发生器连接，从而产生出射频电磁场：</p><p><img src="/Electronics/NFC_Antenna/19.png"></p><p>再通过示波器探头（<code>1MΩ</code> 或者 <code>10MΩ</code>输入阻抗）或者 <code>50Ω</code> 阻抗的 BNC 电缆（示波器输入阻抗也设置为<code>50Ω</code>），将另外一个 <strong>ISO 10373-7</strong>标准的环形天线连接到示波器。</p><p>此时，由于 NFC标签与<strong>第一个环形天线</strong>连接，通过信号发生器输出变化的信号使得NFC标签连接的天线产生电磁感应，这些电磁场会被连接在示波器的<strong>第二个环天线</strong>捕获。<strong>如果当前处于NFC标签的谐振频率时，那么<code>流入 NFC 标签天线的电流</code>、<code>NFC 标签天线产生的电磁波</code>、<code>示波器显示的电压幅值</code>均将会达到最大值</strong>。</p><p><img src="/Electronics/NFC_Antenna/20.png"></p><p>首先，让信号发生器输出峰峰值为 <code>200mV</code>的正弦波信号。然后，以 <code>5MHz</code>作为起点，逐步提高信号发生器的输出频率，直至达到示波器所测量到信号的最大幅值。最后，信号发生器所输出的频率就是NFC 标签的<strong>谐振频率</strong>。下图给了一款 NFC天线原型的<strong>频率响应曲线</strong>，也就是在不同的信号发生器频率下，示波器所测量到的信号幅值：</p><p><img src="/Electronics/NFC_Antenna/21.png"></p><h2 id="从设计到产品">从设计到产品</h2><p>开发设计人员必须了解电路板上 NFC天线的<strong>理论</strong>与<strong>实际</strong>性能差异，这里列出一些注意事项。对于不同的NFC 读卡器，同一个 NFC标签天线所获得的通信效果并不相同，正如下面的示意图所展示的那样：</p><p><img src="/Electronics/NFC_Antenna/22.png"></p><p>另外 PCB制造的工艺参数（例如铜层或者环氧层的厚度）也会对天线性能产生影响，这在更换板材供应商的时候需要格外注意。除此之外，同时使用多个动态NFC标签会导致天线相互耦合，从而出现谐振频率不同于单个天线的情况，例如下面的示意图所展示的情况：</p><p><img src="/Electronics/NFC_Antenna/23.png"></p><p>更加值得注意的是，产品的外壳也会影响 NFC标签天线的通信效果，例如使用金属外壳所产生的<strong>法拉第笼</strong>效应，就会阻止NFC 读卡器的能量与信号传递到 NFC 标签天线。同时外壳也会影响 PCB天线的调谐频率，因而总是建议在最终成品上进行 NFC 射频性能的测试。</p><p><img src="/Electronics/NFC_Antenna/24.png"></p><blockquote><p>▶总而言之，在实际量产过程当中，需要充分的考量到<strong>设计</strong>、<strong>原型</strong>、<strong>生产制造</strong>三个环节对于NFC 标签天线射频性能所带来的一系列影响。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;近场通信&lt;/strong&gt;（&lt;strong&gt;NFC&lt;/strong&gt;，Near Field
Communication）是一种基于&lt;strong&gt;无线射频识别&lt;/strong&gt;（&lt;strong&gt;RFID&lt;/strong&gt;，Radio
Frequency I
Dentification）技术发展起来的近距离无线通信技术，它们都是通过无线频率的电磁感应耦合传递数据，但是
RFID 的传输范围可以达到 &lt;code&gt;1m&lt;/code&gt;，而 NFC 的传输范围通常在
&lt;code&gt;10cm&lt;/code&gt; 以内。NFC 的无线信号频率为
&lt;code&gt;13.56MHz&lt;/code&gt;，可以兼容
&lt;strong&gt;ISO14443&lt;/strong&gt;、&lt;strong&gt;ISO15693&lt;/strong&gt;、&lt;strong&gt;Felica&lt;/strong&gt;
等非接触式智能卡规范，数据传输速率可以达到
&lt;code&gt;106kbit/s&lt;/code&gt;、&lt;code&gt;212 kbit/s&lt;/code&gt;、&lt;code&gt;424kbit/s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/NFC_Antenna/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;意法半导体的 NFC 动态标签芯片 &lt;strong&gt;ST25DV-I2C&lt;/strong&gt; 和
&lt;strong&gt;ST25DV-PWM&lt;/strong&gt; 可以通过低功率的 &lt;strong&gt;I²C&lt;/strong&gt;
总线以及 &lt;code&gt;13.56MHz&lt;/code&gt;
无线射频访问芯片内置的&lt;strong&gt;EEPROM&lt;/strong&gt;（电可擦除只读存储器），同时支持近程的
&lt;strong&gt;ISO/IEC 14443 Type A&lt;/strong&gt; 和远程的 &lt;strong&gt;ISO/IEC
15693&lt;/strong&gt; 标准。本文旨在介绍无源 &lt;strong&gt;RFID&lt;/strong&gt;
的基本原理，以及 &lt;code&gt;13.56MHz&lt;/code&gt;
感应天线设计的基础知识，文中部分内容参考自意法半导体编号为《&lt;strong&gt;AN2972&lt;/strong&gt;》的官方应用笔记（&lt;strong&gt;Application
Note&lt;/strong&gt;）。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="RFID" scheme="http://www.uinio.com/tags/RFID/"/>
    
  </entry>
  
  <entry>
    <title>FreeCAD 参数化 3D 建模上手实例</title>
    <link href="http://www.uinio.com/Design/FreeCAD/"/>
    <id>http://www.uinio.com/Design/FreeCAD/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2022-09-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.freecadweb.org/"><strong>FreeCAD</strong></a>是一款面向<strong>计算机辅助设计</strong>（<strong>CAD</strong>，ComputerAided Design）的 <strong>3D</strong> 参数化建模工具软件，该工具基于<strong>LGPL</strong> 开源协议，同时提供有适配 Linux、Mac OS、Windows操作系统的跨平台版本，其底层采用了 <strong>OpenCascade</strong>来提供二维与三维几何体的生成显示与分析。这里所谓的<strong>参数化建模</strong>就是指通过一系列的参数来控制3D模型的形状，例如一个立方体可以由<code>长度</code>、<code>宽度</code>、<code>高度</code>三个参数共同决定，这些参数可以随时进行修改。除此之外，<strong>FreeCAD</strong>还可以使用其它模型作为参数；例如将一个立方体作为输入参数，<strong>FreeCAD</strong>就能够基于它创建出一个柱状的 3D 模型。</p><p><img src="/Design/FreeCAD/logo.png"></p><p><strong>FreeCAD</strong>并非只是为了完成某一项特定的工作，或者仅用于生成某一类特定的模型。使用者可以利用它创作小到电子元件与<strong>3D</strong>打印部件，大到建筑物的不同尺寸模型。由于每一种任务的工作流程并不完全相同，所以<strong>FreeCAD</strong> 分别提供了相应的工作台。目前网络上关于<strong>FreeCAD</strong>的应用资料较少，所以尝试利用本文记录一些日常使用的技巧，全文基于 2022 年9 月份发布的 <strong>FreeCAD 0.20.1</strong>版本撰写，文中所涉及的实例已经共享至我的 <a href="https://github.com/uinika/FreeCAD-Tutorial-Example"><strong>FreeCAD-Tutorial-Example</strong></a>。</p><span id="more"></span><h2 id="基本设置">基本设置</h2><p>依次选择 FreeCAD 顶部菜单栏上面的【<strong>Edit -&gt;Preference...</strong>】，打开<strong>首选项窗口</strong>：</p><p><img src="/Design/FreeCAD/Section-1/1.png"></p><p>首先，依次在【<strong>General</strong>】界面进行<code>语言</code>、<code>界面风格</code>、<code>默认工作台</code>的设置：</p><p><img src="/Design/FreeCAD/Section-1/2.png"></p><p>然后，再切换至的【<strong>Display</strong>】界面，在【<strong>Navigation</strong>】选项卡下面将3D 导航模式设置为 <code>Blender</code>：</p><p><img src="/Design/FreeCAD/Section-1/3.png"></p><p>最后，继续切换到【<strong>Display</strong>】界面内的【<strong>Colors</strong>】选项卡，选择背景色为<code>简单颜色</code>，并在弹出的<strong>颜色选择对话框</strong>中将其设置为<code>#3C3C3C</code>：</p><p><img src="/Design/FreeCAD/Section-1/4.png"></p><p>保存上述设置之后，FreeCAD界面的语言格式会自动切换为中文，并且界面颜色调整为暗黑风格，此时将工作台切换至【<strong>Part Design</strong>】：</p><p><img src="/Design/FreeCAD/Section-1/5.png"></p><p>鼠标再次选中顶部菜单栏上面的【<strong>编辑 -&gt;首选项...</strong>】，选择弹出窗口中的【<strong>草绘</strong>】界面，勾选显示<code>1mm</code> 的网格：</p><p><img src="/Design/FreeCAD/Section-1/6.png"></p><p>接下来，再打开弹出窗口上的【<strong>Part / PartDesign</strong>】界面，点选下图当中的所有 3 个选项：</p><p><img src="/Design/FreeCAD/Section-1/7.png"></p><h2 id="快速入门">快速入门</h2><p>FreeCAD的<strong>工作台</strong>提供了一系列针对不同模型用途的工具集，通过选择不同的工具集，可以制作不同种类的模型：</p><ul><li><strong>Part</strong>工作台：用于处理实体零件的基础几何体，例如<code>立方体</code>和<code>球体</code>等；</li><li><strong>Draft</strong> 工作台：用于 2D绘图的基本工具，例如<code>直线</code>、<code>圆</code>、<code>弧</code>；</li><li><strong>Sketcher</strong> 工作台：包含用于构建和编辑复杂 2D图形的工具，这些图形可以通过<strong>约束</strong>来进行精确的定位；</li><li><strong>Part Design</strong>工作台：包含构建实体零件的高级工具集，其中包含了<strong>Sketcher</strong> 工作台当中的所有工具；</li><li><strong>Arch</strong> 工作台：用于处理土木工程与建筑模型，其中包含有<strong>Draft</strong> 工作台当中的所有工具；</li><li><strong>Drawing</strong> 工作台：创建与操作 2D 工程图纸，可以在 2D平面上面展示 3D 的模型；</li></ul><p>FreeCAD 的 3D 空间拥有 <code>X</code>、<code>Y</code>、<code>Z</code>三个轴以及一个<strong>原点</strong>，其中 <code>X</code>轴指向右侧，<code>Y</code> 轴指向后面，<code>Z</code>轴指向上方，这三条轴线相交的位置就是<strong>原点</strong>，也就是<code>X</code>、<code>Y</code>、<code>Z</code> 坐标值均为零的点。</p><p><img src="/Design/FreeCAD/Section-2/1.png"></p><p>首先，依次点击工具栏上的【<strong>新建 -&gt; 创建实体 -&gt;创建草图</strong>】，鼠标选择 <code>XY_Plane (基准平面)</code>：</p><p><img src="/Design/FreeCAD/Section-2/2.png"></p><p>然后，FreeCAD 就会自动进入到 <strong>Sketcher</strong>工作台，此时就可以开始着手在屏幕中间的区域进行<strong>草图</strong>的绘制工作：</p><p><img src="/Design/FreeCAD/Section-2/3.png"></p><p>接下来，使用右侧工具栏上的【<strong>创建圆</strong>】工具绘制出一个圆形，并且使用约束工具，将其直径约束为<code>50mm</code>，同时将其<strong>圆心</strong>与坐标<strong>原点</strong>进行【<strong>重合约束</strong>】对齐：</p><p><img src="/Design/FreeCAD/Section-2/4.png"></p><p>最后，点击左侧的【<strong>Close</strong>】退出<strong>Sketcher</strong> 工作台，重新返回到【<strong>PartDesign</strong>】工作台的【<strong>模型</strong>】视图，并且鼠标点击右侧工具栏上的【<strong>凸台</strong>】工具：</p><p><img src="/Design/FreeCAD/Section-2/5.png"></p><p>此时，FreeCAD 自动切换至【<strong>PartDesign</strong>】工作台的【<strong>任务</strong>】视图，在这里同样将<strong>凸台</strong>的高度设置为<code>50mm</code>，然后点击左侧的【<strong>OK</strong>】按钮：</p><p><img src="/Design/FreeCAD/Section-2/6.png"></p><p>此时，FreeCAD 再次切换回【<strong>PartDesign</strong>】工作台的【<strong>模型</strong>】视图：</p><p><img src="/Design/FreeCAD/Section-2/7.png"></p><p>在【<strong>PartDesign</strong>】工作台的【<strong>模型</strong>】视图当中，根据当前采用的鼠标3D 导航设置（前面已经设置为 <code>Blender</code> 模式），就可以对 3D模型进行全方位的观察：</p><p><img src="/Design/FreeCAD/Section-2/8.png"></p><p>完成上述操作之后，将文件保存到 <a href="https://github.com/uinika/FreeCAD-Tutorial-Example"><strong>FreeCAD-Tutorial-Example</strong></a>的 <code>Example-1-Cylinder</code> 目录下名为 <code>Cylinder</code>的文档。除此之外，还可以通过如下的键盘快捷键组合，更加便捷的对 3D模型进行查看：</p><ul><li>【<strong>SHIFT + 方向左/右键</strong>】可以让模型翻转 90 度；</li><li>按住【<strong>CTRL</strong>】键之后，就可以通过鼠标选择多个目标；</li><li>【<strong>V + O</strong>】进入正交投影模式、【<strong>V +P</strong>】进入透视模式；</li><li>【<strong>CTRL + 减号</strong>】缩小模型，【<strong>CTRL + SHIFT +加号</strong>】放大模型；</li><li>按下数字键【<strong>1</strong>】查看前面、【<strong>2</strong>】查看顶部、【<strong>3</strong>】查看右侧、【<strong>4</strong>】查看背部、【<strong>5</strong>】查看底部、【<strong>6</strong>】查看左侧；</li></ul><h2 id="实例一桌子">实例一：桌子</h2><p>首先，在 <a href="https://github.com/uinika/FreeCAD-Tutorial-Example"><strong>FreeCAD-Tutorial-Example</strong></a>的 <code>Example-2-Table</code> 目录下新建一个 <code>Table</code>空白文档。根据前面介绍的方法，使用 <strong>FreeCAD</strong>右侧工具栏上的【<strong>创建矩形</strong>】，绘制出一个长度约束为<code>100mm</code> 宽度约束为 <code>50mm</code> 的矩形：</p><p><img src="/Design/FreeCAD/Section-3/1.png"></p><blockquote><p>➤ <strong>FreeCAD</strong>当中设置宽度的快捷键为【<strong>L</strong>】，设置高度的快捷键为【<strong>I</strong>】。</p></blockquote><h3 id="矩形的居中对齐">矩形的居中对齐</h3><p>然后，分别选中下图【<strong>1</strong>】、【<strong>2</strong>】、【<strong>3</strong>】位置的点（选中后呈现绿色），并且点击右侧工具栏上的【<strong>对称约束</strong>】工具。最后，就可以得到一个与原点居中对齐的矩形，此时由于整个矩形处于<strong>完全约束</strong>状态，所以线条呈现出绿色。</p><p><img src="/Design/FreeCAD/Section-3/2.png"></p><blockquote><p>➤ <strong>Sketcher</strong>工作台当中绘制的任何图形，都必须使其处于完全约束的状态。</p></blockquote><h3 id="选择一个面作为草图">选择一个面作为草图</h3><p>接下来，使用 FreeCAD右侧工具栏上的【<strong>凸台</strong>】工具，将桌面拉伸成为一个厚度为<code>3mm</code> 的立方体，选中底部（此时导航立方体上面显示为<code>BUTTON</code>），点击左侧工具栏上的【<strong>创建草图</strong>】按钮：</p><p><img src="/Design/FreeCAD/Section-3/3.png"></p><h3 id="建立外部参考线">建立外部参考线</h3><p>首先，绘制出 <code>5mm * 5mm</code>的矩形作为桌脚的基础轮廓，然后再点击 FreeCAD右侧工具栏上的【<strong>外部参考几何体</strong>】，并且选择矩形的<strong>右侧边框</strong>作为<strong>外部参考线</strong>，最后分别选中<code>5mm * 5mm</code> 矩形与 <code>100mm * 50mm</code>矩形的右上角顶点，同时分别点击右侧工具栏上的<strong>水平</strong>与<strong>垂直</strong>距离约束，将约束距离设置为<code>3mm</code>。</p><p><img src="/Design/FreeCAD/Section-3/4.png"></p><p>最后，再借助【<strong>凸台</strong>】工具，将这个<code>5mm * 5mm</code> 的矩形拉伸成为高度为 <code>50mm</code>的桌腿。</p><h3 id="创建镜像">创建镜像</h3><p>在 <strong>FreeCAD</strong> 右侧工具栏上，选择刚才创建的桌腿凸台<code>Pad001</code>，然后点击右侧工具栏上的【<strong>镜像</strong>】按钮。</p><p><img src="/Design/FreeCAD/Section-3/5.png"></p><p>在镜像参数当中选择【<strong>垂直草绘轴</strong>】，就可以垂直于草绘时所选择的<strong>轴</strong>，自动生成出一条桌腿。</p><p><img src="/Design/FreeCAD/Section-3/6.png"></p><p>重复刚才的步骤，不过这次选择【<strong>水平草绘轴</strong>】，从而就可以自动生成出另外一条桌腿。</p><p><img src="/Design/FreeCAD/Section-3/7.png"></p><h3 id="使用环形特征">使用环形特征</h3><p>仍然选中之前创建的桌腿凸台<code>Pad001</code>，这次点击右侧工具栏上的【<strong>环形阵列</strong>】按钮。</p><p><img src="/Design/FreeCAD/Section-3/8.png"></p><p>这样就可以创建出最后一条桌腿，到这里一张完整的桌子就绘制完成了。</p><p><img src="/Design/FreeCAD/Section-3/9.png"></p><blockquote><p>➤ 使用<strong>环形阵列</strong>功能时，需要注意左侧 <code>角度</code>和 <code>出现次数</code> 两个参数的设置。</p></blockquote><h2 id="实例二iso-prac2-零件">实例二：ISO-PRAC2 零件</h2><h3 id="选择-xz_plane-基准平面">选择 XZ_Plane 基准平面</h3><p>首先，在 <a href="https://github.com/uinika/FreeCAD-Tutorial-Example"><strong>FreeCAD-Tutorial-Example</strong></a>的 <code>Example-3-ISO-PRAC2</code> 目录下新建一个<code>ISO-PRAC2</code>空白文档。然后，再分别创建一个<strong>实体</strong>和<strong>草图</strong>，选择右侧工具栏上的【<strong>前视图</strong>】按钮，切换至<code>XZ_Plane</code>平面。最后，鼠标点击【<strong>OK</strong>】按钮进入<strong>Sketcher</strong> 工作台。</p><p><img src="/Design/FreeCAD/Section-4/1.png"></p><h3 id="创建折线">创建折线</h3><p>点击 FreeCAD右侧工具栏上的【<strong>创建折线</strong>】工具，绘制出如下的草图，绘制过程当中可以通过按下【<strong>M</strong>】键循环切换工具的行为，从而得到下图当中的圆弧效果。</p><p><img src="/Design/FreeCAD/Section-4/2.png"></p><p>绘制完上图的圆弧效果之后，需要选中并且删除位于圆弧左侧的【<strong>相切约束</strong>】：</p><p><img src="/Design/FreeCAD/Section-4/3.png"></p><h3 id="使用重合约束闭合两点">使用重合约束闭合两点</h3><p>使用右侧工具栏上的【<strong>重合约束</strong>】，让下图当中选中的两个点（绿色）自动进行闭合。</p><p><img src="/Design/FreeCAD/Section-4/4.png"></p><p>使用鼠标进行拖动调整，然后删除弧形右下角的<strong>垂直约束</strong>，最终就可以得到下面的图形。</p><p><img src="/Design/FreeCAD/Section-4/5.png"></p><h3 id="添加更多约束">添加更多约束</h3><p>接下来，再分别为上述图形当中的线条添加<strong>水平约束</strong>、<strong>垂直约束</strong>、<strong>宽度约束</strong>、<strong>长度约束</strong>、<strong>相等约束</strong>、<strong>半径约束</strong>。</p><p><img src="/Design/FreeCAD/Section-4/6.png"></p><p>完成全部约束之后，分别选中弧形的<strong>圆心</strong>和草图的<strong>原点</strong>，然后点击右侧工具栏当中的【<strong>重合约束</strong>】按钮，使得草图与原点完成对齐。</p><p><img src="/Design/FreeCAD/Section-4/7.png"></p><p>实现<strong>完全约束</strong>之后的草图如下面所示，可以看到，所有的线条都呈现出了绿色的效果：</p><p><img src="/Design/FreeCAD/Section-4/8.png"></p><h3 id="使用凸台拉伸">使用凸台拉伸</h3><p>在 <strong>Sketcher</strong>工作台完成草图的绘制工作之后，就可以切换至 <strong>Part Design</strong>工作台，利用工具栏上的【<strong>凸台</strong>】功能将前面绘制的图形拉伸为<code>40mm</code> 高度的三维形状，从而就完成了 ISO-PRAC2零件的全部绘制工作。</p><p><img src="/Design/FreeCAD/Section-4/9.png"></p><h2 id="实例三三脚椅">实例三：三脚椅</h2><h3 id="选择-xy_plane-基准平面">选择 XY_Plane 基准平面</h3><p>在 <a href="https://github.com/uinika/FreeCAD-Tutorial-Example"><strong>FreeCAD-Tutorial-Example</strong></a>的 <code>Example-4-ISO-Chair</code> 目录下新建一个 <code>Chair</code>空白文档，选择<code>XY_Plane (基准平面)</code>，使用【<strong>创建圆</strong>】工具，并将其半径约束为 <code>100mm</code>。</p><p><img src="/Design/FreeCAD/Section-5/1.png"></p><h3 id="让圆心与原点居中对齐">让圆心与原点居中对齐</h3><p>按照上面的操作步骤，分别用鼠标选中<strong>圆心</strong>和<strong>原点</strong>，再点击右侧工具栏上的【<strong>重合约束</strong>】，就可以完成圆心与原点的居中对齐。</p><p><img src="/Design/FreeCAD/Section-5/2.png"></p><h3 id="添加圆形参考线">添加圆形参考线</h3><p>接下来，鼠标选中上面绘制好的圆形，然后点击工具栏右侧的【<strong>切换辅助线</strong>】按钮，就可以将其切换为<strong>辅助线</strong>。</p><p><img src="/Design/FreeCAD/Section-5/3.png"></p><p><strong>参考线</strong>用于在 <strong>Sketcher</strong>工作台里辅助绘制工作，通常呈现为<strong>蓝色</strong>，而在 <strong>PartDesign</strong> 工作台当中并不会被显示。</p><p><img src="/Design/FreeCAD/Section-5/4.png"></p><h3 id="绘制三角形">绘制三角形</h3><p>选择右侧工具栏的【<strong>三角形</strong>】绘制工具，画出一个三角形，然后分别添加【<strong>水平约束</strong>】和【<strong>重合约束</strong>】，最终得到如下的图形。</p><p><img src="/Design/FreeCAD/Section-5/5.png"></p><h3 id="清除三角形顶点连接关系">清除三角形顶点连接关系</h3><p>首先，清除最外侧<strong>较大</strong>的那个蓝色圆形。然后，鼠标选择三角形任意两条边的连接点，按下键盘上面的【<strong>Delete</strong>】键，此时FreeCAD 会自动断开两条边之间的连接关系。</p><p><img src="/Design/FreeCAD/Section-5/6.png"></p><h3 id="新增两条参考线">新增两条参考线</h3><p>首先，使用 <strong>FreeCAD</strong>右侧的【<strong>创建线</strong>】工具绘制出两条线段。然后，使用【<strong>重合约束</strong>】将它们连接到草图原点，再使用【<strong>夹角约束</strong>】将两条线段与垂直坐标轴的夹角设置为<code>60°</code>度，同时将两条线段设置为【<strong>相等约束</strong>】。</p><p><img src="/Design/FreeCAD/Section-5/7.png"></p><h3 id="设置斜线长度">设置斜线长度</h3><p>首先，选中一条之前绘制好的线段。然后，鼠标点击工具栏右侧的【<strong>距离约束</strong>】按钮。最后，将其长度设置为<code>250mm</code>。</p><p><img src="/Design/FreeCAD/Section-5/8.png"></p><h3 id="绘制圆弧">绘制圆弧</h3><p>利用右侧工具栏上的【<strong>圆弧</strong>】创建工具，分别绘制出 3个圆弧。然后分别添加【<strong>相等约束</strong>】，并且使用【<strong>半径约束</strong>】将其半径设置为<code>120mm</code>。</p><p><img src="/Design/FreeCAD/Section-5/9.png"></p><blockquote><p>➤ 为了更加方便的进行展示，在接下来的示例当中，将 FreeCAD的网格尺寸调整为 <code>10mm</code>。</p></blockquote><h3 id="把圆心约束至对象">把圆心约束至对象</h3><p>首先，分别选中蓝色的圆形参考线，以及每一个弧形的圆心。然后，点击【<strong>将点约束至对象</strong>】按钮，从而将圆心约束到圆形的参考线上面。</p><p><img src="/Design/FreeCAD/Section-5/10.png"></p><p>接下来，选择已经被固定至蓝色圆形参考线上面的弧形圆心，以及蓝色参考线段与Y轴，继续使用【<strong>将点约束至对象</strong>】功能，最后就可以得到如下的图形：</p><p><img src="/Design/FreeCAD/Section-5/11.png"></p><h3 id="使用切线约束进行连接">使用切线约束进行连接</h3><p>使用工具栏右侧的【<strong>相切约束</strong>】，闭合草图最外侧的零散线段。</p><p><img src="/Design/FreeCAD/Section-5/12.png"></p><p>如下就是草图最外侧零散线段实现<strong>完全约束</strong>之后的效果。</p><p><img src="/Design/FreeCAD/Section-5/13.png"></p><blockquote><p>➤ 注意不要忘记将之前绘制的两条线段切换为参考线模式。</p></blockquote><h3 id="尝试使用快捷键">尝试使用快捷键</h3><ol type="1"><li>将前面的图形，通过【<strong>凸台</strong>】工具拉伸为一个厚度为<code>3mm</code> 的三维形状；</li><li>选择其中的一个面绘制如下形状，并且利用【<strong>重合约束C</strong>】、【<strong>半径约束 SHIFT +R</strong>】、【<strong>水平约束 SHIFT +H</strong>】、【<strong>垂直约束 SHIFT +V</strong>】对其进行完全约束；</li></ol><p><img src="/Design/FreeCAD/Section-5/14.png"></p><h3 id="绘制-1-个凹坑">绘制 1 个凹坑</h3><ol type="1"><li>首先，绘制 4条圆弧，并且使用【<strong>相切约束</strong>】将它们连接，然后将它们的圆心固定在参考线上面；</li><li>然后，利用【<strong>相等约束</strong>】、【<strong>半径约束</strong>】、【<strong>固定点至对象约束</strong>】将其完全约束，从而完成草图绘制；</li></ol><p><img src="/Design/FreeCAD/Section-5/15.png"></p><h3 id="生成另外-2-个凹坑">生成另外 2 个凹坑</h3><ol type="1"><li>通过 <strong>FreeCAD</strong>提供的【<strong>凹坑</strong>】功能，并且将凹坑类型设置为<code>通过所有</code>；</li><li>首先在左侧模型当中，选中刚才的凹坑<code>Pocket</code>，然后在右侧工具栏，选中【<strong>环形阵列</strong>】，把<code>产生次数</code> 参数设置为 <strong>3</strong>次，从而自动产生出另外 2 个凹坑；</li></ol><p><img src="/Design/FreeCAD/Section-5/16.png"></p><h3 id="倒斜角与圆角">倒斜角与圆角</h3><p>首先，按住【<strong>CTRL</strong>】键多选相应的边。然后，分别将内侧的弧形设置为<code>10mm</code> 的<strong>斜角</strong>，外侧的弧形设置为<code>10mm</code> 的<strong>圆角</strong>，最终得到的效果如下所示。</p><p><img src="/Design/FreeCAD/Section-5/17.png"></p><h3 id="绘制椅脚草图">绘制椅脚草图</h3><ol type="1"><li>选择模型的底部 <code>Bottom</code> 新建草图；</li><li>绘制一个半径为 <code>30mm</code>的<strong>圆形</strong>，并使用【<strong>固定点至对象约束</strong>】将其圆心与Y 轴重合；</li><li>通过【<strong>垂直距离约束</strong>】将<strong>圆心</strong>到<strong>原点</strong>的距离设置为<code>160mm</code>，从而完成草图绘制；</li></ol><p><img src="/Design/FreeCAD/Section-5/18.png"></p><h3 id="生成椅脚">生成椅脚</h3><ol type="1"><li>首先，使用 FreeCAD 的【<strong>凸台</strong>】功能，自动生成长度为<code>180mm</code> 的椅脚；</li><li>然后，在左侧的<strong>组合浏览器</strong>当中，选中上一步产生的椅脚，通过左侧工具栏上的【<strong>环形阵列</strong>】，将<code>出现次数</code>参数设置为<code>3</code>，从而自动创建出另外的 2 条椅脚；</li></ol><p><img src="/Design/FreeCAD/Section-5/19.png"></p><h3 id="操作步骤的显示与隐藏">操作步骤的显示与隐藏</h3><p>使用【<strong>空格键</strong>】，可以切换 FreeCAD组合浏览器当中的每一个操作步骤的显示与隐藏。</p><p><img src="/Design/FreeCAD/Section-5/20.gif"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.freecadweb.org/&quot;&gt;&lt;strong&gt;FreeCAD&lt;/strong&gt;&lt;/a&gt;
是一款面向&lt;strong&gt;计算机辅助设计&lt;/strong&gt;（&lt;strong&gt;CAD&lt;/strong&gt;，Computer
Aided Design）的 &lt;strong&gt;3D&lt;/strong&gt; 参数化建模工具软件，该工具基于
&lt;strong&gt;LGPL&lt;/strong&gt; 开源协议，同时提供有适配 Linux、Mac OS、Windows
操作系统的跨平台版本，其底层采用了 &lt;strong&gt;OpenCascade&lt;/strong&gt;
来提供二维与三维几何体的生成显示与分析。这里所谓的&lt;strong&gt;参数化建模&lt;/strong&gt;就是指通过一系列的参数来控制
3D
模型的形状，例如一个立方体可以由&lt;code&gt;长度&lt;/code&gt;、&lt;code&gt;宽度&lt;/code&gt;、&lt;code&gt;高度&lt;/code&gt;三个参数共同决定，这些参数可以随时进行修改。除此之外，&lt;strong&gt;FreeCAD&lt;/strong&gt;
还可以使用其它模型作为参数；例如将一个立方体作为输入参数，&lt;strong&gt;FreeCAD&lt;/strong&gt;
就能够基于它创建出一个柱状的 3D 模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Design/FreeCAD/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FreeCAD&lt;/strong&gt;
并非只是为了完成某一项特定的工作，或者仅用于生成某一类特定的模型。使用者可以利用它创作小到电子元件与
&lt;strong&gt;3D&lt;/strong&gt;
打印部件，大到建筑物的不同尺寸模型。由于每一种任务的工作流程并不完全相同，所以
&lt;strong&gt;FreeCAD&lt;/strong&gt; 分别提供了相应的工作台。目前网络上关于
&lt;strong&gt;FreeCAD&lt;/strong&gt;
的应用资料较少，所以尝试利用本文记录一些日常使用的技巧，全文基于 2022 年
9 月份发布的 &lt;strong&gt;FreeCAD 0.20.1&lt;/strong&gt;
版本撰写，文中所涉及的实例已经共享至我的 &lt;a href=&quot;https://github.com/uinika/FreeCAD-Tutorial-Example&quot;&gt;&lt;strong&gt;FreeCAD-Tutorial-Example&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Design" scheme="http://www.uinio.com/categories/Design/"/>
    
    
    <category term="CAD" scheme="http://www.uinio.com/tags/CAD/"/>
    
  </entry>
  
  <entry>
    <title>2022 互联网裁员潮之后，国内 IT 行业何去何从？</title>
    <link href="http://www.uinio.com/Thinking/2022-Downsizing/"/>
    <id>http://www.uinio.com/Thinking/2022-Downsizing/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2022-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者作为常年工作在一线的 IT 技术研发人员，早在 2018年就已经不玩儿互联网行业了。主要是感觉 Web技术栈已然走向全家桶化（例如后端 <code>Spring</code> 全家桶、前端<code>Vue</code>全家桶），而开发方式也日趋套路化与工程化，上手难度与技术门槛以肉眼可见的速度不断下探，进而伴随着大量从业人员的持续涌入，整个行业全面开启了<strong>996 内卷模式</strong>。</p><p><img src="/Thinking/2022-Downsizing/logo.png"></p><p>除此之外，叠加近几日<strong>中概股</strong>跌穿了板凳，以及<strong>反垄断监管</strong>的不断强化，互联网行业合规经营的大幕徐徐拉开。未来全行业的整体薪酬水平，必然回归至类似财务会计这类市场化职位应有的水平。高薪光环终究是到了褪去的时刻，重新回到利润与收支挂钩的市场化薪酬体系，将会是整个行业未来的大势所趋。</p><span id="more"></span><p>笔者在 IT 行业的从业时间比较长，经历过 <code>2014~2018</code>年国内互联网的黄金发展时期，目睹过众多互联网企业，在各路资本的助推之下大干快上，薪资水平与岗位数量两旺。然而时过境迁，又不得不感慨市场规律的强大力量：<strong>任何市场化行业，其薪酬与职位数量，都只会与该行业产生的实际利润相关。</strong>过去资本追捧互联网题材，一方面由于国内缺乏健全的反垄断机制，另一方面在于涌入资本对于美股上市有着极为强烈的偏好。在两者共同的化学反应之下，造成了国内互联行业短期的急剧膨胀，大量互联网企业出于垄断流量，或者资本市场套利的目的，在各类<strong>不赚钱甚至也不具备赚钱潜力</strong>的题材背书之下，如同雨后春笋一般冒出头来。</p><p>然而最近一年多以来，各家互联网大厂陆续发起批量的裁员动作，同时不断缩减校园招聘的<code>head count</code>，已然意味着互联网行业的泡沫开始走向消退。从国家宏观产业与经济发展的角度而言，互联网行业泡沫的出清，有益于<strong>中国科技行业</strong>整体的长远健康发展。其主要原因在于国内互联网企业在做大做强之后，对于各路流量完成了事实上的垄断，然而后续并没有将资金投入至更深层次的<strong>技术创新</strong>，反而在各式花样繁多的<strong>金融创新</strong>道路上渐行渐远。例如国内头部的互联网企业，几乎每一家都有推出自己的<strong>金融消费贷款业务</strong>，大量的资金和人力资源都投放在了<strong>垄断流量</strong>（例如社区团购）、<strong>金融信贷</strong>（例如<code>×呗</code>、<code>×宝</code>、<code>×金</code>、<code>×条</code>等高息信贷产品）方面。</p><p>反观海外的 <strong>谷歌 Google</strong>、<strong>脸书 Meta</strong>等互联网巨头，就并未在本企业的移动 App与网站产品当中，夹带与金融消费贷相关的业务与服务，而是在<strong>盈利</strong>并且获取<strong>行业优势地位</strong>之后，广泛的为开源技术社区进行贡献，新的语言（<code>Go</code>、<code>Dart</code>、<code>Hack</code>、<code>React</code>）、新的操作系统（<code>Fuchsia</code>、<code>Chrome OS</code>、<code>Android</code>）、新的算法框架（<code>RankBrain</code>、<code>Deepmind</code>、<code>Prophet</code>）、新的硬件（<code>Tensor</code>、<code>Portal</code>、<code>Oculus</code>、<code>BCI</code>）层出不穷。而对比同期的国内互联网企业，在技术创新与开源社区贡献方面，其建树近乎乏善可陈。</p><blockquote><p>以搜索引擎巨头谷歌 Google 为例，其现有的金融业务当中，Google Pay基于其自有的 Android手机操作系统，仅提供移动支付的基础设施。而与其核心搜索及广告相关的业务当中，贷款业务在其业务闭环之内，借款人限于客户，用途也仅限于对谷歌的广告支出；整体上，谷歌并未推出其它金融服务，从而利用其巨大的流量与强大的数据收集分析能力获利。然而这个中的原因，并非是由于海外的互联网巨头们，自带白莲花属性，能够做到出淤泥而不染。而是在于其所归属的市场主体，拥有着健全的反垄断监管法律体系。企业难以通过流量与数据，随意扩张经营版图。想要获得更多的利润，必须依靠技术层面的创新带动，而非依赖其自身的垄断支配地位。</p></blockquote><p>近年以来，面对美帝在基础科技方面，三番五次的卡脖子行为。国内 IT技术行业<strong>头重脚轻</strong>、<strong>有软无硬</strong>、<strong>缺芯少魂</strong>的短板暴露无遗。而彼时的各大互联网巨头们，却正在为孰能垄断社区团购流量，而激战正酣。所以人民日报专门于2020 年的双十二期间刊文：<a href>《别只惦记着几捆白菜的流量，科技创新的星辰大海更令人心潮澎湃》</a>。时间转瞬即逝，来到了两年之后的今天，针对互联网行业的反垄断监管祭出重拳，其意图就是倒逼国内科技企业与互联网巨头们，将精力放回至技术创新的主赛道上面，合法合规经营，停止无序竞争与流量垄断。</p><p>切换一个视角，美帝今日之所以能够制霸于全球，有媒体认为原因在于其发达的<strong>资本市场</strong>与<strong>金融行业</strong>，也有媒体认为在于其得天独厚的<strong>地理位置</strong>与高效的<strong>集约化农业</strong>，而更多媒体则认为是在于其<strong>强大的军事实力</strong>。而在笔者看来，无论是<code>军事</code>、<code>农业</code>、<code>金融</code>，这些行业与产业背后的<strong>科技属性</strong>才是美帝百年以来真正的立国之本。除了脸书、谷歌这样的互联网巨擎，以及微软、苹果这类耳熟能详的科技大触之外。美帝还拥有着工业软件领域的<strong>Autodesk</strong>、<strong>Ansys</strong>、<strong>Altair</strong>，嵌入式操作系统领域的<strong>Vxworks</strong>、<strong>FreeRTOS</strong>、<strong>QNX</strong>，电子自动化设计领域的<strong>Cadence</strong>、<strong>Synopsys</strong>两巨头，数学分析与仿真领域的<strong>Matlab</strong>、<strong>Mathmatical</strong>，这些厂商在全球基础软件细分市场的份额约在<code>70% ~ 90%</code> 之间。</p><p>而在底层硬件电子技术方面，从电子测量仪器行业的<strong>Keysight</strong>、<strong>Tek</strong>、<strong>Lecroy</strong>、<strong>Fluke</strong>，到拥有琳琅满目模拟/数字芯片产品线的<strong>National Semiconductor</strong>、<strong>TexasInstruments</strong>、<strong>Maxim Integrated</strong>、<strong>AnalogDevices</strong>，以及专注于 FPGA 可编程逻辑器件的<strong>Xilinx</strong>、<strong>Altera</strong>、<strong>Lattice</strong>、<strong>Microsemi</strong>，这些体量与产品线都属于灭霸级存在的IC 厂商，几乎垄断了全球七成以上的市场份额。整体而言，美帝的 IT行业，呈现出 <strong>芯片电子技术 + 基础软件 + 互联网应用</strong>至上而下、齐头并进的<strong>全能型产业格局</strong>。</p><p>我国在<strong>芯片电子技术方向</strong>的落后程度，相信大家已然从近两年的科技制裁与缺芯潮里有所领悟，无需笔者再耗费过多的笔墨。而<strong>软件程序技术方向</strong>，虽然坐拥宠大的人口基数与工程师红利，但是在工业与民用领域的基础性软件产品当中，要么面临着功能与算法方面的重大缺陷，要么直接就处于一片空白的蛮荒状态。整体而言，由于市场化应用程度不高，导致相关企业的盈利能力普遍较弱，从业人员的薪酬待遇水平，远远不及处于资本推波助澜之下的互联网。而在国内互联网行业高歌猛进的这几年当中，由于无数资本的蜂拥进场，快速抬高了互联网从业人员的整体薪酬水平，致使大量原本就读于<strong>电子信息工程</strong>、<strong>自动化</strong>、<strong>应用数学</strong>、<strong>机械</strong>、<strong>物理</strong>、<strong>化学</strong>等理工科专业的优秀毕业生，悉数放弃本专业，而转投互联网Web技术方向。各个基础行业面临着严重的人才流失，而知乎上关于其它专业或者行业，转投互联网的讨论也一直延续至今。学生娃娃们都想着趁年轻，冲入互联网行业挣上一笔快钱。而在国家真正急需的<code>光刻设备</code>、<code>离子注入设备</code>、<code>高纯度蚀刻用硫酸</code>、<code>EDA 自动布线算法</code>、<code>工业设计与仿真软件</code>、<code>高精度多轴数控机床</code>等方向，却由于产业化能力不足，从业人员薪酬水平明显低于互联网，因而一直乏人问津。</p><p>一个国家与民族的强大，必然离不开<strong>科技</strong>的鼎力支持，互联网企业的<strong>合规经营</strong>与去<strong>金融化</strong>，虽然会带来<strong>短期的裁员阵痛</strong>，但是同样可以倒逼互联网公司们，将企业资源集中到科技创新的方向开疆扩土，让人才重新回流至本专业所属的技术领域，特别是在国家当前所紧缺的<strong>底层硬核科技</strong>方面。藉以此文，笔者愿与众IT 行业研发同仁共勉之，<strong>合光同尘，知行合一</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者作为常年工作在一线的 IT 技术研发人员，早在 2018
年就已经不玩儿互联网行业了。主要是感觉 Web
技术栈已然走向全家桶化（例如后端 &lt;code&gt;Spring&lt;/code&gt; 全家桶、前端
&lt;code&gt;Vue&lt;/code&gt;
全家桶），而开发方式也日趋套路化与工程化，上手难度与技术门槛以肉眼可见的速度不断下探，进而伴随着大量从业人员的持续涌入，整个行业全面开启了
&lt;strong&gt;996 内卷模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Thinking/2022-Downsizing/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;除此之外，叠加近几日&lt;strong&gt;中概股&lt;/strong&gt;跌穿了板凳，以及&lt;strong&gt;反垄断监管&lt;/strong&gt;的不断强化，互联网行业合规经营的大幕徐徐拉开。未来全行业的整体薪酬水平，必然回归至类似财务会计这类市场化职位应有的水平。高薪光环终究是到了褪去的时刻，重新回到利润与收支挂钩的市场化薪酬体系，将会是整个行业未来的大势所趋。&lt;/p&gt;</summary>
    
    
    
    <category term="Thinking" scheme="http://www.uinio.com/categories/Thinking/"/>
    
    
    <category term="Economy" scheme="http://www.uinio.com/tags/Economy/"/>
    
  </entry>
  
  <entry>
    <title>《PCB 电流与信号完整性设计》读书笔记</title>
    <link href="http://www.uinio.com/Electronics/PCB_Currents/"/>
    <id>http://www.uinio.com/Electronics/PCB_Currents/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2021-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《PCB 电流与信号完整性设计》</strong>英文名称是<strong>《PCBCurrents How They Flow, How They React》</strong>，作者是 <a href="https://www.ultracad.com/">UltraCAD</a> 公司的创办者 DouglasBrooks，全书着重于物理概念，避免复杂的数学推导，阐述了基本电路的电流源、电流造成的信号完整性问题，以及如何解决串扰和电磁干扰问题。主要内容包括：<code>温度漂移</code>、<code>传输线</code>、<code>反射</code>、<code>耦合电流</code>、<code>功率分配</code>、<code>趋肤效应</code>、<code>介电损耗</code>和<code>通孔</code>等，并且给出了每个常见问题的实用设计方案。</p><p><img src="/Electronics/PCB_Currents/logo.png"></p><p>全书分为四个部分，其中第一部分<strong>电流的性质</strong>介绍了电流的基本定义，第二部分<strong>基本电路中电流的流动</strong>包括了电阻电路、电抗（电容、电感）电路、以及阻抗相关的内容，第三部分则介绍了<strong>电压源与电流源</strong>，第四部分<strong>电路板上的电流</strong>则介绍了PCB 上引入的各种信号完整性问题。</p><span id="more"></span><h2 id="电子与电荷">电子与电荷</h2><h3 id="原子结构">原子结构</h3><p><strong>电流</strong>是由电子的流动而产生，<code>1A</code> 电流指的是<code>1S</code> 时间内通过某个位置 <code>1C</code> 的电荷（即 <span class="math inline">\(6.25 \times 10^{18}\)</span>个电子）。物质的<strong>原子</strong>当中包含有 3种基本粒子：<strong>质子</strong>（带 1个单位正电荷）、<strong>中子</strong>（不带电荷）、<strong>电子</strong>（带1个单位负电荷），其中质子和中子耦合在原子核，而电子则围绕着原子核做圆周运动。自然界当中的稳定元素都呈现电中性，因而任何元素原子当中的质子与电子数量必然相等。</p><p><img src="/Electronics/PCB_Currents/Part-1/1.png"></p><h3 id="价带-导带">价带 &amp; 导带</h3><p><strong>价带</strong>（ValenceBand）是<code>价电子</code>所占据的能量范围，而<strong>导带</strong>（ConductionBand）则是<code>自由运动的电子</code>所具有的能量范围；价带当中只拥有一个电子的元素，更容易脱离价带进入导带形成自由电子，从而表现为<strong>导体</strong>；而价带当中拥有多个电子的元素，由于电子则难以脱离价带，从而表现为<strong>绝缘体</strong>；</p><p><img src="/Electronics/PCB_Currents/Part-1/2.png"></p><blockquote><p><strong>注意</strong>：<strong>电子</strong>带有<strong>负电荷</strong>，<strong>同种电荷相互排斥，异种电荷相互吸引</strong>。</p></blockquote><h3 id="电场">电场</h3><p>可以将带电粒子想象为一个球体，<strong>电场</strong>将会由该带电粒子向外呈辐射状分布：</p><p><img src="/Electronics/PCB_Currents/Part-1/3.png"></p><h3 id="磁场">磁场</h3><p>当电子移动产生电流，电流的周边就会产生<strong>磁场</strong>。这个磁场围绕着电流呈同心圆形式分布，其方向可以通过<strong>右手定则</strong>来确定：将右手<code>拇指</code>指向电流方向，右手<code>其它手指</code>就会沿着磁场的方向进行弯曲：</p><p><img src="/Electronics/PCB_Currents/Part-1/4.png"></p><blockquote><p><strong>注意</strong>：<strong>电流</strong>是单位时间内通过导体某个横截面的电荷量，而<strong>电压</strong>是电路中自由电荷定向移动形成电流的原因。物理上规定<strong>电流的方向是正电荷定向运动的方向，该方向与电子的运动方向相反</strong>。</p></blockquote><p>导体的价带上面电子非常松散，绝缘体的价带则几乎被电子填满，而<strong>硅</strong>、<strong>锗</strong>等元素的价带正好只被电子填充了一半，二者都有4 个价电子位于能够容纳 8个电子的能带之上，这些元素就被称为<strong>半导体</strong>。</p><p><img src="/Electronics/PCB_Currents/Part-1/5.png"></p><ul><li>将<code>锑</code>、<code>砷</code>、<code>磷</code>等少量价带上只存在5个电子的元素添加到<strong>硅</strong>和<strong>锗</strong>当中，就会产生<strong>多余的电子</strong>，称为<strong>N 掺杂</strong>（<strong>N</strong> 表示 Negative 负），进而得到<strong>N 型半导体</strong>；</li><li>将硼、铝、镓等少量价带上只存在 3个电子的元素添加到<strong>硅</strong>和<strong>锗</strong>当中，就会产生大量的<strong>空穴</strong>，称为<strong>P 掺杂</strong>（P 表示 Positive <strong>正</strong>），从而得到<strong>P 型半导体</strong>；</li></ul><h2 id="基本的电流概念">基本的电流概念</h2><h3 id="直流-交流">直流 &amp; 交流</h3><p><strong>直流 DC</strong>是沿着一个方向运动的电流，但是直流并非恒流，其大小可以由电路来决定；而<strong>交流 AC</strong> 的方向随着时间呈周期性变化。</p><p><img src="/Electronics/PCB_Currents/Part-1/6.png"></p><h3 id="阶跃函数">阶跃函数</h3><p><strong>阶跃函数</strong>是一种特殊的连续时间函数，表达的是从<code>0</code> 到 <code>1</code>的跳变过程，属于奇异函数。电路分析当中，阶跃函数是研究动态电路阶跃响应的基础。<strong>电流</strong>或者<strong>电压</strong>从一个量值变换为另外一个量值的过程，被称作<strong>阶跃函数变化</strong>，下图展示了一个从低值到高值变化的阶跃函数：</p><p><img src="/Electronics/PCB_Currents/Part-1/7.png"></p><h3 id="方波">方波</h3><p><strong>方波</strong>是交流电的一种特殊形式，是一种规则的、重复的阶跃变化：</p><p><img src="/Electronics/PCB_Currents/Part-1/8.png"></p><h3 id="脉冲波">脉冲波</h3><p><strong>脉冲波</strong>看起来像是丢失了部分波形的方波，或者是一种占空比非常低的方波：</p><p><img src="/Electronics/PCB_Currents/Part-1/9.png"></p><h3 id="瞬态">瞬态</h3><p><strong>瞬态</strong>表示的是两种<strong>相邻稳定状态</strong>之间变化的物理量，例如下图表示的是由电容器上<code>电压</code>的阶跃变化（上方曲线），所引起的流进电容器的瞬态<code>电流</code>（下方曲线）变化：</p><p><img src="/Electronics/PCB_Currents/Part-1/10.png"></p><h3 id="傅里叶变换">傅里叶变换</h3><p><code>正弦波</code>和<code>余弦波</code>都属于<strong>三角函数波形</strong>，其它复杂波形到三角函数波形的转换都是通过<strong>傅里叶定理</strong>完成：任何信号曲线，都可以通过足够数量，具有不同频率（谐波）与相移的三角函数波形叠加而成。</p><ul><li><strong>谐波</strong>是指对周期性非正弦交流量进行傅里叶级数分解，所得到的大于基波频率整数倍的各次分量；</li><li><strong>基波</strong>是指在复杂的周期性振荡当中，与该振荡最长周期相等的正弦波分量；</li></ul><p>利用<strong>傅里叶变换</strong>，可以将一个<strong>方波</strong>表示为<strong>余弦波</strong>的无穷级数：</p><p><span class="math display">\[Square(\theta) = \cos(\theta) - \frac{\cos(3 \theta)}{3} + \frac{\cos(5\theta)}{5} - \frac{\cos(7 \theta)}{7} + ...\]</span></p><p>上述<strong>傅里叶级数</strong>中的每一项都代表着一个基波频率为 <span class="math inline">\(\theta\)</span>的谐波，当使用余弦函数表示方波时，其中只会包含<strong>奇次谐波</strong>。下图通过多个谐波来表示一个方波，其中的谐波项越多，波形就会越接近方波：</p><p><img src="/Electronics/PCB_Currents/Part-1/11.png"></p><p>当傅里叶级数的谐波项达到 <code>101</code>次的时候，波形就已经非常接近于一个标准的方波：</p><p><img src="/Electronics/PCB_Currents/Part-1/12.png"></p><p>任何波形都可以分解为一系列正弦谐波项，每个谐波项都可以进行单独分析，然后再将结果叠加就可以确定电路的响应。如下分别是<code>锯齿波</code>、<code>三角波</code>、<code>脉冲波</code>三种常见复杂波形的傅里叶级数：</p><p><img src="/Electronics/PCB_Currents/Part-1/13.png"></p><p><img src="/Electronics/PCB_Currents/Part-1/14.png"></p><p><img src="/Electronics/PCB_Currents/Part-1/15.png"></p><h3 id="相对介电常数">相对介电常数</h3><p><strong>相对介电常数</strong> <span class="math inline">\(\epsilon_\tau\)</span>表达的是材料存储电荷的能力，某种物质当中<strong>电磁场</strong>的传播速度等于<code>光速</code>除以该物质<code>相对介电常数</code>的平方根：</p><p><span class="math display">\[信号传播速度 = \frac{11.8}{\sqrt{\epsilon_\tau}} 英寸/纳秒\]</span></p><h3 id="带状线-微带线">带状线 &amp; 微带线</h3><p>设计高速电路板时，通常会存在如下几种常见的走线形式：<code>微带线 a</code>、<code>嵌入式微带线 b</code>、<code>带状线 c</code>、<code>双带状线 d</code>、<code>不对称带状线 e</code>，其中<strong>微带线当中信号的传播速度相对要快于带状线</strong>。</p><p><img src="/Electronics/PCB_Currents/Part-1/16.png"></p><ul><li><strong>带状线</strong>是位于两个参考层之前的走线，无论其位置是居中、双重、偏置还是非对称。</li><li><strong>微带线</strong>则是只在一侧存在参考层的走线，通常其表面为空气或者阻焊油，底面则是电路板材料和参考层；</li></ul><h3 id="信号时序">信号时序</h3><p>电路能够容忍轻微的信号<strong>时序差异</strong>，但是如果时序的差异过大，就容易发生采样错误。例如下图中间部分的信号，相对其它信号出现了严重的不一致，导致系统时钟采样信号时发生了跳变：</p><p><img src="/Electronics/PCB_Currents/Part-1/17.png"></p><blockquote><p><strong>注意</strong>：通过设置走线长度可以控制信号的时序，一些 EDA工具当中可以方便的设置蛇形走线来提供等长的布线。只要蛇形走线具有相应的参考层，并且仅局限于带状线信号层，则不会引发EMI 电磁干扰问题。</p></blockquote><h3 id="频率">频率</h3><p>信号的<strong>频率</strong>可以采用三种方式进行描述：</p><p><img src="/Electronics/PCB_Currents/Part-1/18.png"></p><ol type="1"><li><strong>每秒周期数</strong>，即 <code>Hz</code>，用符号 <span class="math inline">\(f\)</span> 表示，上图波形频率为 3Hz，即 <span class="math inline">\(f=3\)</span>；</li><li><strong>每秒波形经过的角度</strong>，由于上图正弦波在 1个周期内经历了 <code>360°</code> 变化，那么 3 个周期内就会经历 <span class="math inline">\(360° \times 3 = 1080°\)</span>；</li><li><strong>角频率</strong>，将圆的周长分割为弧度，其中 <code>1</code>弧度等于圆周上长度等于半径的弧所形成的角度，定义为<code>1 rad</code>；</li></ol><p>圆的周长为 <span class="math inline">\(2 \pi r\)</span>，其中 <span class="math inline">\(r\)</span> 为半径，则 <code>360°</code>圆周的弧度值等于 <span class="math inline">\(\frac{周长}{半径} = \frac{2\pi r}{r} = 2 \pi\)</span> 弧度。</p><p><img src="/Electronics/PCB_Currents/Part-1/19.png"></p><p>因为 <span class="math inline">\(360°\)</span> 是 <span class="math inline">\(2 \pi\)</span> 弧度，所以正弦波在 1 秒内可以经过<span class="math inline">\(2 \pi f\)</span>弧度，这就是电子学当中经常使用到的<strong>角频率</strong> <span class="math inline">\(\omega\)</span>，表示的是<strong>正弦波在 1秒钟内经过的弧度数</strong>。</p><p><span class="math display">\[\omega = 2 \pi f\]</span></p><h3 id="谐波-基波">谐波 &amp; 基波</h3><p>正弦波通常使用 <span class="math inline">\(\sin(2\pi ft)\)</span>或者 <span class="math inline">\(\sin(\omega t)\)</span>格式进行表示，这里的 <span class="math inline">\(2 \pi f\)</span> 或者<span class="math inline">\(\omega\)</span> 表示的是 1秒之内的周期数，<span class="math inline">\(t\)</span>表示的是以秒为单位的时间变量。具有 <span class="math inline">\(\sin(n\omega t)\)</span>波形的<strong>谐波</strong>信号，其频率是<strong>基波</strong>波形 <span class="math inline">\(\sin(\omega t)\)</span> 的 <code>n</code>倍，谐波频率与基波频率存在着简单的倍数关系。下图是某个信号的基波及其 4次谐波：</p><p><img src="/Electronics/PCB_Currents/Part-1/20.png"></p><h3 id="占空比">占空比</h3><p><strong>占空比</strong>是指信号处于<strong>高电平</strong>状态的时间百分比，下图分别表示的是<code>50%</code>（左）和 <code>25%</code>（右）占空比的方波信号：</p><p><img src="/Electronics/PCB_Currents/Part-1/21.png"></p><h3 id="频率-1">频率</h3><p><strong>频率</strong>是单位时间内电流方向循环改变的次数，但是频率并非高速电路设计当中的主要问题，信号的<strong>上升时间</strong>才是真正的麻烦所在。下图的正弦波与方波信号具有相同的频率，但是它们的上升时间并不相同：</p><p><img src="/Electronics/PCB_Currents/Part-1/22.png"></p><h3 id="上升时间">上升时间</h3><p>信号的<strong>上升时间</strong>是指从波形 <code>10%</code> 位置上升至<code>90%</code>位置所需要的时间长度，而<strong>下降时间</strong>则是从信号<code>90%</code> 位置下降至 <code>10%</code> 位置所需的时间长度：</p><p><img src="/Electronics/PCB_Currents/Part-1/23.png"></p><p>如果电路当中信号变化速度较快，例如电流在 <code>1</code> 纳秒内从<code>0 mA</code> 变化到 <code>10 mA</code>，则可以将其表示为电流变化量<span class="math inline">\(\Delta i\)</span> 除以时间变化量 <span class="math inline">\(\Delta t\)</span>，当此处的 <span class="math inline">\(\Delta t\)</span>小到可以忽略的时候，就可以得到其微分形式 <span class="math inline">\(\frac{di}{dt}\)</span>，这就是信号完整性问题产生的原因所在。在高速电路当中，<span class="math inline">\(dt\)</span>项可以等同于信号的上升或者下降时间。</p><h3 id="周期">周期</h3><p>频率与周期的关系为 <span class="math inline">\(频率 =\frac{1}{周期}\)</span>，例如具有 <code>1MHz</code>频率的正弦波周期为百万分之一秒，即 <code>1us</code> 或者<code>1000ns</code>。</p><h3 id="相移">相移</h3><p>电子学当中的<strong>相位</strong>通常是指三角函数波形，两个三角函数波形之间的时间差称为<strong>相移</strong>。如果两个三角函数波形的波峰位于相同的时间点，则认为两者的相位完全相同，称为<strong>同相</strong>（下图左侧），否则称为<strong>不同相</strong>（下图右侧）；</p><p><img src="/Electronics/PCB_Currents/Part-1/24.png"></p><ul><li><strong>电阻</strong>上的电压与电流完全<strong>同相</strong>；</li><li><strong>电容</strong>上的电流<strong>超前</strong>于电压<code>90°</code>；</li><li><strong>电感</strong>上的电流<strong>滞后</strong>于电压<code>90°</code>；</li></ul><h3 id="振幅">振幅</h3><p><strong>振幅</strong>是指振动的物理量可能达到的最大值，用于表示振动的范围和强度的物理量。</p><ul><li><strong>峰峰值</strong>：一个周期内信号最高值和最低值之间的差值；</li><li><strong>峰值</strong>：是峰峰值振幅的一半，即波形水平中线与其峰值之间的幅度；</li><li><strong>平均值</strong>：对称交流波形振幅总是为零；</li><li><strong>均方根值</strong>：首先将一个波形划分为很多部分，然后求解每个部分振幅的平方，接着计算这些平方值的平均值，最后将平均值开方，就可以得到该波形的<strong>均方根值</strong>（<strong>RMS</strong>，RootMean Square）；</li></ul><h3 id="分贝">分贝</h3><p><strong>分贝</strong>（<strong>dB</strong>）是一种基于<strong>对数</strong>的比率度量单位，其结果与<strong>功率</strong>密切相关，对应的基本单位是<strong>贝尔</strong>，两者换算关系如下所示：</p><p><span class="math display">\[1 贝尔 = 10 分贝\]</span></p><p><code>1</code> 贝尔被定义为功率 <span class="math inline">\(P_1\)</span> 与 <span class="math inline">\(P_2\)</span> 比值的对数：</p><p><span class="math display">\[1 贝尔 = log(\frac{P_2}{P_1})\implies1 分贝 = \frac{1}{10} 贝尔 = log(\frac{P_2}{P_1}) \cdot \frac{1}{10}\]</span></p><h3 id="时间常数">时间常数</h3><p><strong>时间常数</strong>表示物理量从最大值衰减到最大值的 <span class="math inline">\(\frac{1}{e}\)</span>时所需要的时间，该参数在电子学当中与波形发生改变的时间长度有关，即一个波形变化占据全部波形变化的比例。</p><h3 id="白噪声">白噪声</h3><p>由于温度引起电子运动而发出的信号，称为<strong>热噪声</strong>。由于似乎是由所有频率的信号构成，如同白色光线由所有颜色构成一样，所以也被称为<strong>白噪声</strong>。通常情况下，信号比噪声更大，可以通过<strong>信噪比</strong>对两者进行比较。</p><h2 id="基本定律">基本定律</h2><h3 id="回路">回路</h3><p><strong>电流</strong>必须在一个闭合的回路当中进行流动，电流在该回路当中必须处处<strong>恒定</strong>。</p><p><img src="/Electronics/PCB_Currents/Part-1/25.png"></p><p>上面电路当中存在 <code>a</code>、<code>b</code>、<code>c</code>三个回路，基于欧姆定律可以分别得到：</p><p><span class="math display">\[\begin{cases}i_1 = \frac{V}{R_1} = \frac{10}{1000} = 10mA \\i_2 = \frac{V}{R_2} = \frac{10}{5000} = 2mA\end{cases}\impliesi = i_1 + i_2 = 12mA\]</span></p><h3 id="欧姆定律">欧姆定律</h3><p><strong>欧姆定律</strong>：电压 <strong>V</strong>（单位为伏V）等于电流 <strong>I</strong>（单位为安 I）乘以电阻<strong>R</strong>（单位为欧姆 Ω）：</p><p><span class="math display">\[电压 V = 电流 I \times 电阻 R\]</span></p><blockquote><p><strong>注意</strong>：欧姆定律作为<strong>点概念</strong>，适用于电路某个时间的某个特定点。</p></blockquote><h3 id="基尔霍夫电流定律">基尔霍夫电流定律</h3><p><strong>基尔霍夫电流定律</strong>：流入某个结点的电流必须等于流出该结点的电流：</p><p><img src="/Electronics/PCB_Currents/Part-1/26.png"></p><p>流入上部结点的电流为 <span class="math inline">\(i\)</span>，流过电阻<span class="math inline">\(R_1\)</span> 的电流为 <span class="math inline">\(i_1\)</span>，流过电阻 <span class="math inline">\(R_2\)</span> 的电流为 <span class="math inline">\(i_2\)</span>，根据基尔霍夫电流定律可以得到 <span class="math inline">\(i = i_1 +i_2\)</span>。根据<strong>欧姆定律</strong>和<strong>基尔霍夫电流定律</strong>，可以推导出<code>n</code> 个<strong>电阻并联</strong>的<strong>等效电阻</strong><span class="math inline">\(R_{eq}\)</span> 求解公式：</p><p><span class="math display">\[\begin{cases}i_1 = \frac{V}{R_1} \\i_2 = \frac{V}{R_2} \\i = \frac{V}{R_{eq}} \\\end{cases}\implies\frac{V}{R_{eq}} = \frac{V}{R_1} + \frac{V}{R_2}\implies\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2}\impliesR_{eq} = \frac{1}{\frac{1}{R_1} + \frac{1}{R_2}} = \frac{R_1 R_2}{R_1 +R_2}\impliesR_{eq} = \frac{R_1 R_2 ... R_n}{R_1 + R_2 ... R_n}\]</span></p><h3 id="基尔霍夫电压定律">基尔霍夫电压定律</h3><p><strong>基尔霍夫电压定律</strong>：一个回路上的电压之和必然等于<strong>零</strong>；</p><p><img src="/Electronics/PCB_Currents/Part-1/27.png"></p><p>将顺时针作为上图电路的参考方向，电阻 <span class="math inline">\(R_1\)</span> 上的电压降为 <span class="math inline">\(V_1\)</span>，而电阻 <span class="math inline">\(R_2\)</span> 上的电压降为 <span class="math inline">\(V_2\)</span>，电压源上的电压为 <span class="math inline">\(-V\)</span>，根据基尔霍夫电压定律就可以得到 <span class="math inline">\(V_1 + V_2 +(-V) =0\)</span>。结合<strong>欧姆定律</strong>和<strong>基尔霍夫电压定律</strong>，同样可以推导出<code>n</code> 个<strong>电阻串联</strong>的<strong>等效电阻</strong><span class="math inline">\(R_{eq}\)</span> 的求解公式：</p><p><span class="math display">\[V_1 + V_2 +(-V) = 0 \implies V = V_1 + V_2\implies\begin{cases}V_1 = i R_1 \\V_2 = i R_2 \\V = R_{eq}\end{cases}\impliesiR_{eq} = i R_1 + i R_2 \implies R_{eq} = R_1 + R_2\impliesR_{eq} = R_1 + R_2 ... R_3\]</span></p><h2 id="电阻电路">电阻电路</h2><h3 id="电阻率">电阻率</h3><p>导体材料对于电流的阻力称为<strong>电阻率</strong>，例如铜在<code>20°C</code> 室温下的电阻率为 <span class="math inline">\(1.724 \muΩ \cdotcm\)</span>。将<strong>电阻率</strong>除上材料的<strong>横截面积</strong>，就可以得到单位长度材料的电阻：</p><p><span class="math display">\[R = \frac{电阻率 \rho}{横截面积 A}\]</span></p><p>PCB 铜泊走线宽度 <code>10mil</code>，厚度<code>0.65mil</code>，则横截面积 <span class="math inline">\(10mil\times 0.65mil =6.5 mil^2 = 0.000419354cm^2\)</span>，将铜的电阻率代入上面公式，就可以得到每厘米走线长度的电阻<span class="math inline">\(R\)</span> ：</p><p><span class="math display">\[R = \frac{1.724}{0.000419354} = 4114 \mu Ω/cm\]</span></p><ol type="1"><li><strong>电阻</strong>反比于<strong>横截面积</strong>，即横截面积越大，电阻就越小；</li><li><strong>电阻</strong>正比于<strong>长度</strong>，走线越长，电阻就越大；</li><li><strong>电阻</strong>与<strong>温度</strong>呈函数关系，大多数金属材料的温度越高，电阻就会越大；</li></ol><blockquote><p><strong>注意</strong>：<strong>焊锡</strong>的电阻率是<strong>铜</strong>的<code>10~15</code>倍，因此焊接时需要保持铜质导线之间拥有足够的接触面积。</p></blockquote><h3 id="电阻的电流与相位">电阻的电流与相位</h3><p>电阻与电流、电压的关系遵循着欧姆定律 <span class="math inline">\(R=\frac{V}{I}\)</span>，除此之外，电阻还会受到<strong>信号频率</strong>的影响：</p><ul><li>由于绕线电阻具有线圈，因而具有电容和电感效应，其性能表现为频率的函数；</li><li>当导体中有交流电或者交变电磁场时，导体内部的电流分布不均匀，电流集中在导体的表面的薄层，越靠近导体表面，电流就会密度越大，导体内部通过的电流较小，致使导体的电阻增加，对应的损耗功率也会增加，这种现象称为<strong>趋肤效应</strong>（SkinEffect）；</li><li>普通长度的导线具有<strong>寄生电感</strong>，因而会在非常快的上升时间内产生<strong>频率效应</strong>；</li></ul><p>电阻的所有频率效应都是由寄生的电感与电容所引起的，并非电阻的性质，电阻本身是独立于频率的，任何在频率范围内绘制成<strong>直线</strong>的阻抗曲线都表示的是纯电阻：</p><p><img src="/Electronics/PCB_Currents/Part-2/1.png"></p><p>对于交流的电压信号，<strong>通过电阻的电流与电压是完全相同的相位</strong>，下图是通过电阻的<strong>电流信号</strong>（上）与<strong>电压信号</strong>（下）的相位。</p><p><img src="/Electronics/PCB_Currents/Part-2/2.png"></p><h3 id="串联电阻">串联电阻</h3><p>电路当中两个电阻 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 串联的等效电阻 <span class="math inline">\(R_{eq}\)</span> 等于 <span class="math inline">\(R_{eq} = R_1 + R_2\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/3.png"></p><h3 id="并联电阻">并联电阻</h3><p>电路当中两个电阻 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 并联的等效电阻 <span class="math inline">\(R_{eq}\)</span> 等于 <span class="math inline">\(R_{eq} = \frac{R_1 R_2}{R_1 + R_2}\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/4.png"></p><h3 id="功率与能量">功率与能量</h3><p><strong>功率</strong>与<strong>能量</strong>是密切相关的两个概念，其中<strong>功率</strong>是做功的速率，而<strong>能量</strong>是功率经过一段时间之后积累的结果。电子学当中的<strong>功率</strong>可以通过<code>电压</code>乘以<code>电流</code>求解得到：</p><p><span class="math display">\[功率 P = 电压 V \times 电流 I\]</span></p><p>结合欧姆定律，还可以得到如下的功率计算公式：</p><p><span class="math display">\[\begin{aligned}功率 P &amp;= \frac{电压 V^2}{电阻 R}  \\功率 P &amp;= 电流 I^2 \times R\end{aligned}\]</span></p><p>当电流经过电阻时，将会消耗 <span class="math inline">\(I^2 R\)</span>的功率，这些消耗的功率会以电阻<strong>发热</strong>的形式体现，这也正是PCB 走线容易发热的原因所在。</p><p><img src="/Electronics/PCB_Currents/Part-2/5.png"></p><p>任何<strong>电源</strong>都可以等效为<strong>开路电压</strong> <span class="math inline">\(E\)</span> 与<strong>输出阻抗</strong> <span class="math inline">\(R_S\)</span> 的串联，而 <span class="math inline">\(R_L\)</span>为<strong>负载电阻</strong>，此时电路所消耗的<strong>总功率</strong>等于<span class="math inline">\(I^2 R_S + I^2R_L\)</span>。当<strong>负载电阻</strong> <span class="math inline">\(R_L\)</span> 等于<strong>输出阻抗</strong> <span class="math inline">\(R_S\)</span>时，负载可以从信号源获得最大的输出功率，即<strong>阻抗匹配</strong>。</p><h3 id="电阻分压电路">电阻分压电路</h3><p>首先，将两个电阻 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 串联在一起；然后，将电压 <span class="math inline">\(E\)</span>添加在串联电阻的两端，此时两个电阻结合处的输出电压为 <span class="math inline">\(E_{out}\)</span>，该电路就称为<strong>电阻分压电路</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/6.png"></p><p>此时，输出电压 <span class="math inline">\(E_{out}\)</span>与输入电压 <span class="math inline">\(E\)</span> 的比值，等于输出端电阻<span class="math inline">\(R_2\)</span> 与总电阻 <span class="math inline">\(R_1 + R_2\)</span> 的比值：</p><p><span class="math display">\[\begin{cases}回路电流\ i = \frac{E}{R_1 + R_2} \\输出电压\ E_{out} = I \times R_2\end{cases}\implies\frac{E_{out}}{E} = \frac{R_2}{R_1 + R_2}\]</span></p><h2 id="电容">电容</h2><p>电容的单位是<code>法拉</code>（F），当电容极板上 <code>1库伦</code>电荷在极板之间产生 <code>1伏特</code> 的电压时，就称该电容为<code>1F</code>：</p><p><span class="math display">\[电容\ C = \frac{电荷量\ Q}{电压\ V}\]</span></p><p>电子学术语当中，<code>1F</code>法拉的电容值比较大，通常采用<strong>微法</strong>（<span class="math inline">\(\muF，10^{-6}F\)</span>）、<strong>纳法</strong>（<span class="math inline">\(nF，10^{-9}F\)</span>）、<strong>皮法</strong>（<span class="math inline">\(pF，10^{-12}F\)</span>）。电容极板上的<strong>电压</strong>会伴随充电时间的增加而变大：</p><p><span class="math display">\[\frac{dV}{dt} = \frac{i}{C}\]</span></p><h3 id="直流通过电容器">直流通过电容器</h3><p>最初时刻，电子开始流动到电容极板上，由于电容器一个极板的电子会显著多于另一个极板，导致电容极板之间存在着电荷差，进而产生电压；随着时间的推移，电容器极板之间的电压与驱动电压相同，此时将不会再有更多的电子在极板之间流动。</p><p><img src="/Electronics/PCB_Currents/Part-2/7.png"></p><h3 id="交流通过电容器">交流通过电容器</h3><p>由于交流电流的极性反复在发生改变，电容器反复进行充放电，因而电流可以自由的进行流动。</p><p><img src="/Electronics/PCB_Currents/Part-2/8.png"></p><h3 id="电抗-容抗">电抗 &amp; 容抗</h3><p>交流电路当中，<strong>阻抗Z</strong>是<code>电阻 R</code>与<code>电抗 X</code>的总和，即 <span class="math inline">\(Z = R +jX\)</span>，而<strong>电抗</strong>是阻抗复数公式的虚数部分。电容与电感对于电流所起到的阻碍作用称作<strong>电抗</strong>，同样采用<code>欧姆</code>作为计量单位，通常使用符号<code>X</code>来表示。其中，<strong>电容</strong>的电抗称为<strong>容抗</strong>，表示为<span class="math inline">\(X_C\)</span>；而<strong>电感</strong>的电抗称为<strong>感抗</strong>，表示为<span class="math inline">\(X_L\)</span>；</p><p>流过电容器的电流大小，取决于电流的<strong>频率</strong>和<strong>电容</strong>的大小，并且能够引起电路电流与电压的相位变化。前面已经讨论过，<strong>角频率</strong>是正弦波在1 秒钟内所经过的弧度数，即 <span class="math inline">\(\omega = 2 \pif\)</span>，由此就可以推导得到<strong>容抗</strong>的公式：</p><p><span class="math display">\[X_c = -\frac{1}{\omega C} = - \frac{1}{2\pi f C}\]</span></p><blockquote><p><strong>注意</strong>：上面容抗公式中出现的<strong>负号</strong>，表示通过电容器的电压发生了<code>-90°</code> 的相移。</p></blockquote><p><strong>欧姆定律</strong>同样适用于电抗 <span class="math inline">\(电压 V = 电流 I \cdot 容抗X_C\)</span>，其中<strong>电压</strong>的单位为伏特<code>V</code>，<strong>电流</strong>的单位为安培<code>A</code>，<strong>容抗</strong>的单位为欧姆 <code>Ω</code>。</p><h3 id="容抗与频率的关系">容抗与频率的关系</h3><p>下图为 <code>0.01 uF</code>电容器的<strong>容抗</strong>与<strong>频率</strong>关系曲线，观察可以发现，<strong>当频率较高时，电容的容抗比较小；而当频率较低时，电容的容抗比较大</strong>；</p><p><img src="/Electronics/PCB_Currents/Part-2/9.png"></p><h3 id="电容的相移">电容的相移</h3><p>流过的<strong>电流</strong>曲线为<strong>三角波</strong>，此时的输出<strong>电压</strong>曲线为<strong>方波</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/10.png"></p><p>流过<strong>电流</strong>曲线为<strong>正弦波</strong>，则此时的输出<strong>电压</strong>曲线为<strong>滞后于电流<code>90°</code> 的正弦波</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/11.png"></p><h3 id="电容的串并联">电容的串并联</h3><p><strong>电容</strong>的串并联关系与<strong>电阻</strong>正好相反，电容<span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> <strong>串联</strong>之后的等效电容为<span class="math inline">\(C = \frac{C_1 \cdot C_2}{C_1 +C_2}\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/12.png"></p><p>而 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span>电容<strong>并联</strong>后的等效电容为 <span class="math inline">\(C =C_1 + C_2\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/13.png"></p><h2 id="电感">电感</h2><p><strong>电磁感应现象</strong>是指因磁通量变化而产生感应电动势的现象，例如：闭合电路的一部分导体在磁场里做切割磁感线运动时，导体中就会产生<strong>感应电流</strong>和<strong>感应电压</strong>。<strong>法拉第电磁感应定律</strong>是指电路当中<strong>感应电压</strong><span class="math inline">\(\epsilon\)</span>与穿过该电路的<strong>磁通</strong>变化率<span class="math inline">\(\varPhi\)</span> 呈正比：</p><p><span class="math display">\[感应电压\ \epsilon = \frac{\Delta \varPhi}{\Delta t}\]</span></p><p>电感的单位是亨利 <code>H</code>，常用的单位有毫亨<code>mH</code>、微亨 <code>uH</code>、纳亨 <code>nH</code>。当流过<code>1H</code> 亨利电感器的电流，以 <code>1A</code>安培每秒的速度进行变化时，就会产生 <code>1V</code> 伏特的电压：</p><p><span class="math display">\[电感\ L = \frac{电压\ V}{电流变化量\ di / 时间变化量\ dt}\]</span></p><h3 id="直流通过电感器">直流通过电感器</h3><p>直流信号通过电感器时，不会产生反向的感生电流，所以理想电感器对于直流不会产生阻抗：</p><p><img src="/Electronics/PCB_Currents/Part-2/14.png"></p><h3 id="交流通过电感器">交流通过电感器</h3><p>交流信号通过电感器时，变化的磁场会产生出反向的感生电流，会阻止电感器的导通：</p><p><img src="/Electronics/PCB_Currents/Part-2/15.png"></p><blockquote><p><strong>注意</strong>：信号频率越高，电感器对于交流信号的阻抗就越大。</p></blockquote><h3 id="感抗">感抗</h3><p>当线圈中有电流通过时，就会在线圈中形成感应电磁场，而感应电磁场导致线圈当中产生<strong>感应电流</strong>，从而抵制通过线圈的电流，这种电流与线圈之间的相互作用称为<strong>感抗</strong>，采用符号<span class="math inline">\(X_L\)</span>进行表示。感抗的大小取决于<strong>电感量</strong>的大小以及通过信号的<strong>频率</strong>：</p><p><span class="math display">\[X_L = \omega L \xrightarrow{\omega = 2 \pi f} X_L = 2 \pi f L\]</span></p><p><strong>欧姆定律</strong>同样适用于电感，通过电感的电压 <span class="math inline">\(V\)</span>（伏特 <code>V</code>）等于电流 <span class="math inline">\(I\)</span>（安培 <code>A</code>）乘以感抗 <span class="math inline">\(X_L\)</span>（欧姆 <code>Ω</code>）：</p><p><span class="math display">\[V = I \cdot X_L\]</span></p><h3 id="感抗与频率的关系">感抗与频率的关系</h3><p>当频率较低时，感抗较小；而当频率较高时，则感抗将会增大，即<strong>感抗伴随着频率的升高而增大</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/16.png"></p><h3 id="电感相移">电感相移</h3><p>当经过电感的电流为<strong>三角波</strong>，则电感两端的电压呈现为<strong>方波</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/17.png"></p><p>当流经电感的电流为<strong>正弦波</strong>，则电感两端的电压曲线为超前于电流曲线<code>90°</code> 的<strong>正弦波</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/18.png"></p><h3 id="电感的串并联">电感的串并联</h3><p><strong>电感</strong>的串并联关系与<strong>电阻</strong>完全相同，电感<span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 串联之后的等效电感为 <span class="math inline">\(L_{eq} = L_1 + L_2\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/19.png"></p><p>而 <span class="math inline">\(L_1\)</span> 与 <span class="math inline">\(L_2\)</span> 并联之后的等效电感为 <span class="math inline">\(L_{eq} = \frac{L_1 \cdot L_2}{L_1 +L_2}\)</span>：</p><p><img src="/Electronics/PCB_Currents/Part-2/20.png"></p><h3 id="趋肤效应">趋肤效应</h3><p>恒定的电流会在导体截面均匀分布，而交变电流会让导体出现自感电动势，从而抵抗电流的通过，该电动势的大小正比于导体单位时间所切割的磁通量。</p><p><img src="/Electronics/PCB_Currents/Part-2/21.png"></p><p>以圆形截面的导体为例，越靠近导体的中心位置，所受到自感电动势的影响就越大；而越靠近导线表面的位置，所受到自感电动势的影响就越小，进而导致趋近导体表面处的电流密度较大（上图阴影的深浅就就体现了电流密度）。</p><blockquote><p><strong>注意</strong>：由于自感电动势会随着频率的提高而增加，所以趋肤效应也会随频率的提高而增强，造成导体当中通过电流的有效截面积减小，电阻增大。</p></blockquote><h2 id="谐振">谐振</h2><p>对于包含<code>电容</code>、<code>电感</code>、<code>电阻</code>元件的无源一端口网络，其端口可能会呈现出<strong>容性</strong>、<strong>感性</strong>、<strong>阻性</strong>，当电路端口的电压<span class="math inline">\(U\)</span> 和电流 <span class="math inline">\(I\)</span>出现相同的相位，电路呈现阻性时，就称为<strong>谐振</strong>现象，这样的电路就称为<strong>谐振电路</strong>。</p><h3 id="串联谐振">串联谐振</h3><p>对于一个由电感 <span class="math inline">\(L\)</span> 与电容 <span class="math inline">\(C\)</span> 串联起来组成的电路：</p><p><img src="/Electronics/PCB_Currents/Part-2/22.png"></p><p>这个电路的总电抗可以通过 <span class="math inline">\(X_{总} = X_C +X_L\)</span> 计算得到：</p><p><span class="math display">\[X_{总} = X_C + X_L\implies\begin{cases}X_C = - \frac{1}{\omega C} = -\frac{1}{2 \pi f C} \\X_L = \omega L = 2 \pi f L\end{cases}\impliesX_{总} = X_C + X_L = -\frac{1}{\omega C} + \omega L\]</span></p><p>此时如果 <span class="math inline">\(\frac{1}{\omega C} = \omegaL\)</span>，就可以推导得到：</p><p><span class="math display">\[\omega = \frac{1}{\sqrt{LC}} = 2 \pi f\]</span></p><p>当电容值为 <code>0.01uF</code>，而电感值为 <code>10nH</code>时，代入上面方程可以求解得到频率 <span class="math inline">\(f\)</span>的值为 <code>16MHz</code>，即通过频率为 <code>16MHz</code>的信号时，这个 LC 串联电路的阻抗等于零：</p><p><span class="math display">\[f = \frac{1}{2 \pi \sqrt{LC}} = \frac{1}{2\pi \sqrt{0.01\times10^{-6}\times 10 \times^{-9}}} = 16MHz\]</span></p><p>下图左右两侧曲线，分别为<strong>感抗</strong>和<strong>容抗</strong>曲线，两者相交于<code>16MHz</code>位置，由于两者的符号相反，所以正好完全抵消，电抗急剧下降到零：</p><p><img src="/Electronics/PCB_Currents/Part-2/23.png"></p><p>由<code>电感</code>和<code>电容</code>组成的串联电路，当容抗 <span class="math inline">\(X_C\)</span> 与感抗 <span class="math inline">\(X_L\)</span>相等时，电路当中电压与电流的相位相同，电路总体呈现阻性，这种现象就称为<strong>串联谐振</strong>。此时，电路的总阻抗最小，电流将会达到最大值，电感和电容上会产生高于电源许多倍的电压，因而也被称为<strong>电压谐振</strong>。此时，容抗<span class="math inline">\(X_C\)</span> 与感抗 <span class="math inline">\(X_L\)</span>相等时的频率点，就称为<strong>谐振点</strong>。</p><h3 id="并联谐振">并联谐振</h3><p>相应的，<strong>电感</strong>与<strong>电容</strong>并联之后的电抗与<strong>电阻</strong>的并联相类似：</p><p><img src="/Electronics/PCB_Currents/Part-2/24.png"></p><p>此时该电路的<strong>总电抗</strong> <span class="math inline">\(X_{总}\)</span> 可以通过下面的过程推导得到：</p><p><span class="math display">\[X_{总} = \frac{1}{\frac{1}{X_L} + \frac{1}{X_C}} =\frac{1}{\frac{L}{\omega L} - \omega C} = \frac{\omega L}{1 - \omega^2LC}\]</span></p><p>此时，当并联的电容值为 <code>0.01uF</code>，而电感值为<code>10nH</code> 时，谐振点依然为<code>16MHz</code>，但是在此时<strong>电抗将会趋于无穷大</strong>：</p><p><img src="/Electronics/PCB_Currents/Part-2/25.png"></p><p>由<code>电感</code>与<code>电容</code>组成的并联电路当中，当电容的容值使得电路上的<code>电压</code>与<code>电流</code>处于相同的相位，电源提供的电能全部被电阻所消耗，成为电阻电路时，就被称为<strong>并联谐振</strong>。此时电路的总阻抗最大，而总电流最小，但是支路的电流可能大于总电流，因而并联谐振也被称作<strong>电流谐振</strong>。</p><h2 id="阻抗">阻抗</h2><h3 id="阻抗的定义">阻抗的定义</h3><p><strong>阻抗</strong>是<strong>电阻</strong>和<strong>电抗</strong>共同作用的结果，通常使用字母<code>Z</code> 来进行表示，其<strong>复数</strong>表达式为：</p><p><span class="math display">\[Z = R + jX\]</span></p><p>上面方程当中的 <span class="math inline">\(R\)</span>表示<strong>电阻分量</strong>，<span class="math inline">\(X\)</span>表示<strong>电抗分量</strong>，而 <span class="math inline">\(j\)</span>的值为 <span class="math inline">\(\sqrt{-1}\)</span>称为<strong>虚数单位</strong>。</p><h3 id="阻抗的大小">阻抗的大小</h3><p><strong>阻抗</strong>是通过从<strong>原点</strong>指向<code>电阻</code><span class="math inline">\(R\)</span> 与<code>电抗</code> <span class="math inline">\(X\)</span> 交点的向量来进行表示的。</p><p><img src="/Electronics/PCB_Currents/Part-2/26.png"></p><p>上图坐标轴当中的原点、<span class="math inline">\(X\)</span>轴、<span class="math inline">\(R\)</span>轴构成了一个直角三角形，根据三角函数的关系可以得到：</p><p><span class="math display">\[Z = \sqrt{R^2 + X^2}\]</span></p><p>例如在下面电路当中，<span class="math inline">\(100Ω\)</span> 电阻与<span class="math inline">\(0.02 \mu F\)</span> 电容串联在一起：</p><p><img src="/Electronics/PCB_Currents/Part-2/27.png"></p><p>如果此时频率 <span class="math inline">\(\omega =10^6\)</span>，从而可以得到如下推导过程：</p><p><span class="math display">\[\begin{cases}R = 100Ω \\X_C = -\frac{1}{\omega \times 0.02 \times 10^{-6}}\end{cases}\implies\begin{cases}R = 100Ω \\X_C = -\frac{1}{10^6 \times 0.02 \times 10^{-6}}\end{cases}\implies\begin{cases}R = 100Ω \\X_C = -50Ω\end{cases}\]</span></p><p>根据上面的推导结果，就可以将上面电路的阻抗关系绘制到如下坐标轴上：</p><p><img src="/Electronics/PCB_Currents/Part-2/28.png"></p><p>根据上述阻抗向量公式，可以得到该电路的阻抗为 <span class="math inline">\(Z = \sqrt{100^2 + (-50)^2} =111.8\)</span>。此时，如果将频率改变为 <span class="math inline">\(\omega = 10^7\)</span>，则会使得容抗 <span class="math inline">\(X_C = -\frac{1}{10^7 \times 0.02 \times 10^{-6}} =-5Ω\)</span>，此时该电路的阻抗应为：</p><p><span class="math display">\[\begin{cases}R = 100Ω \\X_C = -5Ω\end{cases}\impliesZ = \sqrt{100^2 + (-5)^2} = 100.1\]</span></p><p>由此，就可以得到频率为 <span class="math inline">\(\omega =10^7\)</span> 时，串联 <span class="math inline">\(100Ω\)</span> 电阻与<span class="math inline">\(0.02 \mu F\)</span> 电容的阻抗图：</p><p><img src="/Electronics/PCB_Currents/Part-2/29.png"></p><p>可以看到，高频状态下的容抗值会比较小，决定阻抗值大小的主要是串联的电阻。</p><h3 id="阻抗的相位角">阻抗的相位角</h3><p>阻抗的<strong>相位角</strong>就是下图当中的 <span class="math inline">\(\theta\)</span> 角，是阻抗向量与 <span class="math inline">\(R\)</span>横轴之间的<strong>夹角</strong>。如果这个角为<code>负</code>（阻抗向量指向下方），那么该电路是<strong>容性</strong>。如果这个角为<code>正</code>（阻抗向量指向上方），那么该电路为<strong>感性</strong>。</p><p><img src="/Electronics/PCB_Currents/Part-2/30.png"></p><p>阻抗的<strong>相位角</strong>存在着 3 种特殊情形：</p><ol type="1"><li>相位角为 <code>+90°</code>：阻抗向量与 <code>X</code>轴正半轴重合，电路表现为<strong>纯感性</strong>；</li><li>相位角为 <code>-90°</code>：阻抗向量与 <code>X</code>轴正半轴重合，电路表现为<strong>纯容性</strong>；</li><li>相位角为 <code>0°</code>：阻抗向量与 <code>R</code>轴重合，电路表现为<strong>纯阻性</strong>；</li></ol><p>结合三角函数的知识，角 <span class="math inline">\(\theta\)</span>的正切是<code>对边</code>与<code>邻边</code>的比值，由此可以知道角 <span class="math inline">\(\theta\)</span>等于<code>对边</code>与<code>邻边</code>比值的反正切：</p><p><span class="math display">\[\tan(\theta) = \frac{X}{R}\implies\theta = \tan^{-1}(\frac{X}{R})\]</span></p><p>对于前述的示例电路，可以计算得到如下结果：</p><p><span class="math display">\[\begin{cases}当 \omega = 10^6 时：\tan^{-1}(\frac{-50}{100}) = \tan^{-1}(-0.5) =-26.6° \\当 \omega = 10^7 时：\tan^{-1}(\frac{-5}{100}) = \tan^{-1}(-0.05) =-2.9°\end{cases}\]</span></p><p>阻抗的相位角代表了该电路<code>电压</code>与<code>电流</code>之间的<strong>相位差</strong>，相位角为负则表示当前电路的电压滞后于电流的相位，当频率增加之后，由于高频信号的电容效应会下降，电压相位的滞后程度也会减少。</p><p>下图是频率为 <span class="math inline">\(\omega = 10^6\)</span>时，电路当中各处电压的波形：</p><p><img src="/Electronics/PCB_Currents/Part-2/31.png"></p><p>下图是频率为 <span class="math inline">\(\omega = 10^7\)</span>时，电路当中各处电压的波形：</p><p><img src="/Electronics/PCB_Currents/Part-2/32.png"></p><p>分析上述两组图形，可以得出如下三点结论：</p><ol type="1"><li>通过电阻器的电流 <span class="math inline">\(I_R\)</span> 与电压<span class="math inline">\(V_R\)</span> 同相，并且电容器上的电压 <span class="math inline">\(V_C\)</span> 滞后于电阻器上的电压 <span class="math inline">\(V_R\)</span> 与电流 <span class="math inline">\(I_R\)</span> 有 <code>90°</code> 度；</li><li>尽管电容器上的电压 <span class="math inline">\(V_C\)</span>伴随频率的提高而变小，但是总电压 <span class="math inline">\(V_{Total}\)</span> 并未发生变化；</li><li>当频率为 <span class="math inline">\(\omega = 10^6\)</span>时，总电压 <span class="math inline">\(V_{Total}\)</span>滞后于电流（该电流与电阻上的电压 <span class="math inline">\(V_R\)</span> 同相）<code>26.6°</code>度；而当频率等于 <span class="math inline">\(\omega = 10^7\)</span>时，总电压 <span class="math inline">\(V_{Total}\)</span> 仅滞后于电流<code>2.9°</code> 度；</li></ol><h3 id="串联-rlc-电路示例">串联 RLC 电路示例</h3><p>对于下面这个仅由<code>电阻</code>、<code>电感</code>、<code>电容</code>组成的简单<strong>RLC</strong> 电路：</p><p><img src="/Electronics/PCB_Currents/Part-2/33.png"></p><p>列写感抗 <span class="math inline">\(X_L\)</span>、容抗 <span class="math inline">\(X_C\)</span>、总阻抗 <span class="math inline">\(X_{总}\)</span> 的方程，联立之后可以得到：</p><p><span class="math display">\[\begin{cases}X_L = j \omega L \\X_C = \frac{1}{j \omega L} \\X_{总} = j \omega L + \frac{1}{j \omega L}\end{cases}\implies\begin{cases}X_L = j \omega L \\X_C = -\frac{j}{j \omega C} \\X_{总} = j(\omega L - \frac{1}{\omega C})\end{cases}\impliesZ = R + j(\omega L -  \frac{1}{\omega C})\]</span></p><p>假设电阻 <span class="math inline">\(R = 10 Ω\)</span>、电感 <span class="math inline">\(L = 10 nH\)</span>、电容 <span class="math inline">\(C = 0.01 \mu F\)</span>、频率 <span class="math inline">\(\omega =10^7\)</span>，根据上述的推导结果可以得到：</p><p><span class="math display">\[\begin{cases}R = 10 Ω \\L = 10 nH \\C = 0.01 \mu F \\\omega = 10^7\end{cases}\impliesZ = 10 - j9.9\]</span></p><p>根据前面得到的阻抗 <span class="math inline">\(Z = \sqrt{R^2 +X^2}\)</span> 与阻抗角 <span class="math inline">\(\theta =tan^{-1}(\frac{X}{R})\)</span> 公式，还可以推导得到：</p><p><span class="math display">\[\begin{cases}Z = 14.0716Ω \\\theta = -44.712°\end{cases}\]</span></p><p>如果此时将频率提高至 <span class="math inline">\(\omega =10^8\)</span>，就会推导得到：</p><p><span class="math display">\[\begin{cases}Z = 10Ω \\\theta = 0°\end{cases}\]</span></p><p>已知频率 <span class="math inline">\(\omega = 2 \pif\)</span>，由于此时 <span class="math inline">\(\omega =10^8\)</span>，所以频率 <span class="math inline">\(f = \frac{10^8}{2\pi} = 16MHz\)</span>，这与之前讨论过的 LC电路的谐振频率相同，从而可以得到如下结论：</p><ol type="1"><li>在谐振频率处，通过电路的阻抗是纯阻性的；</li><li>在谐振频率处，阻抗表达式当中的电抗项等于零；</li><li>在谐振频率处，通过电路的相移为 <code>0°</code>；</li></ol><p>下图左侧是上述串联 RLC电路的<strong>阻抗</strong>与<strong>频率</strong>的关系，而右侧体现的则是<strong>相移</strong>与<strong>频率</strong>的关系：</p><p><img src="/Electronics/PCB_Currents/Part-2/34.png"></p><p>分析上述图像还可以得到如下两个结论：</p><ul><li>阻抗总是为<strong>正</strong>，并且<code>谐振频率</code>位置的阻抗最小，<strong>相移</strong>为零；</li><li>如果当前频率<strong>低</strong>于谐振频率（电路呈<strong>容性</strong>），相移为<strong>负</strong>；如果<strong>高</strong>于谐振频率（电路呈<strong>感性</strong>），则相移为<strong>正</strong>；其取值范围位于<span class="math inline">\(-90°~+90°\)</span> 之间；</li></ul><p>分析电阻与电抗电路当中的电压电流，需要处理一些涉及到<strong>相移</strong>的微妙问题。当频率<span class="math inline">\(\omega = 10^7\)</span> 时，阻抗 <span class="math inline">\(Z = 14.0716Ω\)</span>，阻抗的相位角 <span class="math inline">\(\theta = -44.712°\)</span>。这里从相移为<code>0°</code> 的正弦波电压开始分析，先使得最大电压等于<code>10V</code>，这样就可以得到此时的总电压 <span class="math inline">\(V_总 = 10\sin(\theta)\)</span>，再结合欧姆定律就可以得到：</p><p><span class="math display">\[I = \frac{V}{Z} = 0.71065 \sin(\theta + 44.712)\]</span></p><p>由于该电路为容性，电流超前于电压，电压的相移为<strong>负</strong>，所以<span class="math inline">\(\theta\)</span>的正弦函数为<strong>正</strong>。该电路上电感、电阻、电容三个元件上的电压分别等于电流乘以它们各自的电阻或者电抗：</p><p><span class="math display">\[\begin{cases}V_R = I \times R = 7.1061 \sin(\theta + 44.712) \\V_L = I \times X_L = 0.07106 \{sin(\theta + 134.712)\} \\V_C = \frac{I}{X_C} = 7.1061 \{sin(\theta - 45.288)\}\end{cases}\]</span></p><p>下图绘制了包括上述 <span class="math inline">\(V_总\)</span>、<span class="math inline">\(V_R\)</span>、<span class="math inline">\(V_L\)</span>、<span class="math inline">\(V_C\)</span>四个波形在两个周期内的时序关系，注意它们之间的相位关系：</p><p><img src="/Electronics/PCB_Currents/Part-2/35.png"></p><h3 id="并联-rlc-电路示例">并联 RLC 电路示例</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;《PCB 电流与信号完整性设计》&lt;/strong&gt;英文名称是&lt;strong&gt;《PCB
Currents How They Flow, How They React》&lt;/strong&gt;，作者是 &lt;a href=&quot;https://www.ultracad.com/&quot;&gt;UltraCAD&lt;/a&gt; 公司的创办者 Douglas
Brooks，全书着重于物理概念，避免复杂的数学推导，阐述了基本电路的电流源、电流造成的信号完整性问题，以及如何解决串扰和电磁干扰问题。主要内容包括：&lt;code&gt;温度漂移&lt;/code&gt;、&lt;code&gt;传输线&lt;/code&gt;、&lt;code&gt;反射&lt;/code&gt;、&lt;code&gt;耦合电流&lt;/code&gt;、&lt;code&gt;功率分配&lt;/code&gt;、&lt;code&gt;趋肤效应&lt;/code&gt;、&lt;code&gt;介电损耗&lt;/code&gt;和&lt;code&gt;通孔&lt;/code&gt;等，并且给出了每个常见问题的实用设计方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/PCB_Currents/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;全书分为四个部分，其中第一部分&lt;strong&gt;电流的性质&lt;/strong&gt;介绍了电流的基本定义，第二部分&lt;strong&gt;基本电路中电流的流动&lt;/strong&gt;包括了电阻电路、电抗（电容、电感）电路、以及阻抗相关的内容，第三部分则介绍了&lt;strong&gt;电压源与电流源&lt;/strong&gt;，第四部分&lt;strong&gt;电路板上的电流&lt;/strong&gt;则介绍了
PCB 上引入的各种信号完整性问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="PCB" scheme="http://www.uinio.com/tags/PCB/"/>
    
  </entry>
  
  <entry>
    <title>《电路分析导论》读书笔记</title>
    <link href="http://www.uinio.com/Electronics/Introduct_Analysis/"/>
    <id>http://www.uinio.com/Electronics/Introduct_Analysis/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-03-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文力求言简意赅的讨论电路分析过程当中涉及到的一些基本理论知识，全文第1 部分围绕<strong>电路分析</strong>展开，涵盖了电路当中的<code>电阻</code> 与 <code>电容</code>等基本元件，相关的定律（<code>欧姆定律</code>、<code>焦耳定律</code>、<code>基尔霍夫定律</code>）定理（<code>叠加定理</code>、<code>戴维南定理</code>、<code>诺顿定理</code>）和等效变换（<code>电源等效</code>、<code>串并联等效</code>、<code>星形三角形等效</code>），以及基本的分析方法（<code>支路电流法</code>、<code>结点电压法</code>、<code>非线性电阻分析</code>）；第2 部分则以<strong>电磁感应</strong>现象作为核心，同时引入<code>安培力</code>、<code>洛仑兹力</code>、<code>磁通量</code>等电磁学基本概念。</p><p><img src="/Electronics/Introduct_Analysis/logo.png"></p><p>第 3 部分围绕<strong>交流信号</strong>展开，包含了动态元件<code>电阻</code>、<code>电容</code>、<code>电感</code>相关的交流电路，并且介绍了 <code>功率因数</code>的提高，<strong>RC</strong> 与 <strong>LC</strong>电路，以及<strong>三相交流电路</strong>；第 4部分介绍了<strong>互感</strong>与<strong>变压器</strong>，主要讨论互感现象与变压器的原理；第5 部分则主要讨论电路的<strong>过渡过程</strong>，比如<strong>RC</strong> 与 <strong>RL</strong> 电路的过渡过程，以及其中<code>电压</code> 与 <code>电流</code>随着时间变化的规律和影响过渡过程快慢的<code>时间常数</code>，同时还引入了<strong>换路定则</strong>与<code>微分电路</code> 以及 <code>积分电路</code>。</p><span id="more"></span><h2 id="电路基础">电路基础</h2><h3 id="电荷与电场">电荷与电场</h3><h4 id="元电荷">元电荷</h4><p><strong>电子</strong>带有最小单位的<strong>负电荷</strong>，<strong>质子</strong>则带有最小单位的<strong>正电荷</strong>，这些带电粒子所携带的电量<span class="math inline">\(e = - 1.60 \times 10^{-19} C\)</span>就被称为<strong>元电荷</strong>。</p><h4 id="库仑定律">库仑定律</h4><p><strong>同种电荷之间相互排斥，异种电荷之间相互吸引</strong>。真空当中两个静止点电荷<span class="math inline">\(Q_1\)</span> 与 <span class="math inline">\(Q_2\)</span> 之间的相互作用力 <span class="math inline">\(F\)</span>（库仑力），与它们的电荷量的乘积成正比，与它们的距离<span class="math inline">\(r\)</span>的二次方成反比，作用力的方向在它们的连线上面，这就是<strong>库仑定律</strong>：</p><p><span class="math display">\[库仑力 F = 静电力常量 k  \frac{点电荷量 Q_1 \cdot 点电荷量 Q_2}{距离r^2}\]</span></p><blockquote><p><strong>注意</strong>：上述公式当中的 <span class="math inline">\(k =9.0 \times 10^9\ N \cdot m^2 / C^2\)</span>称为<strong>静电力常量</strong>。</p></blockquote><h4 id="电荷守恒定律">电荷守恒定律</h4><p>电荷即不能创造，也不能被消灭，它只能从一个物体转移到另外一个物体，或者从物体的一部分转移至另外一个部分，这就是<strong>电荷守恒定律</strong>。</p><h4 id="静电感应">静电感应</h4><p><strong>静电感应</strong>是指将电荷靠近近不带电的物体，从而使其带电的现象。这种利用静电感应使得物体带电的方式，称为<strong>感应起电</strong>。感应起电并没有创造电荷，只是暂时性分离了物体上的正负电荷。</p><h4 id="电场">电场</h4><p><strong>电场</strong>是一种带电物体周围存在的特殊物质，其基本性质是对放入其中的电荷存在<strong>力</strong>的作用，这种力就称为<strong>电场力</strong>。放置在电场当中的电荷，所受到的电场力<span class="math inline">\(F\)</span> 与其电荷量 <span class="math inline">\(q\)</span>的比值，称为<strong>电场强度</strong>，简称为<strong>场强</strong>，通常用字母<strong>E</strong> 表示，单位为<strong>牛/库</strong><code>N/C</code>：</p><p><span class="math display">\[电场强度 E = \frac{电场力 F}{电荷量 q}\]</span></p><p><strong>电场线</strong>用于表征电场当中各点的场强大小与方向，由一系列从<strong>正电荷</strong>出发，到<strong>负电荷</strong>截止的曲线所组成，曲线密度越大，表征的电场强度也就越大。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/6.png"></p><h3 id="基本物理量">基本物理量</h3><h4 id="电路">电路</h4><p><strong>电路</strong>就是电的流通路径，通常由<code>电源</code>、<code>负载</code>、<code>导线</code>、<code>开关</code>组成。而<strong>电路图</strong>是为了便于对电路进行分析，采用电路符号来表示电路上的实际元件，也称为<strong>电路原理图</strong>。其中，<strong>串联电路</strong>（元件首尾依次相连）和<strong>并联电路</strong>（元件首尾并列连接）是最为基本的两种电路组成形式：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/1.png"></p><p>总体上看，电路一共拥有<code>通路</code>、<code>开路</code>、<code>短路</code>三种物理连接状态：</p><ol type="1"><li><strong>通路</strong>：电路开关闭合之后，所形成的电流回路；</li><li><strong>开路</strong>：电路开关或者导线断开，此时没有电流通过；</li><li><strong>短路</strong>：电路当中的两点被导线直接连通，此时会产生较大的电流；</li></ol><h4 id="电流">电流</h4><p>电荷有规则的运动形成电流，其大小等于导体横截面<strong>电荷量</strong><span class="math inline">\(q\)</span>（库仑<code>C</code>）与<strong>单位时间</strong> <span class="math inline">\(t\)</span>（秒<code>s</code>）的比值，该比值就称为<strong>电流强度</strong>，简称为<strong>电流</strong>，用字母<span class="math inline">\(I\)</span> 进行表示：</p><p><span class="math display">\[电流 I = \frac{电荷量 q}{时间 t}\]</span></p><p>如果在 <code>1</code> 秒钟内通过导体横截面的电荷量为 <code>1</code>库仑，那么导体当中的电流就是 <span class="math inline">\(1 安培 =\frac{1\ 库仑}{1\ 秒钟}\)</span>。电流常用的单位除了安培（<span class="math inline">\(A\)</span>）之外，还有<strong>毫安</strong>（<span class="math inline">\(mA\)</span>）和<strong>微安</strong>（<span class="math inline">\(\mu A\)</span>）以及<strong>纳安</strong>（<span class="math inline">\(nA\)</span>），它们之间的换算关系如下所示：</p><p><span class="math display">\[1 A = 10^3 mA = 10^6 \mu A = 10^9 nA\]</span></p><ul><li>电流的<strong>约定方向</strong>：<strong>正电荷</strong>运动的方向，从正极流向负极，由富兰克林提出并延用至今；</li><li>电流的<strong>真实方向</strong>：<strong>负电荷</strong>运动的方向，从负极流向正极，由汤姆逊提出，由于并不影响分析结果，所以电路分析时习惯上仍然采用富兰克林的约定方向；</li><li>电流的<strong>参考方向</strong>：电路分析时任意指定的方向，指定电流的参考方向之后，计算结果为<strong>正</strong>表示实际方向与参考方向相同，为<strong>负</strong>则表示相反；</li></ul><blockquote><p><strong>注意</strong>：<strong>直流电流</strong>的<code>大小</code>与<code>方向</code>都不会随时间变化，采用大写字母<span class="math inline">\(I\)</span>表示；而<strong>交流电流</strong>的<code>大小</code>与<code>方向</code>均会随着时间进行变化，采用小写字母<span class="math inline">\(i\)</span> 表示。</p></blockquote><h4 id="电压">电压</h4><p><strong>电压</strong>是衡量电场力<strong>做功能力</strong>的物理量，电路当中<strong>a</strong> 与 <strong>b</strong> 两点之间的电压 <span class="math inline">\(U_{ab}\)</span> 等于将单位正电荷从<strong>a</strong> 点迁移至 <strong>b</strong>点时，电场力所做的功，其值等于耗费的<strong>总功率</strong> <span class="math inline">\(W\)</span>（焦耳<code>J</code>）与迁移的<strong>总电荷量</strong> <span class="math inline">\(q\)</span>（库仑 <code>C</code>）之比：</p><p><span class="math display">\[电压 U_{ab} = \frac{功率 W}{电荷量 q}\]</span></p><p>如果通过 <code>1</code> 库仑电荷量消耗的总功率为 1焦耳，那么导体上的电压就为 <span class="math inline">\(1 伏特 = \frac{1\焦耳}{1\ 库仑}\)</span>。电压的单位为<strong>伏特</strong><code>V</code>，除此之外，还有<strong>毫伏</strong>（<span class="math inline">\(mV\)</span>）和<strong>微伏</strong>（<span class="math inline">\(\mu V\)</span>）以及<strong>纳伏</strong>（<span class="math inline">\(nV\)</span>），它们之间的换算关系如下所示：</p><p><span class="math display">\[1 V = 10^3 mV = 10^6 \mu V = 10^9 nV\]</span></p><ul><li>电压的<strong>实际方向</strong>：由<code>高电位</code>指向<code>低电位</code>方向；</li><li>电压的<strong>参考方向</strong>：电路分析时任意指定的方向，指定电压的参考方向之后，计算结果为<strong>正</strong>表示实际方向与参考方向相同，为<strong>负</strong>则表示相反；<ul><li>文字叙述时，电压的参考方向由 <strong>a</strong> 点到<strong>b</strong> 点，此时可以选用双下标 <span class="math inline">\(U_{ab}\)</span> 进行表示；</li><li>电路图当中，通常使用 <strong>+</strong>号表示参考方向的<strong>高电位</strong>，<strong>-</strong>号表示<strong>低电位</strong>，由高电位指向低电位的方向即是该电路的参考方向；</li></ul></li></ul><blockquote><p><strong>注意</strong>：<strong>直流电压</strong>的<code>大小</code>与<code>方向</code>都不会随时间变化，采用大写字母<span class="math inline">\(U\)</span>表示；而<strong>交流电压</strong>的<code>大小</code>与<code>方向</code>均会随着时间进行变化，采用小写字母<span class="math inline">\(u\)</span> 表示。</p></blockquote><h4 id="电位">电位</h4><p>在电路当中任意选择一个<strong>参考点</strong>（通常选择电路的接地点），电路上其它各点相对于参考点的电压降或者电压升，就是各个点的相对<strong>电位</strong>，其单位与电压一样为<strong>伏特</strong><code>V</code>。此时，电路上 <strong>a</strong> 与 <strong>b</strong>两点之间的电压 <span class="math inline">\(U_{ab}\)</span> 等于<strong>a</strong> 点电位 <span class="math inline">\(U_a\)</span> 与<strong>b</strong> 点电位 <span class="math inline">\(U_b\)</span>之差：</p><p><span class="math display">\[U_{ab} = U_a - U_b\]</span></p><p>当某点相对参考点的电位为<strong>正值</strong>时，表示该点的电位<strong>高于</strong>参考点；而当某点相对参考点的电位为<strong>负值</strong>时，则表示该点的电位<strong>低于</strong>参考点。</p><blockquote><p><strong>注意</strong>：实际工程当中，通常将大地作为<strong>零电位参考点</strong>。而在电路分析时，通常会将多个元件汇集的公共点视为参考点。</p></blockquote><h4 id="电动势">电动势</h4><p><strong>电动势</strong>用于表示电源将<strong>其它形式的能量</strong>（非静电力）转换为<strong>电能</strong>的能力，通常使用大写字母<span class="math inline">\(E\)</span>表示，单位同样为<strong>伏特</strong><code>V</code>。其值等于电源能量将电荷从<code>负极</code>传送至<code>正极</code>所做的<strong>功</strong><code>W</code>（焦耳 J）与被传送的<strong>电荷量</strong><code>q</code>（库伦 C）之比：</p><p><span class="math display">\[电动势 E = \frac{电源做功 W}{电荷量 q}\]</span></p><blockquote><p><strong>注意</strong>：电动势的方向被规定为从电源内部的<strong>负极</strong>指向<strong>正极</strong>，即与电源两端电压的方向相反。</p></blockquote><h4 id="电功率">电功率</h4><p><strong>电功率</strong>是指电流在单位时间内所做的功，其值等于电压<span class="math inline">\(U\)</span>（伏特）与电流 <span class="math inline">\(I\)</span>（安培）的乘积，通常采用字母<strong>P</strong>表示，单位为<strong>瓦特</strong>，简称为<strong>瓦</strong><code>W</code>：</p><p><span class="math display">\[电功率 P = 电压 U \times 电流 I\]</span></p><blockquote><p><strong>注意</strong>：<strong>额定功率</strong>是指用电器在长时间稳定工作的情况下，所需要耗费的功率。</p></blockquote><h4 id="电功">电功</h4><p>电流所做的功称为<strong>电功</strong>，电流做功的过程就是电能转换为其它形式能量的过程。电流在某段电路上所做的功，等于该电路两端的<strong>电压</strong><code>U</code>（伏特）与通过<strong>电流</strong><code>I</code>（安培）以及通电<strong>时间</strong><code>t</code>（秒）的乘积，通常采用字母 W进行表示，单位为<strong>焦耳</strong> <code>J</code>：</p><p><span class="math display">\[电功 W = 电压 U \cdot 电流 I \cdot 时间 t\]</span></p><p>由于<strong>焦耳</strong>的单位较小，家庭用电通常使用<strong>度</strong>作为电功的计量单位。<code>1</code>度电就是功率为 <code>1</code> 千瓦的用电设备运行 <code>1</code>小时所消耗的电能：</p><p><span class="math display">\[1 度 = 1 千瓦 \cdot 时 = 1 kW \cdot h\]</span></p><p>电功的<strong>度</strong>与<strong>焦耳</strong>两个单位的换算关系如下面公式所示：</p><p><span class="math display">\[1 度 = 1000 瓦 \times 3600 秒 = 3.6 \times 10^6 焦\]</span></p><h3 id="电阻">电阻</h3><h4 id="电阻定义">电阻定义</h4><p><strong>电阻</strong>元件的基本特征是消耗电能，通常采用字母<strong>R</strong> 进行表示，对应的电路符号如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/2.png"></p><p>电阻值的单位是<strong>欧姆</strong><code>Ω</code>，除此之外，常用的单位还有：</p><p><span class="math display">\[1 MΩ = 10^3 kΩ = 10^6 Ω\]</span></p><h4 id="电阻定律">电阻定律</h4><p>导体的电阻与材料的<strong>电阻率</strong> <span class="math inline">\(\rho\)</span>（欧米 <span class="math inline">\(Ω\cdot m\)</span>），以及<strong>长度</strong> <span class="math inline">\(L\)</span>（米 <span class="math inline">\(m\)</span>），<strong>横截面积</strong> <span class="math inline">\(S\)</span>（平方米 <span class="math inline">\(m^2\)</span>）有关：</p><p><span class="math display">\[电阻 R = 电阻率 \rho \cdot \frac{长度 L}{横截面积 S}\]</span></p><p>金属材料的电阻率与温度相关，温度越高电阻率越大，下面表格是几种常见金属材料在<code>20°C</code> 左右的电阻率：</p><table><colgroup><col style="width: 11%"><col style="width: 38%"><col style="width: 11%"><col style="width: 38%"></colgroup><thead><tr class="header"><th style="text-align: center;">金属材料</th><th style="text-align: center;">电阻率 <span class="math inline">\(\rho\)</span>（<span class="math inline">\(Ω \cdotm\)</span>）</th><th style="text-align: center;">金属材料</th><th style="text-align: center;">电阻率 <span class="math inline">\(\rho\)</span>（<span class="math inline">\(Ω \cdotm\)</span>）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>金</strong></td><td style="text-align: center;"><span class="math inline">\(2.44 \times10^{-8}\)</span></td><td style="text-align: center;"><strong>铝</strong></td><td style="text-align: center;"><span class="math inline">\(2.82 \times10^{-8}\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>银</strong></td><td style="text-align: center;"><span class="math inline">\(1.59 \times10^{-8}\)</span></td><td style="text-align: center;"><strong>钨</strong></td><td style="text-align: center;"><span class="math inline">\(5.6 \times10^{-8}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>铜</strong></td><td style="text-align: center;"><span class="math inline">\(1.72 \times10^{-8}\)</span></td><td style="text-align: center;"><strong>铁</strong></td><td style="text-align: center;"><span class="math inline">\(10.0 \times10^{-8}\)</span></td></tr></tbody></table><h4 id="可变电阻">可变电阻</h4><p>阻值可以改变的电阻称为<strong>可变电阻</strong>，或者<strong>电位器</strong>，其内部主要有<strong>限流</strong>和<strong>分压</strong>2 种连接形式：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/3.png"></p><blockquote><p><strong>注意</strong>：<strong>限流连接方式</strong>移动滑片<strong>P</strong> 可以控制负载 <strong>R</strong>上的<strong>电流</strong>；而 <strong>分压连接方式</strong>：移动滑片<strong>P</strong> 可以控制负载 <strong>R</strong>上的<strong>电压</strong>。</p></blockquote><h4 id="电阻串并联">电阻串并联</h4><p><strong>电阻串联</strong>之后的总电阻等于各个电阻的<strong>阻值之和</strong><span class="math inline">\(R = R_1 + R_2 + R_3\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/4.png"></p><p><strong>电阻并联</strong>之后的总电阻等于各个电阻<strong>阻值的倒数之和</strong><span class="math inline">\(\frac{1}{R} = \frac{1}{R_1} + \frac{1}{R_2}+ \frac{1}{R_3}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/5.png"></p><h3 id="电容器">电容器</h3><h4 id="电容">电容</h4><p>两片平行金属板中间夹上电介质就可以组成最为简单的<strong>电容器</strong>，其电路符号如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/7.png"></p><p>平行板电容器的电容 <span class="math inline">\(C\)</span>可以通过下面的公式计算得到：</p><p><span class="math display">\[C = \frac{介电常量 \epsilon \times 正对面积 S}{4 \pi \times 静电力常量 k\times 极板之间距离 d}\]</span></p><p>电容器所携带的<strong>电荷量</strong> <code>Q</code>与其两极之间的<strong>电势差</strong> <code>U</code>的比值称为该电容器的<strong>电容</strong>值，即一个用于表征电容器容纳电荷能力的物理量：</p><p><span class="math display">\[电容 C = \frac{电荷量 Q}{电势差 U}\]</span></p><p>国际单位制当中，电容的单位是<strong>法拉</strong>，简称<strong>法</strong><code>F</code>，常用的单位还有<strong>微法</strong>（<span class="math inline">\(\mu F\)</span>）、<strong>纳法</strong>（<span class="math inline">\(nF\)</span>）、<strong>皮法</strong>（<span class="math inline">\(pF\)</span>）：</p><p><span class="math display">\[1 F = 10^6 \mu F = 10^9 nF = 10^{12} pF\]</span></p><p>普通电容器通常没有极性，而<strong>电解电容</strong>在使用时需要区分正负极，其电路符号如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/8.png"></p><blockquote><p><strong>注意</strong>：电解电容的优点在于价格便宜，容值较大；但是同时也有体积较大，温度稳定性比较差的缺点。</p></blockquote><p>由于电路的分布特点而具有的电容称为<strong>分布电容</strong>，例如线圈的相邻两匝之间、两个分立的元件之间、两根相邻的导线之间，都会存在着一定的分布电容。其对于电路的影响，等效于<strong>为电路并联上一个电容器</strong>。低频交流电路当中，分布电容的容抗较大，对于电路影响较小。而对于高频交流电路，分布电容带来的影响则不能忽略。</p><h4 id="电容器特性">电容器特性</h4><p>电容器的特点主要体现在其所具备的<strong>通交隔直</strong>方面：</p><ul><li><strong>隔直特性</strong>：刚开始对电容进行充电时，电路上会出现流动的电流；但是当电容充满以后，直流电流就会停止流动；</li><li><strong>通交特性</strong>：伴随交流电源正负半周的不断更替，电容器被不断的充放电，从而呈现出交流信号近似于通过了的效果；</li></ul><p>电容器的通交和隔直特性通常同时体现，例如下图所示电路，<strong>输入信号</strong><span class="math inline">\(U_i\)</span>是一个含有直流分量的交流信号，而<strong>输出信号</strong> <span class="math inline">\(U_o\)</span>当中只存在交流成份，直流成分已经被电容器所滤除：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/9.png"></p><p>除此之外，电容还具有<strong>储能特性</strong>和<strong>两端电压不会突变</strong>的特性：</p><ul><li><strong>储能特性</strong>：理想电容器只会存储电荷，但是也会伴随相应的能量损耗；</li><li><strong>两端电压不会突变</strong>：电容器充放电时，两端电压会呈现出曲线变化，而并不会突然的发生改变；</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-1/10.png"></p><h4 id="电容器的容抗">电容器的容抗</h4><p><strong>容抗</strong>表征的是电容器对于<strong>交流信号</strong>的阻碍作用，其单位为<strong>欧姆</strong><code>1Ω</code>，容抗值 <span class="math inline">\(X_C\)</span>与<strong>交流信号的频率</strong> <span class="math inline">\(f\)</span>以及<strong>电容器容量</strong> <span class="math inline">\(C\)</span>相关：</p><p><span class="math display">\[容抗 X_C = \frac{1}{2 \pi \cdot 频率 f \cdot 电容 C}\]</span></p><blockquote><p><strong>注意</strong>：通过上述公式可以发现：当电容值恒定时，频率越高容抗越小；而当频率一定时，电容越大容抗越小。而对于频率<span class="math inline">\(f = 0\)</span> 的直流信号，电容的容抗 <span class="math inline">\(X_C \rightarrow\infty\)</span>，即相当于<strong>断路</strong>。</p></blockquote><h4 id="电容器的串并联">电容器的串并联</h4><p>电容器在使用时，经常会遇到容值不够，或者耐压能力不足的问题，此时就需要将电容器串联或者并联起来使用。当<strong>电容器串联</strong>使用时，虽然容值会减少，但是可以提升耐压值。而<strong>电容器并联</strong>使用时，虽然增大了容值，但是耐压值并没有发生变化。</p><h5 id="无极性电容串联">无极性电容串联</h5><p>将多个<strong>无极性电容器</strong>首尾相连，就可以组成如下的电容串联电路：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/11.png"></p><p><strong>无极性电容</strong>串联之后，相当于只有最外层的两个极板才可以感应到电荷，并且两个极板之间距离也被增大，此时总电容的倒数等于各个电容器的倒数之和，即总电容值<strong>小于</strong>每一个串联电容的值，但是<strong>耐压值</strong>却得到了提高：</p><p><span class="math display">\[\frac{1}{C} = \frac{1}{C_1} + \frac{1}{C_2} + \frac{1}{C_3}\]</span></p><p>对于下面这个由电容器 <span class="math inline">\(C_1\)</span> 和<span class="math inline">\(C_2\)</span> 构成的串联分压电路：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/12.png"></p><p>电容器 <span class="math inline">\(C_1\)</span> 的容抗 <span class="math inline">\(X_{C1} = \frac{1}{2 \pi f C_1}\)</span>，而 <span class="math inline">\(C_2\)</span> 的容抗 <span class="math inline">\(X_{C2} = \frac{1}{2 \pi fC_2}\)</span>，进而通过分析以后可以得出如下结论：</p><ol type="1"><li>类似于电阻的串联，电容器 <span class="math inline">\(C_1\)</span> 和<span class="math inline">\(C_2\)</span> 上的信号幅度之和 <span class="math inline">\(U_1 + U_2\)</span> 等于输入信号幅度 <span class="math inline">\(U_i\)</span>；</li><li>容值较大的电容，由于容抗较小，两端的<strong>电压降</strong>也会相对较小；而容值较小的电容，由于容抗较大，两端的<strong>电压降</strong>也会相对更大；</li><li>如果一个串联电容的容值，远远大于其它电容，则该电容可以视为<strong>通路</strong>，此时起决定性作用的是容值较小的电容器；</li></ol><h5 id="有极性电容串联">有极性电容串联</h5><p><strong>有极性电容器</strong>（电解电容）的串联，分为<strong>顺序串联</strong>和<strong>逆序串联</strong>两种情况。</p><p><strong>顺序串联</strong>是指 <span class="math inline">\(C_1\)</span> 的负极与 <span class="math inline">\(C_2\)</span>的正极相连，这种串联方式可以提高电容器的耐压值。即当 <span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(C_2\)</span>的容值与耐压值都相等时，串联以后的电容 <span class="math inline">\(C\)</span> 只有 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 的一半，但是耐压值却要比 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 大上一倍。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/13.png"></p><p><strong>逆序串联</strong>是指将电容器 <span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(C_2\)</span>的<strong>正极</strong>或者<strong>负极</strong>相互连接在一起，有极性电容在逆序串联之后不会再具有极性，因而可以作为<strong>无极性电容</strong>来使用：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/14.png"></p><h5 id="电容并联">电容并联</h5><p><strong>电容并联</strong>是指将电容器的正极与负极分别进行连接：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/15.png"></p><p>由于电容并联之后，相当于增大了金属极板的面积，所以并联之后的容值等于各个电容的容值之和，不过此时<strong>耐压值</strong>并未得到提高：</p><p><span class="math display">\[C = C_1 + C_2 + C_3\]</span></p><p>电容并联之后所形成的电路，主要具有如下三个特点：</p><ol type="1"><li>各条支路的电流之和等于总电流，<strong>电容大的支路，由于容抗更小，所以电流更大</strong>，反之亦然；</li><li>并联之后各个电容器上的<strong>电压值相等</strong>，这是并联电路的共性；</li><li>电容并联之后的电路，如果一个电容的容值远大于其它电容，那么该电容器可以视为<strong>开路</strong>，起决定性作用的是容值更大的那个电容器；</li></ol><h5 id="常用电容并联电路">常用电容并联电路</h5><p><strong>一个较大容值的电容与一个较小容值的电容并联</strong>：将一个容值较大的电容器（例如电解电容）与一个容值较小的电容器（例如瓷片电容）并联在一起，大电容主要工作在低频状态，高频状态下虽然其容抗几乎为零，但是呈现出的感抗却非常大，此时总的阻抗依然会较大，所以<strong>大电容在高频情况下的阻抗会大于低频时的阻抗</strong>，主要用于滤除低频干扰信号。而并联的小电容则主要工作在高频状态，由于几乎不会存在感抗，所以<strong>小电容对于高频信号的容抗相对较小</strong>，高频干扰信号可以被有效的引入大地。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/16.png"></p><p><strong>两个相同容值的电容并联</strong>：除了增加容值，减小安装体积之外，还可以提高电路的可靠性，即使其中一个电容开路，另外一个电容也可以让电路正常工作。除此之外，由于容值较小的电容，漏电流相对较小，因此并联之后可以避免更大容值电容器所带来的较大漏电流。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-1/17.png"></p><p>如果并联的两个相同容值电容器 <span class="math inline">\(C_1\)</span>和 <span class="math inline">\(C_2\)</span>分别采用<strong>正温度系数电容器</strong>（例如聚酯电容）和<strong>负温度系数电容器</strong>（例如聚丙烯电容），当外界环境温度发生变化时，两个电容的容值会呈现出此消彼长的关系，从而保持总电容<span class="math inline">\(C = C_1 + C_2\)</span> 的基本恒定。</p><h2 id="基本定律">基本定律</h2><h3 id="欧姆定律">欧姆定律</h3><p><strong>欧姆定律</strong>表述了电路当中的电流，如何由电压和电阻来决定。即导体上的<strong>电流</strong><span class="math inline">\(I\)</span>（安培），与导体两端的<strong>电压</strong><span class="math inline">\(U\)</span>（伏特）成正比，与导体的<strong>电阻</strong><span class="math inline">\(R\)</span>（欧姆）成反比：</p><p><span class="math display">\[电流 I = \frac{电压 U}{电阻 R}\]</span></p><p><strong>伏安特性曲线</strong>是导体当中<code>电压</code>与<code>电流</code>的关系曲线，其中<strong>纵轴</strong>表示电流<span class="math inline">\(I\)</span>，而<strong>横轴</strong>表示电压<span class="math inline">\(U\)</span>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-2/1.png"></p><blockquote><p><strong>注意</strong>：如果元件的伏安特性体现为经过<strong>原点</strong>的一条直线，那么这样的元件就称为<strong>线性元件</strong>。</p></blockquote><h3 id="焦耳定律">焦耳定律</h3><p><strong>焦耳定律</strong>反映了<strong>电能</strong>与<strong>热能</strong>之间的转换关系，即电流通过导体产生的<strong>热量</strong><span class="math inline">\(Q\)</span>（焦耳），与通过<strong>电流</strong><span class="math inline">\(I\)</span>（安培）的二次方成正比，与导体的<strong>电阻</strong><span class="math inline">\(R\)</span>（欧姆）成正比，与通电<strong>时间</strong><span class="math inline">\(t\)</span>（秒）成正比：</p><p><span class="math display">\[热量 Q  = 电流 I^2 \times 电阻 R \times 时间 t\]</span></p><p><strong>焦耳</strong>简称<strong>焦</strong><code>J</code>，是<strong>能量</strong>和<strong>做功</strong>的国际单位，其值等于<code>1</code> 瓦的功率在 <code>1</code> 秒内所做的功 <span class="math inline">\(1 焦=1 瓦·秒\)</span>。</p><h3 id="闭合电路欧姆定律">闭合电路欧姆定律</h3><p>把<strong>电源</strong>接入电路就会形成一个有电流通过的<strong>闭合电路</strong>，可以将闭合电路视为如下两个组成部分：</p><ol type="1"><li>电源内部的电路，简称为<strong>内电路</strong>，内电路的电阻称为<strong>内电阻</strong>；</li><li>电源外部的电路，简称为<strong>外电路</strong>，外电路的电阻称为<strong>外电阻</strong>；</li></ol><p><img src="/Electronics/Introduct_Analysis/Chapter-2/2.png"></p><p>根据能量守恒定律，电源<strong>内电路提供的电能</strong>为 <span class="math inline">\(W\)</span>，等于<strong>外电路消耗的电能</strong><span class="math inline">\(W_1\)</span>与<strong>内电路消耗的电能</strong> <span class="math inline">\(W_2\)</span> 之和：</p><p><span class="math display">\[内电路提供的电能 W = 外电路消耗的电能 W_1 + 内电路消耗的电能 W_2\]</span></p><p>假设闭合电路当中通过的<strong>电流</strong>为 <span class="math inline">\(I\)</span>，<strong>内电阻</strong>为 <span class="math inline">\(r\)</span>，<strong>外电阻</strong>为 <span class="math inline">\(R\)</span>，结合上述方程与焦耳定律、电动势的定义就可以推导得到：</p><p><span class="math display">\[电流 I = \frac{电源电动势 E}{外电阻 R + 内电阻 r}\]</span></p><p>即闭合电路当中的<strong>电流</strong> <span class="math inline">\(I\)</span> 与电源的<strong>电动势</strong> <span class="math inline">\(E\)</span> 成正比，与<strong>内外电阻之和</strong><span class="math inline">\(R + r\)</span>成反比，这就是<strong>闭合电路的欧姆定律</strong>。</p><h3 id="基尔霍夫定律">基尔霍夫定律</h3><p>引入基尔霍夫定律之前，需要介绍几个与之相关的概念，下面电路当中的<span class="math inline">\(U_1\)</span> 和 <span class="math inline">\(U_2\)</span> 分别为电压源：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-2/3.png"></p><ol type="1"><li><strong>支路</strong>：含有元件的分支，上图电路拥有 <span class="math inline">\(acb\)</span>、<span class="math inline">\(adb\)</span>、<span class="math inline">\(R_L\)</span> 三条支路，其中含有电源的 <span class="math inline">\(acb\)</span>、<span class="math inline">\(adb\)</span>称为<strong>有源支路</strong>，而不含电源的 <span class="math inline">\(R_L\)</span> 称为<strong>无源支路</strong>；</li><li><strong>结点</strong>：三条或者以上支路的联结点，上图电路拥有 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 两个结点；</li><li><strong>回路</strong>：多条支路构成的闭合路径，上图电路拥有 <span class="math inline">\(acbda\)</span>、<span class="math inline">\(adbR_L a\)</span>、<span class="math inline">\(acb  R_L a\)</span>三条回路；</li><li><strong>网孔</strong>：没有被支路分割的回路，上图电路拥有 <span class="math inline">\(acbda\)</span>、<span class="math inline">\(adbR_L a\)</span> 两个网孔；</li></ol><p><strong>基尔霍夫电流定律（KCL）</strong>：电路当中任意一个结点流出的电流，等于流入结点的电流之和：</p><p><span class="math display">\[\sum I_{流入} = \sum I_{流出}\]</span></p><p>使用基尔霍夫电流定律 KCL 列写电路方程的步骤如下所示：</p><ol type="1"><li>首先，选定<strong>结点</strong>；</li><li>然后，标识出各条支路的<strong>参考方向</strong>；</li><li>最后，针对该结点列写并且求解 <strong>KCL 方程</strong>；</li></ol><p>基尔霍夫电流定律不仅适合于电路当中的任意一个结点，同样也适用于电路当中的任意一个闭合面，这个闭合面被称为<strong>广义结点</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-2/4.png"></p><p>例如上图当中的 <code>A</code>、<code>B</code>、<code>C</code>三个结点所形成的三角形电路，就可以视为一个广义结点：</p><p><span class="math display">\[\begin{cases}I_A = I_{AB} - I_{CA} \\I_B = I_{BC} - I_{AB} \\I_C = I_{CA} - I_{BC}\end{cases}\impliesI_A + I_B + I_C = 0\implies\sum I = 0\]</span></p><p><strong>基尔霍夫电压定律（KVL）</strong>：沿着电路当中任意一条回路，按照指定方向绕行一周，各个部分电压的代数和恒等于零。</p><p><span class="math display">\[\sum U = 0\]</span></p><p>使用基尔霍夫电压定律 KVL 列写电路方程的步骤如下所示：</p><ol type="1"><li>首先，选定<strong>回路</strong>，并且标识出回路绕行的方向；</li><li>然后，标识出各个支路电流、电压源的<strong>参考方向</strong>；</li><li>最后，针对该回路列写并且求解 <strong>KVL 方程</strong>；</li></ol><blockquote><p><strong>注意</strong>：基尔霍夫电压定律 KVL还可以推广应用于任意的<strong>开口电路</strong>。</p></blockquote><p>▶【例题】求解下面电路的开口电压 <span class="math inline">\(U_{ab}\)</span> ？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-2/5.png"></p><p>◉【解答】首先，标识出上面电路开口电压 <span class="math inline">\(U_{ab}\)</span> 的参考方向，假设 <span class="math inline">\(U_{ab}\)</span> 分别与支路 <code>a</code> 和<code>b</code>组成一个闭合回路；然后，绘制出电路的绕行方向，并且取电压升为<strong>正</strong>，电压降为<strong>负</strong>；最后，就可以利用KVL 列写出如下的关系式：</p><p><span class="math display">\[U_S - I R_S - U_{ab} = 0\impliesU_{ab} = U_S - IR_S\]</span></p><h2 id="电阻电路等效变换">电阻电路等效变换</h2><h3 id="等效电位法">等效电位法</h3><p>利用<strong>等电位法</strong>求解等效电路的步骤如下所示：</p><ol type="1"><li><strong>标识等电位点</strong>：依次找出各个等电位点，然后由<code>高电位</code>到<code>低电位</code>，采用英文字母逐个进行标识；</li><li><strong>结合等势点绘制草图</strong>：合并电位相同的<code>等电位点</code>，并且逐一理清各个电阻连接的关系；</li><li><strong>整理电路图</strong>：将草图上面等效电路的等势点、元件编号与原理图逐一对应；</li></ol><p>下面<strong>左侧</strong>为原始的原理图，<strong>右侧</strong>为利用等电位法分析之后得到的等效电路：</p><p>▶【例题】下图左侧电路当中 <span class="math inline">\(R_1 = R_2 = R_3= 3Ω\)</span>，<span class="math inline">\(R_4 = R_5 = R_6 =6Ω\)</span>，求解 <code>E</code> 与 <code>F</code> 两端的电阻？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/1.png"></p><p>◉【解答】标识出原电路上的等势点<code>a</code>、<code>b</code>、<code>c</code>，从高电势点 <span class="math inline">\(E\)</span> 开始，首先将两个 <code>a</code>点合并到一起，理顺电阻之后，标识电流在 <code>a</code>点的去向，即分别经过 <span class="math inline">\(R_1\)</span>、<span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span> 流向 <code>b</code>点；然后理顺电阻并标识电流在 <code>b</code> 点的去向，即分别经过 <span class="math inline">\(R_4\)</span>、<span class="math inline">\(R_5\)</span>、<span class="math inline">\(R_6\)</span> 流向 <code>c</code> 点，最后流出<code>F</code> 点。根据上图右侧的等效电路，就可以计算得到 <code>E</code>与 <code>F</code> 两端的电阻 <span class="math inline">\(R =3Ω\)</span>。</p><p>▶【例题】下图左侧电路当中 <span class="math inline">\(R_1 = R_3 =4Ω\)</span>，<span class="math inline">\(R_2 = R_5 = 1Ω\)</span>，<span class="math inline">\(R_4 = R_6 = R_7 = 2Ω\)</span>，求解 <code>a</code>与 <code>b</code> 两点之间的电阻？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/2.png"></p><p>◉【解答】标识出原电路上的等势点<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>，首先合并等势点<code>a</code>，电流从 <code>a</code> 点开始分为三路，分别经 <span class="math inline">\(R_2\)</span> 流向 <code>b</code> 点，经 <span class="math inline">\(R_3\)</span> 和 <span class="math inline">\(R_1\)</span> 流向 <code>d</code>点；然后合并等势点 <code>b</code>，电流从 <code>b</code>点开始分为两路，分别经过 <span class="math inline">\(R_5\)</span> 和<span class="math inline">\(R_4\)</span> 流向 <code>c</code> 点和<code>d</code> 点；最后合并等势点 <code>c</code>，电流从 <code>c</code>点也分为两路，分别经过 <span class="math inline">\(R_6\)</span> 和 <span class="math inline">\(R_7\)</span> 流向 <code>d</code>点；根据上图右侧的等效电路，就可以计算得到 <code>a</code> 与<code>b</code> 两点之间的电阻 <span class="math inline">\(R =1Ω\)</span>。</p><p>▶【例题】下图左侧电路当中 <span class="math inline">\(R_1 = R_2 = R_3= R_4 = R_5 = 30Ω\)</span>，求解 <code>a</code> 与 <code>b</code>两点之间的电阻？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/3.png"></p><p>◉【解答】标识出原电路上的等势点<code>a</code>、<code>b</code>、<code>c</code>，从高电势点 <span class="math inline">\(a\)</span> 开始，标识出电流在 <code>a</code>的去向，即分别经过 <span class="math inline">\(R_1\)</span>、<span class="math inline">\(R_2\)</span> 流向 <code>b</code> 点，以及分别经过<span class="math inline">\(R_4\)</span>、<span class="math inline">\(R_3\)</span> 流向 <code>c</code> 点；接下来，合并<code>c</code> 点之后理顺电阻，并且标识出电流在 <code>c</code>点的去向，即经过 <span class="math inline">\(R_5\)</span> 流向<code>b</code> 点；根据上图右侧的等效电路，就可以计算得到 <code>a</code>与 <code>b</code> 两点之间的电阻 <span class="math inline">\(R =11.25Ω\)</span>。</p><h3 id="对称电路的等效">对称电路的等效</h3><p><strong>对称电路</strong>是一种能够<code>上下</code>或<code>左右</code>进行对称的电路，这种对称既体现在电路结构上，也体现在元件参数上，并且<strong>对称结点的电位相等，对称支路上的电流相同</strong>。</p><h4 id="折叠法">折叠法</h4><p>化简对称电路可以采用<strong>折叠法</strong>，即将电路的对称部分重合起来，然后求解等效电阻，并最终得到一个被精简掉一半的电路。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/4.png"></p><p>以上图左侧电路的 <code>AOB</code>作为<strong>折叠线</strong>，由于各条之路均为 2个电阻的串联，所以等效之后采用 <span class="math inline">\(\frac{3\times 3}{3 + 3} = 1.5Ω\)</span>电阻代替，进而最终得到右侧的等效电路。</p><h4 id="短路法">短路法</h4><p>如果相同电位 2个结点之间的<strong>电位差</strong>为零，那么就可以将这 2个结点视为直接<strong>短路</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/5.png"></p><p>根据电路的对称性，前述电路当中的 <code>C、D</code> 和<code>E、F</code>分别为等电位点，可以直接对其进行短路处理。这样并不会改变各个结点的电位和各条支路上的电流分布，从而最终得到上图右侧的等效电路。</p><h4 id="断开法">断开法</h4><p>由于对称电路位于对称轴上的结点具有特殊性质，可以将其与联结该结点的对称支路断开，这种对称电路的等效方法称为<strong>断开法</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/6.png"></p><p>断开前述电路在对称轴上的结点 <span class="math inline">\(O\)</span>，得到 <span class="math inline">\(CO&#39;E\)</span> 和 <span class="math inline">\(DO&#39;&#39;F\)</span> 两条支路，其中 <span class="math inline">\(O&#39;\)</span> 与 <span class="math inline">\(O&#39;&#39;\)</span>为等电位点，这样同样不会改变电路上各个结点的电位以及各条支路上的电流分布。</p><h3 id="惠斯通电桥">惠斯通电桥</h3><p>可以将电阻 <span class="math inline">\(R_1\)</span>、<span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span>、<span class="math inline">\(R_4\)</span> 和内阻为 <span class="math inline">\(R_5\)</span>的<strong>检流计</strong>（一种用于高精度测量电流大小的仪器）连接成如下的<strong>惠斯通电桥</strong>电路，该电路拥有4 个桥臂 <span class="math inline">\(R_1\)</span>、<span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span>、<span class="math inline">\(R_4\)</span>；当这 4 个桥臂的电阻乘积相等时 <span class="math inline">\(R_1 \times R_2 = R_3 \timesR_4\)</span>，检流计的读数为零，这种状态称为电桥的<strong>平衡状态</strong>，相应的<span class="math inline">\(R_1 \times R_2 = R_3 \times R_4\)</span>就被称为电桥的<strong>平衡条件</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/7.png"></p><p>当电桥处于平衡状态时，检流计显示 <code>CD</code> 支路的电流为零，说明2个结点的电位相等，可以将其直接进行<strong>短路</strong>连接，这样并不会改变电路当中各个结点的<strong>电位</strong>和支路<strong>电流</strong>的分布，此时<code>A</code>、<code>B</code> 点之间的<strong>输入电阻</strong> <span class="math inline">\(R_{AB} = (R_1 // R_2) + (R_3 // R_4) = \frac{R_1R_2}{R_1 + R_2} + \frac{R_3 R_4}{R_3 + R_4}\)</span></p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/8.png"></p><p>除此之外，在电桥平衡时，由于 <code>CD</code>支路的电流为零，所以也可以对其进行开路处理，虽然同样不会改变电路当中各个结点的<strong>电位</strong>和支路<strong>电流</strong>分布，但是此时<code>A</code>、<code>B</code> 点之间的<strong>输入电阻</strong>发生了变化 <span class="math inline">\(R_{AB} = \frac{(R_1 + R_2) + (R_3+ R_4)}{R_1 + R_2 + R_3 + R_4} = \frac{R_1 R_2 + R_1 R_4 + R_2 R_3 + R_3R_4}{R_1 + R_2 + R_3 + R_4}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/9.png"></p><blockquote><p><strong>总结</strong>：当电桥处于平衡状态时，如果将同电位的两个结点短路，可以使得原电路<strong>减少一个结点</strong>；而如果将同电位的两个结点开路，则可以使得原电路<strong>减少一个回路</strong>；这两种方法都可以用于求取<code>A</code> 和 <code>B</code>两点之间的等效电阻，可以酌情选择使用。如果电桥不满足平衡条件，就不能采取上述方法进行等效电路的求解。</p></blockquote><p>▶【例题】求解下图左侧电路 <code>A</code> 与 <code>B</code>之间的输入电阻？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/10.png"></p><p>◉【解答】由于上图最左侧的电桥电路，满足 <span class="math inline">\(10Ω \times 15Ω = 5Ω \times 30Ω\)</span>的电桥平衡条件，这里可以先将它转换为中间的电路形式，然后将<code>CD</code>支路断开，从而得到最右侧的等效电路。根据该等效电路上各个电阻之间的串并联关系，就可以轻松的求解得到<code>A</code> 与 <code>B</code> 两点之间的等效电阻 <span class="math inline">\(R_{AB}\)</span>：</p><p><span class="math display">\[R_{AB} = [(5+15) // (10+30)] // 15 = \frac{120}{17} Ω\]</span></p><h3 id="外加电源法">外加电源法</h3><p>不含有<code>电源</code>的电阻电路又称为<strong>无源二端网络</strong>，求解无源二端网络的<strong>输入电阻</strong>时，可以在下图所示电路的<code>A</code>、<code>B</code> 端施加电压 <span class="math inline">\(V\)</span>（该电压值可以随意选取，但是为了计算方便，通常选取整数，并且数值不要太大）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/11.png"></p><p>根据基尔霍夫定律求解出电流 <span class="math inline">\(I\)</span>，此时 <code>A</code>、<code>B</code>端之间的输入电阻为：</p><p><span class="math display">\[R_{AB} = \frac{V}{I}\]</span></p><p>▶【例题】求解下图左侧电路 <code>A</code> 与 <code>B</code>之间的输入电阻？</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/12.png"></p><p>◉【解答】向上图左侧的无源二端网络上施加 <code>10V</code>电压，并且假设各条支路的电流分别为 <span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span>、<span class="math inline">\(I_3\)</span>、<span class="math inline">\(I_4\)</span>，从而能够得到右侧的等效电路，然后根据基尔霍夫定律就可以求解得到：</p><p><span class="math display">\[R_{AB} = \frac{V}{I} = \frac{V}{I_1 + I_2 + I_4} = \frac{10V}{2A} = 5Ω\]</span></p><h3 id="星形与三角形连接等效">星形与三角形连接等效</h3><p>将 <span class="math inline">\(R_{ab}\)</span>、<span class="math inline">\(R_{bc}\)</span>、<span class="math inline">\(R_{ca}\)</span>三个电阻按照如下方式联结，就可以构成 <span class="math inline">\(\Delta\)</span> 型或者 <span class="math inline">\(\pi\)</span> 型联结：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/13.png"></p><p>而将 <span class="math inline">\(R_{ab}\)</span>、<span class="math inline">\(R_{bc}\)</span>、<span class="math inline">\(R_{ca}\)</span> 三个电阻按照以下方式联结，则构成<span class="math inline">\(Y\)</span> 型或者 <span class="math inline">\(T\)</span> 型联结：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/14.png"></p><p>对于外电路而言，在确保每个结点的电流、电位保持不变的前提下，上述的两种联结方式可以进行等效互换：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-3/15.png"></p><p>上图左侧为 <span class="math inline">\(\Delta\)</span> 型或者 <span class="math inline">\(\pi\)</span> 型联结 ──➔ <span class="math inline">\(Y\)</span> 型或者 <span class="math inline">\(T\)</span> 型联结：</p><p><span class="math display">\[Y形电阻 = \frac{\Delta 形相邻电阻乘积}{\Delta 形电阻之和}\implies\begin{cases}R_a = \frac{R_{ab} \cdot R_{ca}}{R_{ab} + R_{bc} + R_{ca}} \\R_b = \frac{R_{ab} \cdot R_{bc}}{R_{ab} + R_{bc} + R_{ca}} \\R_a = \frac{R_{ca} \cdot R_{ca}}{R_{ab} + R_{bc} + R_{ca}}\end{cases}\]</span></p><p>上图右侧为 <span class="math inline">\(Y\)</span> 型或者 <span class="math inline">\(T\)</span> 型联结 ──➔ <span class="math inline">\(\Delta\)</span> 型或者 <span class="math inline">\(\pi\)</span> 型联结：</p><p><span class="math display">\[\Delta 形电阻 = \frac{Y 形电阻两两乘积之和}{Y 型不相邻电阻}\implies\begin{cases}R_{ab} = \frac{R_a R_b + R_b R_c + R_c R_a}{R_c} \\R_{bc} = \frac{R_a R_b + R_b R_c + R_c R_a}{R_a} \\R_{ca} = \frac{R_a R_b + R_b R_c + R_c R_a}{R_b}\end{cases}\]</span></p><h2 id="电压源-电流源">电压源 &amp; 电流源</h2><p>电源存在两种等效形式，一种以输出<strong>电压</strong>为主要特征，称为<strong>电压源</strong>；另外一种以输出<strong>电流</strong>为主要特征，称为<strong>电流源</strong>。</p><h3 id="电压源">电压源</h3><p><strong>实际的电压源</strong>由内阻 <span class="math inline">\(R_S\)</span> 与电压源 <span class="math inline">\(U_S\)</span> 串联而成，下图右侧当中的 <span class="math inline">\(R_L\)</span> 为负载电阻，<span class="math inline">\(I\)</span>为电源向负载输出的电流，此时实际电源两端的电压 <span class="math inline">\(U = U_S - IR_S\)</span>，即电压源两端的电压 <span class="math inline">\(U\)</span> 与负载电流 <span class="math inline">\(I\)</span>呈线性关系，可以表示为下图右侧的<strong>直线</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-4/1.png"></p><blockquote><p><strong>注意</strong>：这条由电源端电压 <span class="math inline">\(U\)</span> 伴随输出电流 <span class="math inline">\(I\)</span>变化的伏安特性曲线，称为电压源的<strong>外特性曲线</strong>，简称为<strong>外特性</strong>。可以看到，当负载电流<span class="math inline">\(I\)</span>增大时，电压源内阻的压降也会增大，而电压源的端电压则随之下降。</p></blockquote><p><strong>理想的电压源</strong>忽略了电压源的内阻 <span class="math inline">\(R_S = 0\)</span>，此时根据 <span class="math inline">\(U = U_S - IR_S\)</span> 可以推导得到 <span class="math inline">\(U = U_S\)</span>，外电压 <span class="math inline">\(U\)</span> 的大小与负载 <span class="math inline">\(R_L\)</span> 无关，对应的外特性曲线为一条平行于<span class="math inline">\(I\)</span> 轴的直线：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-4/2.png"></p><h3 id="电流源">电流源</h3><p><strong>实际的电流源</strong>是由内阻 <span class="math inline">\(R_S\)</span> 与电流源 <span class="math inline">\(I_S\)</span> 并联而成，下图右侧中的 <span class="math inline">\(R_L\)</span> 为负载电阻，这里 <span class="math inline">\(I\)</span> 依然为电源向负载输出的电流，而 <span class="math inline">\(\frac{U}{R_S}\)</span> 表示电源内阻 <span class="math inline">\(R_S\)</span> 上经过的电流，由此就可以得到关系式<span class="math inline">\(I = I_S -\frac{U}{R_S}\)</span>，即电流源输出的电流 <span class="math inline">\(I\)</span> 与负载 <span class="math inline">\(R_L\)</span> 两端的电压 <span class="math inline">\(U\)</span>呈线性关系，对应的外特性曲线如下图右侧所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-4/3.png"></p><blockquote><p><strong>注意</strong>：实际电流源输出的电流 <span class="math inline">\(I\)</span> 总是小于电流源电流 <span class="math inline">\(I_S\)</span>，实际电流源的内阻通常都非常大。当负载发生变化时，电流源输出电流<span class="math inline">\(I\)</span> 的大小取决于电流源内阻 <span class="math inline">\(R_S\)</span>，其阻值越大分得的电流就越小，电流源的输出就更加稳定。</p></blockquote><p><strong>理想电流源</strong>的内阻 <span class="math inline">\(R_S =\infty\)</span>，根据 <span class="math inline">\(I = I_S -\frac{U}{R_S}\)</span> 可以推导得到 <span class="math inline">\(I =I_S\)</span>，输出电流 <span class="math inline">\(I\)</span>的大小与负载 <span class="math inline">\(R_L\)</span>无关，对应的外特性曲线是一条平行于 <span class="math inline">\(I\)</span> 轴的直线：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-4/4.png"></p><h3 id="电压源-电流源等效变换">电压源 &amp; 电流源等效变换</h3><p>根据实际电压源与电流源的<strong>外特性</strong>方程，可以推导得到能够让两者互换使用的等效变换条件：</p><p><span class="math display">\[\begin{cases}电压源 U = U_S - IR_S \implies  I = \frac{U_S}{R_S} - \frac{U}{R_S} \\电流源 I = I_S - \frac{U}{R_S}\end{cases}\implies 等效变换条件\begin{cases}I_S = \frac{U_S}{R_S} \\U_S = I_S R_S\end{cases}\]</span></p><p>当实际电压源与电流源的<strong>内阻相等</strong>，并且满足 <span class="math inline">\(I_S = \frac{U_S}{R_S}\)</span> 或者 <span class="math inline">\(U_S = I_S R_S\)</span>的<strong>等效变换条件</strong>时，两种电源就可以互换使用。除此之外，进行电压源与电流源的等效变换时，还需要注意如下几点：</p><ol type="1"><li><strong>等效</strong>是指对于电源外电路的等效，而对于电源内部电路并不等效；</li><li>电压源与电流源的<strong>参考方向</strong>一致，即电流源流出电流的一端，需要与电压源的正极相对应；</li><li>变换之后不会影响<strong>未变换部分</strong>各条支路上的<strong>电压</strong>与<strong>电流</strong>分布情况；</li><li>由于理想电压源的内阻 <span class="math inline">\(R_S =0\)</span>，而理想电流源的内阻 <span class="math inline">\(R_S =\infty\)</span>，并不满足等效条件，所以<strong>理想电压源与电流源不能进行等效变换</strong>；</li></ol><h3 id="电源的串并联">电源的串并联</h3><ul><li><strong>电压源的串联</strong>：多个电压源的串联可以等效为一个电压源，其<strong>电压</strong>等于各个电压源电压的代数和，其<strong>内阻</strong>为各个电压源内阻的代数和。</li><li><strong>电流源的并联</strong>：多个电流源的串联可以等效为一个电流源，其<strong>电流</strong>等于各个电流源电流的代数和，其<strong>内阻</strong>为各个电压源内阻的并联值。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-4/5.png"></p><ul><li><strong>电压源的并联</strong>：首先将每个<strong>电压源</strong>变换为等效的<strong>电流源</strong>，然后将这些转换之后的并联<strong>电流源</strong>合并，最后把得到的等效电流源转换回等效<strong>电压源</strong>即可。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-4/6.png"></p><ul><li><strong>电流源的串联</strong>：首先将每个<strong>电流源</strong>变换为等效的<strong>电压源</strong>，然后将这些转换之后的串联<strong>电压源</strong>合并，最后把得到的等效电压源转换回等效<strong>电流源</strong>即可。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-4/7.png"></p><ul><li><strong>电压源与电流源串联</strong>：首先将<strong>电流源</strong>转换为等效的<strong>电压源</strong>，然后再按照<strong>串联电压源</strong>的方式进行处理。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-4/8.png"></p><ul><li><strong>电流源与电压源并联</strong>：首先将<strong>电压源</strong>转换为等效的<strong>电流源</strong>，然后再按照<strong>并联电流源</strong>的方式进行处理。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-4/9.png"></p><blockquote><p><strong>总结</strong>：两个电源并联时，需要将电压源转换为等效的电流源；而当两个电源串联时，则需要将电流源转换为等效的电压源。</p></blockquote><h2 id="受控源">受控源</h2><p><strong>受控源</strong>是一种输出量的大小与方向，受到电路当中其它位置电压或电流控制的电源，其拥有两个<strong>输入端</strong>（控制端）和两个<strong>输出端</strong>（受控端），根据输出端所呈现的特性，受控源还可以划分为如下四种：</p><ol type="1"><li><strong>电压控制电压源（VCVS）</strong>：通过控制输入端的<strong>电压</strong>，达到控制输出端<strong>电压</strong>的目的。因为控制量是<code>电压</code>，所以控制支路为<strong>开路</strong>。如果控制端电压为<span class="math inline">\(u_1\)</span>，那么输出端电压就等于 <span class="math inline">\(\mu u_1\)</span>，这里的 <span class="math inline">\(\mu\)</span>没有量纲，被称为<strong>转移电压比</strong>或者<strong>电压放大系数</strong>：<img src="/Electronics/Introduct_Analysis/Chapter-4/10.png"></li><li><strong>电流控制电压源（CCVS）</strong>：通过控制输入端的<strong>电流</strong>，达到控制输出端<strong>电压</strong>的目的。因为控制量是<code>电流</code>，所以控制支路为<strong>短路</strong>。如果控制端电流为<span class="math inline">\(i_1\)</span>，那么输出端电压就等于 <span class="math inline">\(r i_1\)</span>，这里的 <span class="math inline">\(r\)</span>就称为<strong>转移电阻</strong>，单位为欧姆 <code>Ω</code>： <img src="/Electronics/Introduct_Analysis/Chapter-4/11.png"></li><li><strong>电压控制电流源（VCCS）</strong>：通过控制输入端的<strong>电压</strong>，达到控制输出端<strong>电流</strong>的目的。因为控制量是<code>电压</code>，所以控制支路为<strong>开路</strong>。如果控制端电压为<span class="math inline">\(u_1\)</span>，那么输出端电流就等于 <span class="math inline">\(g u_1\)</span>，这里的 <span class="math inline">\(g\)</span>就称为<strong>转移电导</strong>，单位为西门子 <code>S</code>： <img src="/Electronics/Introduct_Analysis/Chapter-4/12.png"></li><li><strong>电流控制电流源（CCCS）</strong>：通过控制输入端的<strong>电流</strong>，达到控制输出端<strong>电流</strong>的目的。因为控制量是<code>电流</code>，所以控制支路为<strong>短路</strong>；如果控制端电流为<span class="math inline">\(i_1\)</span>，那么输出端电压就等于 <span class="math inline">\(\alpha i_1\)</span>，这里的 <span class="math inline">\(\alpha\)</span>没有量纲，被称为<strong>转移电流比</strong>或者<strong>电流放大系数</strong>：<img src="/Electronics/Introduct_Analysis/Chapter-4/13.png"></li></ol><blockquote><p><strong>注意</strong>：<strong>独立源</strong>作为电路的输入，起到对电路的激励作用，是电路得以正常工作的源泉。而<strong>受控源</strong>用于反映电路当中某个位置的电压或电流，对于另一个位置电压或电流的控制关系。概而言之，<strong>受控源并不是一种激励源，其体现的一种控制关系</strong>。</p></blockquote><h2 id="电路分析方法">电路分析方法</h2><h3 id="支路电流法">支路电流法</h3><p><strong>支路电流法</strong>是一种根据<strong>基尔霍夫电压与电流定律</strong>列写出的电路方程，其主要以各个<code>支路电流</code> 作为求解的未知量。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/1.png"></p><p>上面电路由两个电源并联组成，该电路当中存在 3 条支路，2个结点（<code>a</code> 和 <code>b</code>）；如果需要求解 3支路上的电流，就需要列写 3个<strong>独立方程</strong>（不能通过已有方程列写出来的方程称为独立方程）联立进行求解。</p><p>首先，选定未知支路电流的参考方向，并根据 KCL定律列写出如下两个电流方程，其中只有一个为独立方程：</p><p><span class="math display">\[\begin{cases}结点 a \implies I_1 + I_2 - I_3 = 0 \\结点 b \implies I_3 - I_1 - I_2 = 0\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：通常情况下，具有 <span class="math inline">\(n\)</span> 个结点的电路应用 KCL 定律只能列写出<span class="math inline">\(n - 1\)</span> 个独立方程：</p></blockquote><p>然后，针对上面电路里的 Ⅰ、Ⅱ、Ⅲ 三个回路，分别列写出三个 KVL电压方程，其中只有两个为独立方程：</p><p><span class="math display">\[\begin{cases}回路 Ⅰ \implies U_1 - I_1 R_1 - I_3 R_3 = 0 \\回路 Ⅱ \implies U_2 - I_2 R_2 - I_3 R_3 = 0 \\回路 Ⅲ \implies U_1 - I_1 R_1 + I_2 R_2 - U_2 = 0\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：电路分析过程当中，基于网孔列写出的方程一定是<strong>独立方程</strong>。</p></blockquote><p>提取上述 KCL 和 KVL方程当中的<strong>独立方程</strong>，可以得到如下的独立方程组：</p><p><span class="math display">\[\begin{cases}结点 a \implies I_1 + I_2 - I_3 = 0 \\回路 Ⅰ \implies U_1 - I_1 R_1 - I_3 R_3 = 0 \\回路 Ⅱ \implies U_2 - I_2 R_2 - I_3 R_3 = 0\end{cases}\]</span></p><p>联立求解上述方程组，就可以得到支路电流 <span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span>、<span class="math inline">\(I_3\)</span>；如果求解出结果为<strong>正</strong>，则表示该电流的实际方向与参考方向<strong>相同</strong>；如果求解出结果为<strong>负</strong>，则表示该电流的实际方向与参考方向<strong>相反</strong>。</p><p>最后，将采用<strong>支路电流法</strong>的分析步骤总结如下：</p><ol type="1"><li>确定电路的支路数量和结点数量，标注电流的参考方向与网孔绕行方向；</li><li>应用 KCL定律列写<strong>独立电流方程</strong>，规定与参考方向相同为正，相反为负；</li><li>运用 KVL定律列写<strong>独立电压方程</strong>，规定电压上升为正，下降为负；</li><li>求解方程组，得到支路电流；</li></ol><blockquote><p><strong>注意</strong>：支路电流法适用于支路较少的电路（支路数量过多，会增加列写的方程数量），并且在分析含有理想电流源的电路时，由于该支路电流为已知，所以列写回路方程时需要避开理想电流源所在的支路。</p></blockquote><h3 id="结点电压法">结点电压法</h3><p><strong>结点电压法</strong>以电路当中的<strong>结点电压</strong>作为待求量，适用于结点较少支路较多的电路：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/2.png"></p><p>首先，上图电路为四条支路并联的电路，虽然该电路的结点数量较少，但是支路数量较多。这里选择<code>b</code> 点作为参考点，两个结点 <code>a</code> 与 <code>b</code>之间的电压 <span class="math inline">\(U_{ab}\)</span>称为<strong>结点电压</strong>，方向为由 <code>a</code> 点指向<code>b</code> 点。已知各条支路的电流如上图所示，分别对结点<code>a</code> 列写 KCL 方程，对于各条支路列写 KVL方程，得到如下的方程组：</p><p><span class="math display">\[\begin{cases}列写结点 a 的 KCL 方程 \implies I_1 + I_2 - I_3 - I_4 = 0 \\列写 R_1 支路的 KVL 方程 \implies U_{S1} - R_1 I_1 - U_{ab} = 0 \\列写 R_2 支路的 KVL 方程 \implies -U_{S2} - R_2 I_2 - U_{ab} = 0 \\列写 R_3 支路的 KVL 方程 \implies R_3 I_3 - U_{ab} = 0 \\列写 R_4 支路的 KVL 方程 \implies R_4 I_4 - U_{ab} = 0\end{cases}\]</span></p><p>然后，通过求解上述的方程组，就可以得到<strong>求解结点电压的简便公式</strong>：</p><p><span class="math display">\[U_{ab} = \frac{\frac{U_{S1}}{R_1} + \frac{-U_{S2}}{R_2}}{ \frac{1}{R_1}+ \frac{1}{R_2} + \frac{1}{R_3} + \frac{1}{R_4} }= \frac{\sum{\frac{U}{R}}}{\sum{\frac{1}{R}}}\]</span></p><p>最后，将结点电压法分析电路的步骤总结如下：</p><ol type="1"><li>设置零电位参考结点，所有的结点电压均以该点作为<strong>负极</strong>；</li><li>标识出各个支路电流的参考方向；</li><li>根据上述公式列写方程，并求解出结点电压 <span class="math inline">\(U_{ab}\)</span>；</li></ol><p><strong>注意</strong>：结点电压法适用于求解支路上的<code>电压</code>以及<code>电流</code>，特别是对于<strong>支路数量较多、结点数量较少</strong>的复杂电路。</p><h2 id="重要定理">重要定理</h2><h3 id="叠加原理">叠加原理</h3><p>下图左侧的电路当中存在两个电源，各个支路上的电流都是由两个电源共同作用产生。<strong>叠加原理</strong>是指任意一条支路上的电流，都可以视为该电路当中的各个电源分别作用时，在该支路上产生电流的代数和。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/3.png"></p><p>这里假设 <span class="math inline">\(I_1&#39;\)</span>、<span class="math inline">\(I_2&#39;\)</span>、<span class="math inline">\(I_3&#39;\)</span> 是电压源 <span class="math inline">\(U_1\)</span> 单独作用时的支路电流，<span class="math inline">\(I_1&#39;&#39;\)</span>、<span class="math inline">\(I_2&#39;&#39;\)</span>、<span class="math inline">\(I_3&#39;&#39;\)</span> 则是电压源 <span class="math inline">\(U_2\)</span> 单独作用时的支路电流，而 <span class="math inline">\(I_1\)</span>、<span class="math inline">\(I_2\)</span>、<span class="math inline">\(I_3\)</span> 是 <span class="math inline">\(U_1\)</span> 和 <span class="math inline">\(U_2\)</span>两个电压源同时作用时的支路电流，根据叠加原理就可以得到这些支路电流的关系：</p><p><span class="math display">\[\begin{cases}I_1 = I_1&#39; - I_1&#39;&#39; \\I_2 = I_2&#39;&#39; - I_2&#39; \\I_3 = I_3&#39; + I_3&#39;&#39;\end{cases}\]</span></p><p>采用叠加原理计算复杂电路，就是将具有<strong>多个电源</strong>的复杂电路转化为几个<strong>单电源</strong>的电路来进行计算，但是在使用时需要注意以下几点：</p><ol type="1"><li>叠加原理只适用于线性电路，只能用于分析线性电路的电流与电压，但是不能用于计算功率；</li><li>叠加计算电路当中的电流或者电压时，需要注意各条支路上电压与电流的参考方向，叠加后电压电流的参考方向与原支路保持一致时取<strong>正号</strong>，反之则取负号；</li><li>电源单独作用是指，<strong>将电压源用短路线代替，而电流源直接进行断开</strong>，电路当中其它元件的连接关系保持不变；</li></ol><h3 id="戴维南定理">戴维南定理</h3><p>具有两个端口的电路称为<strong>二端网络</strong>，根据内部是否含电源，可以进一步划分为<strong>无源二端网络</strong>、<strong>有源二端网络</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/4.png"></p><p>任何一个线性有源二端网络，对于外电路而言，都可以采用一个电压源 <span class="math inline">\(U_s\)</span> 与内阻 <span class="math inline">\(R_s\)</span><strong>串联</strong>而成的组合电源模型来代替。电压源的<strong>电压</strong>等于有源二端网络的开路电压（即将负载断开之后，<code>a</code>与 <code>b</code>两端之间的电压），而<strong>内阻</strong>等于有源二端网络当中所有独立电源为零时的等效电阻（<span class="math inline">\(U_s = 0\)</span> 时理想电压源短路，<span class="math inline">\(I_s = 0\)</span>时理想电流源开路），这就是<strong>戴维南定理</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/5.png"></p><blockquote><p><strong>注意</strong>：根据戴维南定理得到的等效电路，就称为<strong>戴维南等效电路</strong>。</p></blockquote><h3 id="诺顿定理">诺顿定理</h3><p>任意一个线性有源二端网络，都可以采用一个电流为 <span class="math inline">\(I_s\)</span> 的理想电流源与内阻 <span class="math inline">\(R_s\)</span><strong>并联</strong>的电源模型来等效代替。电流源的电流 <span class="math inline">\(I_s\)</span>等于二端网络端口短路时的短路电流，并联内阻 <span class="math inline">\(R_s\)</span>等于线性有源二端网络去除独立电源之后（理想电压源短路，理想电流源开路）<code>a</code>与 <code>b</code>两端之间的<strong>等效电阻</strong>，这就是<strong>诺顿定理</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/6.png"></p><blockquote><p><strong>注意</strong>：一个<strong>有源二端网络</strong>即可以采用<strong>戴维南定理</strong>转换为等效电压源，也可以采用<strong>诺顿定理</strong>转换为等效电流源，两者对于外电路而言都是等效的。</p></blockquote><h2 id="非线性电阻电路">非线性电阻电路</h2><p>如果电阻两端的<strong>电压</strong>与通过的<strong>电流</strong>成正比，说明其电阻值为一个常数，其两端的电压与电流关系遵循欧姆定律，称为<strong>线性电阻</strong>。如果该电阻值并非一个常数，而是会伴随着电压或者电流发生变化，两端的电压与电流关系也不遵循欧姆定律，这种电阻就称为<strong>非线性电阻</strong>。</p><p>非线性电阻的电压与电流关系，可以采用 <span class="math inline">\(U =f{I}\)</span> 或者 <span class="math inline">\(I = f(U)\)</span>的伏安关系曲线进行表示，下图为<strong>电灯泡钨丝</strong>（左）以及<strong>二极管</strong>（右）的伏安特性曲线：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/7.png"></p><p>因为非线性电阻会随着电压或者电流发生变化，所以计算其阻值时必须指定确切的电压或者电流，例如下图表达的就是工作点<strong>Q</strong> 位置的电阻：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-5/8.png"></p><p>非线性电阻拥有<strong>静态电阻</strong>和<strong>动态电阻</strong>两种表示方式：</p><ul><li><strong>静态电阻</strong>（直流电阻）：等于工作点 <span class="math inline">\(Q\)</span> 的电压 <span class="math inline">\(U\)</span> 与电流 <span class="math inline">\(I\)</span> 之比，即 <span class="math inline">\(R= \frac{U}{I}\)</span>，Q 点的静态电阻正比于 <span class="math inline">\(\tan \alpha\)</span>；</li><li><strong>动态电阻</strong>（交流电阻）：等于工作点 <span class="math inline">\(Q\)</span> 附近的<strong>电压微小变化量</strong><span class="math inline">\(\Delta U\)</span>与<strong>电流微小变化量</strong> <span class="math inline">\(\DeltaI\)</span> 之比的<strong>极限</strong>，即 <span class="math inline">\(r= \lim_{\Delta I \to 0} \frac{\Delta U}{\Delta I}\)</span>，其 <span class="math inline">\(Q\)</span> 点的动态电阻正比于 <span class="math inline">\(\tan \beta\)</span>，这里的 <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(Q\)</span>点的<strong>切线</strong>与<strong>纵轴</strong>的夹角；</li></ul><blockquote><p><strong>注意</strong>：因为非线性电阻的阻值并非一个常数，所以在分析计算时通常只会采用<strong>图解法</strong>。</p></blockquote><h2 id="电磁感应">电磁感应</h2><h3 id="磁场与磁感线">磁场与磁感线</h3><p><strong>磁体</strong>是具有磁性的物质，磁体上磁性最强的部分称为<strong>磁极</strong>，<strong>同性磁极相互排斥，异性磁极相互吸引</strong>。当磁场内某一点，磁针静止时<strong>北极</strong>所指的方向，就是该点的<strong>磁场方向</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/1.png"></p><p><strong>磁感线</strong>是一种用于描述空间当中磁场分布的闭合曲线，<strong>磁体外部</strong>的磁感线从磁体的<strong>北极</strong>出发回到<strong>南极</strong>，而<strong>磁体内部</strong>的磁感线则是从磁体的<strong>南极</strong>出发返回<strong>北极</strong>，下图是几种常见形状磁铁的磁感线分布情况：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/2.png"></p><h3 id="安培定则">安培定则</h3><p>直线电流的方向与磁感线方向之间的关系可以通过<strong>安培定则</strong>（也称为<strong>右手螺旋定则</strong>）来判定：用右手握住导线，让<strong>大拇指</strong>的方向与电流方向保持一致，此时<strong>弯曲四指</strong>所指的方向就是磁感线的环绕方向。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/3.png"></p><p>通常使用符号 <strong>⊚</strong>表示<strong>电流</strong>垂直于平面指向<strong>外侧</strong>，而使用<strong>⊗</strong>表示<strong>电流</strong>垂直于平面指向<strong>内侧</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/4.png"></p><p>通常使用符号 <span class="math inline">\(\cdot\)</span>表示<strong>磁感线</strong>垂直于平面指向<strong>外侧</strong>，而使用<span class="math inline">\(\times\)</span>表示<strong>磁感线</strong>垂直于平面指向<strong>内侧</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/5.png"></p><blockquote><p><strong>注意</strong>：<strong>地磁场</strong>的磁感线从地理南极（地磁北极）出发，到达地理北极（地磁南极），两极的磁性最强，磁感线近乎垂直于地面，而赤道处的磁感线与地面近似平行。</p></blockquote><h3 id="磁感应强度与安培力">磁感应强度与安培力</h3><p><strong>安培力</strong>是磁场对于通电导线产生的作用力，如果将一段通电导线<span class="math inline">\(L\)</span>放入磁场，当导线方向与磁场方向垂直时（下图左），导线所受的安培力最大；当导线方向与磁场方向一致时（下图中），其所受的安培力等于零；而当导线方向与磁场方向斜交呈<span class="math inline">\(\theta\)</span>角时（下图右），安培力介于最大值与零之间。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/6.png"></p><p>当导线方向与磁场方向垂直时，通电导线受到的<strong>安培力</strong><span class="math inline">\(F\)</span> 与<strong>电流</strong> <span class="math inline">\(I\)</span> 和<strong>导线长度</strong> <span class="math inline">\(L\)</span> 呈正比：</p><p><span class="math display">\[安培力 F = 常量 B \times 电流 I \times 导线长度 L\]</span></p><p>上面公式中的 <span class="math inline">\(B\)</span>是一个比例系数，对于磁场当中一个确定的点而言，其值为一个<strong>常量</strong>，所以上面的公式也可以变换为下面的形式：</p><p><span class="math display">\[磁感应强度 B = \frac{安培力 F}{电流 I \times 导线长度 L}\]</span></p><p>相同磁场的同一个位置，无论电流 <span class="math inline">\(I\)</span>、导线长度 <span class="math inline">\(L\)</span> 怎样变化，<span class="math inline">\(B\)</span>的值总是确定的；而在不同磁场或者不同位置当中，<span class="math inline">\(B\)</span> 的值也会有所不同。当 <span class="math inline">\(B\)</span> 的值越大，在电流 <span class="math inline">\(I\)</span> 和导线长度 <span class="math inline">\(L\)</span> 一定的情况下，通电导线所受到的安培力<span class="math inline">\(F\)</span>就越大，所表征的磁场也就越强，因此可以采用 <span class="math inline">\(B\)</span>来描述磁场的强弱，称为<strong>磁感应强度</strong>。</p><p>磁感应强度的单位为<strong>特斯拉</strong>，简称为<strong>特</strong><code>T</code>，当通电导线与磁场垂直时，如果电流 <span class="math inline">\(I = 1A\)</span>，导线长度 <span class="math inline">\(L = 1m\)</span>，并且导线所受到的安培力恰好为<span class="math inline">\(F = 1N(牛)\)</span>，那么 <span class="math inline">\(1T = 1N/(A \cdotm)\)</span>。磁感应强度是一个<strong>矢量</strong>，某一个点的<strong>磁场方向</strong>就是该点磁感应强度的方向。</p><p>以上讨论的是通电直导线与磁感应强度方向相互<strong>垂直</strong>的情况，当通电直导线与磁感应强度方向之间的<strong>夹角</strong>为<span class="math inline">\(\theta\)</span> 的时候，可以将 <span class="math inline">\(B\)</span>分解为两个分量：一个为<strong>水平分量</strong> <span class="math inline">\(B \cos\theta\)</span>，另一个为<strong>垂直分量</strong> <span class="math inline">\(B \sin\theta\)</span>。因为水平分量对于电流的作用力为零，所以安培力完全由<strong>垂直分量</strong>所决定，此时安培力<span class="math inline">\(F\)</span> 的大小等于：</p><p><span class="math display">\[安培力 F = 常量 B \times 电流 I \times 导线长度 L \times \sin \theta\]</span></p><h3 id="左手定则">左手定则</h3><p><strong>通电导线</strong>与<strong>所受安培力</strong>的方向与<strong>磁场</strong>和<strong>电流</strong>方向之间的关系，可以采用<strong>左手定则</strong>来进行判断：张开左手，<strong>大拇指</strong>与其它四指处于相同平面并且互相垂直，让<strong>磁感线</strong>垂直穿入掌心，而其它四指指向<strong>电流</strong>的方向，此时<strong>大拇指</strong>所朝的方向就是导线所受安培力的方向。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/7.png"></p><h3 id="洛仑兹力">洛仑兹力</h3><p><strong>洛仑兹力</strong>是指<strong>磁场</strong>对于<strong>运动电荷</strong>的作用力，其方向可以通过<strong>左手定则</strong>进行判定：伸开左手让磁感线进入掌心，四指朝向<strong>正电荷</strong>运动的方向，此时大拇指所朝的方向就是正电荷所受洛仑兹力的方向，<strong>负电荷</strong>在磁场当中受到的洛仑兹力与正电荷相反。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/8.png"></p><p>洛仑兹力的大小等于<strong>电荷的电量</strong> <span class="math inline">\(q\)</span>、<strong>电荷的速率</strong> <span class="math inline">\(v\)</span>、<strong>磁感应强度</strong> <span class="math inline">\(B\)</span>，以及 <code>v</code> 与 <code>B</code>之间<strong>夹角</strong> <span class="math inline">\(\theta\)</span><strong>正弦</strong>的乘积。</p><p><span class="math display">\[洛仑兹力 f(牛顿) = 电量 q(库仑) \times 速率 v(米/秒) \times 磁感应强度B(特斯拉) \times 夹角 \sin \theta\]</span></p><ul><li>当日 <span class="math inline">\(\theta = 90°\)</span>时，电荷的运动方向与磁场方向垂直，电荷所受的洛仑兹力最大，等于 <span class="math inline">\(q \cdot v \cdot B\)</span>；</li><li>当 <span class="math inline">\(\theta = 0°\)</span>时，电荷的运动方向与磁场方向一致，电荷所受到的洛仑兹力最小，近乎等于零；</li><li>当 <span class="math inline">\(\theta\)</span>的角度为其它值时，洛仑兹力的大小将会介于<strong>最大值</strong>与<strong>最小值</strong>之间；</li></ul><blockquote><p><strong>注意</strong>：运动的电荷在磁场当中受到洛仑兹力影响，其运动方向将会发生偏转，<code>荧光示波器里的示波管</code>、<code>电视机内的显像管</code>、<code>电子显微镜</code>等正是基于这个原理进行工作的。</p></blockquote><h3 id="磁通量">磁通量</h3><p><strong>磁通量</strong>是一个用于表示<strong>磁场分布情况</strong>的物理量，其国际单位为<strong>韦伯</strong>（<code>Wb</code>）：</p><p><span class="math display">\[1Wb = 1Tm^2（T 为磁感应强度的单位\ 特斯拉，m^2 为面积的单位\ 平方米）\]</span></p><p>假设在匀强磁场当中有一个与磁场方向垂直，并且<strong>面积</strong>为<span class="math inline">\(S\)</span>的线圈平面，磁场的<strong>磁感应强度</strong>为 <span class="math inline">\(B\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/9.png"></p><p>那么<strong>磁感应强度</strong> <span class="math inline">\(B\)</span> 与<strong>面积</strong> <span class="math inline">\(S\)</span>的乘积就称为<strong>磁通量</strong>，采用 <span class="math inline">\(\Phi\)</span> 进行表示：</p><p><span class="math display">\[磁通量 \varPhi = 磁感应强度 B \times 面积 S\]</span></p><ul><li>当线圈平面与磁场方向<strong>垂直</strong>时，线圈内的磁通量为最大；</li><li>当线圈平面与磁场方向<strong>平行</strong>时，由于通过线圈的磁感应线为零，所以磁通量为零；</li><li>当线圈平面与磁感线方向存在<strong>夹角</strong>时，取垂直于磁场方向的投影面积为磁通量的计算面积；</li></ul><p>如果穿过闭合电路的磁通量发生了变化，那么闭合电路当中就会产生电流，这种由于磁通量变化而产生电流的现象称为<strong>电磁感应</strong>，其所产生的电流称为<strong>感应电流</strong>。在电磁感应现象中，既然闭合回路当中存在感应电流，那么该电路当中就一定会存在电动势，这种由电磁感应产生的电动势称为<strong>感应电动势</strong>。</p><ul><li><strong>感应电流</strong>：通过电磁感应产生的电流，在存在感应电动势并且电路闭合的情况下产生，其大小取决于感应电动势与电路的总电阻；</li><li><strong>感应电动势</strong>：通过电磁感应产生的电动势，在磁通量发生变化的时候产生（与电路是否闭合无关），其大小与穿过磁通量的变化率成正比；</li></ul><h3 id="法拉第电磁感应定律">法拉第电磁感应定律</h3><p><strong>感应电动势</strong>大小与<strong>磁通量</strong>变化快慢有关系，用磁通量的变化率来描述<strong>磁通量</strong>变化的快慢，其值为磁通量的变化量与产生这个变化所用时间的比值。</p><p>如果时刻 <span class="math inline">\(t_1\)</span> 的磁通量为 <span class="math inline">\(\varPhi_1\)</span>，时刻 <span class="math inline">\(t_2\)</span> 的磁通量变为 <span class="math inline">\(\varPhi_2\)</span>，从 <span class="math inline">\(t_1\)</span> 到 <span class="math inline">\(t_2\)</span> 这段时间内磁通量的变化量就是 <span class="math inline">\(\varPhi_2 - \varPhi_1\)</span>，记为 <span class="math inline">\(\Delta \varPhi = \varPhi_2 -\varPhi_1\)</span>，由于该变化是在 <span class="math inline">\(\Delta t= t_2 - t_1\)</span>时间段内发生的，所以<strong>法拉第电磁感应定律</strong>可以表述为：电路当中<strong>感应电动势</strong>的变化量，与穿过该电路的<strong>磁通量</strong>变化量呈正比。</p><p><span class="math display">\[感应电动势(伏特)\ E = \frac{磁通量变化量(韦伯)\ \Delta\varPhi}{时间变化量(秒)\ \Delta t}\]</span></p><p>一个闭合回路可以被视为一匝线圈，如果线圈的匝数为 <span class="math inline">\(n\)</span>，由于每一匝线圈的感应电动势都为 <span class="math inline">\(\frac{\Delta \varPhi}{\Deltat}\)</span>，并且每一匝线圈相互串联，整个线圈的<strong>电动势</strong><span class="math inline">\(E\)</span> 就等于：</p><p><span class="math display">\[感应电动势(伏特)\ E =\ 线圈匝数\ n \times \frac{磁通量变化量(韦伯)\\Delta \varPhi}{时间变化量(秒)\ \Delta t}\]</span></p><h3 id="动生电动势">动生电动势</h3><p>如果磁通量的变化是由于<strong>导体</strong>与<strong>磁体</strong>的<strong>相对运动</strong>而引发的，那么此时产生的电动势就称为<strong>动生电动势</strong>。当一个匀强磁场中的<strong>磁感应强度</strong>、<strong>导线</strong>、<strong>导线运动方向</strong>三者互相垂直时，感应电动势等于<strong>磁感应强度</strong><span class="math inline">\(B\)</span>、<strong>导线长度</strong> <span class="math inline">\(L\)</span>、<strong>导线运动速度</strong> <span class="math inline">\(v\)</span> 的乘积：</p><p><span class="math display">\[动生电动势 E(伏) = 磁感应强度 B(特斯拉) \times 导线长度 L(米) \times导线运动速度 v(米/秒)\]</span></p><p>如果导线运动方向与导线自身相互垂直，但是与磁力线方向存在着一个<strong>夹角</strong><span class="math inline">\(\theta\)</span>，此时可以将<strong>速度</strong><span class="math inline">\(v\)</span>分解为<strong>垂直于磁力线的分量</strong> <span class="math inline">\(v_1 = v \sin \theta\)</span>和<strong>平行于磁力线的分量</strong> <span class="math inline">\(v_2 =v \cos \theta\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/10.png"></p><p>平行于磁力线的分量不会参与切割磁力线，也就不会产生感应电动势。而垂直于磁力线的分量会切割磁力线，产生感应电动势<span class="math inline">\(BLv_1\)</span>，又由于 <span class="math inline">\(v_1 = v \sin\theta\)</span>，所以此时产生的动生电动势应为：</p><p><span class="math display">\[动生电动势 E(伏) = 磁感应强度 B(特斯拉) \times 导线长度 L(米) \times导线运动速度 v(米/秒) \times 夹角 \sin \theta\]</span></p><p>当导线运动方向与磁力线方向存在夹角 <span class="math inline">\(\theta\)</span>时，导线切割磁力线产生的感应电动势大小，与<strong>磁感应强度</strong><span class="math inline">\(B\)</span>、<strong>导线长度</strong> <span class="math inline">\(L\)</span>、<strong>运动速度</strong> <span class="math inline">\(v\)</span>、<strong>运动方向与磁力线方向的夹角</strong><span class="math inline">\(\theta\)</span><strong>的正弦</strong>成正比。</p><p>归纳起来，感应电动势的产生主要存在如下两种方式：</p><ol type="1"><li>磁感应强度变化产生<strong>感应电动势</strong>；</li><li>导体切割磁感线运动产生<strong>动生电动势</strong>；</li></ol><h3 id="楞次定律">楞次定律</h3><p><strong>楞次定律</strong>是指感应电流具有这样的方向，即感应电流的<strong>磁场</strong>总是会阻碍引起感应电流的<strong>磁通量</strong>发生变化。利用楞次定律可以判定各种情况下<strong>感应电流</strong>的方向，具体可以依照如下步骤进行：</p><ol type="1"><li>明确原来的磁场方向；</li><li>判断穿过闭合电路的磁通量是增加还是减少；</li><li>根据<strong>楞次定律</strong>确定感应电流的磁场方向；</li><li>利用<strong>安培定则</strong>来确定感应电流的方向；</li></ol><blockquote><p><strong>注意</strong>：感应电流的磁场总是阻碍原磁通量的变化，主要是指<strong>阻碍变化</strong>，而非阻碍原磁场。即当原磁通量增加时，感应电流的磁场方向与原磁场方向相反；而当原磁通量减少时，感应电流的磁场与原磁场方向相同。<strong>阻碍</strong>并不是指<strong>阻止</strong>，原磁通量如果增加，感应电流的磁场只能阻碍而不能阻止原磁通量的增加，即原磁通量最后依然还是会增加。</p></blockquote><h3 id="右手定侧">右手定侧</h3><p>伸开右手，使<strong>大拇指</strong>与其它四指处于相同平面并且相互垂直，让磁感线垂直穿入<strong>掌心</strong>，并使大拇指朝向<strong>导体运动的方向</strong>，此时其它四指所朝方向就是<strong>感应电流的方向</strong>，这就是<strong>右手定侧</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/11.png"></p><blockquote><p><strong>注意</strong>：不要混淆<strong>右手定则</strong>与<strong>左手定则</strong>，两个定则的应用可以简单的总结为<strong>因电而动用左手，因动而电用右手</strong>。</p></blockquote><h3 id="磁导率">磁导率</h3><p><strong>磁导率</strong>是一个用于衡量物质<strong>导磁能力</strong>的物理量，其单位为<strong>亨/米</strong>(<code>H/m</code>)，其值通常为一个固定的常数，指定物质的磁导率<span class="math inline">\(\mu\)</span> 与<strong>真空</strong>磁导率<span class="math inline">\(\mu_0 = 4 \pi \times 10^{-7} H/m\)</span>的比值，称为该物质的<strong>相对磁导率</strong> <span class="math inline">\(\mu_r\)</span>：</p><p><span class="math display">\[相对磁导率 \mu_r = \frac{某种物质的磁导率 \mu_r}{真空的磁导率 \mu_0}\]</span></p><table><colgroup><col style="width: 13%"><col style="width: 13%"><col style="width: 14%"><col style="width: 13%"><col style="width: 14%"><col style="width: 31%"></colgroup><thead><tr class="header"><th style="text-align: center;">材料名称</th><th style="text-align: center;">铸铁</th><th style="text-align: center;">硅钢片</th><th style="text-align: center;">镍锌铁氧体</th><th style="text-align: center;">锰锌铁氧体</th><th style="text-align: center;">坡莫合金</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>相对磁导率</strong></td><td style="text-align: center;"><span class="math inline">\(200 \sim400\)</span></td><td style="text-align: center;"><span class="math inline">\(7000 \sim1000\)</span></td><td style="text-align: center;"><span class="math inline">\(10 \sim1000\)</span></td><td style="text-align: center;"><span class="math inline">\(300 \sim5000\)</span></td><td style="text-align: center;"><span class="math inline">\(2 \times10^4 \sim 2 \times 10^5\)</span></td></tr></tbody></table><blockquote><p><strong>注意</strong>：对于<strong>非磁性材料</strong>而言，由于<span class="math inline">\(\mu \approx \mu_0 \implies \mu_r \approx1\)</span>，所以几乎不会具有磁化特性。</p></blockquote><p>磁场当中某一个点的磁感应强度 <span class="math inline">\(B\)</span>与相同点上磁导率 <span class="math inline">\(\mu\)</span>的比值称为该点的<strong>磁场强度</strong>，其单位为<strong>安/米</strong>(<code>A/m</code>)，要注意<strong>磁场强度</strong>与<strong>磁感应强度</strong>分别属于不同的概念，使用时切忌不能混淆。</p><h3 id="磁路">磁路</h3><p>当线圈绕制在闭合的铁芯上时，由于铁芯的磁导率远远高于周围空气的磁导率，使得大部分磁通量集中到了铁芯内部，并且形成一个闭合通路，这种人为造成的磁通路径，就被称为<strong>磁路</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-6/12.png"></p><h2 id="自感与电感器">自感与电感器</h2><h3 id="自感">自感</h3><p>由于导体本身电流的变化而产生的电磁感应现象称为<strong>自感</strong>，当导体中的电流发生变化时，周围的磁场也会随之发生变化，并且由此引发磁通量的变化，从而在导体当中产生<strong>感应电动势</strong>，这个电动势会阻碍导体当中电流的变化，称为<strong>自感电动势</strong>。自感电动势同样与穿过线圈的<strong>磁通量变化率</strong>成正比，由于磁通量<span class="math inline">\(\Delta \varPhi\)</span> 与磁感应强度 <span class="math inline">\(B\)</span> 成正比，而 <span class="math inline">\(B\)</span> 又与产生该磁场的电流 <span class="math inline">\(I\)</span> 成正比，所以 <span class="math inline">\(\Delta \varPhi\)</span> 与 <span class="math inline">\(\Delta I\)</span>也成正比，由此就可以得到自感电动势 <span class="math inline">\(e_L\)</span> 的计算公式：</p><p><span class="math display">\[自感电动势 e_L = 自感系数 L \times \frac{电流 \Delta I}{时间 \Delta t}\]</span></p><p>上面方程当中的 <span class="math inline">\(L\)</span>称为线圈的<strong>自感系数</strong>，简称为<strong>自感</strong>或者<strong>电感</strong>，其大小由线圈本身的特性决定。线圈越长，匝数越多，截面积越大，其自感系数就会越大；除此之外，带有铁芯线圈的自感系数，比没有铁芯要更大。自感系数的单位为<strong>亭利</strong>，简称<strong>亨</strong>，符号为<span class="math inline">\(H\)</span>。如果通过线圈的电流在<code>1s</code> 时间内改变 <code>1A</code> 时产生的自感电动势为<code>1V</code>，那么该线圈的自感系数就等于 <span class="math inline">\(1H = \frac{1V \cdots}{A}\)</span>。<strong>亭利</strong>这个单位值较大，通常会使用更小的<strong>毫亨</strong>（<span class="math inline">\(mH\)</span>）和<strong>微亨</strong>（<span class="math inline">\(\mu H\)</span>）：</p><p><span class="math display">\[1H = 10^3 mH = 10^6 \mu H\]</span></p><p>指定线圈的自感系数通常是固定的，如果一个指定线圈的<strong>截面积</strong>为<span class="math inline">\(S(m^2)\)</span>，<strong>长度</strong>为<span class="math inline">\(l(m)\)</span>，<strong>匝数</strong>为 <span class="math inline">\(N\)</span>，<strong>介质磁导率</strong>为 <span class="math inline">\(\mu(H/m)\)</span>，那么其<strong>电感值</strong><span class="math inline">\(L(H)\)</span> 就等于：</p><p><span class="math display">\[电感 L = \frac{磁导率 \mu \cdot 截面积 S \cdot 匝数 N^2}{长度 l}\]</span></p><h3 id="电感器">电感器</h3><p><strong>电感器</strong>是基于<strong>自感</strong>原理制作的电子元件，最简单的电感线圈就是将导线<strong>空心</strong>的绕几圈，或者在<strong>磁芯</strong>上缠绕几周：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-7/1.png"></p><blockquote><p><strong>注意</strong>：电感元件可以划分为两大类：利用<strong>自感</strong>原理的<strong>电感器</strong>，利用<strong>互感</strong>原理的<strong>变压器</strong>。</p></blockquote><p>电感两端的电压与通过电流的关系为 <span class="math inline">\(e_L = L\frac{\Delta I}{\Delta t}\)</span>，下图展示了电感器的几种电路符号：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-7/2.png"></p><blockquote><p><strong>注意</strong>：使用电感器时需要注意其<strong>工作频率</strong>，高频电感器的电感量较小，但是可以工作在较高的频率之下；而<strong>低频扼流圈</strong>的电感量较大，主要应用于低频电路当中。</p></blockquote><h4 id="感抗">感抗</h4><p><strong>感抗</strong>是指电感器对于<strong>交流电流</strong>存在的阻碍作用，其值与<strong>电感量</strong>大小以及<strong>频率</strong>高低有关。线圈的感抗<span class="math inline">\(X_L\)</span> 与电感 <span class="math inline">\(L\)</span> 和交流频率 <span class="math inline">\(f\)</span> 之间存在如下关系：</p><p><span class="math display">\[感抗 X_L(欧姆) = 2 \pi \cdot 交流频率 f(赫兹) \cdot 电感 L(亨利)\]</span></p><p>由于感抗是由<strong>自感</strong>所引起的，线圈的电感 <span class="math inline">\(L\)</span>越大，自感作用就越大，因而感抗也就越大；交流电的频率 <span class="math inline">\(f\)</span>越高，电流的变化率越大，自感作用也就越强，因而感抗也就越大。除此之外，由于<strong>直流电</strong>的频率<span class="math inline">\(f =0\)</span>，所以电感呈现出<strong>通路</strong>，只存在可以忽略不计的线圈直流电阻；但是电感对于<strong>交流电</strong>存在着阻碍作用，感抗值远远大于线圈的直流电阻对于交流电流的阻碍作用，这就是电感器的<strong>通直隔交</strong>特性。</p><h4 id="电感器的特性">电感器的特性</h4><ul><li><strong>电励磁</strong>：将电能转换成磁能，当<strong>直流电</strong>或者<strong>交流电</strong>经过线圈时，会在线圈内外部产生<strong>磁场</strong>，这个磁场的大小和方向与经过的电流相关；</li><li><strong>磁励电</strong>：将磁能转换成电能，当通过线圈的<strong>磁通量</strong>发生改变时，线圈会在磁场的作用下产生<strong>感应电动势</strong>，磁通量的变化率越大，感应电动势就会越大；当磁场大小与方向不断变化时，感应电动势的大小与方向也在不断发生变化；</li><li><strong>电流不能突变</strong>：当流过线圈的电流大小发生改变时，线圈上会产生<strong>反电动势</strong>来维持原电流大小不变；线圈当中的电流变化率越大，其<strong>反电动势</strong>就会越大；</li></ul><h4 id="电感器的串并联">电感器的串并联</h4><p>类似于<strong>电阻</strong>的串联，<strong>电感器</strong>串联之后的总电感量等于<span class="math inline">\(n\)</span>个串联电感器的<strong>电感值</strong>之和：</p><p><span class="math display">\[L = L_1 + L_2 + ... + L_n\]</span></p><p>同样的，类似于<strong>电阻</strong>的并联，<strong>电感器</strong>并联之后的总电感量的<strong>倒数</strong>，等于<span class="math inline">\(n\)</span>个并联电感器电感值的<strong>倒数</strong>之和：</p><p><span class="math display">\[\frac{1}{L} = \frac{1}{L_1} + \frac{1}{L_2} + ... + \frac{1}{L_n}\]</span></p><blockquote><p><strong>注意</strong>：实际电路设计当中，通常很少将电感器串联或者并联起来进行使用。</p></blockquote><h2 id="互感与变压器">互感与变压器</h2><h3 id="互感">互感</h3><p>下面两个相互靠近的线圈，当第 1 个线圈当中通过电流 <span class="math inline">\(i_1\)</span> 时，会在线圈中产生自感磁链 <span class="math inline">\(\Psi_{11}\)</span>，根据<strong>右手螺旋定则</strong>可以确定其方向；第1 个线圈产生的磁链会有一部分通过第 2个线圈，这部分磁链称为<strong>互感磁链</strong> <span class="math inline">\(\Psi_{21}\)</span>。同样的，当第 2 个线圈通过电流<span class="math inline">\(i_2\)</span> 时，其所产生的磁链 <span class="math inline">\(\Psi_{22}\)</span>也会有一部分通过第一个线圈，从而产生<strong>互感磁链</strong> <span class="math inline">\(\Psi_{12}\)</span>，这种两个线圈相互感应的现象称为<strong>互感</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/1.png"></p><p><strong>磁链</strong>是导电线圈所链环的<strong>磁通量</strong>，其单位与磁通量一样为<strong>韦伯</strong>(<code>Wb</code>)。当一个线圈流过电流时，就会在线圈当中产生<strong>磁通</strong><span class="math inline">\(\varPhi\)</span>，如果线圈的<strong>匝数</strong>为<span class="math inline">\(N\)</span>，并且通过每一匝的磁通量均为 <span class="math inline">\(\varPhi\)</span>，则通过线圈的<strong>磁链</strong><span class="math inline">\(\Psi\)</span> 等于：</p><p><span class="math display">\[磁链 \varPsi = 线圈匝数 N \times 每匝磁通量 \varPhi\]</span></p><h4 id="互感系数">互感系数</h4><p>针对上述示意图当中的两个线圈，互感磁链与产生该磁链电流的比值称为它们的<strong>互感系数</strong>，通常采用符号<span class="math inline">\(M\)</span>进行表示，其与自感系数一样也采用<strong>亨利</strong>(<code>H</code>)作为单位：</p><p><span class="math display">\[互感系数 M = \frac{互感磁链 \varPsi_{21}}{电流 i_1} = \frac{互感磁链\varPsi_{12}}{电流 i_2}\]</span></p><blockquote><p><strong>注意</strong>：互感系数只与两个回路的<code>结构</code>、<code>位置</code>、<code>介质磁导率</code>有关，而与回路当中的<code>电流</code>无关。只有当介质为<strong>铁磁性材料</strong>时，互感系数才会与电流相关。</p></blockquote><p>假设 <span class="math inline">\(L_1\)</span>、<span class="math inline">\(L_2\)</span>分别为两个线圈的电感值，则<strong>互感系数</strong> <span class="math inline">\(M\)</span> 还可以等于：</p><p><span class="math display">\[互感系数 M = 线圈耦合系数 K \sqrt{线圈 1 电感 L_1 \times 线圈 2 电感L_2}\]</span></p><p>上面公式当中的 <span class="math inline">\(K\)</span>是表征线圈耦合程度的<strong>耦合系数</strong>，其取值可以为 <span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span>：</p><ul><li>当 <span class="math inline">\(K = 0\)</span>时，说明线圈产生的磁通互不耦合，因而不存在互感；</li><li>当 <span class="math inline">\(K = 1\)</span>时，说明两个线圈耦合紧密，一个线圈产生的磁通全都与另一个线圈耦合，由于此时产生的互感最大，因而也被称为<strong>全耦合</strong>；</li></ul><h4 id="互感电动势">互感电动势</h4><p>如果 <span class="math inline">\(i_1\)</span> 随着时间发生变化，那么<span class="math inline">\(\varPsi_{21}\)</span>也会随着时间变化。根据<strong>法拉第电磁感应定律</strong>，第 2个线圈将会产生<strong>感应电动势</strong>，这种由于互感产生的电动势称为<strong>互感电动势</strong><span class="math inline">\(e_{21} = \frac{\Delta \varPsi_{21}}{\Deltat}\)</span>。同理，当 <span class="math inline">\(i_2\)</span>随着时间发生变化，同样也会在第 1 个线圈当中产生互感电动势 <span class="math inline">\(e_{12} = \frac{\Delta \varPsi_{12}}{\Deltat}\)</span>。</p><p>根据<strong>互感系数</strong> <span class="math inline">\(M =\frac{\Delta \varPsi_{21}}{i_1} = \frac{\Delta\varPsi_{12}}{i_2}\)</span> 可以推导得到 <span class="math inline">\(\varPsi_{21} = Mi_1\)</span> 和 <span class="math inline">\(\varPsi_{12} = Mi_2\)</span>，将它们代入上面 <span class="math inline">\(e_{21}\)</span> 与 <span class="math inline">\(e_{12}\)</span>的方程，就可以得到如下的方程组：</p><p><span class="math display">\[\begin{cases}第2个线圈的感应电动势 e_{21} = \frac{互感磁链变化 \Delta\varPsi_{21}}{时间变化 \Delta t} = 互感系数 M \times \frac{电流变化\Delta i_1}{时间变化\Delta t} \\第1个线圈的感应电动势 e_{12} = \frac{互感磁链变化 \Delta\varPsi_{12}}{时间变化 \Delta t} = 互感系数 M \times \frac{电流变化\Delta i_2}{时间变化 \Delta t}\end{cases}\]</span></p><p>观察上述方程组可以发现，线圈当中的互感电动势，与<strong>互感系数</strong><span class="math inline">\(M\)</span>和另一个线圈当中<strong>电流变化率</strong> <span class="math inline">\(\frac{电流变化 \Delta i}{时间变化 \Deltat}\)</span>的乘积成正比；互感电动势的方向，可以通过<strong>楞次定律</strong>进行判定。</p><h4 id="互感线圈同名端">互感线圈同名端</h4><p><strong>互感线圈</strong>当中，与<strong>感应电动势</strong>极性始终保持一致的端点称为<strong>同名端</strong>，反之则称为<strong>异名端</strong>，电路原理图当中通常会使用<strong>圆点</strong><span class="math inline">\(\cdot\)</span>符号标识互感线圈的<strong>同名端</strong>。当电流 <span class="math inline">\(i\)</span>通过<code>线圈 1</code>并且随着时间逐步增大时，电流 <span class="math inline">\(i\)</span>所产生的<strong>自感磁通</strong>与<strong>互感磁通</strong>也会随着时间增加。由于磁通的变化，<code>线圈 1</code>当中就会产生<strong>自感电动势</strong>，而<code>线圈 2</code>当中就会产生<strong>互感电动势</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/2.png"></p><p>当原电流增大时，反电动势会阻碍其增大，这样就可以判断出<strong>反向电动势</strong>产生的反向电流方向<span class="math inline">\(i_{反}\)</span> 是从 <code>1</code> 流向<code>2</code>，与原电流 <span class="math inline">\(i\)</span>的方向相反。<strong>反向电动势</strong>产生于<code>线圈 1</code>的两端，根据<strong>内电路当中电流是从负极流向正极</strong>的原理，可以绘制出<code>线圈 1</code>两端电动势的正负极性，即<code>2</code> 端为正 <code>1</code> 端为负。</p><p>对于<code>线圈 2</code>，当电流 <span class="math inline">\(i\)</span>增大时，由于互感的作用，导致通过<code>线圈 2</code>的磁通增加，根据<strong>楞次定律</strong>，可以判断出互感电流<span class="math inline">\(i_互\)</span>的方向（下图左侧）。同样根据内电路当中电流从负极流向正极的原理，还可以绘制出<code>线圈 2</code>两端电动势的正负极性，即<code>4</code> 端为正 <code>3</code> 端为负。由此可见 <code>1</code> 与<code>3</code> 而 <code>2</code> 与 <code>4</code>的极性相同。采用同样的分析方法，就可以绘制出<strong>自感电动势</strong>与<strong>互感电动势</strong>的方向（下图右侧）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/3.png"></p><p>如果上图当中的电流 <span class="math inline">\(i\)</span>并非增大而是在减小，那么各个端点的正负极性都会发生改变。但是无论电流<span class="math inline">\(i\)</span> 如何变化，上面第一张示意图当中的<code>1</code> 与 <code>3</code> 和第二张示意图当中的 <code>1</code> 与<code>4</code>的电动势极性始终会保持一致，属于<strong>同名端</strong>。</p><ol type="1"><li>第一张示意图当中的 <code>1</code> 与 <code>3</code> 以及<code>2</code> 与 <code>4</code> 是<strong>同名端</strong>，而<code>1</code> 与 <code>4</code> 以及 <code>2</code> 与 <code>3</code>是<strong>异名端</strong>；</li><li>第二张示意图当中的 <code>1</code> 与 <code>4</code> 以及<code>2</code> 与 <code>3</code> 是<strong>同名端</strong>，而<code>1</code> 与 <code>3</code> 以及 <code>2</code> 与 <code>4</code>是<strong>异名端</strong>；</li></ol><p>同名端关系只取决于两个耦合线圈的<strong>绕向</strong>与<strong>相对位置</strong>，与电压和电流没有关系，电路当中具有互感的两个线圈可以按照如下两种方式进行绘制：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/4.png"></p><p>上述判断同名端的方式，需要事先了解线圈的<strong>绕向</strong>，但是在实际情况下，线圈经过浸漆或者其它处理，外观上已经无法判断其具体绕向。在这种情况下，就需要采用<strong>实验法</strong>来进行判断：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/5.png"></p><p>上面电路当中，<code>线圈 1</code>与电阻 <span class="math inline">\(R\)</span>、开关 <span class="math inline">\(S\)</span> 串联之后，连接至直流电源 <span class="math inline">\(E\)</span>，将<code>线圈 2</code>两端连接至万用表的表笔，形成闭合回路。然后迅速闭合开关<span class="math inline">\(S\)</span>，使电流从<code>线圈 1</code>的<code>1</code> 端流入，电流随着时间不断增大 <span class="math inline">\(\frac{\Delta I}{\Delta t} &gt;0\)</span>，如果此时万用表显示正值，则<code>线圈 1</code>的<code>1</code> 端与<code>线圈 2</code>的 <code>3</code>端属于<strong>同名端</strong>，反之 <code>1</code> 与 <code>3</code>就是<strong>异名端</strong>。</p><h4 id="互感线圈的串联">互感线圈的串联</h4><p>将两个具有互感的线圈串联在一起，会存在着两种不同的连接方法：</p><ul><li><strong>异名端</strong>相接称为<strong>顺串</strong>；</li><li><strong>同名端</strong>相接称为<strong>反串</strong>。</li></ul><p>下图当中的端点 <code>1</code> 与 <code>3</code>，以及端点<code>2</code> 与 <code>4</code> 属于<strong>同名端</strong>。将<code>2</code> 和 <code>3</code>连接到一起，这样的连接方式称为<strong>顺串</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/6.png"></p><p>假设<code>线圈 1</code>的<strong>自感系数</strong>（电感）为 <span class="math inline">\(L_1\)</span>，<code>线圈 2</code>的<strong>自感系数</strong>（电感）为<span class="math inline">\(L_2\)</span>，两个线圈的<strong>互感系数</strong>为<span class="math inline">\(M\)</span>，那么<strong>顺串之后的电感值</strong><span class="math inline">\(L\)</span> 就等于：</p><p><span class="math display">\[顺串电感 L = 线圈 1 的电感 L_1 + 线圈 2 的电感 L_2 + 2 \times 互感系数 M\]</span></p><p>下图当中的端点 <code>1</code> 与 <code>4</code>，以及端点<code>2</code> 与 <code>3</code> 属于<strong>同名端</strong>。将<code>2</code> 和 <code>3</code>连接到一起，这样的连接方式称为<strong>反串</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/7.png"></p><p>此时同样的，<strong>反串之后的电感值</strong> <span class="math inline">\(L\)</span> 就可以按照如下公式计算得到：</p><p><span class="math display">\[反串电感 L = 线圈 1 的电感 L_1 + 线圈 2 的电感 L_2 - 2 \times 互感系数 M\]</span></p><blockquote><p><strong>注意</strong>：如果两个互感线圈的同名端连接在一起，则两个线圈所产生的磁通总是大小相等方向相反，因而相互抵消，这样的线圈不会具有磁通，因而就不存在电感，仅仅只起到一个电阻的作用，该原理通常运用于<strong>无感电阻</strong>的制作。</p></blockquote><h4 id="互感线圈的并联">互感线圈的并联</h4><p>假设两个互感线圈的<strong>互感系数</strong>为 <span class="math inline">\(M\)</span>，线圈 <code>1</code> 和 <code>2</code>的电感分别为 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span>，其并联时同样存在着<strong>顺并</strong>与<strong>反并</strong>两种连接方法。</p><p>将对应的<strong>同名端</strong>并联在一起称为<strong>顺并</strong>，两个线圈顺并之后的<strong>等效电感</strong><span class="math inline">\(L = \frac{L_1 \cdot L_2 - M^2}{L_1 + L_2 - 2\cdot M}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/8.png"></p><p>而把对应的<strong>异名端</strong>并联在一起称为<strong>反并</strong>，两个线圈反并之后的<strong>等效电感</strong><span class="math inline">\(L = \frac{L_1 \cdot L_2 - M^2}{L_1 + L_2 + 2\cdot M}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/9.png"></p><h3 id="变压器">变压器</h3><p><strong>变压器</strong>是一种用于改变<strong>交流电</strong>电压的元件，其基本结构主要是由<strong>铁芯</strong>和<strong>铜制绕组</strong>两部分共同构成：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/10.png"></p><ul><li><strong>铁芯</strong>用于构成电磁感应所需的<strong>磁路</strong>，由磁导率较高而又相互绝缘的硅钢片层叠而成，铁芯可以划分为芯式与壳式两种，<strong>芯式铁芯</strong>呈<strong>口</strong>字形，绕组套在铁芯柱上面，该结构多应用于大容量电力变压器；而<strong>壳式铁芯</strong>呈<strong>日</strong>字形，绕组被包围在中间，该结构通常应用于小型电子设备的变压器；</li><li><strong>绕组</strong>采用绝缘良好的<strong>漆包线</strong>或者<strong>纱包线</strong>绕制而成，变压器与电源连接的绕组称为<strong>初级绕组</strong>（也称为<strong>原线圈</strong>），与负载连接的绕组称为<strong>次级绕组</strong>（也称为<strong>副线圈</strong>）；变压器的<code>绕组与铁芯之间</code>、<code>不同绕组之间</code>、<code>绕组匝间</code>的绝缘必须保持良好，因为低压绕组与铁芯之间的绝缘较为简单，所以低压绕组靠近铁芯柱的内层，而高压绕组位于低压绕组的外侧；</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-8/11.png"></p><p>上图左侧是变压器的结构示意图，而右侧是它的电路符号。在<strong>初级绕组</strong>施加交变电压<span class="math inline">\(U_1\)</span>之后，通过的交变电流会在铁芯当中产生交变的磁通量，该磁通量会分别穿过<strong>初级绕组</strong>与<strong>次级绕组</strong>，从而产生感生电动势。此时，如果次级绕组的负载电路是闭合的，那么就会在<strong>次级绕组</strong>当中产生交变电流，从而在铁芯当中产生交变的磁通量，该磁通量同样穿过<strong>初级绕组</strong>与<strong>次级绕组</strong>，并且分别引发感生电动势。这种<strong>交变电流</strong>在初级与次级绕组当中发生的互相感应现象就是互感现象，<strong>互感现象是变压器工作的基础原理</strong>。</p><h4 id="电压变换">电压变换</h4><p><strong>初级绕组</strong>与<strong>次级绕组</strong>当中的电流共同产生的磁通量，绝大部分都会通过铁芯，仅仅会有一小部分泄露到铁芯之外，粗略计算时可以省略这些泄露掉的磁通量，即认为穿过两个线圈的交变磁通量相同，两个线圈每匝所产生的<strong>感生电动势</strong>相等。假设<strong>初级绕组的匝数</strong>为<span class="math inline">\(N1\)</span>，<strong>次级绕组的匝数</strong>为<span class="math inline">\(N2\)</span>，而<strong>穿过铁芯的磁通量</strong>为<span class="math inline">\(\varPhi\)</span>，那么初级与次级绕组当中产生的<strong>感生电动势</strong><span class="math inline">\(e_1\)</span> 与 <span class="math inline">\(e_2\)</span> 分别等于：</p><p><span class="math display">\[\begin{cases}初级绕组感生电动势 e_1 = 初级绕组匝数 N_1 \frac{穿过铁芯的磁通量变化\Delta \varPhi}{所花费的时间 \Delta t} \\次级绕组感生电动势 e_2 = 次级绕组匝数 N_2 \frac{穿过铁芯的磁通量变化\Delta \varPhi}{所花费的时间 \Delta t}\end{cases}\implies\frac{初级绕组感生电动势 e_1}{次级绕组感生电动势 e_2} =\frac{初级绕组匝数 N_1}{次级绕组匝数 N_2}\]</span></p><p><strong>初级绕组</strong>中的感生电动势 <span class="math inline">\(e_1\)</span>起着阻碍电流变化的作用，与施加在<strong>初级绕组</strong>两端电压 <span class="math inline">\(U_1\)</span>的作用相反，属于<strong>反电动势</strong>。由于<strong>初级绕组</strong>的电阻很小，如果忽略不计则有<span class="math inline">\(U_1 =e_1\)</span>。此时<strong>次级绕组</strong>相当于一个电源，其感生电动势<span class="math inline">\(e_2\)</span>相当于电源的电动势，由于<strong>次级绕组</strong>的电阻也很小，如果同样忽略不计，则<strong>次级绕组</strong>就会相当于一个没有内阻的电源，所以<strong>次级绕组</strong>的端电压<span class="math inline">\(U_2\)</span> 等于感生电动势 <span class="math inline">\(e_2\)</span>，即 <span class="math inline">\(U_2 =e_2\)</span>，经过推导就可以得到关于<strong>变压比</strong> <span class="math inline">\(n\)</span> 的方程：</p><p><span class="math display">\[\frac{初级绕组两端电压 U_1}{次级绕组两端电压 U_2} =\frac{初级绕组匝数 N_1}{次级绕组匝数 N_2} = 变压比 n\]</span></p><p>由此可见，变压器初级与次级绕组的电压有效值之比等于两个线圈的匝数比<span class="math inline">\(n\)</span>，这个 <span class="math inline">\(n\)</span> 被称为<strong>变压比</strong>：</p><ul><li>如果 <span class="math inline">\(N_2 &gt; N_1 \impliesn&lt;1\)</span>，那么 <span class="math inline">\(U_2 &gt;U_1\)</span>，变压器会让电压升高，称为<strong>升压变压器</strong>；</li><li>如果 <span class="math inline">\(N_2 &lt; N_1 \impliesn&gt;1\)</span>，那么 <span class="math inline">\(U_2 &lt;U_1\)</span>，变压器会让电压降低，称为<strong>降压变压器</strong>；</li><li>如果 <span class="math inline">\(N_2 = N_1 \impliesn=1\)</span>，此时 <span class="math inline">\(U_2 =U_1\)</span>，用于隔离初级与次级绕组上的电压，称为<strong>隔离变压器</strong>；</li></ul><p>变压器当中，<strong>次级绕组</strong>的输出电压一定是<strong>交流电压</strong>，该电压的频率与施加到<strong>初级绕组</strong>两端的交流电压频率相同。因为<strong>初级绕组</strong>产生的交变磁场变化规律与输入交流电压的变化规律相同，而<strong>次级绕组</strong>输出的交流电压变化规律也与磁场变化规律保持相同，所以<strong>输出电压与输入电压的频率相同</strong>。</p><p>如果向变压器的<strong>初级绕组</strong>施加直流电压，那么<strong>初级绕组</strong>当中流过的就是直流电流，此时<strong>初级绕组</strong>产生的磁线大小与方向均不会发生改变，导致<strong>次级绕组</strong>不能产生<strong>感生电动势</strong>，即<strong>次级绕组</strong>两端不会输出任何的电压。</p><ul><li>变压器不能将<strong>初级绕组</strong>的直流电流施加到<strong>次级绕组</strong>，因而<strong>具有隔直的特性</strong>；</li><li>变压器流过<strong>初级绕组</strong>的电流为交流电流时，<strong>次级绕组</strong>两端存在着交流电压输出，因而<strong>具有通交的特性</strong>；</li></ul><h4 id="电流变换">电流变换</h4><p>变压器工作时的功率主要由<strong>次级绕组</strong>输出，由于变压器的线圈存在电阻，极小部分会损耗在变压器内部转换为热能，从而损耗掉一部分能量（称为<strong>铜损</strong>）。而铁芯在交变磁场当中反复进行磁化，也会损耗掉一部分能量导致铁芯发热（称为<strong>铁损</strong>）。变压器的能量损耗很小，效率很高，大型变压器的效率甚至可以达到<code>97% ~ 99.5%</code>，所以实际计算通常会忽略掉这些损耗的能量，近似的认为<strong>变压器的输入与输出功率相等</strong><span class="math inline">\(U_1 I_1 = U_2 I_2\)</span>，根据变压比方程<span class="math inline">\(\frac{U_1}{U_2} = \frac{N_1}{N_2}\)</span>联立就可以得到：</p><p><span class="math display">\[\begin{cases}U_1 I_1 = U_2 I_2 \\\frac{U_1}{U_2} = \frac{N_1}{N_2}\end{cases}\implies\frac{初级绕组电流 I_1}{次级绕组电流 I_2} = \frac{次级绕组匝数N_2}{初级绕组匝数 N_1}\]</span></p><p>上述方程展现了变压器工作时，初级与次级绕组当中电流的关系，即<strong>初级绕组与次级绕组当中的电流有效值与线圈的匝数成反比</strong>。</p><blockquote><p><strong>注意</strong>：变压器的<strong>高压线圈</strong>匝数多通过的电流小，可以选择比较细的导线绕制；而<strong>低压线圈</strong>匝数少而通过的电流大，则应当选择较粗的导线进行绕制。</p></blockquote><h4 id="阻抗变换">阻抗变换</h4><p>当负载运行时，变压器还具有变流作用，负载阻抗 <span class="math inline">\(Z_L\)</span> 决定电流 <span class="math inline">\(I_2\)</span> 的大小，而电流 <span class="math inline">\(I_2\)</span>又决定了<strong>初级绕组</strong>的电流 <span class="math inline">\(I_1\)</span>的大小。即<strong>初级绕组</strong>存在着一个等效阻抗 <span class="math inline">\(Z&#39;\)</span>，其作用是将<strong>次级绕组</strong>的阻抗<span class="math inline">\(Z_L\)</span>折合到<strong>初级绕组</strong>的电路当中：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/12.png"></p><p>当变压器的<strong>次级绕组</strong>连接至 <span class="math inline">\(Z_L\)</span>以后，对于电源而言，相当于连接上阻抗为 <span class="math inline">\(n^2\cdot Z_L\)</span> 的负载，而当变压器负载阻抗 <span class="math inline">\(Z_L\)</span>确定时，调整变压器初级与次级绕组的<strong>匝数比</strong> <span class="math inline">\(n\)</span>，就可以获得所需要的阻抗，具体可以参考如下的推导过程：</p><p><span class="math display">\[\begin{cases}次级绕组负载阻抗 Z_L = \frac{U_2}{I_2} \\初级绕组等效阻抗 Z&#39; = \frac{U_1}{I_1}\end{cases}\implies\frac{Z&#39;}{Z_L} = \frac{U_1}{U_2} \times \frac{I_2}{I_1} = \bigg(\frac{N_1}{N_2} \bigg) = n^2\impliesZ&#39; = n^2 \cdot Z_L\]</span></p><blockquote><p><strong>注意</strong>：当电路输入端阻抗与信号源内阻相等时，信号源就可以将信号功率最大限度的传递给电路。同样的，当负载阻抗与电路的输出阻抗相等时，负载获得的功率最大。这种情况就称为<strong>阻抗匹配</strong>。实际电路当中，信号源与负载的阻抗并不总是匹配，因而需要在两者之间添加专用的<strong>阻抗匹配电路</strong>。</p></blockquote><h4 id="功率">功率</h4><p>变压器<strong>初级绕组</strong>的输人功率为 <span class="math inline">\(P_1=U_1 I_1 \cos \phi_1\)</span>，其中 <span class="math inline">\(\phi_1\)</span>是<strong>初级绕组</strong>当中电压与电流的<strong>相位差</strong>。变压器<strong>次级绕组</strong>的输出功率为<span class="math inline">\(P_2=U_2 I_2 \cos \phi_2\)</span>，其中 <span class="math inline">\(\phi_2\)</span>是<strong>次级绕组</strong>当中电压与电流的<strong>相位差</strong>。由此，就可以得到变压器的损耗功率<span class="math inline">\(P_{损}\)</span>：</p><p><span class="math display">\[变压器损耗功率 P_{损} = 初级绕组输入功率 P_1 - 次级绕组输出功率 P_2\]</span></p><h4 id="效率">效率</h4><p>变压器次级绕组上的<strong>输出功率</strong> <span class="math inline">\(P_2\)</span>与初级绕组上的<strong>输入功率</strong> <span class="math inline">\(P_1\)</span>之比，称为<strong>变压器的效率</strong> <span class="math inline">\(\eta\)</span>：</p><p><span class="math display">\[变压器效率 \eta = \frac{次级绕组输出功率 P_2}{初级绕组输入功率 P_1}\]</span></p><h4 id="额定参数">额定参数</h4><p>变压器制造厂商根据国家相关标准，会对变压器的工作与使用参数进行一系列的限制与规定，这些参数称为<strong>额定值</strong>，变压器的额定参数通常会采用下标<span class="math inline">\(N\)</span> 来进行表示：</p><ul><li><strong>额定电压</strong>（<span class="math inline">\(U_{1N}\)</span> 和 <span class="math inline">\(U_{2N}\)</span>）：变压器安全稳定工作所允许的最大电压值，其中<span class="math inline">\(U_{1N}\)</span>是指<strong>初级绕组</strong>一侧电源的电压，而 <span class="math inline">\(U_{2N}\)</span>则是指<strong>次级绕组</strong>一侧空载时的电压；</li><li><strong>额定电流</strong>（<span class="math inline">\(I_{1N}\)</span> 和 <span class="math inline">\(I_{2N}\)</span>）：变压器安全稳定工作所允许通过的最大电流值，其中<span class="math inline">\(I_{1N}\)</span>是指<strong>初级绕组</strong>一侧所允许通过的最大电流，而 <span class="math inline">\(I_{2N}\)</span>则是指<strong>次级绕组</strong>一侧所允许通过的最大电流。变压器的<strong>满载运行</strong>是指变压器负载运行时，次级绕组通过电流为<span class="math inline">\(I_2 = I_{2N}\)</span>的运行方式。而变压器的<strong>欠载运行</strong>是指 <span class="math inline">\(I_2 &lt; I_{2N}\)</span>的运行方式。<strong>过载运行</strong>则是指 <span class="math inline">\(I_2 &gt; I_{2N}\)</span> 的运行方式；</li><li><strong>额定容量</strong>（<span class="math inline">\(S_N\)</span>）：是指<strong>次级绕组</strong>输出的<strong>额定视在功率</strong>，单位为<code>VA</code>。由于变压器效率极高，所以通常将初级与次级绕组的额定容量设计为相等；</li><li><strong>额定频率</strong>（<span class="math inline">\(f_N\)</span>）：是指变压器安全稳定运行时所需的工作频率，单位为<code>Hz</code>，我国规定的<strong>工业标准频率</strong>（简称<strong>工频</strong>）为<code>50Hz</code>；</li></ul><h4 id="涡流">涡流</h4><p><code>发电机</code>、<code>电动机</code>、<code>变压器</code>的铁芯并非由整块金属构成，而是由许多硅钢薄片层叠而成。这是由于块状金属在变化的磁场当中，金属内部会产生感应电流，这些电流会在金属内部形成<strong>旋涡状</strong>的闭合回路，称为<strong>涡电流</strong>，简称为<strong>涡流</strong>。由于整块金属的电阻通常较小，所以涡流通常也会较强。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-8/13.png"></p><p>上面示意图当中，在块状的铁芯上面绕制了绝缘导线，当交流电通过导线时，穿过铁芯的<strong>磁通量</strong>不断发生变化，铁芯内部就会产生上图虚线所示的涡流。由于块状铁芯的电阻较小，所以内部涡流较强，从而导致铁芯大量发热，损耗了大量电能。为了减少这种涡流损失，通常会将涂有<strong>绝缘油漆</strong>的硅钢薄片层叠起来组成铁芯，这样涡流被限制在狭窄的薄片范围之内，回路的电阻较大，涡流大为减弱。</p><blockquote><p><strong>注意</strong>：铁芯采用的<strong>硅钢</strong>，电阻率比普通钢材更大，从而可以进一步的降低涡流损失。</p></blockquote><h4 id="铜损-铁损">铜损 &amp; 铁损</h4><p>由于变压器初级与次级绕组的<strong>铜质导线</strong>电阻造成的能量损耗称为<strong>铜损</strong>，当变压器空载时，由于<strong>初级绕组</strong>的电阻通常较小，空载电流与电压之间的相位差非常大（接近<code>90°</code>），因此铜损可以被忽略，此时的损耗基本上等于<strong>铁损</strong>；而当变压器工作时，铜损主要取决于<strong>负载电流</strong>的大小，而负载电流的大小与负载的阻抗有关，因而铜损大小实质上由负载的大小与功率因数所决定。</p><p>由于变压器<strong>铁芯</strong>造成的能量损耗称为<strong>铁损</strong>，铁损包括<strong>磁滞损耗</strong>和<strong>涡流损耗</strong>两个部分。磁滞损耗是铁芯在反复磁化过程当中造成的损耗，其与铁芯材料的性质相关；<strong>涡流损耗</strong>则是由于铁芯当中感生电流（涡电流）产生<strong>焦耳热</strong>造成的损耗，采用喷涂有绝缘油漆的硅钢薄片层叠而成的铁芯，可以大为减少涡流损失；除此之外，铁损的大小还与<strong>电源电压</strong>的大小相关，当电源电压一定时，铁损基本为恒定量，而与负载电流无关，造成铁损基本等于其空载损失。</p><h2 id="正弦交流电">正弦交流电</h2><h3 id="直流与交流">直流与交流</h3><p><strong>直流电</strong>是方向不会发生改变的电流，可以将其进一步划分为<strong>恒定直流电</strong>和<strong>脉动直流电</strong>两种类型。其中，<code>方向</code>与<code>大小</code>均不会发生改变的称为<strong>恒定直流电</strong>，而<code>方向</code>不变<code>大小</code>发生变化的则称为<strong>脉动直流电</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/1.png"></p><p><strong>交流电</strong>是<code>大小</code>与<code>方向</code>都会发生改变的电流，同样可以进一步划分为<strong>纯交流电</strong>与<strong>非纯交流电</strong>两种类型。纯交流电的电流平均值为<strong>零</strong>，而非纯交流电的平均值<strong>不为零</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/2.png"></p><p>由于<strong>所有非正弦交流信号都可以使用多个正弦交流信号叠加而成</strong>，所以正弦交流电的应用较为广泛，它即可以通过<strong>发电机</strong>产生，也可以通过三极管、电感、电容组成的<strong>正弦波振荡器</strong>产生。</p><h3 id="正弦交流电-1">正弦交流电</h3><p>大小与方向均随时间按照<strong>正弦规律</strong>进行周期性变化的<strong>电流</strong><span class="math inline">\(i\)</span>、<strong>电压</strong> <span class="math inline">\(u\)</span>、<strong>电动势</strong> <span class="math inline">\(e\)</span>称为<strong>正弦交流电流/电压/电动势</strong>，它们在某一时刻 <span class="math inline">\(t\)</span>的瞬时值，可以采用如下的三角函数方程来进行表示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/3.png"></p><p><span class="math display">\[\begin{aligned}交流电流 &amp; i = 交流电流峰值 I_m \times \sin(交流电角频率 \omega\times 时间 t + 初相位 \phi) \\交流电压 &amp; u = 交流电压峰值 U_m \times \sin(交流电角频率 \omega\times 时间 t + 初相位 \phi) \\交流电动势 &amp; e = 交流电动势峰值 E_m \times \sin(交流电角频率 \omega\times 时间 t + 初相位 \phi)\end{aligned}\]</span></p><h3 id="瞬时值-最大值-有效值-平均值">瞬时值 最大值 有效值 平均值</h3><p>直流电不随时间发生变化，通过其<strong>电流</strong>与<strong>电压</strong>的大小就可以进行描述；而交流电的大小与方向都会随着时间做周期性变化，描述时需要采用更多的物理量。</p><ul><li><strong>瞬时值</strong>：交流电在某一个瞬间的大小，通常采用小写字母进行表示，例如电动势<code>e</code>、电流 <code>i</code>、电压 <code>u</code>；</li><li><strong>最大值</strong>：交流电在一个周期内所能达到的最大值，也被称<strong>峰值</strong>，通常采用大写字母和下标<code>m</code> 进行表示，例如电动势 <span class="math inline">\(E_m\)</span>、电流 <span class="math inline">\(I_m\)</span>、电压 <span class="math inline">\(U_m\)</span>；</li><li><strong>有效值</strong>：根据交流电流的<strong>热效应</strong>进行定义，让交流电和直流电通过相同阻值的电阻，如果在单位时间内产生的热量相等，则将这个直流电的大小称为交流电的有效值；<strong>正弦交流电</strong>的有效值与最大值（<strong>峰值</strong>）之间具有<span class="math inline">\(U = \frac{U_m}{\sqrt{2}}\)</span> 和 <span class="math inline">\(I = \frac{I_m}{\sqrt{2}}\)</span>的关系，而对于正负半周最大值相等的<strong>方波</strong>电流，其热效应与大小为其<strong>最大值</strong>的直流电相同，所以其有效值等于最大值；</li><li><strong>平均值</strong>：由于正弦交流电的波形对称，所以单个周期内的平均值等于<strong>零</strong>，这种情况下可以对其波形的<span class="math inline">\(0 \sim \pi\)</span>正半周期取平均值，这个平均值就称为交流电的平均值。其中，<strong>交流电动势平均值</strong>可以表示为<span class="math inline">\(E_{av}\)</span>、<strong>交流电流平均值</strong>可以表示为<span class="math inline">\(I_{av}\)</span>、<strong>交流电压平均值</strong>可以表示为<span class="math inline">\(U_{av}\)</span>，正弦交流量的平均值与最大值之间具备<span class="math inline">\(E_{av} = \frac{2}{\pi} E_m\)</span>、<span class="math inline">\(I_{av} = \frac{2}{\pi} I_m\)</span>、<span class="math inline">\(U_{av} = \frac{2}{\pi} U_m\)</span>的换算关系：</li></ul><h3 id="正弦交流电三要素">正弦交流电三要素</h3><p>正弦波的三要素分别为<strong>幅值</strong>、<strong>频率</strong>、<strong>初相位</strong>。</p><ol type="1"><li><strong>幅值</strong>反映的是正弦交流电的变化范围；</li><li><strong>角频率</strong>、<strong>周期</strong>、<strong>频率</strong>反映的是正弦交流电的变化快慢；</li><li><strong>初相位</strong>反映的是正弦交流电的起始状态；</li></ol><blockquote><p><strong>注意</strong>：一旦上述三个物理量确定，其正弦波也就确定，因而正弦交流电的分析就紧紧围绕这三个要素展开。</p></blockquote><h4 id="周期与频率">周期与频率</h4><p>类似于其它表征周期性过程的参数，交流电使用了<strong>周期</strong>或者<strong>频率</strong>两个参数来表征变化的快慢：</p><ul><li><strong>周期</strong>：交流电完成<strong>一次周期性变化</strong>所需的<strong>时间</strong>，通常使用字母<span class="math inline">\(T\)</span>进行表示，单位为<strong>秒</strong>(<code>s</code>)；</li><li><strong>频率</strong>：交流电在<strong>一秒内完成周期性变化</strong>的<strong>次数</strong>，通常使用字母<span class="math inline">\(f\)</span>进行表示，单位为<strong>赫兹</strong>(<code>Hz</code>)；</li></ul><p>其中，周期与频率的换算关系如下面的方程组所示：</p><p><span class="math display">\[\begin{cases}周期 T = \frac{1}{频率 f} \\频率 f = \frac{1}{周期T}\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：我国交流电的工业标准频率（<strong>工频</strong>）为<code>50Hz</code>，其周期为 <code>0.02秒</code>，角频率为<code>314 rad/s</code>。</p></blockquote><h4 id="角频率">角频率</h4><p><strong>角频率</strong>是一个用于描述交流电<strong>角度变化快慢</strong>的物理量，表征的是单位时间内变化的<strong>相角</strong>弧度值，通常使用符号<span class="math inline">\(\omega\)</span>进行表示，单位为<strong>弧度/秒</strong>(<code>rad/s</code>)。</p><p><span class="math display">\[角频率 \omega = \frac{2 \pi}{周期 T} = 2 \pi \cdot 频率 f\]</span></p><blockquote><p><strong>注意</strong>：角频率 <span class="math inline">\(ω\)</span>、周期 <span class="math inline">\(T\)</span>，频率 <span class="math inline">\(f\)</span>三个量当中只有一个属于<strong>独立量</strong>，它们都属于反映交流电变化快慢的物理量。</p></blockquote><h4 id="相位-初相位-相位差">相位 初相位 相位差</h4><p>根据前述的交流电瞬时值表达式可以看出，交流电的瞬时值并非简单的由时间<span class="math inline">\(t\)</span> 来决定，而是由 <span class="math inline">\(\omega t + \phi\)</span>共同来确定的，这个值就称为交流电的<strong>相</strong>或者<strong>相位</strong>，相位是一个用于表征特定时刻在<strong>波形循环</strong>当中<strong>所处位置</strong>的物理量，其单位为<strong>弧度</strong>(<code>rad</code>)。其中，<span class="math inline">\(\phi\)</span> 是在时间 <span class="math inline">\(t = 0\)</span>时刻的相位，称为<strong>初相位</strong>，初相位与计时起点相关。如果将下图当中波形的起始选取在<code>A</code> 点位置，那么电压的初相位 <span class="math inline">\(\phi= 0°\)</span>；如果波形起始选取在 <code>B</code> 点位置，则电压的初相位<span class="math inline">\(\phi = 90°\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/4.png"></p><p><strong>初相位</strong>可以是任意数值，但是习惯会让<strong>初相位的绝对值小于<span class="math inline">\(\pi\)</span></strong>，例如下面图象所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/5.png"></p><p>两个交流电的相位之差称为<strong>相位差</strong>，采用 <span class="math inline">\(\Delta \phi\)</span>进行表示。如果交流电的频率相同，则相位差就等于初相位之差。假设存在两个正弦交流电压<span class="math inline">\(e_1\)</span> 与 <span class="math inline">\(e_2\)</span>，其相位分别为 <span class="math inline">\((\omega t + \phi_1)\)</span> 和 <span class="math inline">\((\omega t + \phi_2)\)</span>，那么它们之间的相位差<span class="math inline">\(\Delta \phi\)</span> 就等于：</p><p><span class="math display">\[相位差 \Delta \phi = e_1 的相位 (\omega t + \phi_1) - e_2 的相位 (\omegat + \phi_2) = e_1 的初相位 \phi_1 - e_2 的初相位 \phi_2\]</span></p><p>当相位差 <span class="math inline">\(\Delta \phi &gt; 0\)</span>的时候，<span class="math inline">\(e_1\)</span> 会比 <span class="math inline">\(e_2\)</span>先达到<code>正负最大值</code>和<code>零</code>，此时 <span class="math inline">\(e_1\)</span> 比 <span class="math inline">\(e_2\)</span> 超前 <span class="math inline">\(\Delta \phi\)</span> 角，或者说 <span class="math inline">\(e_1\)</span> 的初相位大于 <span class="math inline">\(e_2\)</span> 的初相位；</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/6.png"></p><p>当相位差 <span class="math inline">\(\Delta \phi &lt; 0\)</span>的时候，说明 <span class="math inline">\(e_1\)</span> 的相位滞后于 <span class="math inline">\(e_2\)</span> 的初相位：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/7.png"></p><p>当相位差 <span class="math inline">\(\Delta \phi = 0\)</span>的时候，说明 <span class="math inline">\(e_1\)</span> 和 <span class="math inline">\(e_2\)</span>的变化步调一致，可以同时达到<code>正负最大值</code>和<code>零</code>，这种情况称为<strong>同相位</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/8.png"></p><p>当相位差 <span class="math inline">\(\Delta \phi = 180°(\pi)\)</span>的时候，该情况称为 <span class="math inline">\(e_1\)</span> 与 <span class="math inline">\(e_2\)</span><strong>反相</strong>，两个交流电的变化步调恰好相反。当一个到达<strong>正最大值</strong>，另一个则会到达<strong>负最大值</strong>；而一个<strong>减小至零</strong>，另一个则会<strong>增大至零</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/9.png"></p><p>当 <span class="math inline">\(\Delta \phi =90°(\frac{\pi}{2})\)</span> 时，这种情况称为 <span class="math inline">\(e_1\)</span> 与 <span class="math inline">\(e_2\)</span> <strong>正交</strong>，其特点是当<span class="math inline">\(e_1\)</span>达到<strong>最大值</strong>时，<span class="math inline">\(e_2\)</span>正好等于<strong>零</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/10.png"></p><h4 id="正弦交流电的表示方法">正弦交流电的表示方法</h4><p>正弦交流电可以分别采用<strong>函数法</strong>、<strong>图像法</strong>、<strong>向量图法</strong>来进行表征。其中，<strong>函数法</strong>是指利用三角函数方程来表示正弦交流特征的方法，例如前面介绍的<code>交流电流</code><span class="math inline">\(i = I_m \times \sin(\omega t +\phi)\)</span>、<code>交流电压</code> <span class="math inline">\(u=  U_m \times \sin(\omega t + \phi)\)</span>、<code>交流电动势</code><span class="math inline">\(e =  E_m \times \sin(\omega t +\phi)\)</span> 瞬时值表达式，就是采用了该种表示方法。</p><p>除此之外，正弦交流电还可以使用函数对应的图像来进行表示，其<code>最大值</code>、<code>周期</code>、<code>初相位</code>、<code>任一时刻瞬时值</code>都可以在图像当中表达出来，这就是更为形象直观的<strong>图像法</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/11.png"></p><p>由于正弦交流电的三要素在旋转的有向线段当中存在着一一对应关系，因而也可以采用旋转的有向线段来表示进行表示，而这种方式被称为<strong>相量图法</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/12.png"></p><p>在上面的示意图当中，从原点出发绘制一条有向线段，其长度等于正弦量的<strong>最大值</strong><span class="math inline">\(I_m\)</span>，其与横轴的夹角等于正弦量的<strong>初相位</strong><span class="math inline">\(\phi\)</span>，此时以<strong>角频率</strong><span class="math inline">\(\omega\)</span>逆时针进行旋转，则在任意一个瞬间，该<strong>有向线段</strong> <span class="math inline">\(I_m\)</span> 在纵轴上的投影就等于该正弦量的瞬时值<span class="math inline">\(i = I_m \sin(\omega t +\phi)\)</span>。由于分析同频率正弦量的时候，只需要使用<strong>大小</strong>与<strong>相位</strong>两个要素，所以有向线段<span class="math inline">\(I_m\)</span>可以直接用于表达正弦交流电。</p><p>通过上述旋转的有向线段来表示正弦量较为烦琐，通常只会使用<strong>初始位置</strong>为<span class="math inline">\(t = 0\)</span>时刻的<strong>有向线段</strong> <span class="math inline">\(I_m\)</span>表征一个正弦量，其长度等于正弦量的<strong>幅值</strong>，与横轴正方向的夹角等于正弦量的<strong>初相位</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/13.png"></p><p>上述的有向线段围绕<strong>角频率</strong>做逆时针方向旋转，其在纵轴上的投影表示的是正弦量的<strong>瞬时值</strong>。由于实际问题当中，通常涉及的都是正弦量的<strong>有效值</strong>，因而为了方便起见，通常会让<strong>有向线段</strong>的长度等于正弦量的<strong>有效值</strong>（即下图当中的<span class="math inline">\(I\)</span>），此时纵轴上的投影就不再表示正弦量的瞬时值：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/14.png"></p><p>这种采用具备<strong>大小</strong>与<strong>方向</strong>的<strong>有向线段</strong>来表征正弦量的方法，称为<strong>向量图表示法</strong>。这个具有大小与方向的有向线段称为<strong>向量</strong>，通常采用大写字母加符号<span class="math inline">\(\cdot\)</span> 来进行表示。</p><blockquote><p><strong>注意</strong>：当使用向量图来表示正弦量的<strong>幅值</strong>与<strong>初相</strong>时，一般以<code>横轴 OX</code>的正方向作为参考，向量与<code>横轴 OX</code>正方向的夹角表示<strong>初相</strong>；以<code>横轴 OX</code>正方向作为起始，<strong>逆时针</strong>旋转相位角度为<strong>正</strong>，<strong>顺时针</strong>旋转相位角度为<strong>负</strong>，向量的长度表示正弦量的<strong>有效值</strong>或者<strong>最大值</strong>。</p></blockquote><p>通过向量图可以清晰的表达出各个正弦量<strong>大小</strong>与<strong>相位</strong>的关系，例如下图左侧是正弦交流<strong>电压</strong><span class="math inline">\(u\)</span> 与<strong>电流</strong> <span class="math inline">\(i\)</span>的波形图，根据波形图当中展现的正弦量大小与相位绘制出右侧的向量图，可以看到<span class="math inline">\(u\)</span> 超前 <span class="math inline">\(i\)</span> 的相位为 <span class="math inline">\(\Delta\phi\)</span>。由此可见，采用向量图来分析交流量的关系简单又明晰：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-9/14.png"></p><blockquote><p><strong>注意</strong>：向量图只能用于表征<strong>正弦周期量</strong>，除此之外，<strong>不同频率的正弦量</strong>不能绘制到同一张向量图。</p></blockquote><h2 id="r-l-c-电路">R / L / C 电路</h2><h3 id="纯电阻电路">纯电阻电路</h3><p>如果<strong>交流电路</strong>当中只存在<strong>电阻</strong>元件，那么该电路就被称为<strong>纯电阻电路</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/1.png"></p><h4 id="电压-电流的关系">电压 &amp; 电流的关系</h4><p>纯电阻电路当中，<code>电流</code>与<code>电压</code>在任意时刻的关系都遵守着<strong>欧姆定律</strong>。假设<strong>电阻</strong>为<span class="math inline">\(R\)</span>，添加在其两端的<strong>交变电压</strong>为<span class="math inline">\(u = U_m \sin \omegat\)</span>，此时通过该电阻的<strong>瞬时电流</strong> <span class="math inline">\(i\)</span> 等于：</p><p><span class="math display">\[瞬时电流 i = \frac{交变电压 u}{电阻 R} = \frac{电压峰值 U_m}{电阻 R}\sin (角频率 \omega \cdot 时间 t) = 电流峰值 I_m \cdot \sin (角频率\omega \cdot 时间 t)\]</span></p><p>如果纯电阻电路当中的<strong>电压</strong>与<strong>电流</strong>均采用<strong>有效值</strong>，那么其关系就会完全遵循<strong>欧姆定律</strong>：</p><p><span class="math display">\[电流有效值 I = \frac{电压有效值 U}{电阻 R}\]</span></p><blockquote><p><strong>注意</strong>：纯电阻电路当中的<strong>电流</strong>与<strong>电压</strong>保持<strong>同相</strong>，换而言之，电阻不会影响到电流与电压的相位关系。</p></blockquote><h4 id="功率消耗">功率消耗</h4><h5 id="瞬时功率">瞬时功率</h5><p>纯电阻交流电路当中，当<strong>电流</strong> <span class="math inline">\(i\)</span> 流过<strong>电阻</strong> <span class="math inline">\(R\)</span>时，会导致电阻产生热量，电阻消耗功率将电能转化为热能，由于流过电阻的电流与电阻两端的电压伴随时间不断发生变化，所以电阻<span class="math inline">\(R\)</span>消耗的功率也会随着时间不断变化。电阻当中某一时刻消耗的电功率称为<strong>瞬时功率</strong>，其值等于<strong>电压</strong><span class="math inline">\(u\)</span> 与<strong>电流</strong> <span class="math inline">\(i\)</span> 瞬时值的乘积，使用小写字母 <span class="math inline">\(p\)</span> 进行表示：</p><p><span class="math display">\[瞬时功率 p = 瞬时电压 u \times 瞬时电流 i = 峰值电流 I_m \cdot 峰值电压U_m \sin^2 (角频率 \omega \cdot 时间 t)\]</span></p><p>根据交流电的<strong>最大值</strong>（峰值）与<strong>有效值</strong>之间的关系，可以得到：</p><p><span class="math display">\[瞬时功率 p = 有效电压 U \cdot 有效电流 I \cdot (1 - \cos (2 \times角频率 \omega \cdot 时间 t)\]</span></p><p>上述的方程说明，任意一个瞬间都恒有<strong>瞬时功率</strong> <span class="math inline">\(p \ge0\)</span>，说明<strong>电阻</strong>总是在吸收功率，属于<strong>耗能元件</strong>。下图展示了<strong>瞬时功率</strong><span class="math inline">\(p\)</span> 伴随<strong>瞬时电压</strong><span class="math inline">\(u\)</span> 与<strong>瞬时电流</strong> <span class="math inline">\(i\)</span> 变化而发生变化的规律：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/2.png"></p><h5 id="平均功率">平均功率</h5><p>虽然<strong>瞬时功率</strong>可以表征电阻消耗功率的瞬时状态，但是不便于去表达与比较大小，所以工程实践当中，经常使用瞬时功率在一个周期内的平均值来表示功率，称为<strong>平均功率</strong>，通常采用大写字母<span class="math inline">\(P\)</span>进行表示，<strong>日常讨论的功率主要就是指平均功率</strong>：</p><p><span class="math display">\[平均功率 P = 有效电压 U \times 有效电流 I = 有效电流 I^2 \times 电阻 R =\frac{有效电压 U^2}{电阻 R}\]</span></p><blockquote><p><strong>注意</strong>：平均功率的表达式与直流电路当中功率的表达形式完全相同，不同之处在于交流电路当中的<code>电流</code>与<code>电压</code>要使用<strong>有效值</strong>。除此之外，<strong>该公式仅适用于纯电阻电路</strong>。</p></blockquote><h3 id="纯电感电路">纯电感电路</h3><p>直流电路当中，影响<code>电流</code>与<code>电压</code>关系的只有<strong>电阻</strong>；而在交流电路当中，影响<code>电流</code>与<code>电压</code>关系的，除了电阻之外，还有<strong>电感</strong>和<strong>电容</strong>。其中，电感采用铜制导线进行绕制，铜的电阻率极小，因此线圈自身的电阻可以忽略不计，而认为线圈只具有电感特性，这种只具有电感特性的电路称为<strong>纯电感电路</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/3.png"></p><h4 id="感抗-1">感抗</h4><p>由于交流电通过电感线圈时，电流时刻在发生改变，导致电感线圈当中产生自感电动势，从而阻碍电流的变化，这样就形成了对于电流的阻碍作用。这种电感对于<strong>交流电</strong>的阻碍作用就称为<strong>感抗</strong><span class="math inline">\(X_L\)</span>，其值与<strong>电感</strong><span class="math inline">\(L\)</span> 和<strong>频率</strong> <span class="math inline">\(f\)</span> 成正比：</p><p><span class="math display">\[感抗 X_L = 2 \pi \times 频率 f \times 电感 L\]</span></p><p>接下来，研究纯电感电路当中<strong>电流</strong>与<strong>电压</strong>的关系，下面电路当中的<span class="math inline">\(L\)</span>是一个电阻可以忽略不计的电感线圈：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/4.png"></p><p>改变上图当中交流电源的电压，通过 <span class="math inline">\(L\)</span>的电流就会随之发生改变，分析几组电流与电压的数值之后，就会发现纯电感电路当中的<strong>电流</strong>与<strong>电压</strong>成正比。这里采用<span class="math inline">\(\frac{1}{X_L}\)</span>作为比例恒量，就可以得到纯电感电路当中欧姆定律的表达式：</p><p><span class="math display">\[电流 I = \frac{电压 U}{感抗 X_L}\]</span></p><p>上述表达式与直流电路上的<strong>欧姆定律</strong>相比，阻抗 <span class="math inline">\(X_L\)</span> 相当于电阻 <span class="math inline">\(R\)</span>，不过这里的 <span class="math inline">\(X_L\)</span>表示的是电感对于交流信号的阻碍作用。</p><p>当<strong>电感线圈</strong>两端添加上<strong>交流电压</strong> <span class="math inline">\(u\)</span>，<strong>线圈</strong>当中就会通过交变电流，由于电流时刻在发生变化，导致线圈产生阻碍电流变化的<strong>自感电动势</strong>。因此，线圈当中电流的变化会滞后于线圈两端外加电压的变化。如果线圈通过的交流<strong>电流</strong>为<span class="math inline">\(i\)</span>、<strong>电压</strong>为 <span class="math inline">\(u\)</span>、产生的<strong>自感电动势</strong>为<span class="math inline">\(e_L\)</span>，则其<strong>正方向</strong>如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/5.png"></p><p>根据<strong>基尔霍夫定律</strong>可以得到 <span class="math inline">\(u = -e_L\)</span>，再假设电流 <span class="math inline">\(i = I_m \sin \omegat\)</span>，经过推算就可以得到<strong>瞬时电压</strong> <span class="math inline">\(u\)</span> 的表达式：</p><p><span class="math display">\[\begin{aligned}瞬时电压 u = 峰值电流 I_m \cdot 角频率 \omega \cdot 电感 L \cdot\sin(角频率 \omega \cdot 时间 t + 90°) \\\xrightarrow{U_m = I_m \omega L = I_m X_L} 峰值电压 U_m \cdot\sin(角频率 \omega \cdot 时间 t + 90°)\end{aligned}\]</span></p><p>纯电感电路当中，<strong>电流的相位相比于电压会滞后<code>90°</code></strong>，如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/6.png"></p><p>自感电动势本身就是由于电流的变化而产生，如果没有电流，也就不会产生自感电动势。电压<span class="math inline">\(u\)</span> 与自感电动势 <span class="math inline">\(e_L\)</span> 大小相等相位相反 <span class="math inline">\(u =e_L\)</span>，说明由于自感电动势具有阻碍电流变化的性质，导致电源的电压必须对其进行平衡。</p><blockquote><p><strong>注意</strong>：<strong>感抗</strong>只是<code>电压</code>与<code>电流</code>的<strong>幅值</strong>或者<strong>有效值</strong>之比，而并不是其<strong>瞬时值</strong>之比<span class="math inline">\(X_L \neq\frac{u}{i}\)</span>。由于<strong>电感电路</strong>与<strong>电阻电路</strong>存在区别，纯电感电路当中，电压与电流之间并不会存在比例关系，例如当电压<span class="math inline">\(u = U_m \sin \omega t\)</span> 的时候，电流<span class="math inline">\(i = \frac{U_m}{X_L} \sin(\omega t - 90°) =I_m \sin(\omega t - 90°)\)</span>。</p></blockquote><h4 id="扼流圈">扼流圈</h4><p><strong>电阻</strong>由导体本身的<code>电阻率</code>、<code>长度</code>、<code>横截面积</code>所共同决定，而与其通过的<strong>电流</strong>无关，根据感抗的公式<span class="math inline">\(X_L = 2 \pi f L\)</span>可以知道感抗与通过电流的频率相关。例如，自感系数为 <code>1H</code>亨的线圈，对于频率为 <span class="math inline">\(f = 0\)</span>的直流电，其阻抗 <span class="math inline">\(X_L = 0\)</span>；而对于<code>50Hz</code> 频率的工频交流电，对应的阻抗则为 <span class="math inline">\(X_L = 3.14 MΩ\)</span>；因此，电感线圈在电路当中具有<strong>通直流阻交流</strong>或者<strong>通低频阻高频</strong>的特性。</p><ul><li>用于<strong>通直流阻交流</strong>的电感线圈称为<strong>低频扼流圈</strong>：线圈绕制在闭合铁心上面，匝数为几千甚至超过一万，自感系数为几十亨，这种线圈对于低频交流电存在着极大的阻碍作用；</li><li>用于<strong>通低频阻高频</strong>的电感线圈称为<strong>高频扼流圈</strong>：线圈绕制在圆柱形铁氧体上面，或者直接为空心，匝数通常为几百，自感系数仅为几个毫亨，这类线圈对于低频交流电的阻碍作用较小，但对于高频交流电的阻碍作用较大；</li></ul><h4 id="功率消耗-1">功率消耗</h4><h5 id="瞬时功率-1">瞬时功率</h5><p>假设<strong>电流</strong> <span class="math inline">\(i = I_m \sin\omega t\)</span>，而<strong>电压</strong> <span class="math inline">\(u= U_m \sin(\omega t + 90°)\)</span>，则<strong>瞬时功率</strong> <span class="math inline">\(p\)</span> 等于：</p><p><span class="math display">\[p = u \cdot i = \{ I_m \sin \omega t \} \times \{ U_m \sin(\omega t +90°) \} = U_m I_m \sin \omega t \cos \omega t = \frac{U_m I_m}{2} \sin 2\omega t = UI \sin 2 \omega t\]</span></p><p>根据该公式可知，<strong>瞬时功率</strong> <span class="math inline">\(p\)</span> 是一个<strong>幅值</strong>大小等于<span class="math inline">\(U \cdot I\)</span>，并且以 <span class="math inline">\(2 \pi\)</span>作为<strong>角频率</strong>，随着时间不断发生变化的物理量，其波形如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/7.png"></p><p>在上图第 1 个和第 3 个的 <span class="math inline">\(\frac{1}{4}\)</span> 周期之内，由于 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(i\)</span> 的正负符号相同，瞬时功率 <span class="math inline">\(p\)</span>为<strong>正</strong>（电流增大，磁场建立，线圈将电能转换为磁能）。而在第2 个和第 4 个的 <span class="math inline">\(\frac{1}{4}\)</span>周期之内，由于 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(i\)</span> 的正负符号相反，瞬时功率 <span class="math inline">\(p\)</span>为<strong>负</strong>（电流减小，磁场消失，线圈将存储的磁能转换为电能），瞬时功率的正负可以按照如下方式进行简单直观的理解：</p><ul><li>当瞬时功率 <span class="math inline">\(p\)</span>为<strong>正值</strong>时，外电路处于<strong>用电</strong>状态，其从电源<strong>消耗</strong>电能；</li><li>当瞬时功率 <span class="math inline">\(p\)</span>为<strong>负值</strong>时，外电路处于<strong>发电</strong>状态，其向电源<strong>充入</strong>电能；</li></ul><h5 id="无功功率-有功功率">无功功率 &amp; 有功功率</h5><p>纯电感电路的<strong>平均功率</strong> <span class="math inline">\(P =0\)</span>，不存在能量消耗，只存在<strong>电源</strong>与<strong>电感元件</strong>之间的能量互换，这种能量互换的规模就采用<strong>无功功率<span class="math inline">\(Q_L\)</span></strong>来进行衡量，其单位为<strong>乏</strong>(<code>var</code>)或者<strong>千乏</strong>(<code>kvar</code>)，并且规定无功功率等于<strong>瞬时功率</strong><span class="math inline">\(p\)</span> 的幅值：</p><p><span class="math display">\[无功功率 Q_L = U \cdot I = I^2 X_L\]</span></p><p>本质上，电感元件属于一种储能元件，它与电源之间进行的是一种能量互换，由于电感元件本身没有消耗能量，所以被命名为<strong>无功功率</strong>。相应的，<strong>平均功率</strong>则会被称为<strong>有功功率</strong>。</p><h3 id="纯电容电路">纯电容电路</h3><p>对于一个只连接有<strong>电容器</strong>的电路，如果忽略连接导线的电阻不计，就可以称为<strong>纯电容电路</strong>。</p><p>交流电之所以能够通过电容器，是因为在电源的电压升高时，可以为电容器充电，电荷向电容器的极板聚集，形成<strong>充电电流</strong>；而当电源的电压降低时，电容器开始放电，电荷从电容器的极板释放出来，形成<strong>放电电流</strong>。电容器的充电与放电不断交替进行，于是电路上就产生了流动的电流。</p><h4 id="容抗">容抗</h4><p>对于导线当中形成电流的自由电荷，当电源的电压推动它们向某一个方向进行定向运动时，电容器两个极板积累的电荷会抵制其向该方向进行定向运动，从而导致<strong>电容对于交流电存在着阻碍作用</strong>，这种电容对于交流电的阻碍作用称为<strong>容抗</strong>，容抗<span class="math inline">\(X_c\)</span> 的大小与<strong>频率</strong><span class="math inline">\(f\)</span> 和<strong>电容器</strong>的容值<span class="math inline">\(C\)</span> 成反比：</p><p><span class="math display">\[容抗 X_C = \frac{1}{2 \pi \cdot 频率 f \cdot 电容 C}\]</span></p><p>分析下面电路，研究纯电容电路当中<code>电流</code>与<code>电压</code>之间的关系，如果改变电路两端的电压，那么电路当中的电流就会随之而改变：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/8.png"></p><p>分析几组<code>电压</code>与<code>电流</code>的数据之后就会发现，纯电容电路当中的<strong>电流</strong><span class="math inline">\(I\)</span> 与<strong>电压</strong> <span class="math inline">\(U\)</span> 成正比，这里以 <span class="math inline">\(\frac{1}{X_C}\)</span>作为<strong>比例恒量</strong>，就可以得到纯电容电路当中<strong>欧姆定律</strong>的表达式：</p><p><span class="math display">\[电流 I = \frac{电压 U}{容抗 X_C}\]</span></p><p>上述方程当中的<strong>容抗</strong> <span class="math inline">\(X_C\)</span>相当于欧姆定律里的<strong>电阻</strong> <span class="math inline">\(R\)</span>，用于表示电容对于交流电的阻抗作用大小。下图当中的电容元件已经连接到了正弦电源，电路当中的<strong>电流</strong><span class="math inline">\(i\)</span>与电容器两端的<strong>电压</strong> <span class="math inline">\(u\)</span> 的正方向如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/9.png"></p><p>当电压发生变化时，电容器极板上的电量也会随之发生改变，在电路当中就会产生电流。如果在电容器两端添加一个正弦电压<span class="math inline">\(u= U_m \sin \omegat\)</span>，经过推算就可以得到电流 <span class="math inline">\(i\)</span>：</p><p><span class="math display">\[电流 i = 峰值电流 I_m \sin \times (角频率 \omega \cdot 时间 t + 90°)\]</span></p><p>上面方程当中的<strong>电流峰值</strong> <span class="math inline">\(I_m = U_m \omegaC\)</span>，因而在纯电容电路当中，<strong>电流比电压的相位超前<code>90°</code></strong>，如下面的图形所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/10.png"></p><h4 id="隔直与旁路">隔直与旁路</h4><p><strong>容抗</strong>与通过电流的<strong>频率</strong>相关，容抗与频率成反比，频率越高容抗越小。例如<code>10pF</code> 电容器，对于频率为 <span class="math inline">\(f =0\)</span> 的直流电，阻抗 <span class="math inline">\(X_c\)</span>为无穷大；而对于 <code>f = 50Hz</code> 的工频交流电，阻抗 <span class="math inline">\(X_C = 318Ω\)</span>；对于 <code>500kHz</code>的交流电，则阻抗 <span class="math inline">\(X_C =0.0318Ω\)</span>，所以电容器在电路当中具有<strong>通交流隔直流</strong>或者<strong>通髙频阻低频</strong>的特性。</p><p>实际电路应用当中，电流通常既包含有<strong>交流成分</strong>，也会包含有<strong>直流成分</strong>。如果需要将交流成分输送至下一级电路，那么只需要在两级电路之间<strong>串联一个电容器</strong>，就可以使得交流成分顺利的通过，而直流成分被成功的阻止，这种用法的电容器称为<strong>隔直电容器</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/11.png"></p><p>如果只需要将低频成分传输至下一级电路，则只要在下级电路的输入端<strong>并联一个电容器</strong>，由于电容器对于高频成分的容抗较小，而对于低频成分的容抗较大，可以使得高频成分顺利的通过电容器，而让低频成分输入到下级电路，这种用法的电容器称为<strong>高频旁路电容器</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/12.png"></p><h4 id="功率消耗-2">功率消耗</h4><h5 id="瞬时功率-2">瞬时功率</h5><p>假设<strong>电压</strong> <span class="math inline">\(u = U_m\sin(\omega t)\)</span>，而<strong>电流</strong> <span class="math inline">\(i = I_m \sin(\omega t +90°)\)</span>，那么<strong>瞬时功率</strong> <span class="math inline">\(p\)</span> 就等于：</p><p><span class="math display">\[\begin{aligned}瞬时功率 p &amp;= 电压 u \times 电流 i \\&amp;= \{ 峰值电压 U_m \cdot \sin (角频率 \omega \cdot 时间 t) \} \times\{峰值电流 I_m \cdot \sin(角频率 \omega \cdot 时间 t + 90°) \} \\&amp;= 峰值电压 U_m \cdot 峰值电流 I_m \cdot \sin (角频率\omega \cdot时间 t) \cdot \cos (角频率\omega \cdot 时间 t) \\&amp;= \frac{峰值电压 U_m \cdot 峰值电流 I_m}{2} \cdot \sin (2 \times角频率 \omega \cdot 时间 t) \\&amp; \xrightarrow{\frac{U_m I_m}{2} = UI} 瞬时功率 p = 电压 U \cdot电流 I \cdot \sin(2 \times 角频率 \omega \cdot 时间 t)\end{aligned}\]</span></p><p>由上述推导结果可以了解，瞬时功率 <span class="math inline">\(p\)</span> 是一个幅值为 <span class="math inline">\(U \cdot I\)</span>，并且以 <span class="math inline">\(2 \omega\)</span>的角频率随时间变化的物理量，其波形变化如图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/13.png"></p><p>在第 1 与第 3 个的 <span class="math inline">\(\frac{1}{4}\)</span>周期当中，电压值增高，电容元件充电，此时电容元件会从电源获取电能，并且将其储存在元件内部的电场当中，所以<span class="math inline">\(p\)</span> 为<strong>正</strong>。而在第 2和第 4 个的 <span class="math inline">\(\frac{1}{4}\)</span>周期内，电压值开始降低，此时电容元件释放出充电时储存的电能，所以 <span class="math inline">\(p\)</span> 为<strong>负</strong>。</p><h5 id="无功功率-有功功率-1">无功功率 &amp; 有功功率</h5><p>纯电容电路当中，平均功率 <span class="math inline">\(P =0\)</span>，即<strong>有功功率</strong>等于零，说明电容元件并不消耗能量，电源与电容元件本身之间只是发生了能量转换，这个能量转换的规模就采用<strong>无功功率</strong><span class="math inline">\(Q\)</span>来进行表示，其值等于<strong>瞬时功率</strong> <span class="math inline">\(p\)</span> 的幅值。</p><p>通常会将电容上的无功功率称为<strong>容性无功</strong>，其值为<strong>负</strong>；而将<strong>电感</strong>的无功功率称为<strong>感性无功</strong>，其值为<strong>正</strong>，这样电容上的无功功率<span class="math inline">\(Q_C\)</span> 就可以等于：</p><p><span class="math display">\[电容无功功率 Q_C = - 电压 U \times 电流 I = - 电流 I^2 \times 容抗 X_C\]</span></p><h5 id="电感与电容元件的比较">电感与电容元件的比较</h5><ul><li><strong>电感元件</strong>上的<strong>电压</strong>超前于<strong>电流</strong><code>90°</code>，而<strong>电容元件</strong>则是<strong>电压</strong>滞后于<strong>电流</strong><code>90°</code>；</li><li><strong>感抗</strong>与<strong>容抗</strong>的频率特性不同，<strong>电感是通直隔交</strong>，对于低频信号的阻碍作用较小；而<strong>电容是通交隔直</strong>，对于高频信号的阻碍较小；</li><li>当<strong>电容</strong>与<strong>电感</strong>上面流过的电流相同时，两者功率的流向相反，即电感从电源吸收功率时，电容则刚向电源发出功率，这里采用感性无功与容性无功来表达这种差别。其中，电感的<strong>感性无功功率</strong><span class="math inline">\(Q_L = UI =I^2X_L\)</span>，而电容的<strong>容性无功功率</strong> <span class="math inline">\(Q_C = -UI = - I^2 X_C\)</span>；</li></ul><h3 id="rlc-串联电路">RLC 串联电路</h3><h4 id="电压与电流关系">电压与电流关系</h4><p>下图是一个<strong>电阻</strong>、<strong>电感</strong>、<strong>电容</strong>元件串联组成的交流电路，电路当中的各个元件都通过相同的电流，电流与电压的<strong>正方向</strong>如下图所示，分析该电路可以应用到前述的<strong>纯电阻</strong>、<strong>纯电感</strong>、<strong>纯电容</strong>电路理论。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/14.png"></p><p>根据<strong>基尔霍夫定律</strong>可以得到 <span class="math inline">\(u = u_R + u_L + u_C\)</span>，假设电流 <span class="math inline">\(i = I_m \sin \omega t\)</span>为参考正弦量，则电阻元件上的电压 <span class="math inline">\(u_R\)</span>与电流<strong>同相</strong>，从而可以得到：</p><p><span class="math display">\[u_R = I_m R \sin \omega t = U_{Rm} \sin \omega t\]</span></p><p>接下来，由于<strong>电感元件</strong>上的电压 <span class="math inline">\(u_L\)</span> <strong>超前于</strong>电流 <span class="math inline">\(90°\)</span>，由此就可以得到：</p><p><span class="math display">\[u_L = I_m \omega L \sin(\omega t + 90°) = U_{Lm} \sin(\omega t + 90°)\]</span></p><p>类似的，由于<strong>电容元件</strong>上的电压 <span class="math inline">\(u_L\)</span> <strong>滞后于</strong>电流 <span class="math inline">\(90°\)</span>，同样也可以得到：</p><p><span class="math display">\[u_C = \frac{I_m}{\omega C} \sin(\omega t - 90°) = U_{Cm} \sin(\omega t -90°)\]</span></p><p>然后，根据阻抗的<code>电压</code>与<code>电流</code>关系，就可以分别得到<code>电阻</code>、<code>电容</code>、<code>电感</code> 的阻抗：</p><p><span class="math display">\[\begin{cases}\frac{U_{Rm}}{I_m} = \frac{U_R}{I} = R \\\frac{U_{Lm}}{I_m} = \frac{U_L}{I} = \omega L = X_L \\\frac{U_{Cm}}{I_m} = \frac{U_C}{I} = \frac{1}{\omega L} = X_C\end{cases}\]</span></p><p>因为<strong>同频率</strong>的正弦量相加，所得到的仍然是同频率的<strong>正弦量</strong>，所以<strong>电源电压</strong><span class="math inline">\(u\)</span> 等于：</p><p><span class="math display">\[u = u_R + u_L + u_C = U_m \sin(\omega t + \phi)\]</span></p><p>观察可以发现，这个电压的幅值为 <span class="math inline">\(U_m\)</span>，与电流之间的相位差为 <span class="math inline">\(\phi\)</span>，这里利用<strong>向量图</strong>来求解<strong>幅值</strong><span class="math inline">\(U_m\)</span> 与<strong>相位差</strong> <span class="math inline">\(\varPhi\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/15.png"></p><p>如果将电压 <span class="math inline">\(u_R\)</span>、<span class="math inline">\(u_L\)</span>、<span class="math inline">\(u_C\)</span> 表示为向量 <span class="math inline">\(\dot{U_R}\)</span>、<span class="math inline">\(\dot{U_L}\)</span>、<span class="math inline">\(\dot{U_C}\)</span>，将这些向量相加就可以得到电源电压<span class="math inline">\(u\)</span> 的向量 <span class="math inline">\(\dot{U}\)</span>。由电压向量 <span class="math inline">\(\dot{U}\)</span> 和 <span class="math inline">\(\dot{U_R}\)</span> 以及 <span class="math inline">\((\dot{U_L} + \dot{U_C})\)</span>所组成的直角三角形，称为<strong>电压三角形</strong>，利用它就可以求解得到<strong>电源电压的有效值</strong><span class="math inline">\(U\)</span>：</p><p><span class="math display">\[U = \sqrt{U_R^2 + (U_L - U_C)^2} = \sqrt{(IR)^2 + (L X_L - L X_C)^2} = I\sqrt{R^2 + (X_L - X_C)^2}\]</span></p><p>上式也可以写做 <span class="math inline">\(\frac{U}{I} = \sqrt{R^2 +(X_L -X_C)^2}\)</span>，此时电路当中<code>电压</code>与<code>电流</code>的有效值（幅值）之比就等于<span class="math inline">\(\sqrt{R^2 + (X_L -X_C)^2}\)</span>，其单位同样为<strong>欧姆</strong>，同样对于电流存在着阻碍作用，称为电路的<strong>阻抗</strong>，使用<span class="math inline">\(|Z|\)</span> 进行表示：</p><p><span class="math display">\[|Z| = \sqrt{R^2 + (X_L - X_C)^2} = \sqrt{R^2 + (\omega L -\frac{1}{\omega C})^2}\]</span></p><p>由此可见，电路的<strong>阻抗</strong> <span class="math inline">\(|Z|\)</span>、<strong>电阻</strong> <span class="math inline">\(R\)</span> 以及 <span class="math inline">\((X_L -X_C)\)</span>三者之间的关系同样可以采用<strong>阻抗三角形</strong>来进行表示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/16.png"></p><p>而电源<strong>电压</strong> <span class="math inline">\(u\)</span>与<strong>电流</strong> <span class="math inline">\(i\)</span>之间的<strong>相位差</strong>，可以通过<strong>电压三角形</strong>来获得：</p><p><span class="math display">\[\tan \phi = \frac{U_L - U_C}{U_R}\implies\phi = \arctan \frac{U_L - U_C}{U_R} = \arctan \frac{X_L - X_C}{R}\]</span></p><p><strong>阻抗</strong> <span class="math inline">\(|Z|\)</span>、<strong>电阻</strong> <span class="math inline">\(R\)</span>、<strong>感抗</strong> <span class="math inline">\(X_L\)</span>、<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 表示了<strong>电压</strong> <span class="math inline">\(u\)</span> 及其分量 <span class="math inline">\(u_R\)</span>、<span class="math inline">\(u_L\)</span>、<span class="math inline">\(u_C\)</span> 与电流 <span class="math inline">\(i\)</span>之间的大小与相位关系。随着电路参数的不同，<strong>电压</strong> <span class="math inline">\(u\)</span> 与<strong>电流</strong> <span class="math inline">\(i\)</span> 之间的<strong>相位差</strong> <span class="math inline">\(\phi\)</span> 也会有所不同，因而可以认为 <span class="math inline">\(\phi\)</span>角的大小是由电路的负载参数所决定的。</p><p>从上面这个推导公式还可以看到，当频率一定时，不仅<strong>相位差</strong><span class="math inline">\(\phi\)</span>的大小取决于电路参数，而且<strong>电流</strong>是滞后还是超前于<strong>电压</strong>也与电路的参数有关：</p><ul><li>如果 <span class="math inline">\(X_L &gt; X_C\)</span>，即 <span class="math inline">\(\phi &gt;0\)</span>，则在相位上<strong>电流</strong> <span class="math inline">\(i\)</span> 比<strong>电压</strong> <span class="math inline">\(u\)</span> <strong>滞后</strong> <span class="math inline">\(\phi\)</span>角，该电路具有<strong>电感性</strong>；</li><li>如果 <span class="math inline">\(X_L &lt; X_C\)</span>，即 <span class="math inline">\(\phi &lt;0\)</span>，则在相位上<strong>电流</strong> <span class="math inline">\(i\)</span> 比<strong>电压</strong> <span class="math inline">\(u\)</span> <strong>超前</strong> <span class="math inline">\(\phi\)</span>角，该电路具有<strong>电容性</strong>；</li><li>如果 <span class="math inline">\(X_L = X_C\)</span>，即 <span class="math inline">\(\phi = 0\)</span>，则在相位上<strong>电流</strong><span class="math inline">\(i\)</span> 与<strong>电压</strong> <span class="math inline">\(u\)</span><strong>同相</strong>，该电路具有<strong>电阻性</strong>；</li></ul><h4 id="rl-串联电路">RL 串联电路</h4><p>在<strong>电阻</strong> <span class="math inline">\(R\)</span>与<strong>电感</strong> <span class="math inline">\(L\)</span><strong>串联</strong>的交流电路当中，<strong>电源电压</strong> <span class="math inline">\(\dot{U}\)</span> 等于<strong>电阻的电压降</strong><span class="math inline">\(\dot{U_R}\)</span>与<strong>电感的电压降</strong> <span class="math inline">\(\dot{U_L}\)</span> 之和：</p><p><span class="math display">\[电源电压 \dot{U} = 电阻的电压降 \dot{U_R} + 电感的电压降 \dot{U_L}\]</span></p><p>根据 <strong>RLC 串联电路</strong>的相位关系，电阻的电压降 <span class="math inline">\(\dot{U_R}\)</span> 与电流 <span class="math inline">\(\dot{I}\)</span> 同相，电感电压降 <span class="math inline">\(\dot{U_L}\)</span> 超前于电流<code>90°</code>，由此就可以绘制出对应的相量图。然后将 <span class="math inline">\(\dot{U_R}\)</span> 与 <span class="math inline">\(\dot{U_L}\)</span>的向量相加之后，就可以得到外加电压 <span class="math inline">\(\dot{U}\)</span>。</p><p>从向量图当中可以看出 <span class="math inline">\(U \neq U_R +U_L\)</span>，即电源电压的有效值不等于<strong>电阻</strong>与<strong>电感</strong>两端电压的有效值之和。</p><h4 id="功率消耗-3">功率消耗</h4><h5 id="瞬时功率-3">瞬时功率</h5><p>已知<strong>电压</strong> <span class="math inline">\(u\)</span>与<strong>电流</strong> <span class="math inline">\(i\)</span>的变化规律与相互关系之后，就可以求解出<strong>瞬时功率</strong> <span class="math inline">\(p\)</span>：</p><p><span class="math display">\[p = ui = U_m I_m \sin(\omega t + \phi) \sin \omega t\impliesp = UI \cos \phi - UI \cos(2 \omega t + \phi)\]</span></p><h5 id="无功功率-有功功率-2">无功功率 &amp; 有功功率</h5><p><strong>电阻</strong>元件会消耗电能，通过计算可以得到电阻元件的<strong>平均功率</strong>，公式当中的<span class="math inline">\(\cos \phi\)</span>称为<strong>功率因数</strong>：</p><p><span class="math display">\[P = UI \cos \phi\]</span></p><p>对于<strong>电感</strong>和<strong>电容</strong>元件，由于会存储与释放电能，并且与电源之间存在着能量互换，相应的<strong>无功功率</strong>可以根据<span class="math inline">\(Q_L = UI = I^2 X_L\)</span> 和 <span class="math inline">\(Q_C = -UI = -I^2 X_C\)</span> 得到，考虑到 <span class="math inline">\(U_L\)</span> 与 <span class="math inline">\(U_C\)</span> 的相位相反，于是就可以得到：</p><p><span class="math display">\[Q = (U_L - U_C) I = I^2(X_L - X_C) = UI \sin \phi\]</span></p><p>上述的两个公式，是计算正弦交流电路当中<strong>平均功率</strong>（<strong>一般功率</strong>）和<strong>无功功率</strong>的一般公式。</p><blockquote><p><strong>注意</strong>：一个交流电源的输出功率，不仅与其<strong>端电压</strong>与<strong>输出电流</strong>的有效值乘积相关，还与负载的参数相关。如果负载的参数不同，那么电压与电流之间的<strong>相位差</strong><span class="math inline">\(\phi\)</span>也就会不同，在相同的<code>电压</code> <span class="math inline">\(U\)</span> 与<code>电流</code> <span class="math inline">\(I\)</span>之下，电路的<strong>有功功率</strong>与<strong>无功功率</strong>同样也会有所不同。</p></blockquote><h5 id="视在功率">视在功率</h5><p><strong>视在功率</strong> <span class="math inline">\(S\)</span>是一个用于表示交流电器设备<strong>容量</strong>的物理量，其值等于<strong>电压有效值</strong><span class="math inline">\(U\)</span> 与<strong>电流有效值</strong><span class="math inline">\(I\)</span> 的乘积：</p><p><span class="math display">\[视在功率 S = 电压有效值 U \times 电流有效值 I = 电流有效值 I^2 \times|电路阻抗 Z|\]</span></p><p>生产实践里的交流电气设备，通常是按照<strong>额定工作电压</strong><span class="math inline">\(U_N\)</span> 与<strong>额定工作电流</strong><span class="math inline">\(I_N\)</span>来设计使用。相应的，这些交流电气设备的容量就可以使用<strong>额定视在功率</strong><span class="math inline">\(S_N = U_N \times I_N\)</span>来进行标识，其单位为<strong>伏安</strong>(<code>VA</code>)或<strong>千伏安</strong>(<code>kVA</code>)。</p><p><strong>平均功率 P</strong>、<strong>无功功率Q</strong>、<strong>视在功率 S</strong>三个功率之间存在着如下的计算关系：</p><p><span class="math display">\[视在功率 S = \sqrt{平均功率 P^2 + 无功功率 Q^2}\]</span></p><p>显然，上述公式也可以采用<strong>功率三角形</strong>来进行表示，<strong>功率/电压/阻抗</strong>的<strong>三角形</strong>都是相似的，这里分别将它们标识在下面的图形当中：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/16.png"></p><blockquote><p><strong>注意</strong>：功率 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span>、<span class="math inline">\(S\)</span>都并非正弦量，所以不能采用<strong>向量</strong>来进行表示。</p></blockquote><p>本节内容介绍了<strong>电阻</strong>、<strong>电感</strong>、<strong>电容</strong>元件串联的交流电路，实际生活当中比较常见的是<strong>电阻与电感元件的串联电路</strong>（忽略电容）和<strong>电阻与电容元件的串联电路</strong>（忽略电感）。</p><h3 id="归纳总结">归纳总结</h3><p><strong>直流电路</strong>的<code>电动势</code>、<code>电压</code>、<code>电流</code><strong>大小</strong>与<strong>方向</strong>均不会发生变化，采用的分析定理有<strong>欧姆定律</strong>、<strong>基尔霍夫定律</strong>、<strong>叠加原理</strong>、<strong>戴维南定理</strong>等。直流电路当中，<strong>电容器</strong>会阻断电流，而<strong>电感器</strong>则会正常导通。除此之外，直流电路并不会存在<strong>相位</strong>的问题，也不会存在<strong>无功功率</strong>与<strong>视在功率</strong>，而只存在<strong>有功功率</strong>的概念。</p><p><strong>正弦交流电路</strong>当中的<code>电压</code>与<code>电流</code>会按照正弦规律进行交替变换，其方向在一个周期内被划分为<strong>正半周</strong>和<strong>负半周</strong>两个部分，而大小由<strong>零</strong>变化到<strong>峰值</strong>又变回<strong>零</strong>。正弦量拥有<strong>振幅</strong>(峰值)、<strong>周期</strong>、<strong>初相位</strong>三个要素。正弦交流电路当中，<strong>电感</strong>会让电流滞后，而<strong>电容</strong>会使电流超前，由于两者都是储能元件，理想状态下即不会消耗功率也不会产生热量。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/17.png"></p><blockquote><p><strong>注意</strong>：实际电路当中，通常同时存在着<strong>直流</strong>和<strong>交流</strong>信号，此时需要将电路划分为直流和交流两个部分来进行计算，最后再将计算得到的结果进行叠加。</p></blockquote><h3 id="rlc-并联电路附录">RLC 并联电路（附录）</h3><p>当<strong>电阻 R</strong>、<strong>电感 L</strong>、<strong>电容C</strong> 并联时，如果 <code>R</code>、<code>L</code>、<code>C</code>元件两端的<strong>电压有效值</strong>为 <span class="math inline">\(U\)</span>，那么<strong>总电流</strong> <span class="math inline">\(I\)</span> 、<strong>总阻抗</strong> <span class="math inline">\(|Z|\)</span>与每条并联支路上<code>电流</code>与<code>电压</code>的关系为：</p><p><span class="math display">\[\begin{cases}电容支路电流 I_C = \frac{有效电压 U}{容抗 X_C} \\电感支路电流 I_L = \frac{有效电压 U}{感抗 X_L} \\电阻支路电流 I_R = \frac{有效电压 U}{电阻 R}\end{cases}\implies\begin{cases}总电流 I = \sqrt{I^2_R + (I_L - I_C)^2}\\\frac{1}{总阻抗 |Z|} = \sqrt{(\frac{1}{R})^2 + (\frac{1}{X_L} -\frac{1}{X_C})^2}\end{cases}\]</span></p><h3 id="功率因数的提高附录">功率因数的提高（附录）</h3><h4 id="功率因数降低的原因">功率因数降低的原因</h4><p>直流电路的<strong>功率</strong>等于<strong>电流</strong>与<strong>电压</strong>的乘积，但是在计算交流电路的<strong>平均功率</strong>（有功功率）时，还需要考虑到<code>电压</code>与<code>电流</code>之间的<strong>相位差</strong><span class="math inline">\(\phi\)</span>，即 <span class="math inline">\(P = UI \cos \phi\)</span>，该公式当中的 <span class="math inline">\(\cos \phi\)</span>就称为电路的<strong>功率因数</strong>。</p><p>根据前面的内容可以了解，电路的功率因数取决于<strong>负载</strong>参数。当属于<strong>电阻性负载</strong>的时候，<code>电压</code>与<code>电流</code>同相，其功率因数等于<code>1</code>。而对于其它类型负载，既存在<strong>电阻</strong>也存在着<strong>电抗</strong>，其<code>电压</code>与<code>电流</code>之间存在着<strong>相位角</strong><span class="math inline">\(\phi\)</span>，通常这种<strong>电感性负载</strong>的功率因数较低，一般介于<code>0.5 ~ 0.6</code>之间，说明交流电源的额定容量无法被充分利用，输出了大量的<strong>无功功率</strong>，导致供电效率降低。</p><p>除了<code>电压</code>与<code>电流</code>之间相位角导致的功率因数下降以外，输入<code>电流</code>或者<code>电压</code>的<strong>波形失真</strong>也是引起功率因数下降的重要原因。例如开关电源采用了<strong>桥式整流</strong>和<strong>电容滤波</strong>电路来实现AC/DC转换，由于滤波电容的充放电作用，其两端的电压呈现出锯齿状纹波。滤波电容上电压的最小值与最大值相差不大，根据<strong>桥式整流二极管</strong>的单向导电性，只有在AC电路上的电压瞬时值高于滤波电容上的电压时，整流二极管才会由于<strong>正向偏置</strong>而导通。而当AC输入电压的瞬时值低于滤波电容上的电压时，整流二极管就会由于<strong>反向偏置</strong>而截止。</p><p>换而言之，在 AC电路上电压的半个周期范围之内，二极管仅在其峰值附近才会导通，<strong>导通角</strong>约为<code>70°</code> 度。虽然 AC的<strong>输入电压</strong>仍然大体保持正弦波形，但是 AC的<strong>输入电流</strong>却呈现出高幅值的尖峰脉冲，如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/18.png"></p><p>这种严重失真的<strong>电流</strong>波形当中包含有大量的<strong>谐波</strong>成份，容易导致电路<strong>功率因数</strong>的严重下降。</p><h4 id="提高功率因数的措施">提高功率因数的措施</h4><p>为了提高负载的<strong>功率因数</strong>，通常会采取补偿措施，最为简单的方法是在<strong>电感性负载</strong>的两端并联上电容器，这种方法称为<strong>并联补偿</strong>，其电路图（左侧）与向量图（右侧）如下所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-10/19.png"></p><p>其中，<span class="math inline">\(\phi_1\)</span>为<strong>感性负载电流</strong> <span class="math inline">\(\dot{I_1}\)</span> 与<strong>输入电压</strong><span class="math inline">\(\dot{U}\)</span> 之间的相位差。而 <span class="math inline">\(\phi\)</span>则是并联电容器以后，<strong>电流</strong> <span class="math inline">\(\dot{I}\)</span> 与<strong>输入电压</strong> <span class="math inline">\(\dot{U}\)</span> 之间的相位差。</p><p>并联电容器之后，<strong>电感性负载的电流</strong> <span class="math inline">\(I_1 = \frac{U}{\sqrt{R^2 + X_L^2}}\)</span>与<strong>功率因数</strong> <span class="math inline">\(\cos \phi_1 =\frac{R}{\sqrt{R^2 + X_L^2}}\)</span>均未发生变化，但是<code>电压</code> <span class="math inline">\(u\)</span> 与<code>电流</code> <span class="math inline">\(i\)</span> 之间的<strong>相位差</strong> <span class="math inline">\(\phi\)</span> 变小（即 <span class="math inline">\(\cos \phi\)</span> 变大）。</p><blockquote><p><strong>注意</strong>：此处讨论的功率因数提高，是指提高<strong>电源</strong>的功率因数，而非提高某个<strong>电感性负载</strong>的功率因数。</p></blockquote><p>如果电容值选取适当，还可以使得 <span class="math inline">\(\phi =0\)</span>。当电感性负载并联上电容器之后，减少了电源与负载之间的能量互换，此时电感性负载所需的<strong>无功功率</strong>，主要由<strong>电容器</strong>提供。换而言之，能量的互换主要发生在电感性负载与电容器之间，从而使得电源得到更为充分的利用。</p><blockquote><p><strong>注意</strong>：并联电容器之后，由于<strong>有功功率</strong>并没有发生改变，所以电容器并不消耗电能。</p></blockquote><p>除了并联补偿方法之外，还可以采用专门的<strong>功率因数校正电路</strong>（PFC，PowerFactorCorrection），它不同于传统的并联补偿，主要是针对非正弦电流波形而采取的提高线路功率因数，迫使AC电流追随电压波形的瞬时变化轨迹，并使得<code>电流</code>与<code>电压</code>保持相同的相位，最终让整个电路呈现<strong>纯电阻性</strong>的措施。</p><h2 id="rc-与-lc-电路">RC 与 LC 电路</h2><h3 id="rc-的串联与并联">RC 的串联与并联</h3><h4 id="rc-串联电路">RC 串联电路</h4><p>当<strong>电阻</strong> <code>R</code> 与<strong>电容</strong><code>C</code> 串联之后（左图），由于电容 <code>C</code>对于各种频率信号的<strong>容抗</strong>各不相同，所以整个 RC电路的阻抗特性曲线如（右图）所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/1.png"></p><p>RC串联电路会对各个频率的信号呈现出不同的阻抗，当信号频率<strong>大于转折频率</strong><span class="math inline">\(f_0\)</span> 以后，电容 <code>C</code>的容抗 <span class="math inline">\(X_C = \frac{1}{2 \pi fc}\)</span>几乎为零，由 RC 串联电路的阻抗公式 <span class="math inline">\(|Z| =\sqrt{R^2 + X_C^2}\)</span> 可以知道 <span class="math inline">\(|Z|\approx R\)</span>，此时 RC 串联电路的<strong>总阻抗</strong>主要由电阻<code>R</code> 的大小来决定。</p><p>而当信号频率<strong>小于转折频率</strong> <span class="math inline">\(f_0\)</span> 时，由于信号频率已经比较低，电容<code>C</code> 的容抗较大，不能被忽略，此时 RC串联电路的总阻抗为<strong>电阻</strong> <code>R</code>与<strong>电容</strong> <code>C</code> 的阻抗之和。又由于电容<code>C</code> 的容抗会随着频率的降低而增大，所以特性曲线当中频率 <span class="math inline">\(f &lt; f_0\)</span>的一段是上升的，频率越低阻抗就越大。RC 串联电路的转折频率 <span class="math inline">\(f_0\)</span> 可以通过下面的公式进行确定：</p><p><span class="math display">\[f_0 = \frac{1}{2 \pi RC}\]</span></p><p>通过上面方程可以看到，当<strong>电阻</strong> <code>R</code>保持不变时，增大<strong>电容</strong> <code>C</code> 会降低转折频率<span class="math inline">\(f_0\)</span>，而当<strong>电容</strong><code>C</code> 减小时，则会增大转折频率 <span class="math inline">\(f_0\)</span>。相应的，通过改变<strong>电阻</strong><code>R</code> 的大小也可以调整转折频率 <span class="math inline">\(f_0\)</span> 的大小。</p><h4 id="rc-并联电路">RC 并联电路</h4><p>下图所示是 RC 并联电路（左侧）及其对应的阻抗特性曲线（右侧）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/2.png"></p><p>该电路的阻抗特性曲线上也存在着一个<strong>转折频率</strong> <span class="math inline">\(f_0\)</span>，其值同样可以通过下面的公式计算得到：</p><p><span class="math display">\[f_0 = \frac{1}{2 \pi RC}\]</span></p><ul><li>当信号频率<strong>低于</strong>转折频率 <span class="math inline">\(f_0\)</span> 时，此时<strong>电容</strong><code>C</code> 相当于开路，整个电路的阻抗由<strong>电阻</strong><code>R</code> 所决定；</li><li>当信号频率<strong>高于</strong>转折频率 <span class="math inline">\(f_0\)</span> 时，此时总阻抗为<strong>电阻</strong><code>R</code> 和<strong>电容</strong> <code>C</code>阻抗的并联值。由于频率升高之后<strong>电容</strong> <code>C</code>的容抗下降，所以 RC 并联电路总阻抗的斜率也在下降；</li></ul><h4 id="rc-串并联电路">RC 串并联电路</h4><p>RC串并联电路（左图）及其阻抗特性曲线（右图）如下图所示，此处不再进行专门的分析与讨论：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/3.png"></p><h3 id="rc-滤波器">RC 滤波器</h3><p><strong>滤波器</strong>是一种可以通过或者阻止特定频带信号的电路，可以分为<strong>无源滤波器</strong>和<strong>有源滤波器</strong>两种类型，分别拥有<strong>RC</strong> 和 <strong>LC</strong>两种电路形式。根据滤波信号的不同，可以再进一步划分为<code>高通</code>、<code>低通</code>、<code>带通</code> 三种子类型。</p><p><strong>低通 RC 滤波器</strong>：当输入信号 <span class="math inline">\(u_i\)</span> 上低于转折频率 <span class="math inline">\(f_0\)</span>的信号进入电路时，<strong>电容</strong> <code>C</code>呈现出较大的容抗，不具备分流的作用，低频信号经过<strong>电阻</strong><code>R</code> 正常输出。而当输入信号 <span class="math inline">\(u_i\)</span> 上高于 <span class="math inline">\(f_0\)</span> 的信号进入时，<strong>电容</strong><code>C</code> 的容抗较小，这些高频信号在经过<strong>电阻</strong><code>R</code> 之后，由<strong>电容</strong> <code>C</code>分流接地，所以该电路具备<strong>通低频阻高频</strong>的作用，此处转折频率<span class="math inline">\(f_0 = \frac{1}{2 \pi RC}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/4.png"></p><p><strong>高通 RC 滤波器</strong>：当输入信号 <span class="math inline">\(u_i\)</span> 中低于转折频率 <span class="math inline">\(f_0\)</span> 的信号进入时，<strong>电容</strong><code>C</code> 的容抗较大，输出电压 <span class="math inline">\(u_o\)</span>减小，并且频率越低输出越小。而当高于转折频率 <span class="math inline">\(f_0\)</span> 的信号进入时，<strong>电容</strong><code>C</code>的容抗较小，不会对信号产生衰减作用，从而实现了<strong>通高频阻低频</strong>的作用，这里的转折频率同样可以由<span class="math inline">\(f_0 = \frac{1}{2 \pi RC}\)</span>求解得到：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/5.png"></p><p><strong>带通 RC滤波器</strong>：只会让特定<strong>频带</strong>的信号通过，而频带之外的信号将会被阻止。将高通与低通滤波器组合到一起，设置适当的电路参数，就可以得到所需要的带通RC 滤波器。</p><p>除此之外，还有由<strong>电感</strong> <code>L</code>和<strong>电容</strong> <code>C</code> 构成 <strong>LC滤波器</strong>，由于电感的感抗会随着频率的增加而增加，而电容的容抗会随着频率的增加而减小，因此<strong>LC 低通滤波器</strong>的串臂接电感，并臂接电容，而 <strong>LC高通滤波器</strong>当中电感与电容的位置正好相反，<strong>LC带通滤波器</strong>则同样是 LC 低通与高通两种滤波器的组合运用。</p><h3 id="lc-振荡电路">LC 振荡电路</h3><p>将下图的开关扳到电池组一侧，对电容器进行充电；然后再将开关扳到电感线圈一侧，让电容器通过电感线圈进行放电，此时会发现电流表上的指针左右摆动，表明电路当中产生了大小与方向做周期性变化的交变电流。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/6.png"></p><p>这种能够产生<strong>大小</strong>与<strong>方向</strong>呈周期性变化电流的电路称为<strong>振荡电路</strong>，上述电路就构成了一个简单的振荡电路，采用示波器观察振荡电流可以发现：LC回路当中产生的振荡电流与电压按照<strong>正弦规律</strong>进行变化。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/7.png"></p><p>接下来，分析 <strong>LC 回路</strong>当中产生振荡电流的完整过程：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/8.png"></p><ol type="1"><li><strong><span class="math inline">\(0\)</span>时刻</strong>：开关刚刚扳到线圈一侧的瞬间，已经充电的电容器尚未进行放电，此时电路当中不存在电流；</li><li><strong><span class="math inline">\(0 \sim \frac{T}{4}\)</span>阶段</strong>：电容器开始放电，由于电感线圈的自感作用，电路当中的电流不会立刻达到最大值，而是从零开始逐渐增大。放电过程当中，线圈周围产生磁场，该磁场会随着电流的增大而增强；随着电容器极板上电荷的逐渐减少，电场逐渐减弱。当放电结束时，电流达到最大值，电容器极板上不再存在电荷，电场能全部转化为磁场能；</li><li><strong><span class="math inline">\(\frac{T}{4} \sim\frac{T}{2}\)</span>阶段</strong>：电容器放电结束之后，由于电感线圈的自感作用，电路里的电流并不会立刻减小为零，而是会保持原有方向继续流动，从而使得电容器在相反方向上重新充电。电容在反向充电过程当中，随着电流的减小，电感线圈周围磁场逐渐减弱，导致电容器两个极板携带上相反的电荷，电场伴随着极板上电荷的增多而不断增强，此时电路里的磁场能又逐渐转化为电场能。当电容充电结束以后，电流减小至零，电容器极板上的电荷达到最大值，磁场能全部被转化为电场能；</li><li><strong>再放电 <span class="math inline">\(\frac{T}{2} \sim\frac{3}{4}T\)</span></strong> 和<strong>再充电<span class="math inline">\(\frac{3}{4}T \sim T\)</span>阶段</strong>：通过不断的充电与放电，电场能与磁场能不断的发生周期性转换，电路当中就产生了振荡电流；</li></ol><p>如果振荡过程当中不存在能量损失，振荡过程能够得以持续进行，并且振幅保持不变，这种振荡称为<strong>无阻尼振荡</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/9.png"></p><p>电磁振荡在实际应用当中总会存在着能量损失，部分能量会被电路上的电阻转化为热能，这样振荡电路的能量逐渐损耗，振荡电流的振幅逐渐减小，直至最后完全停止下来，这种振荡就称为<strong>阻尼振荡</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/10.png"></p><blockquote><p><strong>注意</strong>：实际应用当中为了获得这种振幅保持不变的<strong>等幅振荡</strong>，可以通过<strong>晶体管</strong>将电源的能量周期性的补充至振荡电路，以补充振荡过程当中的能量损耗。</p></blockquote><p>振荡电路当中发生无阻尼振荡的周期与频率，称为该振荡电路的<strong>固有周期</strong>（简称为<code>周期</code>）和<strong>固有频率</strong>（简称为<code>频率</code>）。当添加至电容器上的电压恒定时，<strong>电容器</strong>的电容越大，其容纳的电荷就越多，放电与充电的时间就越长，周期也就越长，频率就会越低；<strong>电感器</strong>线圈的电感值越大，阻碍电流变化的作用就会越强，放电与充电所需的时间也就会越长，因而周期就会越长，频率也就会越低。<strong>周期</strong><span class="math inline">\(T\)</span>（秒）和<strong>频率</strong><span class="math inline">\(f\)</span>（赫兹）分别与<strong>自感系数</strong><span class="math inline">\(L\)</span>（亨利）和<strong>电容</strong><span class="math inline">\(C\)</span>（法拉）的关系如下面方程组所示：</p><p><span class="math display">\[\begin{cases}周期 T = 2 \pi \sqrt{电感 L \times 电容 C} \\频率 f = \frac{1}{2 \pi \sqrt{电感 L \times 电容 C}}\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：由此可见，改变<strong>电容</strong>或者<strong>电感</strong>，就可以调整振荡电路的<strong>周期</strong>与<strong>频率</strong>。</p></blockquote><h3 id="lc-谐振电路">LC 谐振电路</h3><h4 id="lc-串联谐振电路">LC 串联谐振电路</h4><p>下图描述了一个 <strong>LC串联谐振电路</strong>，假设<strong>信号电压</strong>为 <span class="math inline">\(u\)</span>，<strong>频率</strong>为 <span class="math inline">\(f\)</span>，当电路里的<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 和<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 相等 <span class="math inline">\(2\pi f L = \frac{1}{2 \pi f C}\)</span> 时，那么 <span class="math inline">\(\phi = \arctan \frac{X_L - X_C}{R} =0\)</span>，此时输入信号电压 <span class="math inline">\(u\)</span>与电流 <span class="math inline">\(i\)</span>同相，该串联电路产生谐振现象，称为<strong>串联谐振</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/11.png"></p><h5 id="串联谐振频率">串联谐振频率</h5><p>由于 <span class="math inline">\(2 \pi f L = \frac{1}{2 \pi fC}\)</span>是产生串联谐振的条件，由此就可以得到<strong>谐振频率</strong> <span class="math inline">\(f_0\)</span>：</p><p><span class="math display">\[信号频率 f = 谐振频率 f_0 = \frac{1}{2 \pi \sqrt{电感 L \times 电感 C}}\]</span></p><p>从上面的方程可以看到，<strong>谐振频率</strong> <span class="math inline">\(f_0\)</span> 只与<strong>电感</strong><code>L</code> 和<strong>电容</strong> <code>C</code>的大小有关，而与<strong>电阻</strong> <code>R</code>无关。当输入的<strong>信号频率</strong> <span class="math inline">\(f\)</span>等于该电路的<strong>固有谐振频率</strong> <span class="math inline">\(f_0\)</span>时，电路就会发生串联谐振现象。由此可见，通过调节<strong>电感</strong><code>L</code> 与<strong>电容</strong> <code>C</code>以及输入的<strong>信号频率</strong> <span class="math inline">\(f\)</span>，都可以使得电路发生谐振。</p><h5 id="串联谐振特性">串联谐振特性</h5><ul><li>谐振时电路的<strong>阻抗</strong> <span class="math inline">\(|Z|=\sqrt{R^2 + (X_L - X_C)^2} =R\)</span>，可见此时的阻抗值最小，并且呈现出纯阻性。下面的示意图里，阻抗在<strong>谐振频率</strong><span class="math inline">\(f_0\)</span>位置达到最小，该频率对应的阻抗为回路当中的<strong>电阻</strong><code>R</code>。</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/12.png"></p><ul><li>因为谐振时的阻抗值为最小，所以在信号电压不变的情况下，电路当中的<strong>电流</strong><span class="math inline">\(I\)</span> 将会在谐振时达到最大值 <span class="math inline">\(I_0\)</span>：</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/13.png"></p><ul><li>电路发生谐振时，由于<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 和<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 相等，所以<strong>电感</strong><code>L</code> 上的电压等于<strong>电容</strong> <code>C</code>上的电压（<strong>电感</strong> <code>L</code> 上的电压超前于电流<code>90°</code>，而<strong>电容</strong> <code>C</code>上的电压滞后电流 <code>90°</code>），因而信号<strong>电压</strong> <span class="math inline">\(\dot{U}\)</span> 与电阻 <code>R</code>上的<strong>电压</strong> <span class="math inline">\(\dot{U_R}\)</span>保持一致：</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/14.png"></p><ul><li>当 <span class="math inline">\(X_L = X_C &gt; R\)</span>的时候，<strong>电感</strong> <code>L</code> 与<strong>电容</strong><code>C</code>上的电压都将会高于信号电压，但是电压过高会导致元件损坏，因而通常需要避免发生串联谐振。但是在无线电射频应用当中，经常会利用串联谐振来进行选频。</li></ul><blockquote><p><strong>注意</strong>：由于串联谐振时<strong>电感</strong><code>L</code> 与<strong>电容</strong> <code>C</code>上的电压会超过信号电压许多倍，所以串联谐振也被称做<strong>电压谐振</strong>。</p></blockquote><p><strong>电感</strong> <code>L</code> 的电压 <span class="math inline">\(U_L\)</span> 以及<strong>电容</strong><code>C</code> 的电压 <span class="math inline">\(U_C\)</span>与<strong>信号电压</strong> <span class="math inline">\(U\)</span>的比值使用<strong>品质因数</strong> <span class="math inline">\(Q\)</span> 来进行表示：</p><p><span class="math display">\[品质因数 Q = \frac{电容电压 U_C}{信号电压 U} = \frac{电感电压U_L}{信号电压 U} = \frac{1}{\omega_0 CR} = \frac{\omega_0 L}{R}\]</span></p><p><strong>品质因数</strong> <span class="math inline">\(Q\)</span>简称为 <span class="math inline">\(Q\)</span>值，表征的是发生谐振时，电容或电感元件上的电压是输入信号电压的 <span class="math inline">\(Q\)</span> 倍。例如品质因数 <span class="math inline">\(Q = 100\)</span>，而输入电压 <span class="math inline">\(U =6mV\)</span>，那么电路发生谐振时，电容或者电感元件上的电压为 <span class="math inline">\(U_L = U_C = 600mV\)</span>。</p><h5 id="串联谐振应用">串联谐振应用</h5><p>无线电射频接收机选择信号时，就运用到了串联谐振原理。下图是接收机当中的<strong>输入电路</strong>，其作用是将目标频率信号，从天线所接收到的诸多频率信号当中选择出来：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/15.png"></p><p>该电路主要由<strong>天线线圈</strong> <span class="math inline">\(L_1\)</span>，以及电感线圈 <span class="math inline">\(L\)</span> 与可变电容器 <span class="math inline">\(C\)</span>组成的<strong>串联谐振电路</strong>所共同构成。天线接收到的各种不同频率信号会在LC 谐振电路当中产生 <span class="math inline">\(e_1\)</span>、<span class="math inline">\(e_2\)</span>、<span class="math inline">\(e_3\)</span> 等<strong>感应电动势</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/16.png"></p><p>上图当中的 <span class="math inline">\(R\)</span> 是电感线圈 <span class="math inline">\(L\)</span>的电阻，通过调节<strong>可变电容</strong> <span class="math inline">\(C\)</span>的容值，就可以将目标信号的频率调整至串联谐振频率，此时 LC回路当中该频率的电流最大，可变电容器 <span class="math inline">\(C\)</span>两端的该频率电压也就最高。而其它频率由于未能达到谐振，在回路当中产生的电流较小，从而起到了选择信号和抑制干扰的作用。</p><p>除此之外，当谐振曲线比较尖锐时，稍微偏离谐振频率，信号会就大大减弱。换而言之，谐振曲线越尖锐，选择性也就越强。为了定量描述信号选择性的优劣程度，此处引入了<strong>通频带宽度</strong>的概念：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/17.png"></p><p>电流 <span class="math inline">\(I\)</span> 达到其最大值 <span class="math inline">\(I_0\)</span> 的 <code>70.7%</code> 位置（<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>）时，其上限（<span class="math inline">\(I_0\)</span>）与下限（<span class="math inline">\(0.707 I_0\)</span>）之间所对应的频率宽度 <span class="math inline">\(f_1 + f_0 + f_2\)</span>就称为<strong>通频带宽度</strong>。通频带宽度越小，说明谐振曲线就越尖锐，电路的频率选择性也就越强。谐振曲线的<strong>尖锐</strong>或者<strong>平坦</strong>，与<strong>品质因数Q</strong> 的值密切相关：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/18.png"></p><p>假设电路的电感值 <code>L</code> 和电容值 <code>C</code>不变，只改变电阻值 <code>R</code>，那么根据 <span class="math inline">\(Q = \frac{1}{\omega_0 CR} = \frac{\omega_0L}{R}\)</span>，<strong>品质因数 Q</strong> 的值越大，电阻值<code>R</code> 就会越小，谐振曲线就会越尖锐，信号选择性也就会越强。</p><h4 id="lc-并联谐振电路">LC 并联谐振电路</h4><p>下图是一个 <strong>LC 并联谐振电路</strong>，其中 <code>R</code>表示的是电感 <code>L</code> 的直流电阻：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/19.png"></p><h5 id="并联谐振频率">并联谐振频率</h5><p>LC 并联谐振电路的谐振频率 <span class="math inline">\(f_0\)</span>，可以通过下面的公式计算得到：</p><p><span class="math display">\[谐振频率 f_0 = \frac{1}{2\pi \sqrt{电感 L \times 电容 C}}\]</span></p><p>通过上面的方程可以看出，LC 并联谐振电路的谐振频率与 <code>R</code>无关，而只会与电感 <code>L</code> 和电容 <code>C</code>相关，当<strong>信号频率</strong>等于该电路的<strong>固有谐振频率</strong><span class="math inline">\(f_0\)</span> 时，就会发生并联谐振现象。</p><h5 id="并联谐振特性">并联谐振特性</h5><ul><li>发生并联谐振时，电路的阻抗值达到最大，并且呈现纯阻性，<strong>阻抗大小</strong>为<span class="math inline">\(|Z| = \frac{L}{RC}\)</span>；</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/20.png"></p><ul><li>发生并联谐振时，如果信号电压恒定，那么电路当中的电流 <span class="math inline">\(I\)</span> 将会在<strong>谐振频率</strong> <span class="math inline">\(f_0\)</span> 处达到<strong>最小值</strong>：</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/21.png"></p><ul><li>并联谐振回路当中也引入了<strong>品质因数 Q</strong>的概念，与串联回路一样 <span class="math inline">\(Q = \frac{\omega_0L}{R} = \frac{1}{R} \sqrt{\frac{L}{C}}\)</span>；</li><li>发生并联谐振时，由于回路的总电流较小，而电容与电感支路的电流将会达到最大值，即回路总电流的<code>Q</code>倍，但是两者的方向相反大小近似，其差值为回路总电流。由于电容与电感支路当中的电流达到最大值，所以并联谐振也被称为<strong>电流谐振</strong>。</li><li>不同 <code>Q</code> 值具备不同的曲线，<code>Q</code>值较大的曲线更为尖锐。谐振频率 <span class="math inline">\(f_0\)</span>位置，电路的阻抗最大。当信号频率 <span class="math inline">\(f\)</span>高于或者低于谐振频率时，电路的阻抗将会下降，并且偏差越多阻抗就会越小：</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-11/22.png"></p><blockquote><p><strong>注意</strong>：同样可以利用并联谐振时阻抗较高的特点，对信号进行选择，并且将干扰信号滤除。</p></blockquote><h4 id="陷波器">陷波器</h4><p><strong>陷波器</strong>广义上也属于一种<strong>滤波器</strong>，其作用是阻碍特定频带的信号，而该频带之外的信号则能够顺利通过，因而也被称为<strong>吸收电路</strong>。</p><h5 id="lc-串联谐振式陷波器">LC 串联谐振式陷波器</h5><p>下面是 <strong>LC串联谐振陷波器</strong>电路（左侧）及其输出信号特性曲线（右侧），输出信号<span class="math inline">\(u_o\)</span> 在频率 <span class="math inline">\(f_0\)</span>位置较弱，说明该频率的信号已经被阻隔：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/23.png"></p><p>由于 LC串联谐振电路在谐振时的阻抗最小，假设<strong>谐振频率</strong>为 <span class="math inline">\(f_0\)</span>，此时输入信号当中的 <span class="math inline">\(f_0\)</span>频率信号被该电路分流至<strong>地</strong>。而对于远远高于或低于 <span class="math inline">\(f_0\)</span> 频率的信号，由于 LC电路失去谐振能力，电路的阻抗较大不能对地分流，从而只会吸收以 <span class="math inline">\(f_0\)</span> 为中心频率的较小频带信号。</p><h5 id="lc-并联谐振式陷波器">LC 并联谐振式陷波器</h5><p>下面是 <strong>LC并联谐振陷波器</strong>电路（左侧）及其输出信号特性曲线（右侧）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/24.png"></p><p>由于 LC 并联谐振电路的<strong>阻抗</strong> <span class="math inline">\(|Z|\)</span> 为最大值，<span class="math inline">\(|Z|\)</span> 又与下方的<strong>电阻</strong> <span class="math inline">\(R\)</span>构成分压电路，此时<strong>输出信号</strong> <span class="math inline">\(u_o = \frac{R}{R+|Z|}u_i\)</span>，可见在谐振频率<span class="math inline">\(f_0\)</span> 位置，由于阻抗 <span class="math inline">\(|Z|\)</span> 最大，所以输出信号 <span class="math inline">\(u_o\)</span>最小，即输入信号的衰减较大。而对于<strong>输入信号</strong> <span class="math inline">\(u_i\)</span>当中频率远远高于或者低于<strong>谐振频率</strong> <span class="math inline">\(f_0\)</span> 的信号，由于电路失去谐振效应，阻抗<span class="math inline">\(|Z|\)</span>变得非常小，所以输出电压与输入电压近似相等 <span class="math inline">\(u_o \approx u_i\)</span>。</p><h5 id="桥-t-式陷波器">桥 T 式陷波器</h5><p>下面是 <strong>桥 T式谐振陷波器</strong>电路（左侧）及其等效电路（中间），以及它们的输出信号特性曲线（右侧）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/25.png"></p><p>上图左侧是一个由<strong>电阻</strong> <span class="math inline">\(R\)</span> 和<strong>电容</strong> <span class="math inline">\(C\)</span>构成的三角形电路，通过三角形到星形的等效变换，可以将其转换为中间的等效电路，该电路的<strong>谐振频率</strong><span class="math inline">\(f_0\)</span>可以通过下面的公式计算得到：</p><p><span class="math display">\[谐振频率 f_0 = \frac{1}{2\pi \sqrt{电感 L \times (2 \times 电容 C)}}\]</span></p><p>上图中间的等效电路当中，<span class="math inline">\(-\frac{R}{4}\)</span>是一个<strong>负电阻</strong>，当 <span class="math inline">\(r =\frac{R}{4}\)</span> 的时候，该回路谐振时的总电阻为零，对于频率为 <span class="math inline">\(f_0\)</span> 的信号体现出了极强的隔离能力。</p><h5 id="并联桥-t-式陷波器">并联桥 T 式陷波器</h5><p>下面是 <strong>并联桥 T式陷波器</strong>电路（左侧）及其输出信号特性曲线（右侧）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/26.png"></p><p><strong>并联桥 T 式</strong>是在<strong>桥 T式陷波器</strong>电路的基础上，在原来的<strong>电感</strong><code>L</code> 上面并联了<strong>电容器</strong> <span class="math inline">\(C_1\)</span>，从而构成了一个 <strong>LC并联谐振电路</strong>，其谐振频率为 <span class="math inline">\(f_{02}\)</span>。当输入信号频率低于 <span class="math inline">\(f_{02}\)</span> 时，该 LC并联谐振电路失去谐振能力，此时电路呈现出感性，可以将其等效为一个<strong>电感</strong><code>L</code>。这个等效电感 <span class="math inline">\(L\)</span>与<strong>电阻</strong> <code>R</code> 以及两个<strong>电容</strong><code>C</code> 构成了一个<strong>桥 T 式陷波电路</strong>，其吸收频率为<span class="math inline">\(f_{01}\)</span>，并且 <span class="math inline">\(f_{01} &lt;f_{02}\)</span>。由此可见，该<strong>并联桥 T式陷波器</strong>会阻隔频率为 <span class="math inline">\(f_{01}\)</span> 的信号，而对频率为 <span class="math inline">\(f_{02}\)</span> 的信号则会起到提升的作用。</p><h3 id="rc-与-lc-移相电路">RC 与 LC 移相电路</h3><p><strong>移相电路</strong>可以使得输出信号的相位<strong>滞后</strong>或者<strong>超前</strong>于输入信号指定角度，本小节将会介绍几种常用的移相电路。</p><h4 id="rc-移相电路">RC 移相电路</h4><p>RC 移相电路主要由<strong>电阻</strong> <code>R</code>和<strong>电容</strong> <code>C</code>两个元件组成，流经<strong>电阻</strong> <code>R</code>的电流与其两端的电压相位相同，而流过<strong>电容</strong> <code>C</code>的电流超前于电压 <code>90°</code>，RC移相电路正是利用电容器的这个特性来实现移相的。</p><h5 id="rc-超前移相电路">RC 超前移相电路</h5><p>下图左侧是 <strong>RC 超前移相电路</strong>，该电路当中 <span class="math inline">\(u_i\)</span> 为输入信号电压，而 <span class="math inline">\(u_o\)</span> 为输出信号电压（也就是电阻<code>R</code> 两端的电压）。这个电路能够让 <span class="math inline">\(u_o\)</span> 信号的相位超前于 <span class="math inline">\(u_i\)</span>，移相电路的分析通常需要应用到右侧的<strong>向量图</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/27.png"></p><p>根据向量图可以清楚的看到，<span class="math inline">\(\dot{U_C}\)</span> 与 <span class="math inline">\(\dot{U_i}\)</span> 的夹角为 <span class="math inline">\(\phi\)</span>，即 <span class="math inline">\(\dot{U_o}\)</span> 超前于 <span class="math inline">\(\dot{U_i}\)</span> 了 <span class="math inline">\(\phi\)</span>角。说明输入信号添加到该电路之后，输出信号被超前移相了 <span class="math inline">\(\phi\)</span>，所以该电路属于<strong>超前移相电路</strong>。分析该向量图还可以知道，通过改变<span class="math inline">\(\dot{U_R}\)</span> 或者 <span class="math inline">\(\dot{U_C}\)</span> 的大小，就可以改变移相角 <span class="math inline">\(\phi\)</span>，只要适当选取<strong>电阻</strong><code>R</code> 与<strong>电容</strong> <code>C</code> 的值，就能够获取<code>90°</code> 范围之内的<strong>相位超前量</strong>。</p><h5 id="rc-滞后移相电路">RC 滞后移相电路</h5><p>下图左侧是 <strong>RC 滞后移相电路</strong>，该电路与 <strong>RC超前移相电路</strong>的主要区别在于互换了<strong>电阻</strong><code>R</code> 与<strong>电容</strong> <code>C</code>的位置，输入电压依然为 <span class="math inline">\(u_i\)</span>，而输出电压 <span class="math inline">\(u_o\)</span> 则来自于<strong>电容</strong><code>C</code> 两端的电压 <span class="math inline">\(u_c\)</span>，该电路能够使得输出信号 <span class="math inline">\(u_o\)</span> 的相位滞后于输入信号 <span class="math inline">\(u_i\)</span>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/28.png"></p><p>根据向量图可以知道，<span class="math inline">\(\dot{U_o}\)</span> 与<span class="math inline">\(\dot{U_i}\)</span> 的夹角为 <span class="math inline">\(\phi\)</span>，并且 <span class="math inline">\(\dot{U_o}\)</span> 滞后于 <span class="math inline">\(\dot{U_i}\)</span>，说明输入信号进入该电路之后，输出信号被滞后移相了<span class="math inline">\(\phi\)</span>，所以该电路属于<strong>滞后移相电路</strong>。除此之外，还可以从向量图当中发现，通过改变<span class="math inline">\(\dot{U_R}\)</span> 与 <span class="math inline">\(\dot{U_C}\)</span> 的大小，就可以调整相位角 <span class="math inline">\(\phi\)</span>，即适当选取<strong>电阻</strong><code>R</code> 与<strong>电容</strong> <code>C</code> 的值，就能够获取<code>90°</code> 范围以内的<strong>相位滞后量</strong>。</p><h4 id="rl-移相电路">RL 移相电路</h4><h5 id="rl-超前移相电路">RL 超前移相电路</h5><p>下图左侧是 <strong>RL 超前移相电路</strong>，<strong>电感</strong><code>L</code> 可以让电压超前于电流<code>90°</code>，恰好与<strong>电容</strong>的特性相反，该电路当中输入电压为<span class="math inline">\(u_i\)</span>，输出电压 <span class="math inline">\(u_o\)</span> 取自于<strong>电感</strong><code>L</code> 的两端：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/29.png"></p><p>观察向量图可以看到，<span class="math inline">\(\dot{U_o}\)</span>超前于 <span class="math inline">\(\dot{U_i}\)</span> 了 <span class="math inline">\(\phi\)</span> 角，通过调整 <span class="math inline">\(\dot{U_R}\)</span> 或者 <span class="math inline">\(\dot{U_L}\)</span> 的大小，就可以改变移相角 <span class="math inline">\(\phi\)</span>，因此只要适当选取<strong>电阻</strong><code>R</code> 与<strong>电感</strong> <code>L</code> 的值，就能够获得<code>90°</code> 范围以内的<strong>相位超前量</strong>。</p><h5 id="rl-滞后移相电路">RL 滞后移相电路</h5><p>下图左侧是 <strong>RL 滞后移相电路</strong>，该电路的输出电压 <span class="math inline">\(u_o\)</span> 取自于<strong>电阻</strong><code>R</code> 的两端，而不像上面的 <strong>RL超前移相电路</strong>那样取自<strong>电感</strong> <code>L</code>两端。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/30.png"></p><p>分析上图右侧的向量图可以发现，输出信号 <span class="math inline">\(\dot{U_o}\)</span> 滞后于输入信号 <span class="math inline">\(\dot{U_i}\)</span> 的角度为 <span class="math inline">\(\phi\)</span> ，该电路的最大滞后相移量为<code>90°</code>。</p><h4 id="lc-谐振移相电路">LC 谐振移相电路</h4><h5 id="lc-并联谐振移相电路">LC 并联谐振移相电路</h5><p>下图左侧的 <strong>LC并联谐振移相电路</strong>主要由<strong>电感</strong> <code>L</code>与<strong>电容</strong> <code>C</code> 构成，其中电感 L的值可以进行微调，该电路的<strong>谐振频率</strong>为 <span class="math inline">\(f_0\)</span>，下图右侧为该谐振电路的<strong>相频特性曲线</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/31.png"></p><ul><li>当输入信号频率<strong>等于</strong>谐振频率 <span class="math inline">\(f_0\)</span> 时，其输出信号的相移量等于<code>0</code>；</li><li>当输入信号频率<strong>大于</strong>谐振频率 <span class="math inline">\(f_0\)</span> 时，相移量 <span class="math inline">\(\phi\)</span> 为负值（最大为<code>-90°</code>），表示<strong>滞后相移</strong>；</li><li>当输入信号频率<strong>小于</strong>谐振频率 <span class="math inline">\(f_0\)</span> 时，相移量 <span class="math inline">\(\phi\)</span> 为正值（最大为<code>+90°</code>），表示<strong>超前相移</strong>；</li></ul><p>该电路移相的原理为：如果需要对输入频率为 <span class="math inline">\(f_i\)</span>的信号进行滞后相移，那么只需要调整<strong>电感</strong> <code>L</code>的值，使得该电路的谐振频率 <span class="math inline">\(f_0 &lt;f_i\)</span>，从而实现对频率 <span class="math inline">\(f_i\)</span>信号的滞后相移。反之，如果需要对输入信号 <span class="math inline">\(f_i\)</span>进行超前相移，同样只需要调整<strong>电感</strong> <code>L</code>的值，使得电路的谐振频率 <span class="math inline">\(f_0 &gt;f_i\)</span>，从而就可以实现对于频率 <span class="math inline">\(f_i\)</span> 的超前相移。</p><blockquote><p><strong>注意</strong>：对于 <strong>LC并联谐振电路</strong>，当输入信号频率 <span class="math inline">\(f_i\)</span> 等于该谐振频率 <span class="math inline">\(f_0\)</span>时，谐振电路呈现出<strong>阻性</strong>；当 <span class="math inline">\(f_i\)</span> 大于 <span class="math inline">\(f_0\)</span>时，则该电路呈现<strong>容性</strong>；而当 <span class="math inline">\(f_i\)</span> 小于 <span class="math inline">\(f_0\)</span>时，该电路就会呈现<strong>感性</strong>。</p></blockquote><h5 id="lc-串联谐振移相电路">LC 串联谐振移相电路</h5><p><strong>串联谐振移相电路</strong>与上述<strong>并联谐振移相电路</strong>的不同之处在于，当输入信号频率<span class="math inline">\(f_i &gt; f_0\)</span>时，就会发生<strong>滞后相移</strong>；而当 <span class="math inline">\(f_i &lt; f_0\)</span>时，发生的是<strong>超前相移</strong>。与<strong>并联谐振移相电路</strong>一样，只需要通过调节<strong>电感</strong><code>L</code>，就能够改变 <strong>LC串联谐振电路</strong>的谐振频率大小，从而获得 <span class="math inline">\(-90° \sim +90°\)</span> 范围内的相移。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/32.png"></p><blockquote><p><strong>注意</strong>：<strong>LC 串联谐振电路</strong>的输入信号频率<span class="math inline">\(f_i\)</span> 等于其谐振频率 <span class="math inline">\(f_0\)</span>时，谐振电路呈现出<strong>阻性</strong>；当 <span class="math inline">\(f_i\)</span> 大于 <span class="math inline">\(f_0\)</span> 时呈现<strong>感性</strong>；而当<span class="math inline">\(f_i\)</span> 小于 <span class="math inline">\(f_0\)</span>时就会呈现出<strong>容性</strong>。</p></blockquote><h3 id="趋肤效应">趋肤效应</h3><p>当交流信号通过导线时，由于导线上各个部分的电流密度分布不均匀，导致内部的电流密度较小，而表面的电流密度较大，这种现象就称为<strong>趋肤效应</strong>。产生趋肤效应的原因主要是由于<strong>感抗</strong>的作用，导线内部比表面具有更大的电感，对于交流信号的阻碍作用更大，从而使得电流密集于导线的表面。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-11/33.png"></p><p>趋肤效应会致使导线的有效横截面积减小，导线对于交流信号的阻碍较大。交流信号的频率越高，趋肤效应就越加明显。当频率提高至一定程度以后，就可以认为电流完全从导线表面流过。因而在设计<strong>高频交流电路</strong>的时候，必须要考虑趋肤效应的影响。解决办法是通过增加导体的表面积，从而尽量克服趋肤效应带来的不良影响。</p><h2 id="复数与交流电路">复数与交流电路</h2><h3 id="复数基础">复数基础</h3><h4 id="复数的表达形式">复数的表达形式</h4><p><strong>复数</strong>具有多种表示形式，其<strong>代数形式</strong>正如下面公式所展示的那样：</p><p><span class="math display">\[复数 A= 实部 a + 虚数单位 j \times 虚部b\]</span></p><p>其中，<code>a</code> 为复数的<strong>实部</strong>， <code>b</code>为复数的<strong>虚部</strong>，<code>j</code>是<strong>虚数单位</strong> <span class="math inline">\(j =\sqrt{-1}\)</span>。除此之外，复数还可以采用复平面上的<strong>有向线段</strong>来进行表示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/1.png"></p><p>上图当中的横坐标为<strong>实数轴</strong>（单位为<code>+1</code>），纵坐标为<strong>虚数轴</strong>（单位为<code>+j</code>），两条轴构成的平面称为<strong>复平面</strong>。</p><p>复数 <span class="math inline">\(A = a + jb\)</span>就是复平面上横坐标为 <code>a</code> 纵坐标为 <code>b</code>的一个点，其中 <code>a</code> 作为复数的实数部分，其值等于复数<code>A</code> 在<strong>实数轴</strong>上的投影；而 <code>b</code>作为复数的虚数部分，其值等于复数 <code>A</code>在<strong>虚数轴</strong>上的投影。除此之外，复平面上<strong>矢量OA</strong> 的长度采用 <code>r</code>进行表示，称为复数的<strong>模</strong>，而矢量与实轴正方向的夹角 <span class="math inline">\(\phi\)</span>，称为复数的<strong>辐角</strong>。上面的图形当中，复数<code>A</code> 的<strong>实部</strong><code>a</code>、<strong>虚部</strong><code>b</code>、<strong>模</strong><code>r</code>、<strong>辐角</strong> <code>Φ</code>之间存在着如下关系：</p><p><span class="math display">\[\begin{cases}实部 a = 模 r \times \cos 辐角 \phi \\虚部 b = 模 r \times \sin 辐角 \phi\end{cases}\ \ \ \ \ \ \ \ \\begin{cases}模 r = \sqrt{实部 a^2 + 虚部 b^2} \\辐角 \phi = \arctan \frac{虚部 b}{实部 a}\end{cases}\]</span></p><p>根据上面的方程组，就可以将 <span class="math inline">\(A = a +jb\)</span> 改写为如下复数的<strong>三角形式</strong>：</p><p><span class="math display">\[复数 A = 模 r \cdot \cos \phi + 虚数单位 j \cdot 模 r \cdot \sin \phi\]</span></p><p>除此之外，根据<strong>欧拉公式</strong> <span class="math inline">\(\cos \phi = \frac{e^{j \phi} + e^{-j\phi}}{2}\)</span> 和 <span class="math inline">\(\sin \phi = \frac{e^{j\phi} - e^{-j \phi}}{2j}\)</span>还可以得到复数的<strong>指数形式</strong>：</p><p><span class="math display">\[复数 A = 模 r \times e^{虚数单位 j \times 辐角 \phi}\]</span></p><p>为了便于书写和表达，复数的指数形式还可以变换为<strong>极坐标形式</strong>：</p><p><span class="math display">\[复数 A = 模 r \times \angle 辐角 \phi\]</span></p><p>综上所述，<strong>复数</strong> <span class="math inline">\(A\)</span>的多种表达方式都可以总结为下面的等式：</p><p><span class="math display">\[A = a + jb = r \cos \phi + j r \sin \phi = re^{j \phi} = f \angle \phi\]</span></p><blockquote><p><strong>注意</strong>：无论复数采用哪种表达形式，只要拥有<strong>模</strong><span class="math inline">\(r\)</span>、<strong>辐角</strong> <span class="math inline">\(\phi\)</span>（或是<strong>实部</strong> <span class="math inline">\(a\)</span> 与<strong>虚部</strong> <span class="math inline">\(b\)</span>）两个要素就可以确定其对应的复数。</p></blockquote><h4 id="复数的四则运算">复数的四则运算</h4><p>当复数进行<strong>相加</strong>或者<strong>相减</strong>运算的时候，通常采用其<strong>代数形式</strong>，即实部与实部相加减，虚部与虚部相加减：</p><p><span class="math display">\[\begin{aligned}A_1 = a_1 + jb_1 \\A_2 = a_2 + jb_2\end{aligned}\impliesA_1 \pm A_2 = (a_1 \pm a_2) + j(b_1 \pm b_2)\]</span></p><p>而复数的<strong>乘除法</strong>运算，通常会选择使用<strong>指数形式</strong>或者<strong>极坐标形式</strong>。当两个复数<strong>相乘</strong>时，其<strong>模</strong>值相乘，<strong>辐角</strong>相加；而当两个复数<strong>相除</strong>时，其<strong>模</strong>值相除，<strong>辐角</strong>相减：</p><p><span class="math display">\[\begin{aligned}A_1 = r_1 e^{j \phi_1} = r_1 \angle \phi_1 \\A_2 = r_2 e^{j \phi_2} = r_2 \angle \phi_2\end{aligned}\implies\begin{cases}A_1 \times A_2 = r_1 r_2 e^{j(\phi_1 + \phi_2)} = r_1 r_2 \angle(\phi_1+ \phi_2) \\\frac{A_1}{A_2} = \frac{r_1}{r_2} e^{j(\phi_1 + \phi_2)} =\frac{r_1}{r_2} \angle(\phi_1 - \phi_2)\end{cases}\]</span></p><h4 id="虚数单位-j">虚数单位 j</h4><p>电路分析时，经常需要使用到 <span class="math inline">\(j\)</span>的乘方运算，由于<strong>虚数单位</strong> <span class="math inline">\(j= \sqrt{-1}\)</span>，所以就可以得到下面的一系列结果：</p><table><colgroup><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 53%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(j^2 =-1\)</span></th><th style="text-align: center;"><span class="math inline">\(j^3 =-j\)</span></th><th style="text-align: center;"><span class="math inline">\(j^4 =-j\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{1}{j}= \frac{j}{j^2} = -j\)</span></th></tr></thead><tbody></tbody></table><p>根据欧拉公式可以知道 <span class="math inline">\(e^{j \frac{\pi}{2}}= \cos \frac{\pi}{2} + j \sin \frac{\pi}{2} = +j\)</span>，换而言之<span class="math inline">\(e^{j \frac{\pi}{2}}\)</span> 就是 <span class="math inline">\(+j\)</span> 的复数形式，同理还可以得到 <span class="math inline">\(e^{-j \frac{\pi}{2}}\)</span> 为 <span class="math inline">\(-j\)</span> 的复数形式。</p><ul><li>将<strong>复数</strong> <span class="math inline">\(A = re^{j\phi}\)</span> 乘以 <span class="math inline">\(e^{j\frac{\pi}{2}}\)</span>，可以得到 <span class="math inline">\(re^{j\phi} \times e^{j \frac{\pi}{2}} = re^{j(\phi + \frac{pi}{2})} = jre^{j\phi}\)</span>；</li><li>将<strong>复数</strong> <span class="math inline">\(A = re^{j\phi}\)</span> 乘以 <span class="math inline">\(e^{-j\frac{\pi}{2}}\)</span>，则可以得到 <span class="math inline">\(re^{j\phi} \times e^{-j \frac{\pi}{2}} = re^{j(\phi - \frac{pi}{2})} = -jre^{j \phi}\)</span>；</li></ul><p>由此就可以得出结论：复数 <span class="math inline">\(A\)</span> 乘以<span class="math inline">\(+j\)</span>等于该复数对应矢量在<strong>复平面</strong>上，从原矢量位置逆时针旋转<span class="math inline">\(\frac{\pi}{2}\)</span> 角度；同理，复数<span class="math inline">\(A\)</span> 乘以 <span class="math inline">\(-j\)</span>等于该复数对应矢量在<strong>复平面</strong>上，从原矢量位置顺时针旋转<span class="math inline">\(\frac{\pi}{2}\)</span>角度，具体可以参考下面的图形：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/2.png"></p><h3 id="正弦量的复数表达">正弦量的复数表达</h3><p>正弦量主要是由<strong>幅值</strong>(或<strong>有效值</strong>)、<strong>频率</strong>、<strong>初相位</strong>三个要素决定，正弦交流电路当中，由于电压与电流均属于同频率的正弦量，因而如果需要求解电压或者电流，只需要获得其<code>幅值/有效值</code>和<code>初相位</code>即可，而<strong>复数正好可以代表这两个要素</strong>。</p><p>假设电流 <span class="math inline">\(i\)</span> 的瞬时表达式为 <span class="math inline">\(i = I_m \sin(\omega t + \phi) = \sqrt{2} I\sin(\omega t + \phi)\)</span>，将电流的有效值向量 <span class="math inline">\(\dot{I}\)</span> 放置到复平面：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/3.png"></p><p>结合前面讨论的知识，就可以获得该正弦量的复数表达形式 <span class="math inline">\(\dot{I}\)</span>：</p><p><span class="math display">\[\dot{I} = a + jb = I(\cos \phi + j \sin \phi) = I e^{j \phi} = L \angle\phi\]</span></p><p>由于 <span class="math inline">\(\dot{I}\)</span>是复数，其<strong>模</strong>值等于正弦量的有效值 <span class="math inline">\(I\)</span>，辐角等于正弦量的初相角 <span class="math inline">\(\phi\)</span>，这个复数就称为<strong>有效值向量</strong>。同理，复数<span class="math inline">\(\dot{I}_m\)</span>则被称作电流的<strong>最大值向量</strong>。</p><blockquote><p><strong>注意</strong>：为了区别于普通的复数，表示正弦量的复数通常需要添加<span class="math inline">\(\dot{}\)</span> 符号。</p></blockquote><h3 id="复数的应用">复数的应用</h3><h4 id="纯电感欧姆定律向量复数表达式">纯电感欧姆定律向量复数表达式</h4><p>纯电感电路当中，假设回路电流 <span class="math inline">\(i = I_m \sin\omegat\)</span>，由于纯电感电路当中<strong>电流</strong>比<strong>电压</strong>滞后<code>90°</code>，所以<strong>电压</strong> <span class="math inline">\(u = U_m \sin (\omega t +90°)\)</span>，该等式当中的 <span class="math inline">\(U_m = I_m \omegaL\)</span>，即 <span class="math inline">\(U_m = I_m X_L\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/4.png"></p><p><strong>电流</strong> <span class="math inline">\(i\)</span>和<strong>电压</strong> <span class="math inline">\(u\)</span>瞬时表达式对应的复数形式，可以参考下面的推导过程：</p><p><span class="math display">\[\begin{cases}\dot{I} = I e^{j 0°} = I \angle 0° \\\dot{U} = U e^{j 90°} = U \angle 90°\end{cases}\implies\frac{\dot{U}}{\dot{I}} = \frac{U}{I} e^{j90°}\]</span></p><p>由于<strong>纯电感电路</strong><code>电压</code>与<code>电流</code>的<strong>有效值</strong>符合欧姆定律，即<span class="math inline">\(U = I X_L\)</span>，而 <span class="math inline">\(X_L =\frac{U}{I}\)</span>，从而可以得到纯电感电路<strong>欧姆定律</strong>的向量复数表达式：</p><p><span class="math display">\[\frac{\dot{U}}{\dot{I}} = \frac{U}{I} e^{j90°} = j X_L\implies\dot{U} = j I X_L = j \dot{I} \omega L\]</span></p><h4 id="纯电容欧姆定律向量复数表达式">纯电容欧姆定律向量复数表达式</h4><p>纯电容电路当中，假设输入电压 <span class="math inline">\(u = U_m \sin\omegat\)</span>，由于纯电容电路当中<strong>电流</strong>比<strong>电压</strong>滞后<code>90°</code>，所以<strong>电流</strong> <span class="math inline">\(i = I_m \sin (\omega t + 90°)\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/5.png"></p><p><strong>电流</strong> <span class="math inline">\(i\)</span>和<strong>电压</strong> <span class="math inline">\(u\)</span>的瞬时表达式所对应的复数形式，同样可以参考下面的推导过程：</p><p><span class="math display">\[\begin{cases}\dot{U} = U e^{j 0°} = U \angle 0° \\\dot{I} = I e^{j 90°} = I \angle 90°\end{cases}\implies\frac{\dot{U}}{\dot{I}} = \frac{U}{I} e^{-j90°}\]</span></p><p>由于<strong>纯电容电路</strong><code>电压</code>与<code>电流</code>的<strong>有效值</strong>符合欧姆定律，即<span class="math inline">\(U = I X_C\)</span>，而 <span class="math inline">\(X_C =\frac{U}{I}\)</span>，从而就可以得到纯电感电路<strong>欧姆定律</strong>的向量复数表达式：</p><p><span class="math display">\[\frac{\dot{U}}{\dot{I}} = \frac{U}{I} e^{-j90°} = - j X_C\implies\dot{U} = - j I X_C = - j \frac{\dot{I}}{\omega C} = \frac{\dot{I}}{j\omega C}\]</span></p><h4 id="交流电路频率特性分析">交流电路频率特性分析</h4><p>下图左侧 RC 电路上的 <span class="math inline">\(\dot{U_1}\)</span>是<strong>输入信号</strong>电压，<span class="math inline">\(\dot{U_2}\)</span>是<strong>输出信号</strong>电压，而右侧是该电路对应的向量图：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/6.png"></p><p>根据上述电路，可以求解出该电路的<strong>输出电压</strong> <span class="math inline">\(\dot{U_2}\)</span> 等于：</p><p><span class="math display">\[\dot{U_2} = \dot{I} \times \frac{1}{j \omega c} = \frac{\dot{U_1}}{R +\frac{1}{j \omega C}} \times \frac{1}{j \omega C} = \frac{\dot{U_1}}{1 +j \omega RC}\]</span></p><p>通常情况下，<strong>输出电压</strong> <span class="math inline">\(\dot{U_2}\)</span> 与<strong>输入电压</strong><span class="math inline">\(\dot{U_2}\)</span>的比值称为这个电路的<strong>传递函数</strong>：</p><p><span class="math display">\[\frac{\dot{U_2}}{\dot{U_1}} = \frac{1}{1 + j \omega RC} =\frac{1}{\sqrt{1 + (\omega RC)^2}} \angle - \arctan(\omega RC) =T(\omega) \angle \phi(\omega)\]</span></p><p>可以看到在上述方程当中，传递函数的结果也是一个复数。而等式当中的<span class="math inline">\(T(\omega) = \frac{U_2}{U_1} =\frac{1}{\sqrt{1 + (\omega RC)^2}}\)</span>是输出电压与输入电压<strong>有效值</strong>的比值，也是角频率 <span class="math inline">\(\omega\)</span> 的函数。而 <span class="math inline">\(\phi(\omega) = - \arctan(\omega RC)\)</span>则是输出电压与输入电压之间的<strong>相位差</strong>，同样也是角频率<span class="math inline">\(\omega\)</span>的函数。稍加归纳，即可以得出如下的结论：</p><ul><li>当 <span class="math inline">\(\omega = 0\)</span> 时，<span class="math inline">\(T(\omega) = 1\)</span>，<span class="math inline">\(\phi(\omega) = 0\)</span>；</li><li>当 <span class="math inline">\(\omega = \infty\)</span> 时，<span class="math inline">\(T(\omega) = 0\)</span>，<span class="math inline">\(\phi(\omega) = -\frac{\pi}{2}\)</span>；</li><li>当 <span class="math inline">\(\omega = \omega_0 =\frac{1}{RC}\)</span> 时，<span class="math inline">\(T(\omega) =\frac{1}{\sqrt{2}} = 0.707\)</span>，<span class="math inline">\(\omega(\phi) = -\frac{\pi}{4}\)</span>；</li></ul><p>当输出电压下降至输入电压的 <code>0.707</code> 倍时，两者的相位差为<span class="math inline">\(-\frac{\pi}{4}\)</span>。实际应用当中，为了使输出电压不至于下降过大，特规定该值为最低限度，此时对应的<span class="math inline">\(\omega_0\)</span>称为<strong>截止角频率</strong>，其<strong>频率特性曲线</strong>如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-12/7.png"></p><p>可以看到，当 <span class="math inline">\(\omega &lt;\omega_0\)</span> 的时候，<span class="math inline">\(T(\omega)\)</span>的变化不大；而当 <span class="math inline">\(\omega &gt;\omega_0\)</span> 时，<span class="math inline">\(T(\omega)\)</span>下降明显；表明该电路可以通过低频信号，而且能够抑制高频信号，这也就是前面内容介绍过的<strong>低通滤波器</strong>。</p><h2 id="三相交流电路">三相交流电路</h2><h3 id="三相交流电的产生">三相交流电的产生</h3><p>一个线圈在磁场里转动，电路当中只会产生一个交变电动势，此时发出的交流电称为<strong>单相交流电</strong>。如果在磁场里有三个互成角度的线圈同时转动，那么电路当中就会产生三个交变电动势，此时发出的交流电流称为<strong>三相交流电</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/1.png"></p><p>下图是三相发电机的示意图，在铁芯上固定着<strong>AX</strong>、<strong>BY</strong>、<strong>CZ</strong>三个线圈，它们之间互成 <code>120°</code>角。转动铁芯就会带动三个线圈在磁场当中匀速的转动，从而发出<code>最大值</code>与<code>频率</code>都相同，但是<code>相位</code>并不相同（相位之间互差<code>120°</code>）的三个电动势。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/2.png"></p><p>取上图当中的 <span class="math inline">\(t = 0\)</span>时刻作为时间起点，这三个电动势可以分别被表示为 <span class="math inline">\(e_A\)</span>、<span class="math inline">\(e_B\)</span>、<span class="math inline">\(e_C\)</span>：</p><p><span class="math display">\[\begin{cases}e_A = E_m \sin \omega t \\e_B = E_m \sin (\omega t - 120°) \\e_C = E_m \sin (\omega t - 240°) = E_m \sin (\omega + 120°)\end{cases}\]</span></p><p>三相交流电依次出现<strong>正最大值</strong>的顺序称为<strong>相序</strong>，顺时针按照<strong>A → B → C</strong>顺序循环的相序称为<strong>顺序</strong>或者<strong>正序</strong>，而按照<strong>A → C → B</strong>顺序循环的相序称为<strong>逆序</strong>或者<strong>负序</strong>。<strong>相序是由发电机转子的旋转方向决定的</strong>，多数情况下会选择使用<strong>顺序</strong>。</p><h3 id="三相电源星形连接">三相电源星形连接</h3><p>电源（例如<strong>交流发电机</strong>）的三相绕组通常采用<strong>星形连接</strong>方法，将绕组的<code>X</code>、<code>Y</code>、<code>Z</code>三个末端连接在一起形成公共点，称为电源的<strong>中性点</strong>或者<strong>零点</strong>，用英文字母<strong>N</strong> 进行表示。然后从<code>A</code>、<code>B</code>、<code>C</code> 三个首端以及中点<strong>N</strong>引出四条导线与外电路相连接，从而构成一个<strong>三相四线制电源</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/3.png"></p><p>其中，从首端引出的三条导线称为<strong>相线</strong>或者<strong>端线</strong>，俗称为<strong>火线</strong>，分别用字母<span class="math inline">\(A\)</span>(黄)、<span class="math inline">\(B\)</span>(绿)、<span class="math inline">\(C\)</span>(红)表示，而从中性点引出的导线称为<strong>中线</strong>或者<strong>零线</strong>，采用字母<span class="math inline">\(N\)</span>(黑) 进行表示。</p><h3 id="相电压-线电压">相电压 &amp; 线电压</h3><p>从<strong>三相四线制电源</strong>当中可以获得<strong>相电压</strong>和<strong>线电压</strong>两种电压形式：</p><ul><li><strong>相电压</strong>：电源每相两端之间的电压，即<code>相线</code>与<code>中线</code>之间的电压，其参考方向是从<code>相线</code>指向<code>中线</code>，有效值采用<span class="math inline">\(U_A\)</span>、<span class="math inline">\(U_B\)</span>、<span class="math inline">\(U_C\)</span> 进行表示，或者一律采用 <span class="math inline">\(U_p\)</span> 进行表示；</li><li><strong>线电压</strong>：相线与相线之间的电压，其有效值用 <span class="math inline">\(U_{AB}\)</span>、<span class="math inline">\(U_{BC}\)</span>、<span class="math inline">\(U_{CA}\)</span> 进行表示，或者一律采用 <span class="math inline">\(U_1\)</span> 进行表示；</li></ul><p><strong>线电压</strong>与<strong>相电压</strong>之间的换算关系为<span class="math inline">\(U_l = \sqrt{3}U_p\)</span>，线电压与相电压之间的关系可以采用下面的向量图进行表示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/4.png"></p><p>从上图可以看到，三个<strong>线电压</strong>之间的相位差仍然为<code>120°</code>，它们分别比三个<strong>相电压</strong>超前了<code>30°</code>。如果相电压是对称的，那么线电压一定也是对称的，根据向量图可以得到三个线电压与三个相电压之间的换算关系：</p><p><span class="math display">\[\begin{cases}U_{AB} = 2 U_A \cos 30° = 2 \times \frac{\sqrt{3}}{2} U_A = \sqrt{3} U_A\\U_{BC} = \sqrt{3} U_B \\U_{CA} = \sqrt{3} U_C\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：我国的低压三相供电标准为 <strong>50Hz380V/220V</strong>，其中的 <code>220V</code>是指<strong>相电压</strong>，而 <code>380V</code>是指<strong>线电压</strong>（<span class="math inline">\(380 V =\sqrt{3} \times220V\)</span>），工程上讨论三相电源的电压大小时，通常指的是电源的<strong>线电压</strong>。</p></blockquote><h3 id="三相负载连接">三相负载连接</h3><p>交流用电设备（负载）可以划分为<strong>单相负载</strong>（使用单相电源供电的用电设备）和<strong>三相负载</strong>（使用三相电源供电的用电设备）两种类型，三相供电系统当中的负载具有<strong>星形</strong>（<span class="math inline">\(Y\)</span>）和<strong>三角形</strong>（<span class="math inline">\(\Delta\)</span>）两种基本接法。</p><h4 id="负载星形连接">负载星形连接</h4><h5 id="对称负载">对称负载</h5><p>下图所示的<strong>三相四线制</strong>电路当中，假设其<strong>线电压</strong>为<code>380V</code>，负载连接要根据其额定电压来决定。通常情况下，电灯（单相负载）的额定电压为<code>220V</code>，需要连接在<strong>火线</strong>与<strong>中线</strong>之间。由于电灯负载使用量较大，不能集中连接在<strong>一相</strong>当中，而应当比较均匀的分布在各相，这种连接方法就被称为<strong>星形连接</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/5.png"></p><p>三相四线制电路当中，负载的星形连接可以采用下图进行表示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/6.png"></p><p>电路当中的 <span class="math inline">\(Z_A\)</span>、<span class="math inline">\(Z_B\)</span>、<span class="math inline">\(Z_C\)</span> 分别为 <span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>相的<strong>负载</strong>，并且 <span class="math inline">\(Z_A = Z_B =Z_C\)</span>，它们既可以是三相交流电机的<strong>三相绕组</strong>，也可以是由三个单相负载组成的<strong>三相负载</strong>。三个负载的一端连接到火线<strong>A</strong>、<strong>B</strong>、<strong>C</strong>，另外三个端连接为公共端，称为<strong>负载中点N</strong>，然后将其与电源的中点 <span class="math inline">\(N&#39;\)</span> 进行连接。</p><p>如果忽略输电线路上的阻抗压降，那么每相负载的电压就等于对应电源的<strong>相电压</strong>，即电源线电压的<span class="math inline">\(\frac{1}{\sqrt{3}}\)</span> 倍：</p><p><span class="math display">\[电源的相电压 U_p = \frac{1}{\sqrt{3}} 电源的线电压 U_l\]</span></p><p>三相电路当中的电流也有<strong>相电流</strong>与<strong>线电流</strong>之分，每相负载当中的电流<span class="math inline">\(I_p\)</span>称为<strong>相电流</strong>，每条火线当中的电流 <span class="math inline">\(I_l\)</span>称为<strong>线电流</strong>。当负载为星形连接时，相电流就等于线电流<span class="math inline">\(I_p = I_l\)</span>。</p><p><strong>对称三相负载星形连接</strong>的电路，其各相负载电流的幅度相等，各相电流的相位依次相差<code>120°</code>，因而三个<strong>相电流</strong> <span class="math inline">\(I_A\)</span>、<span class="math inline">\(I_B\)</span>、<span class="math inline">\(I_C\)</span> 是对称的，而<strong>中线电流</strong><span class="math inline">\(I_N\)</span> 等于<code>0</code>。正是由于中线电流为<code>0</code>，所以动力用电通常会省去中线，而直接采用<strong>三相三线制星形</strong>供电方式。尽管没有中线，但是由于负载具备对称性，从而保证了<strong>负载中点</strong><span class="math inline">\(N&#39;\)</span> 和<strong>电源中点</strong><span class="math inline">\(N\)</span> 的电位相等。</p><h5 id="不对称负载">不对称负载</h5><p><strong>阻抗不相等的三相负载</strong>称为<strong>三相不对称负载</strong>，该场景主要发生在<strong>三相四线制</strong>低压民用供电线路当中，由于各个家庭拥有的电器数量不同，使用时间又较为随意，因而供电线路会处于<strong>三相不对称负载</strong>的运行状态。此时，各相的电流不相等，中线电流也不为零。</p><p>正是由于<strong>中线</strong>的存在，即使三相负载不对称，<strong>负载</strong>的三个相电压仍然等于对称的<strong>电源</strong>相电压，因而能够保证负载的正常工作。但是如果中线发生断开事故，就会导致其中一相或者两相的电压升高，造成负载的相电压不等于电源的相电压，进而导致负载损坏或者无法正常工作，同时还会致使<strong>负载中点</strong>（零线）带电。</p><blockquote><p><strong>注意</strong>：三相负载越不对称，这个现象就越为严重，民用供电线路当中出现大范围烧毁家用电器的事故，多数情况就是由于中线断路导致的。</p></blockquote><h4 id="负载三角形连接">负载三角形连接</h4><p><strong>负载三角形连接</strong>的三相电路可以采用下图电路进行表示，该电路当中的<span class="math inline">\(Z_{AB}\)</span>、<span class="math inline">\(Z_{BC}\)</span>、<span class="math inline">\(Z_{CA}\)</span>为每相的<strong>负载</strong>。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/7.png"></p><p>当负载进行三角形连接时，由于各相负载都直接连接到电源的<strong>线电压</strong>，所以<strong>负载</strong>的相电压等于<strong>电源</strong>的线电压。因而无论负载对称与否，其相电压总是对称的：</p><p><span class="math display">\[U_{AB} = U_{BC} = U_{CA} = 线电压 U_l = 相电压 U_p\]</span></p><p>负载三角形连接时的<strong>相电流</strong> <span class="math inline">\(I_p\)</span> 与<strong>线电流</strong> <span class="math inline">\(I_l\)</span>并不相同，如果负载对称，那么<strong>线电流</strong>就是<strong>相电流</strong>的<span class="math inline">\(\sqrt{3}\)</span>倍，并且<strong>线电流</strong>的相位滞后于<strong>相电流</strong><code>30°</code>，即 <span class="math inline">\(I_l = \sqrt{3}I_p\)</span>。</p><blockquote><p><strong>注意</strong>：<strong>三相电动机</strong>的绕组即可以连接为<strong>三角形</strong>，也可以连接为<strong>星形</strong>，而照明负载通常都连接为<strong>具有中线的星形</strong>。</p></blockquote><h3 id="三相电路的功率计算">三相电路的功率计算</h3><h4 id="有功功率">有功功率</h4><p>无论负载是<strong>星形连接</strong>还是<strong>三角形连接</strong>，其<strong>总有功功率</strong><span class="math inline">\(P\)</span>等于<strong>各相有功功率</strong>之和，而不管其三相负载对称与否：</p><p><span class="math display">\[总功率 P = P_A + P_B + P_C = U_A I_A \cos \phi_A + U_B I_B \cos \phi_B +U_C I_C \cos \phi_C\]</span></p><p>上面方程当中的 <span class="math inline">\(U_A\)</span>、<span class="math inline">\(U_B\)</span>、<span class="math inline">\(U_C\)</span>是三相负载的<strong>相电压</strong>，而 <span class="math inline">\(I_A\)</span>、<span class="math inline">\(I_B\)</span>、<span class="math inline">\(I_C\)</span>是三相负载的<strong>相电流</strong>，<span class="math inline">\(\phi_A\)</span>、<span class="math inline">\(\phi_B\)</span>、<span class="math inline">\(\phi_C\)</span>则是三相负载<code>相电压</code>与<code>相电流</code>之间的<strong>相位差</strong>。</p><p>当三相负载对称时，每一相的有功功率都相等，因而三相<strong>总功率</strong><span class="math inline">\(P\)</span> 等于：</p><p><span class="math display">\[总功率 P = 3 \times 相电压 U_p \times 相电流 I_p \times \cos 相位差 \phi\]</span></p><blockquote><p><strong>注意</strong>：当对称负载是<strong>星形连接</strong>时，<strong>线电压</strong><span class="math inline">\(U_l = \sqrt{3}U_p\)</span>，<strong>线电流</strong> <span class="math inline">\(I_l =I_p\)</span>；当对称负载是<strong>三角形连接</strong>时，<strong>线电压</strong><span class="math inline">\(U_l = U_p\)</span>，<strong>线电流</strong><span class="math inline">\(I_l = \sqrt{3} I_p\)</span>。</p></blockquote><h4 id="无功功率-视在功率">无功功率 &amp; 视在功率</h4><p>三相电路的<strong>无功功率</strong>用于衡量三相电源与负载之间能量交换的大小，根据能量守恒定律，三相电路的<strong>无功功率</strong><span class="math inline">\(Q\)</span> 等于三相负载的无功功率之和：</p><p><span class="math display">\[无功功率 Q = Q_A + Q_B + Q_C = U_A I_A \sin \phi_A + U_B I_B \sin \phi_B+ U_C I_C \sin \phi_C\]</span></p><p>当负载对称时，<strong>无功功率</strong> <span class="math inline">\(Q\)</span> 与<strong>相电压</strong> <span class="math inline">\(U_p\)</span> 以及<strong>相电流</strong> <span class="math inline">\(I_p\)</span> 之间具备 <span class="math inline">\(Q = 3 U_p I_p \sin \phi\)</span> 的关系。</p><blockquote><p><strong>注意</strong>：无功功率如果没有被负载完全消耗，那么就只能在电路当中反复传送（时而从电源传送到负载，时而又从负载传送至电源），无功功率的这种来回传送不仅会占用电网资源，还会加大传输线路的损耗。</p></blockquote><p>三相电路的<strong>视在功率</strong>就是三相电路可以提供的<strong>最大功率</strong>，通常情况下就是电网的容量：</p><p><span class="math display">\[视在功率 S = \sqrt{P^2 + Q^2} = 3 U_p I_p = \sqrt{3} U_l I_l\]</span></p><blockquote><p><strong>注意</strong>：上面的公式表明，<strong>提高功率因数</strong>并且<strong>减少无功功率</strong>，就可以充分发挥电网的供电能力。</p></blockquote><h3 id="安全用电">安全用电</h3><h4 id="触电危险因素">触电危险因素</h4><p>触电的危险程度与这些因素紧密相关：<strong>通过人体的电流与电压</strong>、<strong>电流作用时间的长短</strong>、<strong>频率高低</strong>、<strong>电流经过人体的途径</strong>、<strong>人体的电阻</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/8.png"></p><h4 id="单相与双相触电">单相与双相触电</h4><p>人体触电主要有<strong>单相</strong>与<strong>双相</strong>两种触电形式：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/9.png"></p><ul><li><strong>单相触电</strong>：人体的一部分与带电的相线接触，另一部分又同时与大地或者零线接触；</li><li><strong>双相触电</strong>：人体的不同部位同时接触两根带电相线，触电的电压较高，危险性非常大；</li></ul><h4 id="保护接地">保护接地</h4><p>下图是三相电源<strong>中性点</strong>不接地时的示意图，虽然此时供电线路没有与大地直接连接，但是线路与大地之间却存在着电容效应（分布电容）。供电线路越长，分布电容越大，对于<code>50Hz</code>工频而言产生的容抗就越小。如果发生漏电事故，电流将会通过<strong>人体</strong>、<strong>大地</strong>、<strong>分布电容</strong>构成回路：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/10.png"></p><p>如果将负载的外壳通过导线与大地进行连接，那么发生触电事故时，人体的电阻<span class="math inline">\(R_r\)</span> 将会与接地电阻 <span class="math inline">\(R_d\)</span> 并联。人体的电阻较低时约有<code>1000Ω</code>，而接地装置的接地电阻应当低于<code>4Ω</code>，显然由于 <span class="math inline">\(R_r &gt;&gt;R_d\)</span>，漏电电流的绝大部分将会被接地电阻 <span class="math inline">\(R_d\)</span>分流，此时通过人体的电流较小，从而有效保障了人身安全，这种措施就称为<strong>保护接地</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/11.png"></p><blockquote><p><strong>注意</strong>：<strong>人工接地体</strong>通常需要采用钢管或者角钢植入地下<code>4m</code> 以上，保护接地仅适于中性点不接地的供电网络。</p></blockquote><h4 id="保护接零">保护接零</h4><p>大多数三相四线制供电系统当中，<strong>三相电源</strong>（发电机）的<strong>中性点</strong>都是通过接地导线与大地进行可靠连接，此时负载的金属外壳并不会直接接地，而是连接到零线上面，这种措施称为<strong>保护接零</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/12.png"></p><p>当电器发生漏电时，<strong>相线</strong>通过漏电的金属外壳与<strong>零线</strong>连通构成回路。由于该回路的电阻较小，导致漏电电流较大，致使相线上的保险丝<code>FU</code> 熔断，进而切断电源保护人身安全。</p><p>如果<strong>保护接零</strong>系统当中的零线断开，那么非但不会起到保护作用，还会在三相负载不平衡时，引起各相电压不相等，造成用电设备无法正常工作或者烧毁，为此供电系统专门引入了<strong>多点重复接地</strong>作为保护措施：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-13/13.png"></p><p>正常情况下，<strong>重复接地电阻</strong> <span class="math inline">\(R_c\)</span> 与<strong>中性点接地电阻</strong><span class="math inline">\(R_o\)</span>并联，从而降低接零系统的电阻，提高保护能力。当零线断开时，故障电流就会通过重复接地电阻<span class="math inline">\(R_c\)</span>构成回路，使得保险丝能够及时熔断，进而起到漏电保护的作用。</p><h2 id="rc-与-rl-电路过渡过程">RC 与 RL 电路过渡过程</h2><p>本节内容主要分析 <strong>RC</strong> 与 <strong>RL</strong>线性电路的过渡过程，主要讨论两个方面的问题：</p><ol type="1"><li>过渡过程当中<code>电压</code>与<code>电流</code>随时间变化的规律；</li><li>影响过渡过程快慢的时间常数；</li></ol><h3 id="过渡过程">过渡过程</h3><p>当从一种稳定状态转换至另外一种新的稳定状态时，并不会发生跃变，而是需要经历一定的时间与过程，这个物理过程就称为<strong>过渡过程</strong>。电路当中产生过渡过程的原因主要有如下两个：</p><ul><li>电路当中存在<strong>电感</strong> <code>L</code>或者<strong>电容</strong> <code>C</code>等动态元件，这是产生过渡过程的<strong>内因</strong>；</li><li>电路的结构或者参数发生变化，例如开关的<code>开启</code>与<code>闭合</code>、元件的<code>接通</code>与<code>断开</code>等，这是产生电路过渡过程的<strong>外因</strong>；</li></ul><p>之前小节内容讨论的都是稳定状态下的电路，此时电路当中的<code>电压</code>与<code>电流</code>已经达到某一个稳态值（对于交流电路而言，指其<strong>幅值</strong>达到稳定），这就是所谓的<strong>稳态</strong>，而电路在过渡过程当中的工作状态被称为<strong>暂态</strong>过程。</p><h3 id="换路定则">换路定则</h3><p>一个处于稳定状态下的电路，如果电路当中的电源、元件参数、电路结构发生改变，那么电路的工作状态也会发生变化，该电路就会从原来的稳定状态进入另外一种新的稳定状态，这就是所谓的<strong>换路</strong>。发生换路之后，在过渡过程开始的瞬间，电路当中的<strong>电容电压</strong>与<strong>电感电流</strong>统称为电路的<strong>初始条件</strong>或者<strong>初始值</strong>，而确定电路初始值的依据就是<strong>换路定则</strong>。</p><p>下图所示的 <strong>RC 电路</strong>当中，<strong>开关</strong><code>S</code> 闭合之前，电容两端的<strong>电压</strong> <span class="math inline">\(u_C =0\)</span>，此时电容器极板上的<strong>电荷</strong> <span class="math inline">\(q = 0\)</span>；当<strong>开关</strong><code>S</code> 闭合之后，由于<strong>电场能量</strong> <span class="math inline">\(W = \frac{1}{2}C u_C^2\)</span>不会发生突变，所以<strong>电压</strong> <span class="math inline">\(u_C\)</span> 也就不会突变，电容器两端的电压会从<code>0</code> 逐步转变为等于 <span class="math inline">\(U\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/1.png"></p><p>而下图所示的 <strong>RL 电路</strong>当中，<strong>开关</strong><code>S</code> 闭合之前，电路当中的<strong>电流</strong> <span class="math inline">\(i_L = 0\)</span>，电感线圈的<strong>磁通</strong><span class="math inline">\(\phi = 0\)</span>；当<strong>开关</strong><code>S</code> 闭合以后，由于磁场能量 <span class="math inline">\(W =\frac{1}{2}L i_L^2\)</span> 不会发生突变，所以电流 <span class="math inline">\(i_L\)</span> 也就无法突变，而必须从 <code>0</code>逐步变化为 <span class="math inline">\(\frac{U}{R}\)</span>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/2.png"></p><p>简便起见，我们可以认为<strong>换路</strong>是在一瞬间完成的，通常会将<strong>换路瞬间</strong>作为计时的起点<span class="math inline">\(t =0_+\)</span>，而将<strong>换路前的时刻</strong>记为 <span class="math inline">\(t =0_-\)</span>，<strong>换路之后的初始时刻</strong>则记为 <span class="math inline">\(t = 0_+\)</span>，进而可以得出如下两条结论：</p><ol type="1"><li>在换路的一瞬间，如果流过<strong>电容</strong>的<strong>电流</strong>保持为有限值，则<strong>电容</strong>两端的<strong>电压</strong>应当保持换路前瞬间的原始值（不能发生突变），即<span class="math inline">\(u_C(0_+) =u_C(0_-)\)</span>；对于原来两端不存在电压的电容而言，换路瞬间 <span class="math inline">\(u_C(0_+) = u_C(0_-) =0\)</span>，电容相当于<strong>短路</strong>；</li><li>在换路的一瞬间，如果<strong>电感</strong>两端的<strong>电压</strong>保持为有限值，则<strong>电感</strong>当中的<strong>电流</strong>应当保持换路前瞬间的原始值（不能发生突变），即<span class="math inline">\(i_L(0_+) =i_L(0_-)\)</span>；对于原来不存在电流的电感而言，换路瞬间 <span class="math inline">\(i_L(0_+) = i_L(0_-) =0\)</span>，电感相当于<strong>开路</strong>；</li></ol><blockquote><p><strong>注意</strong>：<strong>换路定则</strong>仅仅只适用于换路一瞬间的状态。</p></blockquote><h4 id="电路初始值计算">电路初始值计算</h4><p>电路的<strong>初始值</strong>就是换路之后 <span class="math inline">\(t = 0_+\)</span>时刻的<code>电压</code>与<code>电流</code>值，可以根据<strong>换路定则</strong>和<strong>基尔霍夫定律</strong>，按照下面步骤进行求解：</p><ol type="1"><li>根据换路之前稳态电路 <span class="math inline">\(t = 0_-\)</span>时刻的等效电路，就可以计算出<strong>电容电压</strong> <span class="math inline">\(u_C(0_-)\)</span> 和<strong>电感电流</strong><span class="math inline">\(i_L(0_-)\)</span>，由于换路时只有<strong>电容电压</strong>和<strong>电感电流</strong>维持不变，其它的电压与电流无需进行计算；</li><li>根据换路定则可以得到电容电压与电感电流的<strong>初始值</strong>，即<span class="math inline">\(u_C(0_+) = u_C(0_-)\)</span> 以及 <span class="math inline">\(i_L(0_+) = i_L(0_-)\)</span>；</li><li>在 <span class="math inline">\(t = 0_+\)</span>时刻的等效电路当中，如果 <span class="math inline">\(u_C(0_+) =0\)</span>，就可以将<strong>电容器</strong> <code>C</code> 短路；如果<span class="math inline">\(u_C(0_+) = U\)</span>，则可以用一个电压为<code>U</code> 的<strong>电压源</strong>代替电容；如果 <span class="math inline">\(i_L(0_+) = 0\)</span>，就将<strong>电感器</strong><code>L</code> 开路；如果 <span class="math inline">\(i_L(0_+) =I\)</span>，则采用一个电流为 <span class="math inline">\(I\)</span>的<strong>电流源</strong>代替电感；</li><li>根据 <span class="math inline">\(t = 0_+\)</span>时刻的等效电路，利用稳态电路的分析方法，就可以计算出电路的任意一个初始值。</li></ol><blockquote><p><strong>注意</strong>：在换路的一瞬间，仅有<strong>电容电压</strong>与<strong>电感电流</strong>无法跃变，而<strong>电容电流</strong>与<strong>电感电压</strong>是可以发生跃变的；而对于<strong>纯电阻电路</strong>，电流和电压都可以发生跃变。</p></blockquote><h4 id="电路稳态值计算">电路稳态值计算</h4><p>电路的<strong>稳态值</strong>是指换路之后，达到新的稳定状态时的<code>电压</code>与<code>电流</code>值，通常情况下采用<span class="math inline">\(u(\infty)\)</span>、<span class="math inline">\(i(\infty)\)</span> 进行表示。</p><p><strong>直流状态</strong>下的 <strong>RC</strong> 与<strong>RL</strong>电路，在电路达到新的稳定状态时，<strong>电容器</strong>相当于<strong>开路</strong>，而<strong>电感器</strong>相当于<strong>短路</strong>。由此，就可以绘制出<span class="math inline">\(t = \infty\)</span>时的等效电路，再通过直流电路的分析方法进行计算即可。</p><h3 id="rc-电路过渡过程">RC 电路过渡过程</h3><h4 id="放电过渡过程">放电过渡过程</h4><p>下图是一个 RC 串联电路，换路之前，<strong>开关</strong><code>S</code> 处于<strong>位置 1</strong>，电源对电容进行充电，当充至<span class="math inline">\(u_C = U\)</span> 之后，在 <span class="math inline">\(t = 0\)</span> 时刻，将<strong>开关</strong><code>S</code> 从<strong>位置 1</strong> 拨到<strong>位置2</strong>，使得电路断开电源，此时<strong>电容</strong> <code>C</code>会经过<strong>电阻</strong> <code>R</code> 进行放电：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/3.png"></p><p>接下来，讨论放电过程当中，电路的<code>电压</code>和<code>电流</code>随<code>时间</code>的变化规律。当<strong>开关</strong><code>S</code> 从<strong>位置 1</strong> 拔动至<strong>位置 2</strong>时，<strong>电容器</strong> <code>C</code>开始放电，此时电容器两端<strong>电压</strong> <span class="math inline">\(u_C\)</span> 的变化规律如下所示：</p><p><span class="math display">\[u_C = U_e^{-\frac{t}{\tau}}\]</span></p><p>假设电流的正方向如上图箭头所示，此时放电电流的变化规律如下面方程所示：</p><p><span class="math display">\[i = \frac{U}{R} e^{-\frac{t}{\tau}}\]</span></p><p>在上面的等式当中，<strong>常数</strong> <span class="math inline">\(e= 2.718\)</span>，而 RC 电路的<strong>时间常数</strong> <span class="math inline">\(\tau = RC\)</span>（具有时间量纲）。时间常数 <span class="math inline">\(\tau\)</span>会影响电容两端的<strong>电压</strong> <span class="math inline">\(u_C\)</span> 和<strong>电流</strong> <span class="math inline">\(i\)</span>，并且决定电路放电时间的长短。如果 <span class="math inline">\(\tau\)</span>越大，就说明<strong>电容</strong>与<strong>电阻</strong>较大（电容越大，存储电荷越多；电阻越大，放电电流越小）；反过来，如果<span class="math inline">\(\tau\)</span>越小，就说明<strong>电容</strong>与<strong>电阻</strong>较小（放电时间更短，放电电流较大）。</p><p>换路之后，当 <span class="math inline">\(t = \tau\)</span>的时刻，根据 <span class="math inline">\(u_C =U_e^{-\frac{t}{\tau}}\)</span> 可以得到 <span class="math inline">\(u_C(\tau) = U_e^{-1} = \frac{U}{2.718} =0.368U\)</span>，此后每经过一个时间常数 <span class="math inline">\(\tau\)</span>，电容电压就会衰减至原值的<code>0.368</code> 倍：</p><p><span class="math display">\[\begin{aligned}u_C(2\tau) = 0.368 u_C(1\tau) = 0.135U \\u_C(3\tau) = 0.368 u_C(2\tau) = 0.050U \\u_C(4\tau) = 0.368 u_C(3\tau) = 0.018U \\u_C(5\tau) = 0.368 u_C(4\tau) = 0.007U\end{aligned}\]</span></p><p>理论上，电路只有经过 <span class="math inline">\(t = \infty\)</span>时间才能达到稳定，但是实际上只经过了 <span class="math inline">\(t =5\tau\)</span> 之后，电容电压就已经衰减至原值的<code>0.7%</code>。通常认为换路之后经过 <span class="math inline">\(5\tau\)</span>时间，电容的放电就已经基本结束，电容上的<code>电压</code>与<code>电流</code>变化曲线如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/4.png"></p><p>电容放电的快慢可以通过改变电路的<strong>时间常数</strong>来进行控制，下图给出了<span class="math inline">\(\tau_1 &gt; \tau_2 &gt; \tau_3\)</span>三种不同时间常数下 <span class="math inline">\(u_C\)</span>的变化曲线：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/5.png"></p><h4 id="充电过渡过程">充电过渡过程</h4><p>当 <strong>RC串联电路</strong>的开关闭合之后，就会开始对电容器进行充电，此时可以划分为<strong>零状态</strong>和<strong>非零状态</strong>两种情况来进行分析。</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/6.png"></p><h5 id="零状态">零状态</h5><p>换路之前，电路当中所有的储能元件均未储存能量，此时属于电路的<strong>零状态</strong>，即初始状态为零<span class="math inline">\(u_C(0_-) =0\)</span>。当<strong>开关</strong> <code>S</code>闭合以后，电压源开始对电容器进行充电，经过推算，零状态下电容器两端<strong>电压</strong><span class="math inline">\(u_C\)</span> 的变化规律如下所示：</p><p><span class="math display">\[u_C = U(1 - e^{-\frac{t}{\tau}})\]</span></p><p>假设充电电流的正方向如上图所示，同样经过推算，就可以总结出充电<strong>电流</strong><span class="math inline">\(i\)</span> 的变化规律：</p><p><span class="math display">\[i = \frac{U}{R} e^{-\frac{t}{\tau}}\]</span></p><p>换路之后，当 <span class="math inline">\(t = \tau\)</span>的时刻，根据公式 <span class="math inline">\(u_C = U(1 -e^{-\frac{t}{\tau}})\)</span> 就可以得到 <span class="math inline">\(u_C(\tau)\)</span> 至 <span class="math inline">\(u_C(5\tau)\)</span>：</p><p><span class="math display">\[u_C(\tau) = U(1 - e^{-1}) = U(1 - 0.368) = 0.632 U\implies\begin{cases}u_C(2\tau) = 0.865U \\u_C(3\tau) = 0.950U \\u_C(4\tau) = 0.982U \\u_C(5\tau) = 0.993U\end{cases}\]</span></p><p>电路在理论上只有经过 <span class="math inline">\(t = \tau\)</span>时间才能达到稳定，实际上在经过 <span class="math inline">\(t =5\tau\)</span> 之后，电容的电压就已经上升至电压源 <span class="math inline">\(U\)</span> 的<code>99.3%</code>。因而通常认为，换路之后经过 <span class="math inline">\(5\tau\)</span>时间，电容器的充电就已经基本结束，<strong>电容电压</strong> <span class="math inline">\(u_C\)</span> 和<strong>电阻电压</strong> <span class="math inline">\(u_R\)</span>的变化曲线如<strong>下图左侧</strong>所示，而<strong>电流</strong> <span class="math inline">\(i\)</span>的变化曲线如<strong>下图右侧</strong>所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/7.png"></p><blockquote><p><strong>注意</strong>：电容器充电的快慢可以通过改变电路的<strong>时间常数</strong>来实现，时间常数越小充电越快，时间常数越大则充电越慢。</p></blockquote><h5 id="非零状态">非零状态</h5><p>换路之前，电路当中的储能元件已经储存有能量，此时就处于电路的<strong>非零状态</strong>。对于本节内容开头的电路而言，假设在换路之前，电容器已经存在<span class="math inline">\(U_0\)</span>电压，根据推算，就可以得到换路之后电容器的<strong>充电电压</strong><span class="math inline">\(u_C\)</span> 和<strong>充电电流</strong><span class="math inline">\(i\)</span>：</p><p><span class="math display">\[\begin{cases}u_C = U + (U_0 - U) e^{- \frac{t}{\tau}} \\i = \frac{U - U_0}{R} e^{-\frac{t}{\tau}}\end{cases}\]</span></p><p>充电<strong>电压</strong> <span class="math inline">\(u_C\)</span>（下图左侧）和充电<strong>电流</strong><span class="math inline">\(i\)</span>（下图右侧）的波形图分别如下所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/8.png"></p><h4 id="微分电路">微分电路</h4><p>下图就是一个由<strong>电阻</strong> <code>R</code>和<strong>电容</strong> <code>C</code>构成的<strong>微分电路</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/9.png"></p><ul><li><strong>微分电路的主要作用</strong>：当输入下图 <code>A</code>所示的<strong>周期性矩形脉冲</strong>时，微分电路就会输出下图<code>B</code> 所示的<strong>正负尖峰脉冲</strong>；</li><li><strong>微分电路的构成条件</strong>：输入的<strong>脉冲宽度</strong><span class="math inline">\(t_p\)</span>要远远大于电路的<strong>时间常数</strong> <span class="math inline">\(\tau\)</span>；</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-14/10.png"></p><p>接下来，简要介绍微分电路的工作过程。当输入信号 <span class="math inline">\(u_1\)</span>脉冲出现的一瞬间，由于<strong>电容</strong> <code>C</code>两端的电压不能发生突变，所以呈现出短路状态，导致脉冲被添加到<strong>电阻</strong><code>R</code> 上面，此时 <code>R</code> 上的电压 <span class="math inline">\(u_2\)</span> 为最大。因为 RC 时间常数 <span class="math inline">\(\tau = RC\)</span>非常小，所以在脉冲没有消失之前，<strong>电容</strong> <code>C</code>就已经充满了电荷，呈现开路状态。由于没有充电电流经过<strong>电阻</strong><code>R</code>，所以电压 <span class="math inline">\(u_2\)</span>等于零，该过程会产生上图 <code>B</code>所示波形里的<strong>正尖峰脉冲</strong>。同时，这个过程还会为<strong>电容</strong><code>C</code> 充上<strong>左正右负</strong>的电压，电压大小为输入信号<span class="math inline">\(u_1\)</span> 脉冲的幅值 <span class="math inline">\(U\)</span>。</p><p>当输入信号 <span class="math inline">\(u_1\)</span>脉冲消失的一瞬间，<span class="math inline">\(u_1\)</span>等于零，此时相当于输入端接地。由于电容两端的电压无法突变，此刻<strong>电阻</strong><code>R</code> 上的电压 <span class="math inline">\(u_2\)</span>为负的最大电压值 <span class="math inline">\(-U\)</span>，即<strong>电容</strong><code>C</code>充上了<strong>左正右负</strong>的电压。又由于<strong>电容</strong><code>C</code> 的左端接地，所以 <span class="math inline">\(u_2\)</span>为负电压。因为 <span class="math inline">\(\tau = RC\)</span>比较小，所以<strong>电容</strong> <code>C</code>通过<strong>电阻</strong> <code>R</code> 很快放电完毕，而 <span class="math inline">\(u_2\)</span> 又为零，从而得到上图 <code>B</code>所示波形当中的<strong>负尖峰脉冲</strong>。</p><p>当第 2 个脉冲到来的时候，<strong>电阻</strong> <code>R</code>上面又会获得<strong>正尖峰脉冲</strong>。而当 <span class="math inline">\(u_1\)</span>脉冲消失的时候，又会获得<strong>负尖峰脉冲</strong>。这样就可以<strong>通过微分电路，将矩形脉冲转换为正负尖峰脉冲</strong>。</p><h4 id="积分电路">积分电路</h4><p>下图就是一个由<strong>电阻</strong> <code>R</code>和<strong>电容</strong> <code>C</code>构成的<strong>积分电路</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/11.png"></p><ul><li><strong>积分电路的主要作用</strong>：当输入下图 <code>A</code>所示的<strong>周期性矩形脉冲</strong>时，积分电路将会输出下图<code>B</code> 所示的<strong>锯齿波</strong>；</li><li><strong>积分电路的构成条件</strong>：与微分电路的构成正好相反，积分电路的的<strong>时间常数</strong><span class="math inline">\(\tau\)</span>要远远大于<strong>脉冲宽度</strong> <span class="math inline">\(t_p\)</span>；</li></ul><p><img src="/Electronics/Introduct_Analysis/Chapter-14/12.png"></p><p>接下来，简要介绍积分电路的工作过程。当输入的<strong>矩形脉冲信号</strong><span class="math inline">\(u_1\)</span> 出现时，输出 <span class="math inline">\(u_2\)</span> 产生的电流会经过<strong>电阻</strong><code>R</code> 对<strong>电容</strong> <code>C</code>进行充电，使得<strong>电容</strong> <code>C</code> 上面的电压 <span class="math inline">\(u_2\)</span> 逐渐增大。当脉冲消失之后，<span class="math inline">\(u_1\)</span> 等于零，<strong>电容</strong><code>C</code> 上面已经充满的电压又会经过<strong>电阻</strong><code>R</code> 进行放电。但是由于时间常数 <span class="math inline">\(\tau = RC\)</span>比较大，所以放电过程较为缓慢。当第 2个脉冲到来的时候，又会对<strong>电容</strong> <code>C</code>继续进行充电，使得<strong>输出电压</strong> <span class="math inline">\(u_2\)</span> 增大。通过观察就可以发现上图<code>B</code> 所示波形当中，输入脉冲越密集，输出电压 <span class="math inline">\(u_2\)</span> 就会越大。</p><h3 id="rl-电路过渡过程">RL 电路过渡过程</h3><h4 id="接通恒定电压">接通恒定电压</h4><p>下图是一个由<strong>电阻</strong> <code>R</code>和<strong>电感</strong> <code>L</code> 组成的 <strong>RL串联电路</strong>：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/13.png"></p><p>当<strong>开关</strong> <code>S</code> 没有闭合的时候，电感器 <span class="math inline">\(L\)</span>当中没有存储能量。而将<strong>开关</strong> <code>S</code>闭合以后，电路将会与恒定电压为 <span class="math inline">\(U\)</span>的<strong>电压源</strong>导通，此时根据推算，电感器两端的<strong>电压</strong><span class="math inline">\(u_L\)</span>与电路当中的<strong>电流</strong> <span class="math inline">\(i\)</span>分别等于：</p><p><span class="math display">\[\begin{cases}u_L = U_e^{-\frac{t}{\tau}}\\i = \frac{U}{R}(1 - e^{-\frac{t}{\tau}})\end{cases}\]</span></p><p>上面方程组当中的 <span class="math inline">\(\tau\)</span>同样具有时间的量纲，被称为 RL 电路的<strong>时间常数</strong>，<span class="math inline">\(u_L\)</span> 与 <span class="math inline">\(i\)</span> 的变化曲线如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/14.png"></p><h4 id="短路-断开">短路 &amp; 断开</h4><p>对于下图所示的 <strong>RL电路</strong>，在换路之前，<strong>开关</strong> <code>S</code> 与位置<code>2</code>导通，整个电路处于<strong>稳态</strong>，此时<strong>电感器</strong><code>L</code> 当中的电流 <span class="math inline">\(I =\frac{U}{R}\)</span>，电感器储存了磁场能量：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/15.png"></p><p>当 <span class="math inline">\(t = 0\)</span>时刻，将<strong>开关</strong> <code>S</code> 从位置 <code>2</code>放回到位置 <code>1</code>，电路就可以变换为下面的形式：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/16.png"></p><p>由于<strong>电感器</strong> <code>L</code>上的电流无法突变，所以电感上电流的初始值为 <span class="math inline">\(i_L(0_+) = i_L(0_-) =\frac{U}{R}\)</span>，随后电感器当中存储的能量会不断通过<strong>电阻</strong><code>R</code> 进行释放。<strong>电感值</strong> L越大，电感器上面储存的电量就会越多，释放能量所需要的时间也就会越长，<strong>电阻</strong><code>R</code>越大，能量的衰减也就会越慢。经过推算，当<strong>开关</strong><code>S</code> 从位置 <code>2</code> 回到位置 <code>1</code>的时候，如果选定上图箭头所示的方向为正方向，那么电感器上面<strong>电流</strong><span class="math inline">\(i_L\)</span> 与<strong>电压</strong> <span class="math inline">\(u_L\)</span> 的变化规律为：</p><p><span class="math display">\[\begin{cases}i_L = \frac{U}{R} e^{-\frac{t}{\tau}}\\u_L = - Ue^{-\frac{t}{\tau}}\end{cases}\]</span></p><p>上面方程组当中的 <span class="math inline">\(u_L\)</span>为负值，说明电感上面电压的方向与参考方向相反，<span class="math inline">\(i_L\)</span> 与 <span class="math inline">\(u_L\)</span> 的变化曲线如下图所示：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/17.png"></p><p>如果上面 RL 电路当中的<strong>开关</strong> <code>S</code>从电源断开，而并没有进行<strong>短路</strong>，那么此时电流的变化率<span class="math inline">\(\frac{\Delta I}{\Delta t}\)</span>将会非常大，进而导致线圈产生的<strong>自感电动势</strong> <span class="math inline">\(e_L = L\frac{\Delta I}{\Delta t}\)</span>也会很大，该自感电动势可能导致开关击穿损毁，所以往往会在把<strong>线圈</strong>从<strong>电源</strong>断开的同时，对线圈进行短路，使得电流得以逐渐减小。</p><p>除此之外，还可以应用其它保护措施，例如在电感线圈的两端并联上<strong>续流二极管</strong>（下图左），或者接入<strong>阻容吸收电路</strong>（下图右）：</p><p><img src="/Electronics/Introduct_Analysis/Chapter-14/18.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文力求言简意赅的讨论电路分析过程当中涉及到的一些基本理论知识，全文第
1 部分围绕&lt;strong&gt;电路分析&lt;/strong&gt;展开，涵盖了电路当中的
&lt;code&gt;电阻&lt;/code&gt; 与 &lt;code&gt;电容&lt;/code&gt;
等基本元件，相关的定律（&lt;code&gt;欧姆定律&lt;/code&gt;、&lt;code&gt;焦耳定律&lt;/code&gt;、&lt;code&gt;基尔霍夫定律&lt;/code&gt;）定理（&lt;code&gt;叠加定理&lt;/code&gt;、&lt;code&gt;戴维南定理&lt;/code&gt;、&lt;code&gt;诺顿定理&lt;/code&gt;）和等效变换（&lt;code&gt;电源等效&lt;/code&gt;、&lt;code&gt;串并联等效&lt;/code&gt;、&lt;code&gt;星形三角形等效&lt;/code&gt;），以及基本的分析方法（&lt;code&gt;支路电流法&lt;/code&gt;、&lt;code&gt;结点电压法&lt;/code&gt;、&lt;code&gt;非线性电阻分析&lt;/code&gt;）；第
2 部分则以&lt;strong&gt;电磁感应&lt;/strong&gt;现象作为核心，同时引入
&lt;code&gt;安培力&lt;/code&gt;、&lt;code&gt;洛仑兹力&lt;/code&gt;、&lt;code&gt;磁通量&lt;/code&gt;
等电磁学基本概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/Introduct_Analysis/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;第 3 部分围绕&lt;strong&gt;交流信号&lt;/strong&gt;展开，包含了动态元件
&lt;code&gt;电阻&lt;/code&gt;、&lt;code&gt;电容&lt;/code&gt;、&lt;code&gt;电感&lt;/code&gt;
相关的交流电路，并且介绍了 &lt;code&gt;功率因数&lt;/code&gt;
的提高，&lt;strong&gt;RC&lt;/strong&gt; 与 &lt;strong&gt;LC&lt;/strong&gt;
电路，以及&lt;strong&gt;三相交流电路&lt;/strong&gt;；第 4
部分介绍了&lt;strong&gt;互感&lt;/strong&gt;与&lt;strong&gt;变压器&lt;/strong&gt;，主要讨论互感现象与变压器的原理；第
5 部分则主要讨论电路的&lt;strong&gt;过渡过程&lt;/strong&gt;，比如
&lt;strong&gt;RC&lt;/strong&gt; 与 &lt;strong&gt;RL&lt;/strong&gt; 电路的过渡过程，以及其中
&lt;code&gt;电压&lt;/code&gt; 与 &lt;code&gt;电流&lt;/code&gt;
随着时间变化的规律和影响过渡过程快慢的&lt;code&gt;时间常数&lt;/code&gt;，同时还引入了&lt;strong&gt;换路定则&lt;/strong&gt;与
&lt;code&gt;微分电路&lt;/code&gt; 以及 &lt;code&gt;积分电路&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="Circuit Analysis" scheme="http://www.uinio.com/tags/Circuit-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>《实用电子元器件与电路基础》读书笔记</title>
    <link href="http://www.uinio.com/Electronics/Practical_Electronics/"/>
    <id>http://www.uinio.com/Electronics/Practical_Electronics/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-04-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>《<strong>实用电子元器件与电路基础</strong>》的英文原版书籍名称叫做《<strong>PracticalElectronics forInventors</strong>》，全书从电路基本原理入手，围绕各种类型的电子元器件进行了详细介绍。首先是阐述了基本的电路理论，然后重点讨论了包括<code>电阻</code>、<code>电容</code>、<code>电感</code>、<code>变压器</code>在内的基本元器件；接下来介绍了半导体电子技术，并且详细分析了<code>二极管</code>、<code>晶体管</code>、<code>晶闸管</code>等半导体元件的性能与参数，以及<code>运算放大器</code>、<code>滤波电路</code>、<code>振荡电路</code>、<code>定时器</code>、<code>稳压电路与电源</code>等经典的模拟电路。</p><p><img src="/Electronics/Practical_Electronics/logo.png"></p><p>最后介绍了数字电子技术相关的内容，从基本的<code>逻辑门</code>电路入手，重点讨论了<strong>组合逻辑电路</strong>和<strong>时序逻辑电路</strong>，以及相关的<code>触发器</code>，<code>寄存器</code>、<code>计数器</code>、<code>缓冲器</code>、<code>锁存器</code>、<code>收发器</code>，乃至于<strong>存储器</strong>与<strong>微控制器</strong>。除此之外，该书还简单介绍了<strong>线性函数</strong>、<strong>二次函数</strong>、<strong>指数/对数函数</strong>、<strong>三角函数</strong>、<strong>复数</strong>、<strong>微积分</strong>等数学预备知识。电子元器件的<strong>选型</strong>与<strong>运用</strong>是硬件工程师日常工作当中最为主要的内容，希望本篇文章能够对广大电子爱好者有所帮助。</p><span id="more"></span><h2 id="数学预备知识">数学预备知识</h2><p>本章节内容主要用于归纳电子技术相关的常用数学基础知识。</p><h3 id="希腊字母">希腊字母</h3><table style="width:100%;"><colgroup><col style="width: 18%"><col style="width: 6%"><col style="width: 6%"><col style="width: 19%"><col style="width: 18%"><col style="width: 6%"><col style="width: 6%"><col style="width: 18%"></colgroup><thead><tr class="header"><th style="text-align: center;">英文</th><th style="text-align: center;">大写</th><th style="text-align: center;">小写</th><th style="text-align: center;">音标</th><th style="text-align: center;">英文</th><th style="text-align: center;">大写</th><th style="text-align: center;">小写</th><th style="text-align: center;">音标</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Alpha</strong></td><td style="text-align: center;">Α</td><td style="text-align: center;">α</td><td style="text-align: center;">/ˈælfə/</td><td style="text-align: center;"><strong>Beta</strong></td><td style="text-align: center;">Β</td><td style="text-align: center;">β</td><td style="text-align: center;">/ˈbetə/</td></tr><tr class="even"><td style="text-align: center;"><strong>Gamma</strong></td><td style="text-align: center;">Γ</td><td style="text-align: center;">γ</td><td style="text-align: center;">/ˈɡæmə/</td><td style="text-align: center;"><strong>Delta</strong></td><td style="text-align: center;">∆</td><td style="text-align: center;">δ</td><td style="text-align: center;">/ˈdeltə/</td></tr><tr class="odd"><td style="text-align: center;"><strong>Epsilon</strong></td><td style="text-align: center;">Ε</td><td style="text-align: center;">ε</td><td style="text-align: center;">/ˈepsɪlɑːn/</td><td style="text-align: center;"><strong>Zeta</strong></td><td style="text-align: center;">Ζ</td><td style="text-align: center;">ζ</td><td style="text-align: center;">/ˈzeɪtə/</td></tr><tr class="even"><td style="text-align: center;"><strong>Eta</strong></td><td style="text-align: center;">Ε</td><td style="text-align: center;">η</td><td style="text-align: center;">/ˈiːtə/</td><td style="text-align: center;"><strong>Theta</strong></td><td style="text-align: center;">Θ</td><td style="text-align: center;">θ</td><td style="text-align: center;">/ˈθeɪtə/</td></tr><tr class="odd"><td style="text-align: center;"><strong>Iota</strong></td><td style="text-align: center;">Ι</td><td style="text-align: center;">ι</td><td style="text-align: center;">/aɪˈoʊtə/</td><td style="text-align: center;"><strong>Kappa</strong></td><td style="text-align: center;">Κ</td><td style="text-align: center;">κ</td><td style="text-align: center;">/ˈkæpə/</td></tr><tr class="even"><td style="text-align: center;"><strong>Lambda</strong></td><td style="text-align: center;">Λ</td><td style="text-align: center;">λ</td><td style="text-align: center;">/ˈlæmdə/</td><td style="text-align: center;"><strong>Mu</strong></td><td style="text-align: center;">Μ</td><td style="text-align: center;">µ</td><td style="text-align: center;">/mjuː/</td></tr><tr class="odd"><td style="text-align: center;"><strong>Nu</strong></td><td style="text-align: center;">Ν</td><td style="text-align: center;">ν</td><td style="text-align: center;">/njuː/</td><td style="text-align: center;"><strong>Xi</strong></td><td style="text-align: center;">Ξ</td><td style="text-align: center;">ξ</td><td style="text-align: center;">/ksaɪ/</td></tr><tr class="even"><td style="text-align: center;"><strong>Omicron</strong></td><td style="text-align: center;">Ο</td><td style="text-align: center;">ο</td><td style="text-align: center;">/ˈɑːməkrɑːn/</td><td style="text-align: center;"><strong>Pi</strong></td><td style="text-align: center;">Π</td><td style="text-align: center;">π</td><td style="text-align: center;">/paɪ/</td></tr><tr class="odd"><td style="text-align: center;"><strong>Rho</strong></td><td style="text-align: center;">Ρ</td><td style="text-align: center;">ρ</td><td style="text-align: center;">/rəʊ/</td><td style="text-align: center;"><strong>Sigma</strong></td><td style="text-align: center;">Σ</td><td style="text-align: center;">σ</td><td style="text-align: center;">/ˈsɪɡmə/</td></tr><tr class="even"><td style="text-align: center;"><strong>Tau</strong></td><td style="text-align: center;">Τ</td><td style="text-align: center;">τ</td><td style="text-align: center;">/tɔːˌtaʊ/</td><td style="text-align: center;"><strong>Upsilon</strong></td><td style="text-align: center;">Υ</td><td style="text-align: center;">υ</td><td style="text-align: center;">/ˈʊpsɪlɑːn/</td></tr><tr class="odd"><td style="text-align: center;"><strong>Phi</strong></td><td style="text-align: center;">Φ</td><td style="text-align: center;">φ</td><td style="text-align: center;">Phi</td><td style="text-align: center;"><strong>Chi</strong></td><td style="text-align: center;">Χ</td><td style="text-align: center;">χ</td><td style="text-align: center;">/kaɪ/</td></tr><tr class="even"><td style="text-align: center;"><strong>Psi</strong></td><td style="text-align: center;">Ψ</td><td style="text-align: center;">ψ</td><td style="text-align: center;">/psaɪ/</td><td style="text-align: center;"><strong>Omega</strong></td><td style="text-align: center;">Ω</td><td style="text-align: center;">ω</td><td style="text-align: center;">/oʊˈmeɡə/</td></tr></tbody></table><h3 id="单位前缀">单位前缀</h3><table><colgroup><col style="width: 13%"><col style="width: 6%"><col style="width: 16%"><col style="width: 12%"><col style="width: 13%"><col style="width: 6%"><col style="width: 18%"><col style="width: 13%"></colgroup><thead><tr class="header"><th style="text-align: center;">单位前缀</th><th style="text-align: center;">符号</th><th style="text-align: center;">乘方</th><th style="text-align: center;">音标</th><th style="text-align: center;">单位前缀</th><th style="text-align: center;">符号</th><th style="text-align: center;">乘方</th><th style="text-align: center;">音标</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>tera</strong></td><td style="text-align: center;">T</td><td style="text-align: center;"><span class="math inline">\(×10^{12}\)</span></td><td style="text-align: center;">/ˈterə/</td><td style="text-align: center;"><strong>milli</strong></td><td style="text-align: center;">m</td><td style="text-align: center;"><span class="math inline">\(×10^{−3}\)</span></td><td style="text-align: center;">/ˈmɪli/</td></tr><tr class="even"><td style="text-align: center;"><strong>giga</strong></td><td style="text-align: center;">G</td><td style="text-align: center;"><span class="math inline">\(×10^9\)</span></td><td style="text-align: center;">/ˈɡɪɡə/</td><td style="text-align: center;"><strong>micro</strong></td><td style="text-align: center;">µ</td><td style="text-align: center;"><span class="math inline">\(×10^{−6}\)</span></td><td style="text-align: center;">micro</td></tr><tr class="odd"><td style="text-align: center;"><strong>mega</strong></td><td style="text-align: center;">M</td><td style="text-align: center;"><span class="math inline">\(×10^6\)</span></td><td style="text-align: center;">/ˈmeɡə/</td><td style="text-align: center;"><strong>nano</strong></td><td style="text-align: center;">n</td><td style="text-align: center;"><span class="math inline">\(×10^{−9}\)</span></td><td style="text-align: center;">/ˈnænoʊ/</td></tr><tr class="even"><td style="text-align: center;"><strong>kilo</strong></td><td style="text-align: center;">k</td><td style="text-align: center;"><span class="math inline">\(×10^3\)</span></td><td style="text-align: center;">/ˈkilo/</td><td style="text-align: center;"><strong>pico</strong></td><td style="text-align: center;">p</td><td style="text-align: center;"><span class="math inline">\(×10^{−12}\)</span></td><td style="text-align: center;">/ˈpiːkoʊ/</td></tr><tr class="odd"><td style="text-align: center;"><strong>centi</strong></td><td style="text-align: center;">c</td><td style="text-align: center;"><span class="math inline">\(×10^{−2}\)</span></td><td style="text-align: center;">/ˈsentɪ/</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr></tbody></table><h3 id="线性函数">线性函数</h3><p><strong>线性函数</strong> <span class="math inline">\(y = mx +b\)</span> 会在坐标轴上绘制出一条<strong>直线</strong>，这条直线的斜率<span class="math inline">\(\frac{\Delta y}{\Delta x}\)</span> 等于<span class="math inline">\(m\)</span>，垂直截距等于 <span class="math inline">\(b\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/1.png"></p><h3 id="二次函数">二次函数</h3><p><strong>二次函数</strong> <span class="math inline">\(y = ax^2 + bx +c\)</span>会在坐标轴上绘制出一条<strong>抛物线</strong>，这条抛物线的大小受到<span class="math inline">\(\alpha\)</span> 值的影响，其横坐标为 <span class="math inline">\(-\frac{b}{2a}\)</span>，而纵坐标为 <span class="math inline">\(-\frac{b^2}{a+c}\)</span>，方程的<strong>根</strong>位于抛物线与横轴的交点，可以通过公式<span class="math inline">\(x = \frac{-b \pm \sqrt{b^2 -4ac}}{2a}\)</span> 计算得到：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/2.png"></p><h3 id="指数函数">指数函数</h3><p>形如 <span class="math inline">\(y=a^x（a&gt;0，且a \neq 1）\)</span>的函数称为<strong>指数函数</strong>，其中的 <span class="math inline">\(x\)</span> 为自变量，函数的定义域为 <span class="math inline">\(R\)</span>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/3.png"></p><table><colgroup><col style="width: 6%"><col style="width: 18%"><col style="width: 17%"><col style="width: 19%"><col style="width: 18%"><col style="width: 19%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(x^0 =1\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{1}{x^n} = x^{-n}\)</span></th><th style="text-align: center;"><span class="math inline">\(x^{1/n} =\sqrt[n]{x}\)</span></th><th style="text-align: center;"><span class="math inline">\(x^m \cdotx^n = x^{m+n}\)</span></th><th style="text-align: center;"><span class="math inline">\((xy)^n = x^n\cdot y^n\)</span></th><th style="text-align: center;"><span class="math inline">\((x^n)^m =x^{n \cdot m}\)</span></th></tr></thead><tbody></tbody></table><h3 id="对数函数">对数函数</h3><p>如果 <span class="math inline">\(a^y = x（a&gt;0，且 a \neq1）\)</span>，那么 <span class="math inline">\(y\)</span> 就叫做以 <span class="math inline">\(a\)</span> 为底 <span class="math inline">\(N\)</span> 的<strong>对数</strong>，记作 <span class="math inline">\(y = log_a x\)</span>，其中 <span class="math inline">\(a\)</span> 称为对数的<strong>底数</strong>，而<span class="math inline">\(x\)</span> 称为<strong>真数</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/4.png"></p><ul><li><strong>常用对数</strong>：通常将以 <code>10</code> 为底的对数 <span class="math inline">\(\log_{10} x\)</span> 记为 <span class="math inline">\(\lg x\)</span>；</li><li><strong>自然对数</strong>：通常将以无理数 <code>2.71828...</code>作为底数的对数 <span class="math inline">\(\log_e x\)</span> 记为 <span class="math inline">\(\ln x\)</span>；</li></ul><p>根据对数的定义，就可以得到对数与指数之间的关系：<span class="math inline">\(a^y = x（当 a&gt;0 且 a \neq 1 时）\iff y = \log_ax\)</span>。</p><table><colgroup><col style="width: 26%"><col style="width: 28%"><col style="width: 45%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\log_b 1 =0\)</span></th><th style="text-align: center;"><span class="math inline">\(\log_b b =1\)</span></th><th style="text-align: center;"><span class="math inline">\(\log_b 0 =\begin{cases} +\infty b &lt; 1 \\ -\infty b &gt; 1\end{cases}\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\log_b(x\cdot y) = \log_b x + \log_b y\)</span></td><td style="text-align: center;"><span class="math inline">\(\log_b(\frac{x}{y}) = \log_b x - \log_by\)</span></td><td style="text-align: center;"><span class="math inline">\(\log_b (x^y)= y \log_b x\)</span></td></tr></tbody></table><h3 id="三角函数">三角函数</h3><p>对于半径为 <span class="math inline">\(R\)</span> 的圆形，弧长 <span class="math inline">\(S\)</span> 所对应的圆心角弧度 <span class="math inline">\(\theta = \frac{弧长 S}{半径 R}\)</span>，此时<span class="math inline">\(1 弧度 = \frac{180°}{\pi} =57.296°\)</span>，而 <span class="math inline">\(1° = \frac{\pi}{180°} =0.17453 弧度\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/5.png"></p><p>当半径 <span class="math inline">\(R\)</span> 从 <span class="math inline">\(x\)</span>正半轴开始<strong>逆时针</strong>方向旋转时，<span class="math inline">\(\theta\)</span>为<strong>正角</strong>，而<strong>顺时针</strong>方向旋转时，<span class="math inline">\(\theta\)</span> 为<strong>负角</strong>。</p><table><colgroup><col style="width: 11%"><col style="width: 11%"><col style="width: 11%"><col style="width: 21%"><col style="width: 21%"><col style="width: 21%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\sin \theta= \frac{y}{R}\)</span></th><th style="text-align: center;"><span class="math inline">\(\cos \theta= \frac{x}{R}\)</span></th><th style="text-align: center;"><span class="math inline">\(\tan \theta= \frac{y}{x}\)</span></th><th style="text-align: center;"><span class="math inline">\(\cot \theta= \frac{x}{y} = \frac{1}{tan \theta}\)</span></th><th style="text-align: center;"><span class="math inline">\(\sec \theta= \frac{R}{x} = \frac{1}{\cos \theta}\)</span></th><th style="text-align: center;"><span class="math inline">\(\csc \theta= \frac{R}{y} = \frac{1}{\sin \theta}\)</span></th></tr></thead><tbody></tbody></table><h3 id="正弦与余弦函数">正弦与余弦函数</h3><p>下图为<strong>正弦函数</strong>曲线 <span class="math inline">\(y = A\sin\theta\)</span>，为了方便改变函数的<code>垂直水平位置</code>、<code>周期</code>、<code>相位</code>，可以将其改写为<span class="math inline">\(y = A \sin(Bx + C) + D\)</span> 的形式，其中<span class="math inline">\(A\)</span> 表示<strong>幅值</strong>，而<span class="math inline">\(2 \pi / B\)</span> 表示<strong>周期</strong><span class="math inline">\(T\)</span>，<span class="math inline">\(C\)</span> 表示<strong>相移</strong>，<span class="math inline">\(D\)</span> 表示<strong>垂直位移</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/6.png"></p><p>电子学当中，可以将电压表示为 <span class="math inline">\(V(t) = V_0\sin(\omega t + \varPhi) + V_{dc}\)</span>，其中 <span class="math inline">\(V_0\)</span> 为<strong>峰值电压</strong>，<span class="math inline">\(V_{dc}\)</span> 为<strong>直流分量</strong>，<span class="math inline">\(\varPhi\)</span> 为<strong>相移</strong>，<span class="math inline">\(\omega\)</span> 为<strong>角频率</strong> <span class="math inline">\(rad/s\)</span>。除此之外，<strong>余弦函数曲线</strong><span class="math inline">\(y = A \cos \theta\)</span> 与 <span class="math inline">\(y = A \sin \theta\)</span> 相差了 <span class="math inline">\(\frac{\pi}{2}\)</span> 幅度或者 <span class="math inline">\(90°\)</span> 度相移：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/7.png"></p><p>正弦函数与余弦函数之间的关系如下面表格所示：</p><table><colgroup><col style="width: 48%"><col style="width: 51%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\sin(\frac{\pi}{2} \pm x) = + \cos x\)</span> 或者<span class="math inline">\(\sin(90° \pm x) = + \cos x\)</span></th><th style="text-align: center;"><span class="math inline">\(\cos(\frac{\pi}{2} \pm x) = \pm \sin x\)</span>或者 <span class="math inline">\(\cos(90° \pm x) = \pm \sinx\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sin(\frac{3\pi}{2} \pm x) = - \cos x\)</span>或者 <span class="math inline">\(\sin(270° \pm x) = - \cosx\)</span></td><td style="text-align: center;"><span class="math inline">\(\cos(\frac{3\pi}{2} \pm x) = \pm \sin x\)</span>或者 <span class="math inline">\(\cos(270° \pm x) = \pm \sinx\)</span></td></tr></tbody></table><h3 id="斜率">斜率</h3><p><strong>斜率</strong>反映了<strong>直线</strong>相对于<strong>水平面</strong>的倾斜度，一条直线与某平面直角坐标系横坐标轴的<strong>正半轴</strong>所形成<strong>角</strong>的<strong>正切值</strong>，就等于该直线的<strong>斜率</strong>。</p><p><span class="math display">\[直线的斜率 = \frac{直线某点在\ y\ 轴的变化量\ \Delta y}{直线某点在\ x\轴的变化量\ \Delta x}\]</span></p><p>假设函数 <span class="math inline">\(f(x)\)</span>的图形为一条<strong>曲线</strong>，此时存在着一个<strong>点</strong>沿着这条曲线移动，经过该<strong>点</strong>绘制切线，当该点沿着曲线运动时，切线的斜率不断发生变化。实际生活当中，切线的斜率有着极为重要的意义，例如：</p><ul><li>当绘制某个物体相对于时间的位移曲线时，曲线上某个时间点的切线斜率，就表示了该物体在该时间点的<strong>瞬时速度</strong>；</li><li>基于时间的充电曲线当中，时刻 <span class="math inline">\(t\)</span>位置的斜率就表示该时刻的<strong>瞬时电流</strong>；</li></ul><h3 id="微分学">微分学</h3><p><strong>微分学</strong>作为作为计算<strong>斜率</strong>的途径之一，可以用于计算曲线上任意一点位置的切线斜率。例如函数<span class="math inline">\(y = x^2\)</span>，通过微分计算可以得到 <span class="math inline">\(y\)</span> 的<strong>导数</strong> <span class="math inline">\(y&#39; = \frac{dy}{dx} =2x\)</span>，通过它可以获得曲线 <span class="math inline">\(y\)</span>上任意一点位置的斜率。如果此时需要求解 <span class="math inline">\(x =2\)</span> 位置的斜率，将 <span class="math inline">\(x = 2\)</span>代入至 <span class="math inline">\(\frac{dy}{dx}\)</span>表达式，就可以得到斜率等于 <span class="math inline">\(4\)</span>。</p><p>当计算某个函数的导数时，假设 <span class="math inline">\(P(x,y)\)</span> 为曲线 <span class="math inline">\(y = f(x)\)</span>上面的一点，而 <span class="math inline">\(Q(x + \Delta x, y + \Deltay)\)</span> 为曲线上的另外一点，此时 <span class="math inline">\(P\)</span> 点与 <span class="math inline">\(Q\)</span> 点之间的直线斜率为 <span class="math inline">\(\frac{f(x + \Delta x) - f(x)}{\Deltax}\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/8.png"></p><p>将具体函数代入上面等式，例如对于函数 <span class="math inline">\(f(x)= x^2\)</span>，那么 <span class="math inline">\(f(x + \Delta x) = (x +\Delta x)^2\)</span>，此时完整的表达式可以记为 <span class="math inline">\(\frac{[(x + \Delta x)^2 - x^2]}{\Deltax}\)</span>。接下来固定 <span class="math inline">\(x\)</span> 的值，令<span class="math inline">\(\Delta x\)</span> 趋近于<code>0</code>，如果斜率趋近于某一个只依赖于 <span class="math inline">\(x\)</span> 的值，则称该值为曲线在 <span class="math inline">\(P\)</span> 点处的<strong>斜率</strong>。</p><p>曲线在 <span class="math inline">\(P\)</span> 点位置的斜率是一个关于<span class="math inline">\(x\)</span> 的函数，定义域为极限里存在的每个<span class="math inline">\(x\)</span> 值，那么斜率就可以表示为 <span class="math inline">\(f&#39;(x)\)</span>、<span class="math inline">\(\frac{dy}{dx}\)</span>、<span class="math inline">\(\frac{df}{dx}\)</span>三种形式，这三种表达方式均称为 <span class="math inline">\(f(x)\)</span>的导数：</p><p><span class="math display">\[f&#39;(x) = \frac{dy}{dx} = \lim_{\Delta x \rightarrow 0} \frac{f(x +\Delta x) - f(x)}{\Delta x}\]</span></p><p>对于上述示例当中的函数 <span class="math inline">\(f(x) =x^2\)</span>，求取极限之后，可以得到其导数为 <span class="math inline">\(f&#39;(x) = \frac{dy}{dx} =2x\)</span>。实际计算当中，使用上述极限公式计算较为繁琐，通常会直接应用下面表格当中的<strong>求导法则</strong>与<strong>函数导数</strong>：</p><table><colgroup><col style="width: 10%"><col style="width: 14%"><col style="width: 18%"><col style="width: 25%"><col style="width: 30%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\frac{d}{dx}a = 0\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{d}{dx}x^n = nx^{n - 1}\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{d}{dx}e^x = e^x\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{d}{dx}\ln x = \frac{1}{x}\)</span></th><th style="text-align: center;"><span class="math inline">\(\frac{d}{dx}\sin x = \cos x\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\frac{d}{dx}\cos x = -\sin x\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{d}{dx}au(x) = a \frac{d}{dx} u(x)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{d}{dx}(u + v) = \frac{du}{dx} +\frac{dv}{dx}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{d}{dx}\Bigl(\frac{u}{v}\Bigl) =\frac{v(du/dx) - u(dv/dx)}{v^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{d}{dx}\left \lbrace u(v(x)) \right \rbrace = \frac{du}{dx} \cdot\frac{dv}{dx}\)</span></td></tr></tbody></table><blockquote><p><strong>注意</strong>：上面表格当中的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n\)</span> 是<strong>常数</strong>，而 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 表示<strong>函数</strong>。</p></blockquote><ul><li><strong>导数</strong>是函数图像在某一点位置的<strong>斜率</strong>，即纵坐标增量<span class="math inline">\(\Delta y\)</span> 与横坐标增量 <span class="math inline">\(\Delta x\)</span> 的<strong>比值</strong>；</li><li><strong>微分</strong>是指函数图像在某一点处的切线在横坐标取得增量<span class="math inline">\(\Delta x\)</span>以后，纵坐标所相应取得的<strong>增量</strong>；</li></ul><h3 id="积分学">积分学</h3><p><strong>微分学</strong>的目标是寻找函数的导数，而<strong>积分学</strong>的任务则是寻找导数的原函数。通常约定<span class="math inline">\(y = f(x)\)</span>形式为<strong>函数</strong>，而 <span class="math inline">\(\frac{dy}{dx} = \frac{df(x)}{dx}\)</span>形式为<strong>导数</strong>，形如 <span class="math inline">\(\int dy =\int f(x)dx\)</span> 的称为<strong>积分</strong>。其中，<span class="math inline">\(\int\)</span> 称为<strong>积分符号</strong>，而<span class="math inline">\(f(x)\)</span>称为<strong>被积函数</strong>，<span class="math inline">\(dx\)</span>称为<strong>积分变量</strong>。实质上积分可以被视为一个<strong>求和计算</strong>的过程，例如求解下图以曲线作为边界的阴影区域面积：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/9.png"></p><p>已知等式 <span class="math inline">\(\frac{dy}{dx} =f(x)\)</span>，通过积分计算就可以得到 <span class="math inline">\(y\)</span>：</p><p><span class="math display">\[\frac{dy}{dx} = f(x) \implies \int dy = \int f(x)dx\xrightarrow{对等式两侧进行积分}y \pm C = \int f(x) dx \implies y = \int f(x) dx + C\]</span></p><p>最后推导出等式 <span class="math inline">\(\int dy = y \pmC\)</span>，通过逆运算可知任何 <span class="math inline">\(y \pmG\)</span> 形式的函数，求导之后均等于 <span class="math inline">\(y\)</span>。其中 <span class="math inline">\(C\)</span> 的值可正可负，习惯上采用等号左侧加<span class="math inline">\(C\)</span>的形式，这种形式的积分称为<strong>不定积分</strong>。例如已知 <span class="math inline">\(\frac{dy}{dx} =2\)</span>，可以通过如下推导过程求解得到 <span class="math inline">\(y\)</span>：</p><p><span class="math display">\[dy = 2dx \implies \int dy = \int 2dx \implies y = 2x + C\]</span></p><p>实际情况经常期望得到一个不包含常数的确定解，为了去掉常数项，就需要利用到边界条件。这里仍然以<span class="math inline">\(\frac{dy}{dx} = 2\)</span> 为例，如果只关注<span class="math inline">\(\frac{dy}{dx}\)</span> 在区间 <span class="math inline">\(1 \sim 5\)</span>范围内的值，就可以利用<strong>定积分</strong>来进行计算：</p><p><span class="math display">\[y = \int^{b}_{a} f(x) dx = F(x) {\vert}^b_a = F(b) - F(a)\]</span></p><p>上面公式当中的 <span class="math inline">\(F\)</span>代表不含积分常数的<strong>定积分</strong>，而 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 限定了 <span class="math inline">\(F\)</span> 当中 <span class="math inline">\(x\)</span>的取值区间，将已知条件代入方程可以得到：</p><p><span class="math display">\[y = \int^{5}_{1} 2dx = 2x {\vert}^5_1 = 2 \times 5 - 2 \times 1 = 8\]</span></p><p>对于更为复杂的函数，求解积分需要耗费较长时间推导其<strong>原函数</strong>。实际工作当中，更多会直接应用下面表格当中的<strong>积分公式</strong>进行分析讨论：</p><table><colgroup><col style="width: 27%"><col style="width: 22%"><col style="width: 27%"><col style="width: 22%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\int dx = x+ C\)</span></th><th style="text-align: center;"><span class="math inline">\(\int a f(x)dx = a \int f(x) dx\)</span></th><th style="text-align: center;"><span class="math inline">\(\int(du(x)\pm dv(x)) = \int du(x) \pm \int dv(x)\)</span></th><th style="text-align: center;"><span class="math inline">\(\int udv =uv - \int vdu\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\int u^n du= \frac{u^{n+1}}{u+1} + C \ (n \neq 1)\)</span></td><td style="text-align: center;"><span class="math inline">\(\int\frac{1}{u} du = \ln u + C\)</span></td><td style="text-align: center;"><span class="math inline">\(\int \ln xdx= x \ln x - x + C\)</span></td><td style="text-align: center;"><span class="math inline">\(\int sin xdx= -cos x + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\int \cosxdx = \sin x + C\)</span></td><td style="text-align: center;"><span class="math inline">\(\int x \sinxdx = \sin x - x \cos x + C\)</span></td><td style="text-align: center;"><span class="math inline">\(\int x \cosxdx = \cos x + x \sin x + C\)</span></td><td style="text-align: center;"><span class="math inline">\(\sin x \cosx = \frac{1}{2} \sin^2 x + C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\int e^u dx= e^u + C\)</span></td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td></tr></tbody></table><blockquote><p><strong>注意</strong>：上面表格当中的 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 分别表示 <strong><span class="math inline">\(x\)</span> 的函数</strong>。</p></blockquote><h3 id="复数">复数</h3><p>利用<strong>复数</strong>及其对应的<strong>算术运算法则</strong>来模拟与求解正弦电路相关的问题，可以避免复杂的微分方程计算过程。<strong>复数</strong><span class="math inline">\(z = a + ib\)</span>主要由<strong>实部</strong>和<strong>虚部</strong>两部分所共同组成：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/10.png"></p><p>上面公式当中的 <code>a</code>称为<strong>实部</strong>，<code>b</code>称为<strong>虚部</strong>，<code>i</code>称为<strong>虚数单位</strong>（<span class="math inline">\(i =\sqrt{-1}\)</span>）。电路分析当中，为了避免<strong>虚数单位</strong><code>i</code> 与<strong>电流符号</strong> <span class="math inline">\(i\)</span> 相互混淆，而改用 <code>j</code>来代替虚数单位<code>i</code>。除此之外，复数还可以在采用直角坐标系上的图像（下图左侧）来进行表示，其中<strong>横轴</strong>表示<strong>实部</strong><code>a</code>，而<strong>纵轴</strong>表示<strong>虚部</strong><code>b</code>（下图右侧），即复数的<strong>直角坐标系形式</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/11.png"></p><blockquote><p><strong>注意</strong>：可以将直角坐标系里的<strong>复数</strong>视为一个由<code>0</code> 指向 <code>P</code>点的<strong>矢量</strong>，对应的<strong>模值</strong>为 <span class="math inline">\(r = \sqrt{a^2 +b^2}\)</span>，其与<strong>正实轴</strong>之间的夹角 <span class="math inline">\(\theta = \arctan(\frac{b}{a})\)</span>。</p></blockquote><p>将复数用于电路分析，必须对其进行形式上的改变。将 <code>a</code>更换为 <span class="math inline">\(r \cdot \cos \theta\)</span>，而<code>b</code> 更换为 <span class="math inline">\(r \cdot \sin\theta\)</span>，进而得到 <span class="math inline">\(z = r \cdot \cos\theta + j \times r \cdot \sin\theta\)</span>，这就是复数的<strong>三角形式</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/12.png"></p><p>复数的三角形式满足 <span class="math inline">\(e^{j \theta} = \cos\theta + j \sin \theta\)</span> 的关系，首先分别对 <span class="math inline">\(e^{j \theta}\)</span>、<span class="math inline">\(\cos \theta\)</span>、<span class="math inline">\(j \sin \theta\)</span> 取幂级数，然后将 <span class="math inline">\(\cos \theta\)</span> 与 <span class="math inline">\(j \sin \theta\)</span>的幂级数相加，最后就可以证明其结果与 <span class="math inline">\(e^{j\theta}\)</span>的幂级数相等，从而就可以得到复数的<strong>指数形式</strong>：</p><p><span class="math display">\[z = r \cdot e^{j \theta}\]</span></p><p>上面的复数指数形式，还可以进一步简写为由<strong>矢量</strong> <span class="math inline">\(r\)</span> 与<strong>角度</strong> <span class="math inline">\(\theta\)</span>两部分组成的<strong>极坐标形式</strong>：</p><p><span class="math display">\[z = r \cdot \angle \theta\]</span></p><blockquote><p><strong>注意</strong>：复数的<strong>极坐标形式</strong>可以视为其<strong>指数形式</strong>的简写，相对而言，<strong>极坐标形式</strong>更为直观，计算起来也更加便捷。</p></blockquote><p>终上所述，一共获得了<strong>复数</strong>的四种基本表示形式（<code>标准形式</code>、<code>直角坐标系形式</code>、<code>三角形式</code>、<code>指数形式</code>），每一种形式在电路分析当中都具有相应的特殊用途：</p><p><span class="math display">\[\begin{aligned}复数的直角坐标系形式：&amp;z = a + ib \\复数的三角形式：&amp;z = r \cdot \cos \theta + j \times r \cdot \sin\theta \\复数的极坐标形式：&amp;z = r \cdot \angle \theta \\复数的指数形式：&amp;z = r \cdot e^{j \theta}\end{aligned}\]</span></p><p>下图直观的展示了复数在各种形式之间的转换关系：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/13.png"></p><p>如下的表格，比较全面的总结了复数在各种形式下的<strong>加</strong>、<strong>减</strong>、<strong>乘</strong>、<strong>除</strong>四则运算法则：</p><p><img src="/Electronics/Practical_Electronics/Chapter-1/14.png"></p><p>而接下来的表格，展示了复数在计算过程当中，一些经常被使用到的关系方程式：</p><table><colgroup><col style="width: 25%"><col style="width: 27%"><col style="width: 11%"><col style="width: 25%"><col style="width: 10%"></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(X(度) =\frac{180°}{\pi} X(弧度)\)</span></th><th style="text-align: center;"><span class="math inline">\(X(弧度) =\frac{\pi}{180°} X(度)\)</span></th><th style="text-align: center;"> </th><th style="text-align: center;"> </th><th style="text-align: center;"> </th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(j =\sqrt{-1}\)</span></td><td style="text-align: center;"><span class="math inline">\(j^2 =-1\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{j}= -j\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{A +jB} = \frac{A - jB}{A^2 + B^2}\)</span></td><td style="text-align: center;"> </td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{j(0°)} =1\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{j(90°)} =j\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{j(180°)}= -1\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{j(270°)}= -j\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{j(360°)}= 1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1 \angle 0°= 1\)</span></td><td style="text-align: center;"><span class="math inline">\(1 \angle 90°= j\)</span></td><td style="text-align: center;"><span class="math inline">\(1 \angle180° = -1\)</span></td><td style="text-align: center;"><span class="math inline">\(1 \angle270° = -j\)</span></td><td style="text-align: center;"><span class="math inline">\(1 \angle360° = 1\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(Z^2 = (re^{j\theta})^2 = r^2 e^{j2 \theta}\)</span></td><td style="text-align: center;"><span class="math inline">\(Z^2 = (r\angle \theta)^2 = r^2 \angle 2 \theta\)</span></td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td></tr></tbody></table><blockquote><p><strong>注意</strong>：如果需要在电路分析过程当中进行复数运算，那么可以直接套用上述公式简化计算量。</p></blockquote><p>▶【例题】应用复数的四则混合运算，求解下面复数的<strong>直角坐标形式</strong>与<strong>极坐标形式</strong>结果？</p><p><span class="math display">\[\frac{(2 + j5)+(3 - j10)}{(3 + j4)(2 + j8)}\]</span></p><p>◉【解】直接运用之前表格当中列出的关系式，就可以得到下面的推导过程：</p><p><span class="math display">\[\frac{(2 + j5)+(3 - j10)}{(3 + j4)(2 + j8)}\implies \frac{5 - j5}{(3 + j4)(2 + j8)}\implies \frac{7.07 \angle 45.0°}{(5 \angle 53.1°)(8.25 \angle 76.0°)}\implies \frac{7.07 \angle 45.0°}{41.25 \angle 129.1°}\implies 0.17 \angle - 84.1°\]</span></p><p>◉【解】上述步骤所获得的计算结果，可以按照题设要求转换为<strong>三角形式</strong>或者<strong>直角坐标形式</strong>：</p><p><span class="math display">\[0.17 \angle −84.1° = 0.17 \cos (−84.1°) + j0.17 \sin (−84.1°) = 0.017 −j0.17\]</span></p><blockquote><p><strong>注意</strong>：进行复数的<strong>除法</strong>或者<strong>乘法</strong>运算时，最佳实践是将复数转换为<strong>指数形式</strong>。而对于复数的<strong>加法</strong>与<strong>减法</strong>运算，最佳实践是将其转换为<strong>直角坐标系形式</strong>。</p></blockquote><p>形如等式 <span class="math inline">\(|Z| = \sqrt{(R_e Z)^2 + (I_mZ)^2}\)</span> 或者 <span class="math inline">\(arg(Z) =\arctan(\frac{I_m Z}{R_e Z}) = \tan^{-1} (\frac{I_m Z}{R_e Z})\)</span>表示的依然是一个复数，该等式当中的 <span class="math inline">\(|Z|\)</span>是复数的<strong>幅值</strong>或者<strong>模</strong>，<span class="math inline">\(I_m Z\)</span> 是复数的<strong>虚部</strong>，而<span class="math inline">\(arg(Z)\)</span> 表示的是 <span class="math inline">\(Z\)</span> 的<strong>幅角</strong>或者 <span class="math inline">\(\theta\)</span><strong>相位角</strong>。如果按照这个对应规则，那么对于复数 <span class="math inline">\(Z = 3 + j4\)</span> 而言：</p><p><span class="math display">\[\begin{cases}R_e Z = 3 \\I_m Z = 4 \\|Z| = \sqrt{(3)^2 + (4)^2} = 5 \\arg(Z) = \arctan(\frac{4}{3}) = 53.1°\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：电路分析过程当中，引入<strong>复数</strong>的概念，可以有效简化<strong>交流电路</strong>的分析计算过程。</p></blockquote><h2 id="电路基础">电路基础</h2><h3 id="电流">电流</h3><p><strong>电流</strong>是单位时间内通过某一横截面 <strong>A</strong>的总电荷，这里的横截面可以理解为导体上的一个薄片：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/1.png"></p><p>如果在 <span class="math inline">\(\Delta t\)</span>时间内，通过某一横截面的电荷量为 <span class="math inline">\(\DeltaQ\)</span>，那么就可以定义<strong>平均电流</strong> <span class="math inline">\(I_{ave}\)</span> 等于：</p><p><span class="math display">\[I_{ave} = \frac{\Delta Q}{\Delta t}\]</span></p><p>如果电流随着时间变化，那么可以定义 <span class="math inline">\(\Delta\rightarrow 0\)</span>时的电流值为<strong>瞬时电流</strong>，即瞬时电流是电荷通过某一横截面的变化率：</p><p><span class="math display">\[I = \lim_{\Delta \rightarrow 0} \frac{\Delta Q}{\Delta t} =\frac{dQ}{dt}\]</span></p><p>电流的单位称为<strong>安培</strong> <code>A</code>，其值等于<code>1C/s</code><strong>库伦每秒</strong>，除此之外，常用的单位还有<strong>毫安</strong>、<strong>微安</strong>、<strong>纳安</strong>：</p><p><span class="math display">\[\begin{aligned}1A &amp;= 1C/s \\1 mA &amp;= 10^{-3}A \\1 \mu A &amp;= 10^{-6}A \\1 nA &amp;= 10^{-9}A \\\end{aligned}\]</span></p><p><strong>电流</strong>是由导体内<strong>自由电子</strong>的定向移动而形成的，每个自由电子的电荷量为<span class="math inline">\(-1.602 \times 10^{-19}C\)</span>。由于导体当中的<strong>质子</strong>与<strong>电子</strong>数量相等符号相反，因而整体呈现电中性：</p><p><span class="math display">\[\begin{cases}Q_{electron} &amp;= -1.602 \times 10^{-19} C \\Q_{proton} &amp;= +1.602 \times 10^{-19} C\end{cases}\]</span></p><p>最早<strong>富兰克林</strong>（Franklin）将<strong>正电荷</strong>运动的方向定义为电流方向，后来<strong>汤姆逊</strong>（Thomson）纠正了这一观点，认为<strong>负电荷</strong>（自由电子）运动的方向才是电流的方向，但是无论哪种方向，对于电路的分析计算结果都不会产生实质性影响。</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/2.png"></p><h3 id="电压">电压</h3><p>电路两点之间存在<strong>电压</strong>才能够形成电流，导体两端的电压提供了推动导体当中自由电子运动的<strong>电动势</strong>（EMF，Electro-MotiveForce），电压有时候也被称为<strong>电势差</strong>或者<strong>电位</strong>，但是后者更偏向于相对位能的概念。</p><p>实质上，<strong>电压</strong>表示的是<strong>单位电荷</strong>在两点之间的<strong>位能差</strong>，是衡量电场力<strong>做功能力</strong>的物理量。如果两点之间的电压为<code>1V</code> 伏特，相当于将 <code>1C</code>库仑的电荷从一点移动到另外一点所需要做的功为 <code>1J</code> 焦耳：</p><p><span class="math display">\[电压 V = \frac{功率 U}{电荷量 q}\implies1 V 伏特 = \frac{1 J 焦耳}{1 C 库仑}\]</span></p><p>电子学当中，通常会使用<strong>功率</strong> <span class="math inline">\(P\)</span>（每秒钟为电路提供的能量，单位为<strong>瓦特</strong><code>W</code>）来定义电压的单位<strong>伏特</strong>：</p><p><span class="math display">\[功率 P = 电压 V \times 电流 I \implies 1 V 伏特 = \frac{1 W 瓦特}{1 A安培}\]</span></p><h3 id="电阻">电阻</h3><h4 id="欧姆定律">欧姆定律</h4><p><strong>欧姆定律</strong>是指物体两端的<strong>电阻</strong> <span class="math inline">\(R\)</span> 等于两端<strong>电压</strong> <span class="math inline">\(V\)</span> 与通过<strong>电流</strong> <span class="math inline">\(I\)</span> 之比，单位为<strong>欧姆</strong><code>Ω</code>，</p><p><span class="math display">\[电阻 R = \frac{电压 V}{电流 I} \implies 1 Ω 欧姆 = \frac{1 V 伏特}{1 A安培}\]</span></p><p>欧姆定律只适用于<strong>欧姆材料</strong>，即在所能承受的电压范围之内，该材料的电阻为一个<strong>常数</strong>。由于非欧姆材料的电阻不是常数，所以并不会遵循欧姆定律。</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/3.png"></p><p>通常情况下，欧姆定律被写作 <span class="math inline">\(V = I \timesR\)</span>的形式，即使用电阻与电流来定义电压。欧姆材料的<strong>电阻</strong><span class="math inline">\(R\)</span>与欧姆定律当中的<strong>电压</strong> <span class="math inline">\(V\)</span>无关。换而言之，就是不能使用<strong>电阻</strong>和<strong>电流</strong>来定义<strong>电压</strong>，而只能使用<strong>电压</strong>与<strong>电流</strong>来定义<strong>电阻</strong>。</p><h4 id="电阻率-电导率">电阻率 &amp; 电导率</h4><p><strong>电阻率</strong> <span class="math inline">\(\rho\)</span>反映了物体阻碍电流的能力，属于材料的固有特性，其单位为<strong>欧姆 <span class="math inline">\(\cdot\)</span> 米</strong>（<span class="math inline">\(Ω \cdot m\)</span>）</p><p><span class="math display">\[电阻率 \rho = 电阻 R \frac{横截面积 A}{长度 L}\]</span></p><p><strong>电导率</strong> <span class="math inline">\(\sigma\)</span>反映了物体通过电流的能力，同样也是材料的固有特性，其值等于电阻率的倒数，单位为<strong>西门子</strong><span class="math inline">\(S = (Ω \cdot m)^{-1}\)</span></p><p><span class="math display">\[电导率 \sigma = \frac{1}{电阻率 \rho}\]</span></p><p>下面的表格里，分别列举出了一些常见材料的<strong>电阻率</strong>与<strong>电导率</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/4.png"></p><blockquote><p><strong>注意</strong>：<strong>大部分金属的电导率会随着温度的升高而增大</strong>，这是由于温度升高会导致材料晶格当中原子的振动，从而阻碍导体内部电子的漂移运动。</p></blockquote><h3 id="欧姆热">欧姆热</h3><p>理想电阻的情况下，可以认为其全部功率都被转化为<strong>热能</strong>，将<strong>欧姆定律</strong><span class="math inline">\(I = \frac{V}{R}\)</span> 或者 <span class="math inline">\(V = IR\)</span> 代入<strong>功率</strong>的表达式<span class="math inline">\(P = VI\)</span>当中，就可以得到<strong>功率</strong> <span class="math inline">\(P\)</span>所消耗的热能，即<strong>欧姆热</strong>或者<strong>焦耳热</strong>：</p><p><span class="math display">\[\begin{aligned}功率 P = 电压 V \times 电流 I &amp;= 电压 V \times \frac{电压 V}{电阻 R}= \frac{V^2}{R} \\功率 P = 电压 V \times 电流 I &amp;= (电流 I \times 电阻 R) \times 电流I = I^2 \times R\end{aligned}\]</span></p><h3 id="awg-导线规格">AWG 导线规格</h3><p>导线的尺寸可以使用<strong>导线规格</strong>来进行表示，国际上经常采用<strong>美国导线规格</strong>（<strong>AWG</strong>，AmericanWireGauge）作为通用标准，该标准下<strong>较小的规格数目对应着较大直径的导线</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/5.png"></p><p>下面的表格列举了<strong>铜导线</strong>的常见 AWG 规格，其中单位<span class="math inline">\(1 mil 密尔 = 0.0254mm 毫米\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/6.png"></p><blockquote><p><strong>注意</strong>：<strong>圆密尔</strong> <code>CM</code>是一个<strong>面积</strong>单位，表示的是直径为 <code>1 mil</code>的圆面积。</p></blockquote><h3 id="接地">接地</h3><h4 id="接地分类">接地分类</h4><p>通常会将电路当中的一点定义为 <code>0V</code>参考点，并以此作为测量电路上其它各点电压的基准，该点通常被称为<strong>接地点</strong>或者<strong>电流返回端</strong>，采用下图符号进行表示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/7.png"></p><blockquote><p><strong>注意</strong>：物理上的<strong>接地</strong>，是指将导体埋入大地<span class="math inline">\(8 英尺 = 2.4384 米\)</span> 以上。</p></blockquote><p>除此之外，为避免发生混淆，可以采用含义更为明确的<strong>大地</strong>、<strong>框架底座接地</strong>(功率接地)、<strong>模拟数字接地</strong>、<strong>电压参考点</strong>符号：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/8.png"></p><blockquote><p><strong>注意</strong>：除了作为零电压参考点使用之外，接地系统的另外一个重要作用是为无线电设备产生的<strong>杂散射频</strong>电流提供一条流入大地的低阻通路，称为<strong>射频接地</strong>。</p></blockquote><h4 id="单点接地">单点接地</h4><p>较为复杂的 PCB设计当中，<strong>信号噪声产生的最普遍原因是由于没有良好的接地</strong>，如果将PCB线路当中的某些点作为接地点，那么接地线的内阻会导致这些接地点之间存在着电位差，从而形成糟糕的<strong>接地回路</strong>，导致电压读数产生误差。</p><p>下图给出了这个问题的说明，图中两个分离的底座接地，<span class="math inline">\(V_G\)</span>表示信号接地端与负载接地端之间的电压，<span class="math inline">\(V_S\)</span>为负载接地端与信号输出端之间的电压，此时会得到一个错误的电压 <span class="math inline">\(V_S + V_G\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/9.png"></p><p>解决该问题的方法是采用下图所示的<strong>单点接地</strong>，即为了避免在电路当中产生接地回路，而将所有电路的接地端都连接至一个点：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/10.png"></p><p>理论上这是一个很棒的方法，但是由于 PCB电路的接地端数量通常会比较多，实际布线操作很难将其全部连接至一个点，替代的方法是采用<strong>接地母线</strong>，也就是采用较宽的铜制导线，以便承受回流至电源的全部负载电流。由于接地母线可以按需进行延长，所以布线时进行接地操作会较为方便：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/11.png"></p><p>PCB电路板通常会划分为<strong>模拟电路</strong>和<strong>数字电路</strong>两个部分，通常情况下会将两者分别进行接地处理，最后再将其<strong>接地点</strong>连接起来进行<strong>单点接地</strong>，作用是防止电路当中的接地回路产生电流噪声。</p><ul><li><strong>数字电路</strong>当中，当信号发生改变时会在电路中产生冲击电流；</li><li><strong>模拟电路</strong>当中，当负载电流发生变化或者改变方向时也会产生冲击电流；</li></ul><p>上述两种情况下，如果电流发生改变，则根据欧姆定律，接地回路上的阻抗电压也将会随之改变，从而导致系统参考点（通常选择在电源引出端）相对于接地面的电压也发生变化。接地回路上的阻抗由<code>电阻</code>、<code>容抗</code>、<code>感抗</code>共同组成，其中<code>电阻</code>与<code>感抗</code>起到主要作用。</p><ul><li>如果接地回路当中经过的是<strong>直流电流</strong>，则<code>电阻</code>起到主要作用，并且产生一个直流偏置电压；</li><li>如果接地回路当中经过的是<strong>交流电流</strong>，则同时产生<code>电阻</code>、<code>感抗</code>、<code>容抗</code>，进而产生一个高频交流电压；</li></ul><p>上述两种情况下，局部电路的电压变化都会导致<strong>噪声</strong>的出现，而减少噪声的最好办法就是先将<strong>模拟接地</strong>和<strong>数字接地</strong>分开，最后再进行<strong>单接地点</strong>。</p><h3 id="串并联电路">串并联电路</h3><p>电路主要存在<strong>串联</strong>与<strong>并联</strong>两种基本连结方式，其中<strong>串联</strong>的负载具有<strong>分压</strong>的作用，而<strong>并联</strong>的负载具有<strong>分流</strong>的作用：</p><p><img src="/Electronics/Practical_Electronics/Chapter-2/12.png"></p><h2 id="静态电路理论">静态电路理论</h2><h3 id="电阻与欧姆定律">电阻与欧姆定律</h3><p><strong>电阻</strong>可以<strong>限制电路当中电流的流动</strong>，或者是<strong>在电路两端形成电压</strong>，主要分为<strong>固定电阻</strong>与<strong>可变电阻</strong>两大类型，其电路表示符号如下所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/1.png"></p><p>如果在一个电阻的两端添加直流电压，那么运用<strong>欧姆定律</strong>就可以计算出经过这个电阻的电流：</p><p><span class="math display">\[电压 V = 电流 I \times 电阻 R\]</span></p><p>如果要计算出该电阻<strong>欧姆热</strong>所消耗的功率，可以将欧姆定律代入<strong>功率</strong>的计算公式：</p><p><span class="math display">\[功率损耗 P = 电流 I \times 电压 V = \frac{电压 V^2}{电阻 R} = I^2 R\]</span></p><blockquote><p><strong>注意</strong>：设计电路的时候，电阻的实际功率不能超过其<strong>最大额定功率</strong>，否则会损坏电阻。典型的电阻器额定功率值有<code>1/8W</code>、<code>1/4W</code>、<code>1/2W</code>、<code>1W</code>。生产环境下，电阻的额定功率应当至少大于期望值的<strong>两倍以上</strong>。</p></blockquote><p>假设下图当中的电阻可以调节阻值，并且电源电压恒定为<code>5V</code>。此时，<strong>增大电阻</strong>就会导致<strong>电流</strong>与<strong>功率</strong>的减小；而当<strong>减小电阻</strong>时，<strong>电流</strong>与<strong>功率</strong>又会增加，所以<strong>选用阻值较小的电阻器时，必须适当提高电阻器的额定功率参数</strong>标准。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/2.png"></p><h3 id="电阻的并联">电阻的并联</h3><p>当多个电阻器进行并联时，每一个并电阻器上的<strong>电压</strong>相同，但是通过的<strong>电流</strong>会跟随<strong>阻值</strong>进行变化。<strong>并联电路的总电阻，小于各个并联电阻的阻值</strong>，并联电阻器的总电阻计算公式如下面所示：</p><p><span class="math display">\[R_{total} = \frac{1}{\frac{1}{R_1} + \frac{1}{R_2} + \frac{1}{R_3} +\frac{1}{R_4} + \frac{1}{R_5} + ...}\]</span></p><p>如果仅仅只有<strong>两个电阻</strong>并联在一起，则其总电阻的计算公式可以被简化为下面的形式：</p><p><span class="math display">\[R_{total} = \frac{R_1 \times R_2}{R_1 + R_2}\]</span></p><ol type="1"><li>根据<strong>基尔霍夫电流定律</strong>得到<strong>总电流</strong><span class="math inline">\(I_{total} = I_1 + I_2 + I_3 + ... +I_n\)</span>；</li><li>根据<strong>欧姆定律</strong>可以进一步得到 <span class="math inline">\(I_{total} = \frac{V_1}{R_1} + \frac{V_2}{R_2} +\frac{V_3}{R_3} + ... + \frac{V_n}{R_n}\)</span>；</li><li>由于并联电阻上的电压 <span class="math inline">\(V_n\)</span>都等于总电压 <span class="math inline">\(V_{total}\)</span>，代入以后得到 <span class="math inline">\(I_{total} = \frac{V_{total}}{R_1} +\frac{V_{total}}{R_2} + \frac{V_{total}}{R_3} + ... +\frac{V_{total}}{R_n}\)</span>；</li><li>提取<strong>公因数</strong> <span class="math inline">\(V_{total}\)</span> 进行化简 <span class="math inline">\(I_{total} = V_{total}(\frac{1}{R_1} +\frac{1}{R_2} + \frac{1}{R_3} + ... + \frac{1}{R_n})\)</span>；</li><li>继续将等式变换为<strong>欧姆定律</strong>的形式 <span class="math inline">\(\frac{1}{\frac{1}{R_1} + \frac{1}{R_2} +\frac{1}{R_3} + ... + \frac{1}{R_n}} =\frac{V_{total}}{I_{total}}\)</span></li><li>此时 <span class="math inline">\(\frac{1}{\frac{1}{R_1} +\frac{1}{R_2} + \frac{1}{R_3} + ... + \frac{1}{R_n}}\)</span>部分就是等效<strong>总电阻</strong> <span class="math inline">\(R_{total}\)</span> 的计算公式；</li></ol><h3 id="电阻的串联">电阻的串联</h3><p>当多个电阻器进行串联时，<strong>总电阻</strong>等于各个串联电阻之和，流经每一个串联电阻器的<strong>电流</strong>相同，而<strong>电压</strong>则跟随阻值进行变化，串联电阻器的总电阻<span class="math inline">\(R_{total}\)</span> 计算公式如下所示：</p><p><span class="math display">\[R_{total} = R_1 + R_2 + R_3 + R_4 + R_5 ... + R_n\]</span></p><ol type="1"><li>根据<strong>基尔霍夫电压定律</strong>得到总电压 <span class="math inline">\(V_{total} = V_1 + V_2 + V_3 + ... +V_n\)</span>；</li><li>由于经过每一个串联电阻器的电流 <span class="math inline">\(I\)</span>都相同，根据<strong>欧姆定律</strong>可以进一步得到 <span class="math inline">\(I \times R_{total} = I \cdot R_1 + I \cdot R_2 + I\cdot R_3 + ... + I \cdot R_n\)</span>；</li><li>消除等式两边的<strong>公因数</strong> <span class="math inline">\(I\)</span>，就能够得到等效<strong>总电阻</strong>的计算公式<span class="math inline">\(R_{total} = R_1 + R_2 + R_3 + ... +R_n\)</span>；</li></ol><blockquote><p><strong>注意</strong>：电阻上标记的<strong>最大額定功率</strong>不非电阻器实际消耗的功率。流过每一个串联电阻上经过的<strong>电流</strong>都相同，但是每一个串联电阻器上的<strong>电压</strong>会随阻值的不同而变化。</p></blockquote><h3 id="电阻分压电路">电阻分压电路</h3><p>下图是一个<strong>串联电阻分压电路</strong>，其中 <span class="math inline">\(V_{in}\)</span> 为输入电压，而 <span class="math inline">\(V_2\)</span> 为<strong>输出电压</strong> <span class="math inline">\(V_{out}\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/3.png"></p><p>可以看到，<strong>每一个串联电阻上的电压与其电阻值的大小成正比</strong>，上述电路对应的<strong>分压公式</strong>如下所示：</p><p><span class="math display">\[\begin{aligned}V_1 = \frac{R_1}{R_1 + R_2} \times V_{in} \\V_2 = \frac{R_2}{R_1 + R_2} \times V_{in} \\\end{aligned}\]</span></p><p><strong>10％规则</strong>是设计分压电路的时候，选择<strong>电阻</strong> <span class="math inline">\(R_1\)</span> 与 <span class="math inline">\(R_2\)</span>的一种标准方法，该方法综合考虑了<strong>负载的影响</strong>与<strong>负载损耗功率最小</strong>的问题。</p><ol type="1"><li>首先是选择 <span class="math inline">\(R_2\)</span>，使得 <span class="math inline">\(R_2\)</span> 上的电流 <span class="math inline">\(I_2\)</span> 为<strong>预期负载电流</strong>的<code>10％</code>，此时就称 <span class="math inline">\(R_2\)</span>为<strong>泄漏电阻</strong> <span class="math inline">\(R_{bleed}\)</span>，而 <span class="math inline">\(R_2\)</span> 上的电流称为<strong>泄漏电流</strong><span class="math inline">\(I_{bleed}\)</span>；</li><li>然后计算出通过电阻器的<strong>总电流</strong>，根据<strong>欧姆定律</strong>就可以计算得到电阻<span class="math inline">\(R_1\)</span> 的取值；</li></ol><p>▶【例题】下图是一个 <code>10V</code> 的电压源，如果要将一个额定电压为<code>3V</code>，额定电流为 <code>9.1mA</code>的设备连接到电源上，请为该电路的负载设计一个分压器？</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/4.png"></p><p>◉【解】根据题设条件，可以分别计算得到<strong>泄露电流</strong> <span class="math inline">\(I_{bleed}\)</span> 与<strong>泄露电阻</strong><span class="math inline">\(R_{bleed}\)</span>：</p><p><span class="math display">\[\begin{cases}I_{bleed} = I_2 = 9.1 mA \times 10\% = 0.91mA \\R_{bleed} = R_2 = 3V \times 0.0091A = 3197Ω\end{cases}\]</span></p><p>◉【解】考虑到真实电阻器的阻值带有误差，<span class="math inline">\(R_2\)</span> 需要选择一个阻值接近于上述计算值的<span class="math inline">\(3300Ω\)</span> 电阻器。接下来，确定电阻<span class="math inline">\(R_1\)</span>，使其输出电压维持在<code>3V</code>。首先计算出通过电阻器 <span class="math inline">\(I_1\)</span> 的总电流，然后根据欧姆定律计算出<span class="math inline">\(R_1\)</span>：</p><p><span class="math display">\[I_1 = I_2 + I_{load} = 0.91 mA + 9.1mA = 10.0mA = 0.01 A\impliesR_1 = \frac{10V - 3V}{0.01 A} = 700Ω\]</span></p><p>◉【解】最后，再来着手确定两个电阻器所需的额定功率：</p><p><span class="math display">\[\begin{cases}P_1 = \frac{V_1^2}{R_1} = \frac{(7V)^2}{700Ω} = 0.07W = 70mW \\P_{R2} = \frac{V_2^2}{R_2} = \frac{(3V)^2}{3300Ω} = 0.003W = 3mW\end{cases}\]</span></p><p>◉【解】根据上述推导过程就可以知道，选择<strong>额定功率</strong>小于<code>1/4W</code> 的电阻器就可以满足需求。</p><p>▶【例题】已知<strong>负载1</strong>（<code>75V</code>，<code>30mA</code>）、<strong>负载2</strong>（<code>50V</code>，<code>10mA</code>)、<strong>负载3</strong>（<code>25V</code>，<code>10mA</code>），请采用<code>10%</code>规则设计一个可以分别为三个负载提供功率的<strong>多项分压器</strong>？</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/5.png"></p><p>◉【解】运用 <code>10％</code>规则确定分压电阻的关键是计算<strong>泄漏电流</strong> <span class="math inline">\(I_{R4}\)</span>，其值等于<strong>总电流</strong>的<code>10%</code>，也就是总电流的 <code>0.1</code>倍，具体计算步骤如下所示：</p><p><span class="math display">\[I_{R4} = 0.1 \times (10mA + 10mA + 30mA) = 5mA\]</span></p><p>◉【解】接下来，再根据<strong>欧姆定律</strong>获得<strong>泄露电阻</strong><span class="math inline">\(R_4\)</span> 的阻值：</p><p><span class="math display">\[R_4 = \frac{(25V - 0V)}{0.005A  } = 5000Ω\]</span></p><p>◉【解】此时，流过<strong>电阻</strong> <span class="math inline">\(R_3\)</span> 的电流，等于经过<strong>电阻</strong><span class="math inline">\(R_4\)</span> 的电流与经过<strong>负载3</strong> 的电流之和：</p><p><span class="math display">\[I_{R3} = I_{R4} + I_{load3} = 5mA + 10mA = 15mA\]</span></p><p>◉【解】然后，应用欧姆定律和<strong>负载 2</strong> 与<strong>负载3</strong> 之间的电位差来求解<strong>电阻</strong> <span class="math inline">\(R_3\)</span>：</p><p><span class="math display">\[R_3 = \frac{(50V - 25V)}{0.015A} \approx 1667Ω\]</span></p><p>◉【解】类似的，根据经过<strong>电阻</strong> <span class="math inline">\(R_2\)</span>上的电流，运用欧姆定律，就可以求解得到<strong>电阻</strong> <span class="math inline">\(R_2\)</span>：</p><p><span class="math display">\[I_{R2} = I_{R3} + I_{load2} = 15mA + 10mA = 25mA\impliesR_2 = \frac{(75V - 50V)}{0.025A} = 1000Ω\]</span></p><p>◉【解】同样根据经过<strong>电阻</strong> <span class="math inline">\(R_1\)</span>上的电流，根据欧姆定律，还可以求解得到<strong>电阻</strong> <span class="math inline">\(R_1\)</span>：</p><p><span class="math display">\[I_{R1} = I_{R2} + I_{load1} = 25mA + 30mA = 55mA\impliesR_2 = \frac{(100V - 75V)}{0.055A} = 455Ω\]</span></p><blockquote><p><strong>注意</strong>：虽然<strong>分压器</strong>结构简单，但是不能随意调节参数。如果一个负载的<code>电阻</code>或者<code>电源电压</code>发生改变，那么所有负载的电压都会发生变化。相比较而言，采用基于运算放大器的<strong>电压调整器</strong>是更佳选择。</p></blockquote><h3 id="理想电压源">理想电压源</h3><p><strong>理想电压源</strong>是一个双端元件，其两个端子之间的电压保持着一个固定值。如果将一个可变的负载连接到一个理想电压源，那么无论负载的电阻值如何进行变化，理想电压源的电压始终保持不变，而根据<span class="math inline">\(I = \frac{V}{R}\)</span>，当电压 <span class="math inline">\(V\)</span> 固定时，电流 <span class="math inline">\(I\)</span> 随着电阻 <span class="math inline">\(R\)</span>的变化而变化。当电阻的阻值变为<strong>零</strong>时，理想电压源的电流就会变为<strong>无穷大</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/6.png"></p><p>现实世界并不存在能够提供无穷大电流的电源设备，如果直接用导线将理想电压源的两端连接起来，那么电路当中产生的电流将会致使导线熔化，为了避免出现类似的理论难题，必须定义一个由<code>理想电压源</code>与<code>电阻</code>串联组成的<strong>实际电压源</strong>，其提供的最大电流为一个有限值。其中的电阻作为<code>电源内阻</code>，表示电压源并非一个理想的导体，可以降低电压源两端的电压，具体降低的数值取决于电压源两端的<strong>电压</strong>与经过的<strong>电流</strong>（或者<strong>负载电阻</strong>的大小）。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/7.png"></p><p>上图的电路当中，将一个理想电压源的两端开路，此时由于电路没有形成回路，电源内阻上面没有电流经过，因而不会产生电压，电压源的端电压<span class="math inline">\(V_T\)</span> 等于理想电压源的电压 <span class="math inline">\(V_S\)</span>。当将一个负载电阻 <span class="math inline">\(R_{load}\)</span> 与电压源连接之后，此时电阻 <span class="math inline">\(R\)</span>与电源内阻串联。根据分压公式，电压源的端电压为 <span class="math inline">\(V_T = V_S \frac{R_{load}}{R_{load} +r_s}\)</span>，表明当负载电阻 <span class="math inline">\(R_{load}\)</span> 远远大于电源内阻时（约<code>1000</code> 倍以上），电源内阻 <span class="math inline">\(r_s\)</span> 的影响较小可以忽略。但是当负载电阻<span class="math inline">\(R_{load}\)</span>小于或者接近电源内阻时，就必须考虑到电源内阻的影响。</p><h3 id="理想电流源">理想电流源</h3><p>下面给出了电子学当中<strong>直流电流源</strong>的符号，它能够在任意时刻为负载提供一个恒定不变的电流<span class="math inline">\(I_S\)</span>，而不论负载电阻如何进行变化。这意味着为了保持电流源的电流恒定，理想电流源的端电压将会随着<strong>负载电阻</strong>的变化而变化。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/8.png"></p><p>通常情况下，<strong>实际电流源</strong>都具有一个非常大的并联内阻，这个内阻可以使得电流源的端电流减小，减小量取决于电流源的<strong>电流值</strong>与<strong>端电压</strong>（或<strong>负载电阻</strong>的大小）。当电流源的两端开路时，电流源的电流<span class="math inline">\(I_T\)</span>显然应该为零，但是如果在电流源两端接上负载电阻 <span class="math inline">\(R_{load}\)</span>，与电流源的内阻 <span class="math inline">\(r_s\)</span>组成并联电阻电路，运用<strong>并联电阻分流公式</strong>，就可以得到其端电流<span class="math inline">\(I_T = I_S \frac{r_s}{R_{load} +r_s}\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/9.png"></p><p>上式表明当负载电阻 <span class="math inline">\(R_{load}\)</span>小于电流源的内阻 <span class="math inline">\(r_s\)</span>时，流过内阻的电流将会非常小，通常可以忽略不计。但是当负载电阻 <span class="math inline">\(R_{load}\)</span> 大于或者接近电流源内阻 <span class="math inline">\(r_s\)</span> 的时候，计算时就必须考虑内阻 <span class="math inline">\(r_s\)</span>。</p><h3 id="电压源-电流源转换">电压源 &amp; 电流源转换</h3><p>一个电源既可以采用<strong>电流源</strong>表示，也可以采用<strong>电压源</strong>表示，本质上它们是相互等价的。两者之间进行相互转换时，首先保持<strong>电源内阻</strong>不变，然后应用欧姆定律将<strong>电压源</strong>的<code>电压</code>转换成<strong>电流源</strong>的<code>电流</code>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/10.png"></p><p>由于理想电流源的内阻是无穷大的，所以理想电流源的两端可以承受任意大小的电压（或者任意的负载电阻变化）。因而<strong>理想电流源</strong>可以采用一个具有极高电压<span class="math inline">\(V\)</span>的<strong>电压源</strong>与一个较大的<strong>电阻</strong> <span class="math inline">\(R\)</span>的串联组合，来近似的进行表示。如果负载电阻远远小于电阻 <span class="math inline">\(R\)</span>，那么这个近似模型提供给任意负载的电流为<span class="math inline">\(\frac{V}{R}\)</span>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/11.png"></p><p>例如上图当中的电路由一个 <code>1kV</code> 的电压源与一个<code>1MΩ</code> 的内阻串联组成，当负载电压保持在 <span class="math inline">\(0V \sim 10V\)</span> 之间时（<span class="math inline">\(0&lt;R_{load}&lt;10kΩ\)</span>），电路当中的电流将会维持在<code>1mA</code>，而精度在 <code>1％</code>以内。实际上，即使负载电阻发生了变化，由于电压源的内阻远远大于负载电阻，电流也会保持不变<span class="math inline">\(I = \frac{1000V}{1\ 000\ 000Ω  + 100\000Ω}\)</span>。由于 <span class="math inline">\(1\ 000\ 000Ω\)</span>的阻值较大，因而可以忽略负载电阻 <span class="math inline">\(R_{load}\)</span>。</p><h3 id="电池的串并联">电池的串并联</h3><p><strong>电池串联</strong>之后会<strong>增大电压</strong>，<strong>输出电压</strong>等于每一节电池上的电压之和，<strong>输出电流</strong>等于每一节电池上经过的电流，输出<strong>总功率</strong>为<span class="math inline">\(P = \frac{(n \timesV_{battery})^2}{R_{load}}\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/12.png"></p><p><strong>电池并联</strong>之后会<strong>增大电流</strong>，<strong>输出电压</strong>等于每一节电池两端的电压，<strong>输出电流</strong>等于每一节电池上经过的电流之和，输出<strong>总功率</strong>为<span class="math inline">\(P =\frac{V_{battery}^2}{R_{load}}\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/13.png"></p><h3 id="基尔霍夫定律">基尔霍夫定律</h3><p><strong>基尔霍夫定律</strong>给出了分析电路的最普遍的方法，该定律不仅适用于<strong>线性电路</strong>（含有电阻、电感、电容元件），同样也适用于<strong>非线性电路</strong>（含有二极管、三极管等元件），基尔霍夫定律主要包括有如下两个<strong>子定律</strong>：</p><ol type="1"><li><strong>基尔霍夫电压定律（回路定律）</strong>：电路当中沿着任意一个<strong>回路</strong>的所有<strong>电压</strong>的<strong>代数和</strong>为<strong>零</strong>：<span class="math display">\[\sum_{close\ path} \Delta V = V_1 + V_2 + V_3 + ... + V_n\]</span></li><li><strong>基尔霍夫电流定律（节点定律）</strong>：<strong>流入</strong>一个节点的所有<strong>电流之和</strong>等于<strong>流出</strong>该节点的所有<strong>电流之和</strong>：<span class="math display">\[\sum \Delta I_{in} = \sum \Delta I_{out}\]</span></li></ol><h3 id="叠加原理">叠加原理</h3><p><strong>叠加原理</strong>适用于分析含有多个<strong>电源</strong>的线性电路，其内容是指<strong>线性电路</strong>任意一个支路上的<strong>电流</strong>，等于电路当中<strong>每一个电源单独作用</strong>时（其余电源置零，<strong>电压源短路，电流源开路</strong>）在该支路产生的<strong>电流之和</strong>。</p><p>例如下图左侧电路包含有<code>两个电阻</code>、一个<code>电压源</code>、一个<code>电流源</code>，应用叠加原理可以将其转换为后面两种形式：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/14.png"></p><p>首先，把<strong>电流源置零</strong>，将电流源从电路里移除掉，也就是将<strong>电流源</strong><span class="math inline">\(I_B\)</span> 的两个端子断开：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/15.png"></p><p>此时，上图当中流过电阻的电流，仅会由<strong>电压源</strong> <span class="math inline">\(V_A\)</span> 产生，其值等于电压 <span class="math inline">\(V_A\)</span> 除以等效电阻：</p><p><span class="math display">\[I_{21} = \frac{V_A}{R_1 + R_2}\]</span></p><p>然后，将<strong>电压源置零</strong>，直接通过导线让电压源两端短路，使得电路成为一个<strong>分流器</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/16.png"></p><p>此时，<strong>电流源</strong>在电阻 <span class="math inline">\(R_2\)</span> 两端产生的电流 <span class="math inline">\(I_{22}\)</span> 等于：</p><p><span class="math display">\[I_{22} = \frac{I_B R_1}{R_1 + R_2}\]</span></p><p>最后，运用叠加原理，将电流 <span class="math inline">\(I_{21}\)</span> 与 <span class="math inline">\(I_{22}\)</span> 相加，就可以得到支路 2上所经过电流 <span class="math inline">\(I_2\)</span> 的值：</p><p><span class="math display">\[I_2 = I_{21} + I_{22} = \frac{V_A - I_B R_1}{R_1 + R_2}\]</span></p><blockquote><p><strong>注意</strong>：叠加原理是分析<strong>线性电路</strong>的一种重要方法，也是<strong>戴维南定理</strong>和<strong>诺顿定理</strong>成立的基础，这两者在电路分析当中相比叠加原理更为实用，实际电路分析当中较少直接应用到叠加原理。</p></blockquote><h3 id="戴维南定理">戴维南定理</h3><p>如果只关注电路当中两个端子之间所连接支路的参数，那么可以将这条支路从复杂电路当中断开，并且把剩余部分电路视为拥有两个端子的<strong>线性二端网络</strong>，然后采用<strong>一个电压源与一个电阻的串联</strong>支路来代替，这种电路分析方法就称为<strong>戴维南定理</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/17.png"></p><p>串联支路上的电压源称为<strong>戴维南等效电压</strong> <span class="math inline">\(V_{THEV}\)</span>，电阻称为<strong>戴维南等效电阻</strong><span class="math inline">\(R_{THEV}\)</span>，而整个串联支路称为<strong>戴维南等效电路</strong>。运用这个简单的等效电路，再结合欧姆定律，就可以计算出其所连接电路上的<strong>负载电流</strong><span class="math inline">\(I = \frac{V_{THEV}}{R_{THEV} +R_{LOAD}}\)</span>。</p><p>接下来，运用戴维南定理来求解下图左上角的<strong>分压电路</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/18.png"></p><ol type="1"><li>首先，去掉<strong>负载</strong> <span class="math inline">\(R_3\)</span>，使得电路上的 A 与 B 两端断开，</li><li>然后，应用欧姆定律或者分压公式求解出<strong>戴维南等效电压</strong><span class="math inline">\(V_{THEV}\)</span>，也就是 <code>A</code> 与<code>B</code> 两端的开路电压；</li><li>接下来，计算 <code>A</code> 与 <code>B</code>两端的<strong>戴维南等效电阻</strong> <span class="math inline">\(R_{THEV}\)</span>，把<strong>直流电源</strong><span class="math inline">\(V_{BAT}\)</span> 短路，计算或者测量<code>A</code> 与 <code>B</code> 两端的等效电阻 <span class="math inline">\(R_{THEV}\)</span>，即电阻 <span class="math inline">\(R_1\)</span> 与电阻 <span class="math inline">\(R_2\)</span> 的并联等效电阻；</li><li>最后，就可以得到使用 <span class="math inline">\(V_{THEV}\)</span>与 <span class="math inline">\(R_{THEV}\)</span>串联表示的<strong>戴维南等效电路</strong>，此时负载上的电压 <span class="math inline">\(V_3\)</span> 与电流 <span class="math inline">\(I_3\)</span> 分别为：</li></ol><p><span class="math display">\[\begin{cases}V_3 = \frac{R_3}{R_3 + R_{THEV}} \times V_{THEV} = \frac{2000Ω}{2800Ω}\times 8V = 5.7V \\I_3 = \frac{V_{THEV}}{R_3 + R_{THEV})} = \frac{8V}{2800Ω} = 0.003A\end{cases}\]</span></p><h3 id="诺顿定理">诺顿定理</h3><p>类似于戴维南定理，<strong>诺顿定理</strong>也是通过一个等效电路来代替复杂的二端网络，而不同之处在于<strong>诺顿等效电路</strong>是由<strong>一个电流源与一个电阻的并联</strong>所组成。其中，由于<strong>诺顿等效电阻</strong>的值与<strong>戴维南等效电阻</strong>恰好相等，因而只需要计算出电流源的<strong>诺顿等效电流</strong><span class="math inline">\(I_{NORTON}\)</span> 即可。</p><p>接下来，对于前面采用戴维南定理分析的<strong>分压电路</strong>，这里改用诺顿定理来进行分析，其中<strong>诺顿电流</strong><span class="math inline">\(I_{NORTON}\)</span> 就是节点 <code>A</code>与 <code>B</code> 之间的<strong>短路电流</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-3/19.png"></p><ol type="1"><li>首先，去掉负载 <span class="math inline">\(R_3\)</span>，将<code>A</code> 与 <code>B</code> 的两端短路，此时电阻 <span class="math inline">\(R_2\)</span>被短路没有电流经过，根据欧姆定律可以得到<strong>诺顿等效电流</strong>：<span class="math display">\[I_{NORTON} = \frac{V_{BAT}}{R_1} = \frac{10V}{1000Ω} = 0.01A\]</span></li><li>然后，计算<strong>诺顿等效电阻</strong>，由于诺顿等效电阻与维南等效电阻相等，这里直接使用之前计算得到的<strong>戴维南等效电阻</strong><span class="math inline">\(R_{THEV} = 800Ω\)</span>；</li><li>最后，得到了<strong>诺顿等效电路</strong>，把 <span class="math inline">\(R_3\)</span>重新连接到等效电路，运用欧姆定律与分流公式就可以求解出经过 <span class="math inline">\(R_3\)</span> 的电流：</li></ol><p><span class="math display">\[I_3 = \frac{R_{THEV}}{R_{THEV} + R_3} \times I_{NORTON} =\frac{800Ω}{2800Ω} \times 0.01A = 0.003A\]</span></p><blockquote><p><strong>注意</strong>：<strong>诺顿定理</strong>对应的是<strong>电流源</strong>，<strong>戴维南定理</strong>对应的是<strong>电压源</strong>，两者在本质上依然是<strong>叠加原理</strong>。<strong>诺顿等效电路</strong>与<strong>戴维南等效电路</strong>可以相互转换，它们转换之后的等效电阻都相同；戴维南等效电路中的<strong>等效电阻</strong>与<strong>等效电压源串联</strong>；而诺顿等效电路中的<strong>等效电阻</strong>与<strong>等效电流源</strong>并联；戴维南等效电路的电压等于诺顿等效电路<strong>空载时</strong>等效电阻上的电压。而诺顿等效电源的电流等于戴维南等效电源的<strong>短路电流</strong>。</p></blockquote><h2 id="动态电路理论">动态电路理论</h2><h3 id="交流-直流">交流 &amp; 直流</h3><p><strong>直流（DC）</strong>：<code>电流</code>或者<code>电压</code>的<strong>大小</strong>、<strong>方向</strong>都不会发生变化；</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/1.png"></p><p><strong>交流（AC）</strong>：<code>电流</code>或者<code>电压</code>的<strong>大小</strong>、<strong>方向</strong>均呈周期性变化；</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/2.png"></p><p><strong>脉动直流（PulseDC）</strong>：<code>电流</code>或者<code>电压</code>的<strong>大小变化</strong>，而<strong>方向不发生改变</strong>，可以将其视为<strong>交流</strong>与<strong>直流</strong>的叠加；</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/3.png"></p><h3 id="交流电的产生">交流电的产生</h3><p>交流发电机利用<strong>电磁感应原理</strong>可以产生<strong>正弦交流信号</strong>，下面示意图展示了一个由<strong>磁体</strong>和<strong>线圈</strong>构成的简单交流发电机，<strong>线圈</strong>放置在<strong>磁体</strong>的<code>N</code> 极与 <code>S</code>极之间，可以围绕轴心进行旋转。伴随线圈在磁场当中的旋转，通过线圈的<strong>磁通量</strong>不断发生变化，线圈当中的电荷由于受到磁场力而发生运动，从而在线圈两端形成<strong>感应电压</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/4.png"></p><p>通过线圈的<strong>磁通量</strong> <span class="math inline">\(\varPhi\)</span>是线圈与磁场方向<strong>夹角</strong> <span class="math inline">\(\theta\)</span> 的函数，而感应电压是以 <span class="math inline">\(\omega\)</span>作为<strong>角频率</strong>（<code>rad/s</code>，弧度每秒）的正弦量。</p><h3 id="交流与直流的叠加">交流与直流的叠加</h3><p>下图是两个<strong>幅值</strong>相同，而且<strong>频率</strong>相近的交流信号，以及将它们串联之后得到的合成波形；注意两个交流信号的<strong>正向峰值点</strong>在合成之后，将会得到更高的<strong>峰值点</strong>，这就是所谓的<strong>拍现象</strong>，<strong>拍频率</strong>等于<span class="math inline">\(f_2 - f_1 = 500Hz\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/5.png"></p><p>下图是两个<strong>频率</strong>与<strong>幅值</strong>相差较大的交流信号，以及使它们串联之后得到的合成波形，可以发现一个波<strong>驮载</strong>在另外一个波上面：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/6.png"></p><blockquote><p><strong>注意</strong>：把两个<strong>幅值</strong>与<strong>相位</strong>不同，但是<strong>频率</strong>相同的正弦波合成之后，得到的仍然是<strong>正弦波</strong>，这个特点在交流电路分析当中尤为重要。</p></blockquote><h3 id="其它波形">其它波形</h3><p>利用<strong>傅里叶变换</strong>，通过一系列正弦波的叠加，就可以获得任意的周期性波形：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/7.png"></p><p>一个<strong>理想的正弦电压源</strong>，无论其负载如何，总是可以提供所需的<strong>电流</strong>并且维持两端的<strong>电压</strong>。而一个<strong>理想的正弦电流源</strong>，无论负载如何，都能够提供所需的<strong>电压</strong>并维持其输出<strong>电流</strong>。除此之外，还可以建立用于产生<strong>方波</strong>信号的<strong>时钟源</strong>。下图从左至右，分别展示了<strong>交流电压源</strong>、<strong>交流电流源</strong>、<strong>时钟源</strong>的符号：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/8.png"></p><h3 id="交流信号三要素">交流信号三要素</h3><p>交流<code>电压</code>或者<code>电流</code>信号的完整描述，需要使用<strong>幅值</strong>、<strong>频率</strong>、<strong>相位</strong>三要素。</p><h4 id="幅值">幅值</h4><p>下图展示了一个正弦<code>电压</code>或者<code>电流</code>的<strong>幅值</strong>，与一个<strong>逆时针旋转圆周</strong>的对应关系。<code>电压</code>、<code>电流</code>的幅值随着圆周上与<span class="math inline">\(0°\)</span>线之间的<strong>夹角</strong>进行正弦变化，例如 <span class="math inline">\(\sin 90°\)</span> 为<code>1</code>，对应<strong>正半波</strong>的最大值；而 <span class="math inline">\(\sin 270°\)</span> 为<code>-1</code>，对应<strong>负半波</strong>的最大值；而 <span class="math inline">\(\sin 45°\)</span> 为<code>0.707</code>，对应着<strong>最大值</strong>的 <code>0.707</code>倍：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/9.png"></p><h4 id="频率-周期">频率 &amp; 周期</h4><p>持续转动的<strong>发电机</strong>可以产生正弦变化的<code>电压</code>或者<code>电流</code>，随着时间的不断推移，正弦波形也会不断的循环。在循环的波形上任意选取一点（例如<strong>正峰值</strong>位置）作为标记点，则每秒钟<code>电流</code>或者<code>电压</code>到达该标记点的次数，就称为交流电的<strong>频率</strong>。换而言之，频率表示的是<strong>电信号</strong>循环的速率，其单位为<strong>赫兹</strong><code>Hz</code>。而每次循环所持续的时间称为<strong>周期</strong>，周期在数值上等于<strong>频率的倒数</strong>：</p><p><span class="math display">\[\begin{cases}频率f(Hz) = \frac{1}{周期T(s)} \implies f = \frac{1}{T} \\周期T(s) = \frac{1}{频率f(Hz)} \implies T = \frac{1}{f}\end{cases}\]</span></p><p>例如 <code>60Hz</code> 交变电流信号的<strong>周期</strong>为 <span class="math inline">\(T = \frac{1}{60Hz} = 0.0167S\)</span>，而<code>2ns</code> 周期交变电压信号的<strong>频率</strong>为 <span class="math inline">\(f = \frac{1}{2 \times 10^{-9}(s)} =500MHz\)</span>。</p><h4 id="相位">相位</h4><p>绘制下图所示的<code>电压</code>、<code>电流</code>正弦曲线时，通常以<code>0°</code> 作为计时起点，即信号正半周的起始点，而正向峰值则出现在<code>90°</code> 位置。换而言之，相对于 <code>0°</code>起始点，交流峰值所处的<strong>相位</strong>为 <code>90°</code>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/10.png"></p><blockquote><p><strong>注意</strong>：一个交流信号的<strong>周期</strong>被划分为<code>360°</code>，并以此作为<strong>时间</strong>与<strong>相位</strong>的计量单位。</p></blockquote><p><strong>相位</strong>可以用于比较<strong>频率</strong>相同的交流信号，例如下图所示的正弦波<strong>A</strong> 先经过 <code>0°</code> 点，而正弦波<strong>B</strong> 后经过 <code>0°</code>点，两个波形之间存在着<strong>相位差</strong>。图中 <strong>B</strong>滞后于 <strong>A</strong> 有 <code>45°</code>，或者说 <strong>A</strong>超前于 <strong>B</strong> 有 <code>45°</code>。如果正弦波<strong>A</strong> 和 <strong>B</strong>出现在相同的电路当中，两者叠加之后合成的波形相位将会介于<strong>A</strong> 与 <strong>B</strong>的相位之间。而对于同频率的正弦波而言，叠加之后产生的合成波形<strong>频率</strong>相同，而<strong>幅值</strong>与<strong>相位</strong>将会发生改变：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/11.png"></p><blockquote><p><strong>注意</strong>：两个同频率正弦波起始点不同，它们之间的相位差可以采用<strong>弧度</strong>或<strong>角度</strong>进行度量，上图当中<strong>B</strong> 的起始点比 <strong>A</strong> 滞后 <code>1/8</code>周期，即 <strong>B</strong> 滞后于 <strong>A</strong> 有<code>45°</code>。</p></blockquote><p>下图所示的是一种<strong>相位差</strong>的<strong>特殊情况</strong>，其中<strong>B</strong> 滞后于 <strong>A</strong> 有 <code>90°</code>，也就是<strong>B</strong> 恰好落后于 <strong>A</strong> 有 <code>1/4</code>周期，即波形经过 <code>0°</code>点时，另一个波形恰好到达<strong>峰值</strong>的位置：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/12.png"></p><p>下图所示的是另外一种<strong>相位差</strong>的<strong>特殊情况</strong>，其中<strong>A</strong> 与 <strong>B</strong> 相位差为<code>180°</code>，因而当 <strong>A</strong>波形为<strong>负</strong>的时候，<strong>B</strong>波形为<strong>正</strong>，反之亦然。当在同一个电路当中，添加这样两个<strong>幅值</strong>相同的<code>电压</code>、<code>电流</code>信号时，将会导致它们相互抵消：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/13.png"></p><h3 id="均方根有效值">均方根有效值</h3><p>如果向<strong>电阻</strong>的两端添加交流电压，则通过电阻的<code>电流</code>将会与<code>交变电压</code>的相位一致，根据<code>交变电压</code>与<code>电阻</code>的值，就可以基于<strong>欧姆定律</strong>计算出<code>交变电流</code>。例如信号发生器所产生正弦波的计算表达式为：</p><p><span class="math display">\[V(t) = V_P \sin(2\pi \times f \times t)\]</span></p><p>上面等式当中的 <span class="math inline">\(V_P\)</span>是<strong>正弦电压峰值</strong>、<span class="math inline">\(f\)</span>为<strong>频率</strong>、<span class="math inline">\(t\)</span>为<strong>时间</strong>，利<strong>用欧姆定理</strong>与<strong>功率定理</strong>可以得到如下表达式：</p><p><span class="math display">\[I(t) = \frac{V(t)}{R} = \frac{V_P}{R} \sin (2\pi \times f \times t)\]</span></p><p>将上述的 <span class="math inline">\(V(t)\)</span> 与 <span class="math inline">\(I(t)\)</span>的波形，绘制在相同的坐标系当中。此时<code>电流</code>与<code>电压</code>的<strong>相位</strong>一致，即<code>电流</code>伴随着<code>电压</code>同时增大：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/14.png"></p><p>可以看到，当交流电源两端接入<strong>纯电阻负载</strong>时，电压与电流处于相同的<strong>相位</strong>。如果负载不是纯电阻负载（例如<strong>电容</strong>、<strong>电感</strong>），那么情况就将会完全不同（后续章节会进行介绍）。求解正弦信号下<strong>电阻</strong>所消耗的功率，可以将<strong>正弦电压</strong>的表达式直接代入<strong>欧姆定律</strong>，从而得到<strong>瞬时功率</strong>的表达式：</p><p><span class="math display">\[P(t) = \frac{V(t)^2}{R} = \frac{V_P^2}{R} \sin(2 \pi \times f \times t)\]</span></p><p>从数学角度来看，<code>电压</code>、<code>电流</code>与<code>功率</code>的瞬时表达式并不复杂，只需要将具体时间<span class="math inline">\(t = 1.3S\)</span>代入即可求解出实际值。但是仅获得某一具体时刻的<code>电流</code>、<code>电压</code>、<code>功率</code>意义不大，还必须知道计时的起点。实际应用当中，这些瞬时值很难获取。最有效的方法是采用<strong>平均值</strong>代替<strong>瞬时值</strong>，而且运用平均值计算<strong>有功功率</strong>损耗可以不涉及正弦函数。然而正弦波在一个周期当中的<strong>正</strong>、<strong>负</strong>波形会相互抵消，导致<code>电压</code>、<code>电流</code>的平均值为<strong>零</strong>。所以对于<strong>功率</strong>而言，<strong>正半波</strong>与<strong>负半波</strong>都在进行能量的传递。因而必须找到一个能够代替<strong>平均值</strong>的参数，而这个参数正是<strong>均方根值</strong>（<strong>RMS</strong>，RootMeanSquare），这个值可以通过对<code>交变电压</code>、<code>交变电流</code>的<strong>瞬时值</strong>进行<strong>平方</strong>，然后获取其在一个周期当中的<strong>平均值</strong>，再对这个值进行<strong>开平方根</strong>来获得。</p><p>均方根值 <strong>RMS</strong>也称为<strong>有效值</strong>，其实质是<code>交流电压/电流</code>与<code>直流电压/电流</code>所消耗热能的等效，即<strong>交流电的均方根值等于相同电阻元件消耗交/直流功率，产生同等热量时刻的值</strong>。根据上述原理，电阻在交流峰值时消耗的功率是直流时消耗功率的两倍，也就是说，<strong>平均交流功率</strong>是<strong>交流峰值功率</strong>的<span class="math inline">\(\frac{1}{2}\)</span>。</p><p><span class="math display">\[平均功率 P_{ave} = \frac{峰值功率 P_{peak}}{2}\]</span></p><p>假设<strong>正弦电压</strong> <span class="math inline">\(V(t) = V_P\sin(2 \pi \times f \times t)\)</span>、<strong>正弦电流</strong> <span class="math inline">\(I(t) = I_P \sin(2 \pi \times f \timest)\)</span>，则它们的 <strong>RMS</strong>有效值表达式如下方程所示：</p><p><span class="math display">\[\begin{cases}V_{RMS} = \sqrt{\frac{1}{T} \int_0^T V(t)^2 dt} = \frac{1}{\sqrt{2}}\times V_P = 0.707 \times V_P \\I_{RMS} = \sqrt{\frac{1}{T} \int_0^T I(t)^2 dt} = \frac{1}{\sqrt{2}}\times I_P = 0.707 \times I_P\end{cases}\]</span></p><p>上述的推导过程表明，<code>电压</code>与<code>电流</code>的<strong>RMS</strong>值只与<code>电压</code>或者<code>电流</code>的<strong>峰值</strong>有关，而与<strong>时间</strong>和<strong>频率</strong>无关，通过简单的计算可以得到如下换算关系：</p><p><span class="math display">\[\begin{cases}V_{RMS} = \frac{V_P}{\sqrt{2}} \approx \frac{V_P}{1.414} \approx 0.707\times V_P \implies V_P \approx V_{RMS} \times 1.414 \\I_{RMS} = \frac{I_P}{\sqrt{2}} \approx \frac{I_P}{1.414} \approx 0.707\times I_P \implies I_P \approx I_{RMS} \times 1.414\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：美国家庭用电标准为<code>60Hz，1VAC</code>，欧洲国家则普遍采用<code>50Hz，2VAC</code>，单位 <strong>VAC</strong> 表示该电压值属于<strong>RMS 均方根有效值</strong>。</p></blockquote><p>把<code>电压</code>与<code>电流</code>的 <strong>RMS</strong>有效值代人欧姆定律，就可以得到<strong>交流欧姆定律</strong>：</p><p><span class="math display">\[V_{RMS} = I_{RMS} \times R\]</span></p><p>同样的，把<code>电压</code>与<code>电流</code>的 <strong>RMS</strong>有效值代入<strong>功率定理</strong>，就可以得到<strong>交流功率定理</strong>（此处的功率是指<strong>有功功率</strong>）：</p><p><span class="math display">\[P = I_{RMS} \times V_{RMS} = \frac{V_{RMS}^2}{R} = I_{RMS}^2 R\]</span></p><blockquote><p><strong>注意</strong>：上述公式只能应用于不包含<code>电容</code>与<code>电感</code>的<strong>纯电阻电路</strong>当中。</p></blockquote><p><img src="/Electronics/Practical_Electronics/Chapter-4/15.png"></p><p>下面的表格，展示了上图<strong>电压</strong>与<strong>电流</strong>的<code>均方根有效值</code>、<code>峰值</code>、<code>峰峰值</code>、<code>半波平均值</code>之间的关系，掌握它们之间的换算关系尤为重要：</p><table><colgroup><col style="width: 17%"><col style="width: 17%"><col style="width: 64%"></colgroup><thead><tr class="header"><th style="text-align: center;">待转换类型</th><th style="text-align: center;">结果类型</th><th style="text-align: center;">换算因数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><strong>峰峰值</strong></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><strong>平均值</strong> ★</td><td style="text-align: center;"><span class="math inline">\(\frac{2}{2\pi}\)</span> 或者 0.6366</td></tr><tr class="odd"><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\sqrt{2}}\)</span> 或者 0.7071</td></tr><tr class="even"><td style="text-align: center;"><strong>峰峰值</strong></td><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><span class="math inline">\(0.5\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>峰峰值</strong></td><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{2\sqrt{2}}\)</span> 或者 0.35355</td></tr><tr class="even"><td style="text-align: center;"><strong>平均值</strong> ★</td><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><span class="math inline">\(\frac{\pi}{2}\)</span> 或者 1.5708</td></tr><tr class="odd"><td style="text-align: center;"><strong>平均值</strong> ★</td><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><span class="math inline">\(\frac{\pi}{2\times \sqrt{2}}\)</span> 或者 1.1107</td></tr><tr class="even"><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><strong>峰值</strong></td><td style="text-align: center;"><span class="math inline">\(\sqrt{2}\)</span> 或者 1.4142</td></tr><tr class="odd"><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><strong>平均值</strong> ★</td><td style="text-align: center;"><span class="math inline">\(\frac{2\times \sqrt{2}}{\pi}\)</span> 或者 0.9003</td></tr><tr class="even"><td style="text-align: center;"><strong>有效值</strong></td><td style="text-align: center;"><strong>峰峰值</strong></td><td style="text-align: center;"><span class="math inline">\(2 \times\sqrt{2}\)</span> 或者 2.828</td></tr></tbody></table><blockquote><p><strong>注意</strong>：上面表格当中标注有 ★符号的，表示的是半个周期内的平均值。</p></blockquote><p><img src="/Electronics/Practical_Electronics/Chapter-4/16.png"></p><p>下面的表格，展示了上图所示<strong>正弦波</strong>、<strong>方波</strong>、<strong>三角波/锯齿波</strong>的<code>半波平均值</code>、<code>峰值</code>、<code>峰峰值</code>、<code>有效值</code>之间的换算关系：</p><table><thead><tr class="header"><th style="text-align: center;">波形</th><th style="text-align: center;">半波平均值</th><th style="text-align: center;">有效值</th><th style="text-align: center;">峰值</th><th style="text-align: center;">峰峰值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>正弦波</strong></td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.11</td><td style="text-align: center;">1.567</td><td style="text-align: center;">3.14</td></tr><tr class="even"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.90</td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.414</td><td style="text-align: center;">2.828</td></tr><tr class="odd"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.637</td><td style="text-align: center;">0.707</td><td style="text-align: center;">1.00</td><td style="text-align: center;">2.00</td></tr><tr class="even"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.318</td><td style="text-align: center;">0.354</td><td style="text-align: center;">0.50</td><td style="text-align: center;">1.00</td></tr><tr class="odd"><td style="text-align: center;"><strong>方波</strong></td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.00</td><td style="text-align: center;">2.00</td></tr><tr class="even"><td style="text-align: center;"><strong>三角波</strong>或<strong>锯齿波</strong></td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.15</td><td style="text-align: center;">2.00</td><td style="text-align: center;">4.00</td></tr><tr class="odd"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.87</td><td style="text-align: center;">1.00</td><td style="text-align: center;">1.73</td><td style="text-align: center;">3.46</td></tr><tr class="even"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.50</td><td style="text-align: center;">0.578</td><td style="text-align: center;">1.00</td><td style="text-align: center;">2.00</td></tr><tr class="odd"><td style="text-align: center;">... ...</td><td style="text-align: center;">0.25</td><td style="text-align: center;">0.289</td><td style="text-align: center;">0.50</td><td style="text-align: center;">1.00</td></tr></tbody></table><h3 id="电容">电容</h3><p>在两块带有相反极性电荷的平行板之间，填充上绝缘介质，就可以制作成为一个<strong>平行板电容器</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/17.png"></p><p><strong>电容器</strong>是一种专门用于保存电荷，从而通过<strong>电场</strong>储存电能的元器件。如果移出电容器两极的电源，那么电容器自身的<strong>漏电流</strong>将会导致完全放电。或者采用一根<strong>导线</strong>连接电容器的两极，也可以中和两个极板上的异种电荷，从而达到快速放电的目的。</p><p>电容器当中存储的<strong>电荷量</strong>，与其两极之间<strong>电压</strong>的比值就称为<strong>电容</strong>，采用符号<span class="math inline">\(C\)</span> 进行表示：</p><p><span class="math display">\[电容 C = \frac{电荷 Q}{电压 V}\]</span></p><p>上述公式当中电容 <span class="math inline">\(C\)</span>的值总是取<strong>正值</strong>，单位为<strong>法拉</strong>，简写为<span class="math inline">\(F\)</span>，<code>1</code>法拉等于<strong>一库仑每伏</strong> <span class="math inline">\(1F =\frac{1C}{1V}\)</span>。<code>固定电容器</code>、<code>有极性电容器</code>、<code>可变电容器</code>、<code>微调电容器</code>的符号(左侧)，以及实际电容器的<strong>等效模型</strong>(右侧)分别如下图所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/18.png"></p><blockquote><p><strong>注意</strong>：<strong>电容器</strong>的取值范围比较宽泛，即可以在给定的<strong>电压</strong>之下存储不同的<strong>电荷量</strong>，也可以在给定<strong>电荷量</strong>的情况下维持不同的<strong>电压</strong>。因而选取合适的电容器，就能够控制<strong>电荷量</strong>或者<strong>电压</strong>。</p></blockquote><h4 id="电容值">电容值</h4><p>电容器的容值与<strong>极板面积</strong> <span class="math inline">\(A\)</span>（单位为 <span class="math inline">\(m^2\)</span>）、<strong>极板间距</strong> <span class="math inline">\(d\)</span>（单位为 <span class="math inline">\(m\)</span>）、电介质的<strong>介电常数</strong><span class="math inline">\(\varepsilon\)</span>（真空介电常数 <span class="math inline">\(\varepsilon_0 = 8.85 \times 10^{-12}\ C^2 /N \cdotm^2\)</span>）有关。如果极板上的<strong>电压</strong>为 <span class="math inline">\(V\)</span>，极板之间的<strong>电场强度</strong><span class="math inline">\(E =\frac{V}{d}\)</span>，此时极板上必然携带有<strong>等量的异种电荷</strong><span class="math inline">\(Q\)</span>：</p><p><span class="math display">\[电荷 Q = 介电常数 \varepsilon \times 极板面积 A \times 极板间电场强度 E= \frac{介电常数 \varepsilon \times 极板面积 A \times 两极电压V}{极板间距 d}\]</span></p><p>上述方程当中的 <span class="math inline">\(\frac{\varepsilonA}{d}\)</span> 部分，就是电容器 <span class="math inline">\(C\)</span>的<strong>容值</strong>计算公式：</p><p><span class="math display">\[电容值 C = \frac{介电常数\varepsilon \times 极板面积 A}{极板间距 d}\]</span></p><p><strong>某一种介质</strong>的介电常数与<strong>真空</strong>的介电常数的比值，就称为该介质材料的<strong>相对介电常数</strong><span class="math inline">\(k\)</span>：</p><p><span class="math display">\[相对介电常数 k = \frac{某物质介电常数 \varepsilon}{真空介电常数\varepsilon_0}\]</span></p><p>将<strong>相对介电常数</strong> <span class="math inline">\(k\)</span>的表达式，代入至上述的<strong>电容值</strong> <span class="math inline">\(C\)</span> 的表达式里，就可以得到下面的方程：</p><p><span class="math display">\[电容值 C = \frac{相对介电常数 k \times 真空介电常数 \varepsilon_0 \times极板面积 A}{极板间距 d} = \frac{(8.85 \times 10^{-12}) \times相对介电常数 k \times 极板面积 A}{极板间距 d}\]</span></p><p>相对介电常数的变化范围为 <span class="math inline">\(1.00059\)</span>（一个标准大气压下的空气）到 <span class="math inline">\(10^5\)</span>（某一些陶瓷材料），下面的表格展示了一些常见介质的<strong>相对介电常数</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/19.png"></p><p>通常情况下，电容器的极板数量不止两个，通过极板的交替层叠，就可以在较小空间内获得较大的容值，由<span class="math inline">\(n\)</span><strong>层</strong>极板构成的电容器<strong>容值</strong>表达式如下所示：</p><p><span class="math display">\[电容值 C = \frac{相对介电常数 k \times 真空介电常数 \varepsilon_0 \times极板面积 A}{极板间距 d} \times (极板层数 n - 1)\]</span></p><blockquote><p><strong>注意</strong>：电容器的<strong>极板</strong>通常使用金属薄片制作而成，极板之间填充<strong>固态或者液态电介质</strong>（如<code>云母</code>、<code>纸</code>、<code>聚丙烯</code>、<code>陶瓷</code>）。其中，<strong>电解电容器</strong>的极板采用<strong>铝箔</strong>制成，极板之间填充的电介质为半液体状的化合物，电解电容器的容值通常较大，使用时需要区分其正负极性。极性的限制意味着<strong>电解电容</strong>不能直接应用于交流电路，但是可以应用于交流与直流叠加的电路当中，只要<strong>交流峰值电压</strong>不超过其最大<strong>直流工作电压</strong>（<strong>DCWV</strong>，Direct-CurrentWorkingVolts）即可，否则就会造成电介质击穿，在两个极板之间形成一道低阻的电流路径，导致电容器完全损坏。</p></blockquote><h4 id="理想电容实际电容">理想电容/实际电容</h4><p><strong>理想电容器</strong>容值的微分形式可以记为 <span class="math inline">\(dQ = C \timesdV\)</span>，其中<strong>电容值</strong> <span class="math inline">\(C\)</span> 是一个不会随着<strong>电荷</strong><span class="math inline">\(Q\)</span> 或者<strong>电压</strong> <span class="math inline">\(V\)</span> 变化的常量，而此时<strong>电流</strong><span class="math inline">\(I =\frac{dQ}{dt}\)</span>，将其与电容的微分表达式联立之后，就可以得到经过电容器的<strong>电流</strong><span class="math inline">\(I_C\)</span>：</p><p><span class="math display">\[I_C = \frac{d 电荷量 Q}{d 时间 t} = \frac{d(电容值 C \times 电容电压V_C)}{d 时间 t} = 电容值 C \times \frac{d 电容电压 V_C}{d 时间 t}\]</span></p><p>上面的方程表示在 <span class="math inline">\(dt\)</span>时间内，有大小为 <span class="math inline">\(C \times dVc\)</span>的微量电荷 <span class="math inline">\(dQ\)</span>流入<strong>右侧极板</strong>，同时在<strong>左侧极板</strong>上出现数量相同的电荷<span class="math inline">\(dQ\)</span>，即量值为 <span class="math inline">\(\frac{dQ}{dt} = \frac{C \times dV_C}{dt}\)</span>的电流进入了<strong>左侧极板</strong>。根据上述电容器经过电流 <span class="math inline">\(I_C\)</span>的微分方程，可以求解得到电容器上<strong>电压</strong> <span class="math inline">\(V_C\)</span> 的表达式：</p><p><span class="math display">\[V_C = \frac{1}{C} \int I_C dt\]</span></p><p>上述方程针对的都是<strong>理想电容器</strong>，其所反映的各种特性，并不能直接应用于<strong>实际电容器</strong>，使用时应当加以鉴别和区分：</p><ul><li><p>首先，如果在理想电容器两端施加直流电压，由于电压的变化率为 <span class="math inline">\(\frac{dV}{dt} = 0\)</span>，则电容器的电流为 <span class="math inline">\(0\)</span>，因而直流电路当中的电容器相当于<strong>开路</strong>。如果此时突然改变电压值，那么<span class="math inline">\(\frac{dV}{dt} = \frac{9V}{0V} =\infty\)</span>，此时电容器上的电流为<strong>无穷大</strong> <span class="math inline">\(\infty\)</span>，但是实际电路当中的电流不可能为无穷大。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/20.png"></p></li><li><p>其次，电容器在直流状态下并没有电流经过，只有当其两端电压发生改变时，电容器才能够存储或者释放来自于电流的电荷。例如闭合上面电路当中的<strong>充电开关</strong>时，<code>9V</code>电源会连接到电容器的两端，电容器中的电荷量立刻上升至最大值。然而对于实际电容器，由于其<strong>内电阻</strong>的存在，积累电荷需要耗费一定时间，使得<strong>位移电流</strong>不会为无穷大。而在电容器充电过程当中，<strong>电流</strong>会先突变至<span class="math inline">\(\frac{V_{battery}}{R_{internal}}\)</span>而后迅速呈指数规律下降，与此同时<strong>电压</strong>会呈指数规律上升至与电源电压相等，下图是<strong>实际电容器</strong>在充电过程当中，<code>电压</code>与<code>电流</code>的变化曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/21.png"></p></li><li><p>最后，当闭合<strong>放电开关</strong>之后，电容器的正负极板之间会形成一条导电路径，从而释放出与<strong>充电方向</strong>相反的电流，伴随着电荷的逐渐中和，<strong>电流</strong>从初始峰值<span class="math inline">\(\frac{V_{battery}}{R_{internal}}\)</span>衰减，而<strong>电压</strong>则按照指数规律下降：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/22.png"></p></li></ul><blockquote><p><strong>注意</strong>：由于实际电路当中经常存在<strong>电阻器</strong>元件，其电阻值远大于电容器的<strong>内阻</strong>，因而后者通常可以忽略，后续的<strong>RC阻容电路</strong>将会更加详细的讨论这一点。</p></blockquote><h4 id="电容器存储的能量">电容器存储的能量</h4><p>虽然<strong>理想电容器</strong>不会消耗能量，但是<strong>实际电容器</strong>的<strong>内阻</strong>是会消耗能量的，不过该内阻值通常比较小，因而往往会忽略其造成的热损耗。</p><p>电容器当中的能量以<strong>电场</strong>的形式进行储存，将电容器的<strong>电流</strong>代入至<strong>功率表达式</strong><span class="math inline">\(P = IV\)</span> 当中，再将结果代入功率的定义<span class="math inline">\(P = \frac{dE}{dt}\)</span> 里，对 <span class="math inline">\(E\)</span>进行积分，就可以获得电容器上面存储的能量 <span class="math inline">\(E_{cap}\)</span>：</p><p><span class="math display">\[E_{cap} = \int VIdt = \int VC \frac{dV}{dt} = \int CVdV = \frac{1}{2}CV^2\]</span></p><p>例如在 <span class="math inline">\(1000 \mu F\)</span>的电容器两端添加 <code>5V</code>的电压，那么该电容器里面存储的<strong>能量</strong> <span class="math inline">\(E_{cap}\)</span> 等于：</p><p><span class="math display">\[E_{cap} = \frac{1}{2} CV^2 = \frac{1}{2} \times (1000 \times 10^{-6}F)\times (5V)^2 = 0.0125 J\]</span></p><h4 id="rc-时间常数">RC 时间常数</h4><p>首先，将电容器连接到<strong>直流电压源</strong>的两端，使其在一瞬间完成充电。然后，再把充满电的电容器两端进行短接，使其在一瞬间完成放电。基于这个过程，如果在该电路里加入一个电阻器，那么其<strong>充放电速率</strong>将会遵循下图所示的指数规律：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/23.png"></p><p>上图左侧 <strong>RC 充电电路</strong>当中的<strong>电阻</strong><span class="math inline">\(R= 10kΩ\)</span>，而<strong>电容</strong><span class="math inline">\(C = 100 \muF\)</span>，其<strong>波形图</strong>如右侧所示。此时电路当中的<strong>电阻电压</strong><span class="math inline">\(V_R\)</span>、<strong>电容电压</strong><span class="math inline">\(V_C\)</span>、<strong>电流</strong> <span class="math inline">\(I\)</span> 之间的关系如下面方程所示：</p><p><span class="math display">\[\begin{aligned}I = \frac{V_S}{R} e^{-\frac{t}{RC}} &amp;\implies \frac{t}{RC} = - \ln\bigg(\frac{IR}{V_S} \bigg) \\V_R = IR = V_S \cdot e^{-\frac{t}{RC}} &amp;\implies \frac{t}{RC} = -\ln \bigg(\frac{V_R}{V_S} \bigg) \\V_C = \frac{1}{C} \int Idt = V_S(1 - e^{-\frac{t}{RC}}) &amp;\implies\frac{t}{RC} = -\ln \bigg( \frac{V_S - V_C}{V_S} \bigg)\end{aligned}\]</span></p><p>上述方程当中<strong>电流</strong> <span class="math inline">\(I\)</span>的单位为<strong>安培</strong>，<strong>电压源</strong> <span class="math inline">\(V_S\)</span>的单位为<strong>伏特</strong>，<strong>电阻</strong> <span class="math inline">\(R\)</span>的单位为<strong>欧姆</strong>，<strong>电容</strong> <span class="math inline">\(C\)</span>的单位为<strong>法拉</strong>，<strong>接入电压源后的时间</strong> <span class="math inline">\(t\)</span>单位为<strong>秒</strong>，除此以外<strong>自然常数</strong> <span class="math inline">\(e \approx 2.718\)</span>。</p><p>通常以小写字母 <span class="math inline">\(\tau = t = RC\)</span>来表示电路的<strong>时间常数</strong>（单位为<strong>秒</strong>），表示的是RC 电路当中，<strong>电容器</strong>通过<strong>电阻</strong>从初始的<code>0</code> 电压，充电至最大电压的 <code>63.2%</code>所需要的时间；或者是通过同一个电阻，将电容放电至其初始电压<code>36.8%</code> 所需要的时间。</p><ol type="1"><li>经过 <code>1</code> 个时间常数 <span class="math inline">\(t = RC =\tau\)</span> 以后，电容器上的充电电压达到电源电压的<code>63.2%</code>；</li><li>经过 <code>2</code> 个时间常数 <span class="math inline">\(t = 2RC =2\tau\)</span> 以后，电容器上的电压达到电源电压的<code>86.5%</code>；</li><li>经过 <code>3</code> 个时间常数 <span class="math inline">\(t = 3RC =3\tau\)</span> 以后，电容器上的电压达到电源电压的<code>95%</code>；</li><li>以此类推，在 <code>5</code> 个时间常数以后，电容电压为电源电压的<code>99.24%</code>，可以认为已经<strong>充电完毕</strong>；</li></ol><p>下图右侧 <strong>RC 放充电电路</strong>当中的<strong>电阻</strong><span class="math inline">\(R = 3kΩ\)</span>，而<strong>电容</strong><span class="math inline">\(C = 0.1 \muF\)</span>，其<strong>波形图</strong>如右侧所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/24.png"></p><p>此时电路当中的<strong>电阻电压</strong> <span class="math inline">\(V_R\)</span>、<strong>电容电压</strong> <span class="math inline">\(V_C\)</span>、<strong>电流</strong> <span class="math inline">\(I\)</span> 之间的关系如下面方程所示：</p><p><span class="math display">\[\begin{aligned}I = \frac{V_S}{R} e^{-\frac{t}{RC}} &amp;\implies \frac{t}{RC} = - \ln\bigg(\frac{IR}{V_S} \bigg) \\V_R = IR = V_S \cdot e^{-\frac{t}{RC}} &amp;\implies \frac{t}{RC} = -\ln \bigg(\frac{V_R}{V_S} \bigg) \\V_C = \frac{1}{C} \int_0 Idt = V_S \cdote^{-\frac{t}{RC}}  &amp;\implies \frac{t}{RC} = -\ln \bigg(\frac{V_C}{V_S} \bigg)\end{aligned}\]</span></p><p>RC 电路当中，电容器的放电过程，正好与其充电过程完全相反：</p><ol type="1"><li>经过 <code>1</code> 个时间常数 <span class="math inline">\(t =1\tau\)</span> 以后，电容电压下降 <code>63.2%</code>，为电源电压的<code>37．8%</code>；</li><li>经过 <code>5</code> 个时间常数 <span class="math inline">\(t =5\tau\)</span> 以后，电容电压下降 <code>99.24%</code>，为电源电压的<code>0.76%</code>，可以认为此时已<strong>放电完毕</strong>；</li></ol><h4 id="寄生电容">寄生电容</h4><p>电容效应并不只存在于电容器的内部，不同电位的表面相互靠近时也会产生<strong>电场</strong>，从而也存在电容效应，称为<strong>寄生电容</strong>。这种效应会对电路造成不必要的干扰，因而必须采取措施降低其影响：</p><ul><li>让电容器的<strong>引脚尽可能的短</strong>；</li><li>对<strong>相同电位的元件进行分组</strong>避免形成电容耦合；</li></ul><p>高阻抗电路当中，由于<strong>容性电抗</strong>占据电路<strong>阻抗</strong>的比例较大，因而寄生电容造成的影响也会更大。除此之外，由于寄生电容往往与电路形成<strong>并联</strong>，当信号频率较高时，就会造成正常信号<strong>被旁路</strong>的问题。</p><h4 id="电容的并联">电容的并联</h4><p>当多个电容器进行并联时，总电容 <span class="math inline">\(C_{total}\)</span>等于各个并联电容的容值之和，其计算方式类似于<strong>串联电阻</strong>：</p><p><span class="math display">\[C_{total} = C_1 + C_2 + C_3 + C_4 + ... C_n\]</span></p><blockquote><p><strong>注意</strong>：可以将电容器的并联，直观的视为增大了<strong>电容器极板的面积</strong>。</p></blockquote><p>对于下面电路的上半部分结点，运用<strong>基尔霍夫电流定理</strong>可以得到<span class="math inline">\(I_{total} = I_1 + I_2 + I_3 + ... +I_n\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/25.png"></p><p>由于电容 <span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(C_2\)</span> 两端的电压均为 <span class="math inline">\(V\)</span>，将其代入上面的基尔霍夫电流方程，化简之后结果中的括号部分，就是并联等效电容的计算公式：</p><p><span class="math display">\[I = C_1 \frac{dV}{dt} + C_2 \frac{dV}{dt} + C_3 \frac{dV}{dt} + ... +C_n \frac{dV}{dt}= (C_1 + C_2 + C_3 + ... + C_n) \frac{dV}{dt}\]</span></p><blockquote><p><strong>注意</strong>：并联电容器两端的安全电压，主要受限于<strong>额定电压最低</strong>的那一个电容。</p></blockquote><h4 id="电容的串联">电容的串联</h4><p>当多个电容器串联在一起的时候，<strong>总电容</strong> <span class="math inline">\(C_{total}\)</span>的倒数等于每一个串联电容器容值的倒数之和，其计算方式类似于<strong>并联电阻</strong>：</p><p><span class="math display">\[\frac{1}{C_{total}} = \frac{1}{C_1} + \frac{1}{C_2} + \frac{1}{C_3} +... + \frac{1}{C_n}\]</span></p><p>串联之后的<strong>总电容</strong>将会降低，并且小于<strong>容值最小</strong>的那个电容；每一个串联电容器两端的电压，等于输入电压<span class="math inline">\(V_{IN}\)</span> 的分数 <span class="math inline">\(V_{IN} \cdot(\frac{C_{total}}{C_2})\)</span>，许多电路就利用到了电容器的这种<strong>分压特性</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/26.png"></p><p>由于每一个串联电容器上的电流 <span class="math inline">\(I\)</span>相等，根据<strong>基尔霍夫电压定理</strong>得到下面的方程，该方程最后结果的括号部分，就是串联等效电容的计算公式：</p><p><span class="math display">\[V = \frac{1}{C_1} \int Idt + \frac{1}{C_2} \int Idt + \frac{1}{C_3} \intIdt + ... + \frac{1}{C_n} \int Idt = \bigg ( \frac{1}{C_1} +\frac{1}{C_2} + \frac{1}{C_3} + ... + \frac{1}{C_n} \bigg ) \int Idt\]</span></p><blockquote><p><strong>注意</strong>：每一个串联电容器两端的电压，都不得超过其<strong>额定电压</strong>，必要时可以借助<strong>分压电阻</strong>来避免电容器损坏。</p></blockquote><h4 id="电容与交流信号">电容与交流信号</h4><p>交流电路当中的<strong>电容器</strong>，可以允许或者限制<strong>特定频率</strong>的电流通过。下图所示的就是在交流信号下，电容器的<strong>电压</strong>、<strong>电流</strong>、<strong>功率</strong>关系曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/27.png"></p><p>上图当中正弦电压的最大值为 <code>100V</code>，在 <code>0 ~ A</code>这段时间里，外加电压从 <code>0V</code> 上升至<code>38V</code>，此时电容器也会被充电至 <code>38V</code>；而在<code>A ~ B</code> 阶段，外加电压上升至<code>71V</code>，电容器电压也随之提高了 <code>33V</code>，由于<code>A ~ B</code> 阶段电容器的电压增量相比 <code>0 ~ A</code>阶段要小，因而电容器的电荷增量也要比 <code>0 ~ A</code> 阶段更少；到了<code>B ~ C</code> 阶段，外加电压从 <code>71V</code> 上升至<code>92V</code>，电容器电压随之提高了<code>21V</code>，电压增量继续减小；继续到 <code>C ~ D</code>阶段，外加电压只增加了 <code>8V</code>，电压增量进一步减小。</p><p>如果把前 <span class="math inline">\(\frac{1}{4}\)</span>周期分割为多个时间段，就会发现电容器的充电电流波形与外加电压一样为<strong>正弦波</strong>，周期起始点的电流为最大值，当<strong>电压</strong>达到最大值时<strong>电流</strong>变为零，表明在电压与电流之间存在着<code>-90°</code> 相位差。第二个 <span class="math inline">\(\frac{1}{4}\)</span> 周期，也就是<code>D ~ H</code>这段时间，外加电压降低，电容器将电荷释放回电路，并且电流方向与充电电压的方向相反；第三、四个<span class="math inline">\(\frac{1}{4}\)</span>周期，将会分别重复第一、二个 <span class="math inline">\(\frac{1}{4}\)</span>周期的过程，不同之处在于外加<strong>电压</strong>的极性相反，<strong>电流</strong>也会发生相应的改变。换而言之，电容器的充放电过程产生了交变电流。</p><blockquote><p><strong>注意</strong>：通过电容器的的<strong>电流</strong>超前于<strong>电压</strong>有<code>90°</code> 度。</p></blockquote><h4 id="容抗">容抗</h4><p>电容器上面的<strong>电荷量</strong>正比于<strong>电容</strong>与外加<strong>电压</strong><span class="math inline">\(Q =CV\)</span>，一个交流电路当中，电荷在电路当中进行周期性的往返运动，<code>电荷/电流</code>的运动速度与<code>电压</code>、<code>电容</code>、<code>频率</code>呈正比关系。将<strong>电容</strong>与<strong>频率</strong>相乘，就可以得到一个类似于<code>电阻</code>的参数<strong>容抗</strong><span class="math inline">\(X_C\)</span>，其单位与电阻一样为<strong>欧姆</strong><code>Ω</code>：</p><p><span class="math display">\[容抗 X_C = \frac{1}{2 \pi \times 频率 f \times 电容 C} = \frac{1}{角频率\omega \times 电容 C}\]</span></p><p>上面公式当中，<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 的单位为欧姆<code>Ω</code>，<strong>频率</strong> <span class="math inline">\(f\)</span> 的单位为赫兹<code>Hz</code>，<strong>电容</strong> <span class="math inline">\(C\)</span> 的单位为法拉<code>F</code>，而<strong>圆周率</strong> <span class="math inline">\(\pi\)</span> 约等于 <code>3.1416</code>，而 <span class="math inline">\(2 \pi f\)</span> 通常使用<strong>角频率</strong><span class="math inline">\(\omega\)</span> 进行代替。</p><p>当频率 <span class="math inline">\(f\)</span> 为无穷大时，容抗 <span class="math inline">\(X_C\)</span>等于零，即高频时电容器相当于<strong>短路</strong>，可以认为电容器具有<strong>高通特性</strong>。而当频率<span class="math inline">\(f\)</span> 等于零时，容抗 <span class="math inline">\(X_C\)</span>趋于无穷大，电容器相当于<strong>断路</strong>，可以认为电容器具有<strong>抑制低频</strong>信号的特性。</p><blockquote><p><strong>注意</strong>：虽然<strong>容抗</strong> <span class="math inline">\(X_C\)</span>的单位为<strong>欧姆</strong>，但是容抗并不会消耗电能。在 <span class="math inline">\(\frac{1}{4}\)</span>周期内存储在电容器的电能，会在下一个 <span class="math inline">\(\frac{1}{4}\)</span>周期释放回电路，即一个周期当中的<strong>平均功率</strong>为零。</p></blockquote><p>下图展示了各种<strong>理想电容器</strong>的<code>容抗</code>与<code>频率</code>之间的关系，可以看出两者呈现<strong>反比关系</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/28.png"></p><p><strong>实际电容器</strong>需要考虑到<code>电容内阻</code>以及<code>电感效应</code>，其<code>容抗</code>与<code>频率</code>的关系如下图所示，图中曲线的最低点表示电容器的<strong>谐振点</strong>，该频率点下电容器的<code>电容</code>与<code>电感</code>效应相互抵消，因而只剩下<code>内阻</code>，这个点的频率就被称为<strong>谐振频率</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/29.png"></p><p>上图当中，实际电容器的阻抗，首先会随着<strong>频率</strong>的增大而<strong>减小</strong>，然后又会随着<strong>频率</strong>的增大而<strong>增大</strong>。由于实际电路当中<strong>寄生效应</strong>的存在，电容器的曲线与上图描绘的曲线可能并不完全一致。</p><h4 id="电容分压电路">电容分压电路</h4><p>电容器分压电路通常只用于交流电路当中（由于电容器会隔断直流电压，所以其构成的分压电路不能工作在直流状态），电容器分压电路的<strong>交流输出电压</strong><span class="math inline">\(V_{out}\)</span>计算公式与<strong>电阻分压电路</strong>不同，其分子是串联电容 <span class="math inline">\(C_1\)</span> 而非 <span class="math inline">\(C_2\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/30.png"></p><blockquote><p><strong>注意</strong>：电容器分压电路的输出电压与输入电压的<strong>频率</strong>无关。</p></blockquote><h4 id="品质因数-q">品质因数 Q</h4><p>对于<strong>电容</strong>、<strong>电感</strong>等储能元件，可以通过<strong>品质因数Q</strong> 来区别其性能优劣。这类元件的 <strong>Q值</strong>等于元件<strong>存储的能量</strong>（即储能相关的参数<code>电抗</code>）与其<strong>内部消耗的能量</strong>（即耗能相关的参数<code>电阻</code>）之比：</p><p><span class="math display">\[品质因数 Q = \frac{电抗 X}{电阻 R}\]</span></p><p><strong>品质因数 Q没有单位</strong>，<strong>电容器</strong>的<strong>电抗</strong> <span class="math inline">\(X\)</span> 就等于其<strong>容抗</strong> <span class="math inline">\(X_C\)</span>，而<strong>电感器</strong>的<strong>电抗</strong><span class="math inline">\(X\)</span> 同样等于其<strong>感抗</strong><span class="math inline">\(X_L\)</span>，<strong>电阻</strong> <span class="math inline">\(R\)</span>表示的是元件中与能量消耗相关的全部内阻。</p><blockquote><p><strong>注意</strong>：电容器的 <strong>Q</strong>值通常都比较高，例如<strong>陶瓷电容器</strong>和<strong>云母电容器</strong>的<strong>Q</strong> 值可以达到 <code>1200</code>以上；而<strong>微型可调陶瓷电容器</strong>的 <strong>Q</strong>值比较小，某些应用场合下可以忽略；而<strong>微波电容器</strong>的<strong>Q</strong> 值在 <code>10GHz</code> 以上工作频率不会超过<code>10</code>。</p></blockquote><h3 id="电感">电感</h3><p>电子学当中的三个基本元件分别是<strong>电阻</strong>、<strong>电容</strong>、<strong>电感</strong>。其中，<strong>电容器</strong>以<code>电场</code>的形式存储电能，而<strong>电感器</strong>则是以<code>磁场</code>的形式储存电能。现代物理将<strong>电场</strong>与<strong>磁场</strong>结合起来形成了场论，称为<strong>电磁学</strong>。</p><h4 id="电磁感应">电磁感应</h4><p>磁场可以使得导体内部的电子受力，并且沿着某一个方向移动形成<strong>电流</strong>，其作用效果类似于电路里的<strong>电动势</strong>（EMF，ElectromotiveForce），通常称为<strong>感应电动势</strong>，根据<strong>法拉第电磁感应定律</strong>，电路当中的<strong>感应电动势</strong>与<strong>磁通</strong>变化率成正比：</p><p><span class="math display">\[感应电动势 EMF = - \frac{d\ 磁通量 \varPhi_M}{d\ 时间 t}\]</span></p><p>上面等式当中的 <span class="math inline">\(\varPhi_M\)</span>是穿过闭合回路的<strong>磁通量</strong>，其值等于<strong>磁场强度</strong><span class="math inline">\(B\)</span> 与<strong>面积</strong> <span class="math inline">\(A\)</span> 点积的<strong>积分</strong>：</p><p><span class="math display">\[磁通量 \varPhi_M = \int 磁场强度 B \cdot d\ 面积 A\]</span></p><p>可以看到，在电路当中产生<strong>感应电动势</strong>的途径，主要存在如下三种：</p><ol type="1"><li><strong>磁场强度</strong> <span class="math inline">\(B\)</span>随着<strong>时间</strong> <span class="math inline">\(t\)</span>进行变化；</li><li>电路的<strong>回路面积</strong> <span class="math inline">\(A\)</span> 随<strong>时间</strong> <span class="math inline">\(t\)</span> 进行变化；</li><li><strong>磁场强度</strong> <span class="math inline">\(B\)</span>与<strong>回路面积</strong> <span class="math inline">\(A\)</span>的法线角度随<strong>时间</strong> <span class="math inline">\(t\)</span>变化；</li></ol><h4 id="电感器">电感器</h4><p><strong>自感</strong>是指通过闭合线圈的<strong>电流</strong>发生了变化，致使线圈本身产生感应电动势的现象。<strong>电感器</strong>就是一种基于自感原理的电子元器件。其通常具有<strong>环状</strong>结构，内部可以产生较大的<strong>磁通</strong>。当电流变化较大时，也可以承受住较大的<strong>自感电压</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/31.png"></p><p>下图分别展示了<strong>空芯电感器</strong>、<strong>磁芯电感器</strong>、<strong>可调电感器</strong>、<strong>铁氧体磁环</strong>的电路符号：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/32.png"></p><ul><li><strong>空芯电感器</strong>：射频场景应用较多，可以避免由于内部<strong>磁滞</strong>与<strong>涡流</strong>引起的损耗；</li><li><strong>磁芯电感器</strong>：产生的磁场强度比空心电感器更大，通过较少<strong>线圈匝数</strong>就可以实现较大的电感值；</li><li><strong>可调电感器</strong>：通过改变磁芯<strong>长度</strong>，或者沿着线圈安置<strong>滑块</strong>，以及在磁芯中放置能够削弱<strong>磁芯</strong>磁通量的金属小块等方式，来实现电感值的可调；</li><li><strong>铁氧体磁环</strong>：没有缠绕线圈，使用时直接将导线穿过<strong>磁环</strong>；</li></ul><h4 id="电感器工作原理">电感器工作原理</h4><p>当电感器两端电压值增大时，电路当中的电流随之增大，通过螺旋线圈的磁通量也将会增大。增大的磁通量会对自由电子产生<strong>反向</strong>的作用力，这个作用力就是与<strong>初始电压方向</strong>相反的<strong>感应电动势</strong>，称为<strong>反向感应EMF</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/33.png"></p><p>而当电感器两端电压值降低时，电路当中的电流随之减小，通过螺旋线圈的磁通量也将会减小。减小的磁通量会对自由电子产生<strong>同向</strong>的作用力，这个作用力就是与<strong>初始电压方向</strong>相同的<strong>感应电动势</strong>，称为<strong>同向感应EMF</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/34.png"></p><h5 id="电感的充磁">电感的充磁</h5><p>电感的<strong>充磁</strong>是指电源提供的能量传递到电感磁场的过程，例如下图所示电路当中，将开关由<strong>B</strong> 拔向 <strong>A</strong>时，电感上的电压发生改变，产生一个突然增大的电流，此时电感的磁场从零开始快速增大，这个过程就称为电感的<strong>充磁</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/35.png"></p><p>根据<strong>法拉第电磁感应定律</strong>，随着电感线圈<strong>磁通量</strong>的增大，线圈内的自由电子受到一个与电源电压方向相反的作用力（<strong>反向感应EMF</strong>）:</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/36.png"></p><p><strong>反向感应电动势</strong>的作用结果是在电流增大时，电感产生的阻力也在增大。一段时间之后，电路里的电流不再上升，磁场强度也停止变化，通过线圈的磁通量也不再发生变化，此时<strong>反向感应电动势</strong>消失，电感呈现为直接导通的状态。下面示意图的上半部分是<strong>电源电压</strong>与<strong>感应电压</strong>的关系曲线，而下半部分则是经过电感的<strong>电流</strong>曲线<span class="math inline">\(I = \frac{V_s}{R}(1 -e^{-t/(L/R)})\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/37.png"></p><h5 id="电感的去磁">电感的去磁</h5><p>电感的<strong>去磁</strong>就是将电感中的<strong>磁场能量</strong>释放回电路，从而转换为<strong>电能</strong>的过程。将开关由<strong>A</strong> 拔向 <strong>B</strong>时，电感上的电压发生改变，使得电流趋于零，此时电感的磁场强度骤然减小，这个过程就称为电感的<strong>去磁</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/38.png"></p><p>去磁过程当中，电感会力图阻止磁场的减小，根据法拉第电磁感应定律，通过线圈的<strong>磁通量</strong>减小，线圈内的自由电子会受到与开关拔动之前的电源电压同向的作用力（<strong>同向感应EMF</strong>）。因而电感会在电流降低的过程当中，充当电源的角色为电路提供电流，其所提供的能量来自于磁场的变化：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/39.png"></p><p>下面示意图的上半部分同样是<strong>电源电压</strong>与<strong>感应电压</strong>的关系曲线，而下半部分依然是经过电感的<strong>电流</strong>曲线<span class="math inline">\(I =\frac{V_s}{R}(e^{-t/(L/R)})\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/40.png"></p><h4 id="电感系数">电感系数</h4><p>电感的<strong>感应电压</strong> <span class="math inline">\(V_L\)</span>（感应电动势）与<strong>电流</strong><span class="math inline">\(I_L\)</span>的关系可以采用下面的方程来进行表示：</p><p><span class="math display">\[感应电压 V_L = \frac{d\ 电流 I_L}{d\ 时间 t}\]</span></p><p>分别对上述方程的左右两侧进行积分，就可以求解得到<strong>电流</strong><span class="math inline">\(I_L\)</span> 的表达式：</p><p><span class="math display">\[电流 I_L = \frac{1}{电感系数 L} \int 感应电压\ V_L\ \cdot d\ 时间\ t\]</span></p><p>该表达式中的 <span class="math inline">\(L\)</span>称为<strong>电感系数</strong>，其大小与电感的物理特性相关，例如<strong>线圈</strong>的形状与匝数、<strong>磁芯</strong>的材料与结构等。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/41.png"></p><blockquote><p><strong>注意</strong>：理想电感两端的电压是<strong>感应电压</strong><span class="math inline">\(V_L\)</span>，当稳态直流通过电感时 <span class="math inline">\(V_L =0\)</span>，此时电感相当于<strong>短路</strong>。</p></blockquote><p>电感系数的单位为<strong>亨利</strong> <code>H</code>，<code>1H</code>等于当电流变化率为 <code>1A/s</code> 时 <code>1V</code> 的感应电压，即<span class="math inline">\(1 H = \frac{1V}{1A/s}\)</span>。电子元件厂商生产的电感器，其典型电感系数范围在 <span class="math inline">\(0.1nH \sim 50H\)</span> 之间，除了亨利<code>H</code> 这个单位之外，电感系数的常用单位还有<strong>纳亨</strong><code>nH</code>、<strong>微亨</strong><code>μH</code>、<strong>毫亨</strong> <code>mH</code>：</p><p><span class="math display">\[1 H = 10^3 mH = 10^6 μH = 10^9 nH\]</span></p><p>电感系数也可以根据其<strong>物理原理</strong>来进行定义，即任意时刻的电感系数等于<strong>磁通链</strong><span class="math inline">\(N \varPhi_M\)</span> 与<strong>电流</strong><span class="math inline">\(I\)</span> 的比值：</p><p><span class="math display">\[电感 L = \frac{磁通链 N \varPhi_M}{电流 I}\]</span></p><p>对于下图所示的<strong>空心螺线管</strong>，当流过线圈的电流为 <span class="math inline">\(I\)</span>，应用<strong>安培定律</strong>就可以计算出其磁通量<span class="math inline">\(\varPhi_M\)</span>：</p><p><span class="math display">\[\varPhi_M = B \cdot A = \bigg( \frac{\mu_0 NI}{l} \bigg) \cdot A = \mu_0A n_{unit} I\]</span></p><p>上述计算过程当中，<span class="math inline">\(n_{unit}\)</span>为线圈单位长度的<strong>匝数</strong> <span class="math inline">\(n_{unit} = \frac{N}{l}\)</span>，其中 <span class="math inline">\(N\)</span> 为<strong>总匝数</strong>，<span class="math inline">\(l\)</span> 为<strong>线圈长度</strong>，<span class="math inline">\(A\)</span> 为<strong>横截面积</strong>，<span class="math inline">\(\mu\)</span>为线圈内芯的<strong>磁导率</strong>。除金属铁以及铁氧体之外，大多数材料的磁导率都近似为<strong>空气的磁导率</strong><span class="math inline">\(\mu_0 = 4 \pi \times 10^{-7}\ T\cdotm/A^2\)</span>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/42.png"></p><p>根据<strong>法拉第电磁感应定律</strong>，每匝线圈上面都存在着<strong>感应电压</strong>，因而<strong>总感应电压</strong><span class="math inline">\(V_L\)</span> 为磁通量 <span class="math inline">\(\varPhi_M\)</span> 变化率的 <code>n</code>倍，这里的 <code>n</code> 表示的是线圈匝数：</p><p><span class="math display">\[V_L = N \times \frac{d \varPhi_M}{dt} = \frac{\mu N^2 A}{l} \times\frac{dI}{dt}\]</span></p><p>上式当中的 <span class="math inline">\(\frac{\mu N^2 A}{l}\)</span>部分就是电感线圈的<strong>电感系数</strong> <span class="math inline">\(L_{sol} = \frac{\mu N^2A}{l}\)</span>，其值伴随着<strong>线圈总匝数</strong> <span class="math inline">\(N\)</span> 的平方进行变化，如果匝数增加<code>1</code> 倍，那么电感系数将会增加 <code>4</code>倍；如果让线圈的电感系数增加 <code>1</code> 倍，则匝数应为线圈原有匝数的<span class="math inline">\(\sqrt{2}\)</span> 或者<code>1.414</code>倍。</p><h4 id="电感器上的能量">电感器上的能量</h4><p>类似于之前介绍的理想电容器，理想电感器同样不消耗能量，而是将能量存储在磁场当中，当磁场减小的时候，又会将能量释放回电路。利用功率定理<span class="math inline">\(P = IV\)</span>，结合功率的定义 <span class="math inline">\(P = \frac{dW}{dt}\)</span> 和电感方程 <span class="math inline">\(V =\frac{LdI}{dt}\)</span>，并使用电感的<strong>储能</strong> <span class="math inline">\(E_L\)</span> 代替<strong>功</strong> <span class="math inline">\(W\)</span> 就可以获得如下的推导过程：</p><p><span class="math display">\[储能 E_L = \int P dt = \int IV dt = \int IL \frac{dI}{dt} dt = \int LIdt = \frac{1}{2} LI^2\]</span></p><p>上面等式当中，<strong>能量</strong> <span class="math inline">\(E_L\)</span> 的单位为<strong>焦耳</strong><code>J</code>，<strong>电流</strong> <code>I</code>的单位为<strong>安培</strong> <code>A</code>，<strong>电感</strong><code>L</code> 的单位为<strong>亨利</strong><code>H</code>。</p><blockquote><p><strong>注意</strong>：实际电感器只会有少部分的能量被其<strong>内电阻</strong>以<strong>热量</strong>的形式损耗。</p></blockquote><h4 id="电感器结构">电感器结构</h4><p>电感线圈通常绕制在磁性材料上面，例如<code>叠片式铁芯</code>、<code>铁氧体混合材料</code>，磁芯可以增大线圈的<strong>磁通密度</strong>，进而提高<strong>电感系数</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/43.png"></p><blockquote><p><strong>注意</strong>：<strong>磁芯线圈</strong>产生<code>磁通密度</code>与<strong>空芯线圈</strong>产生<code>磁通密度</code>的比值，称为磁芯材料的<strong>相对磁导率</strong><span class="math inline">\(\mu_R = \frac{\mu}{\mu_0}\)</span>。</p></blockquote><p>如果磁芯材料是<strong>导体</strong>（相比于<strong>钢制材料</strong>，<strong>铁氧体材料</strong>电阻率更大），那么在磁场发生变化时，磁芯材料内部就会产生下图所示的<strong>涡流效应</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/44.png"></p><p>当流过线圈的电流增大时，通过磁芯的磁通量就会发生变化，磁芯材料当中就会感应到环路电流，出现类似于电阻的热损耗，这种现象就称为<strong>涡流效应</strong>（低阻抗率材料的涡流损耗较大）。为了避免这种情况的发生，可以将涂有绝缘漆的导体薄片，层叠在一起构成磁芯，从而降低<strong>磁通</strong>变化所引起的涡流效应。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/45.png"></p><p>除了涡流效应之外，使用钢制材料的另一个问题在于其磁导率会随着<code>磁场强度</code>、<code>电流</code>、<code>温度</code>的变化而发生变化。当磁场强度足够大时，钢制磁芯将会发生饱和，其相对磁导率会降低至约等于<code>1</code>的水平。钢制磁芯的磁场与线圈当中电流的变化过程有关，这种<strong>剩磁特性</strong>在电感器当中，会造成额外的损耗，这种损耗被称为<strong>磁滞损耗</strong>。为了避免这种情况的出现，必须让磁芯式电感器工作于<strong>非饱和状态</strong>。通过<code>降低工作电流</code>、<code>使用较大磁芯</code>、<code>改变线圈匝数</code>、<code>使用低磁导率的磁芯</code>或者<code>带有空气间隙的磁芯</code>，都可以完成这个目标。</p><blockquote><p><strong>注意</strong>：当<strong>涡流</strong>与<strong>磁滞</strong>造成的损耗较大时，电感的特性更加类似于一个<strong>电阻器</strong>。除此之外，由于电感线圈存在着匝间电容，因而在某些情况下，还会呈现出类似于<strong>电容器</strong>的特性。</p></blockquote><h4 id="实际电感理想电感">实际电感/理想电感</h4><p>下面公式当中的 <span class="math inline">\(\frac{d I_L}{dt}\)</span>表示的是通过电感的<strong>电流</strong>相对于<strong>时间</strong>的变化率，如果通过电感的电流不变，那么电感两端就不会存在着电压。如果一段时间内，流过电感的电流是<strong>直流</strong>，那么<span class="math inline">\(\frac{d I_L}{dt} = V_L =0\)</span>，因而直流条件下电感相当于<strong>短路</strong>。</p><p><span class="math display">\[V_L = L \times \frac{d I_L}{dt}\]</span></p><p>如果经过电感的<strong>电流</strong> <span class="math inline">\(I_L\)</span> 随着时间 <span class="math inline">\(t\)</span> 发生变化，那么 <span class="math inline">\(\frac{d I_L}{dt} \neq0\)</span>，此时电感两端就会出现<strong>感应电压</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/46.png"></p><ol type="1"><li>在 <code>0 ~ 1 秒</code> 这段时间内，<strong>电流</strong>的变化率为<span class="math inline">\(\frac{d I_L}{dt} = 1A/s\)</span>，如果电感系数 <span class="math inline">\(L =0.1H\)</span>，那么这段时间产生的<strong>感应电压</strong> <span class="math inline">\(V = 0.1 H \times 1 A/s = 0.1V\)</span>；</li><li>在 <code>1 ~ 2 秒</code> 这段时间内，<strong>电流</strong>保持恒定<span class="math inline">\(\frac{d I_L}{dt} = 0A/s\)</span>，因而这段时间产生的<strong>感应电压</strong>为 <span class="math inline">\(V = 0.1 H \times 0 A/s = 0\)</span>；</li><li>在 <code>2 ~ 3 秒</code> 这段时间内，<strong>电流</strong>变化率为<span class="math inline">\(\frac{d I_L}{dt} = -1A/s\)</span>，则这段时间产生的<strong>感应电压</strong> <span class="math inline">\(V = 0.1 H \times -1 A/s = -0.1V\)</span>；</li></ol><p>假设一个<strong>理想电感</strong> <span class="math inline">\(L\)</span> 与 <code>10V</code>的<strong>电源</strong> <span class="math inline">\(V_s\)</span>通过一个<strong>开关</strong>进行连接：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/47.png"></p><p>当<strong>开关闭合</strong>的一瞬间，根据电感方程 <span class="math inline">\(V_L = L \times \frac{dI_L}{dt}\)</span>，可以推断出 <span class="math inline">\(\frac{dI}{dt}\)</span>将会趋于无穷大，这就意味着<strong>感应电压</strong>的上升情况正比于<strong>电源电压</strong>，电路当中没有电流通过，<strong>反向电压</strong>为无穷大（下图上半部分）。同样的，如果把<strong>开关打开</strong>，则会产生一个无穷大的<strong>同向电压</strong>（下图下半部分）。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/48.png"></p><p>但是在现实世界当中，不可能出现无穷大的电压值，因为<strong>实际电感器</strong>上总是存在着<strong>内阻</strong>以及<strong>内部电容</strong>，所以下面的<strong>实际电感</strong>模型模型当中，就包含进了<code>内阻</code>与<code>电容</code>的参数。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/49.png"></p><p>电感方程之所以没有直接包含一个内阻项的原因，在于<strong>电感系数</strong><span class="math inline">\(L\)</span>是一个独立的参数，其大小只会与<strong>磁场能量的变化</strong>相关，而不会与线圈的<code>电阻</code>与<code>电容</code>损耗相关。分析诸如<strong>RL</strong> 和 <strong>RLC</strong>这类更为复杂的电路时，在电路当中使用分散的电阻，就可以防止电感方程出现<strong>奇异解</strong>。</p><p>当需要进行精确的分析时，如果必须考虑到电感的<strong>内阻</strong>，那么可以使用<strong>理想电感</strong>和<strong>电阻</strong><span class="math inline">\(R_{DC}\)</span>的<strong>串联</strong>来作为<strong>实际电感模型</strong>，这个串联的<span class="math inline">\(R_{DC}\)</span>称为电感的<strong>直流电阻</strong>。如果需要进行更为精确的分析（例如高频电路场景），那就必须同时考虑到内阻和电容效应，此时可以再在理想电感上面并联一个<strong>电阻</strong><span class="math inline">\(R_P\)</span> 和一个<strong>电容</strong><span class="math inline">\(C_P\)</span>，正如上面的示意图所展示的那样。</p><h4 id="lr-充电电路">LR 充电电路</h4><p>下面左图所示的 RL电路由<strong>电阻</strong>与<strong>电感</strong>串联组成，<strong>电阻</strong>会控制输入电感磁场的能量变化速率，而在磁场减小的时候，电阻也会控制能量释放回电路的速率。假设下图左侧电路的<strong>电阻</strong><span class="math inline">\(R = 100Ω\)</span>，而<strong>电感</strong><span class="math inline">\(L = 20mH\)</span>，开关闭合的瞬间 <span class="math inline">\(t =0\)</span>，则其<code>电压</code>与<code>电流</code>的响应曲线如下面右图所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/50.png"></p><p>上述 RL 充电电路的电流与电压方程如下所示，其中 <span class="math inline">\(\tau = \frac{L}{R}\)</span>为<strong>时间常数</strong>，而常数<code>e = 2.718</code>。除此之外，<strong>电流</strong>的单位为<strong>安培</strong>、<strong>电源电压</strong><span class="math inline">\(V_S\)</span> 与<strong>电阻电压</strong><span class="math inline">\(V_R\)</span> 以及<strong>电感电压</strong><span class="math inline">\(V_L\)</span>的单位都为<strong>伏特</strong>、<strong>电阻</strong> <span class="math inline">\(R\)</span>的单位为<strong>欧姆</strong>、<strong>电感系数</strong> <span class="math inline">\(L\)</span> 的单位为<strong>亨利</strong>、而 <span class="math inline">\(t\)</span>表示<strong>接入电源之后的时间</strong>，其单位为<strong>秒</strong>。</p><p><span class="math display">\[\begin{aligned}I = \frac{V_S}{R}(1 - e^{-t/(L/R)}),\ &amp;\frac{t}{(L/R)} = -\ln \big(\frac{1 - V_S/R}{V_S} \big) \\V_R = IR = V_S(1 - e^{-t/(L/R)}),\ &amp;\frac{t}{(L/R)} = -\ln \big(\frac{V_R - V_S}{V_S} \big)  \\V_L = L \frac{dI}{dt} = V_S \cdot e^{-t/(L/R)},\ &amp;\frac{t}{(L/R)} =-\ln \big( \frac{V_L}{V_S} \big)\end{aligned}\]</span></p><p>运用<strong>基尔霍夫电压定律</strong>，对于闭合回路当中的<code>电压</code>进行求和，就可以得到RL 电路的充电响应表达式：</p><p><span class="math display">\[V_S = IR + L \frac{dI}{dt} \implies \frac{dI}{dt} + \frac{R}{L} \times I= \frac{V}{L}\]</span></p><p>求解上述的<strong>非齐次微分方程</strong>，初始条件为开关闭合之前的电流<span class="math inline">\(I(0) = 0\)</span>，由此就可以求解得到电流<span class="math inline">\(I\)</span> 的表达式：</p><p><span class="math display">\[I = \frac{V_S}{R}(1 - e^{-t/(L/R)})\]</span></p><p>将上面的 <span class="math inline">\(I\)</span>代入欧姆定律和电感电压的表达式，分别就可以得到<strong>电阻电压</strong><span class="math inline">\(V_R\)</span> 与<strong>电感电压</strong><span class="math inline">\(V_L\)</span>：</p><p><span class="math display">\[\begin{aligned}&amp; V_R = I \cdot R = V_S(1 - e^{-t/(L/R)}) \\&amp; V_L = L \cdot \frac{dI}{dt} = V_S \cdot e^{-t/(L/R)}\end{aligned}\]</span></p><p>这里假设<strong>电阻值为零</strong>，在没有电阻的情况下闭合开关，根据欧姆定律<code>电流</code>将会持续增大，最终使得<strong>自感电压</strong>与<strong>电源电压</strong>相等。如果电路当中<strong>存在电阻</strong>，那么欧姆定律就会限制电流的大小，此时<strong>电感</strong> <span class="math inline">\(L\)</span>上产生的<strong>反向感应电压</strong>，必须等于<strong>电源电压</strong>与<strong>电阻电压</strong>之差；当电流接近欧姆定律所限制大小的时候，这个感应电压将会变得非常小；由于反向电压在理论上不可能完全消失，电流也不会完全达到欧姆定律所限制的大小。所以在实际情况下，该差值较短时间内就能够降低到可以被忽略的水平。</p><p>当电流达到最大值的 <code>63.2%</code>时，所花费的时间就称为<strong>时间常数</strong>，其值 <span class="math inline">\(\tau\)</span> 等于 <span class="math inline">\(\frac{L}{R}\)</span>，单位为<strong>秒</strong>。每经过<code>1</code> 个时间常数，电路都将会再传输 <code>63.2%</code>的剩余电流，大约经过 <code>5</code>个时间常数之后，就可以认为电流已经达到了最大值。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/51.png"></p><p>如果一个 RL 电路的<strong>电感</strong>为<code>10mH</code>，串联<strong>电阻</strong>值为<code>10Ω</code>，当该电路通电之后，电流达到最大值约需要经过<code>5</code> 个时间常数，所以 <span class="math inline">\(t = 5 \tau =5(L/R) = 5(10 \times 10^{-3}H) / 10Ω = 5.0 \times 10^{-3} 秒 = 50毫秒\)</span>。当电感系数增加到 <code>1.0H</code>的时候，所需要的时间则会增加到 <code>0.5</code>秒。由于电路里的电阻值不变，所以两种情况下电流的最大值都相同。但是增大电感系数之后，电流达到最大值所需要的时间将会变长。下图给出了电路在拥有<strong>相同电阻不同电感</strong>的情况下，<code>电流</code>的响应曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/52.png"></p><h4 id="lr-放电电路">LR 放电电路</h4><p>断开开关之后，电感的磁场会随着电流的消失而消失，储存在磁场当中的能量将会被<strong>释放</strong>回电路。在开关断开的瞬间，由于感应电压与磁场的变化率呈正比，磁场骤降引发的<strong>感应电压</strong>通常比<strong>电源电压</strong>要大上许多倍，进而导致开关触点位置产生火花或者电弧。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/53.png"></p><p>当电路里的<strong>电感系数</strong>以及<strong>电流</strong>很大的时候，就会在短时间之内释放较大的能量，导致开关触点烧蚀熔化。如果在开关触点两端串联上<code>电容</code>和<code>电阻</code>，就可以抑制火花或者电弧，这样用途的<strong>RC电路</strong>被称为<strong>缓冲电路</strong>。下图左侧的电路可以在不断开电路的情况下移除<strong>电源</strong>激励，此时电流将会遵循下图右侧的波形，以及接下来的方程进行<strong>衰减</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/54.png"></p><p>对于上述的 RL放电电路，运用<strong>基尔霍夫定律</strong>，对闭合回路当中的电压进行求和，就可以得到如下的推导过程：</p><p><span class="math display">\[V_S = IR + L \times \frac{dI}{dt}\implies\frac{dI}{dt} + \frac{R}{L} \times I = \frac{V}{L}\]</span></p><p>对于上述的非齐次微分方程进行求解，并且假设初始条件为开关闭合之前的电流<span class="math inline">\(I(0)\)</span>，就可以求解得到电流 <span class="math inline">\(I\)</span>：</p><p><span class="math display">\[I(0) = \frac{V_R}{R} \implies I = \frac{V_S}{R} \cdot e^{-t(L/R)}\]</span></p><p>同样将上面的电流 <span class="math inline">\(I\)</span>代入欧姆定律和电感电压表达式，就可以得到<strong>电阻电压</strong> <span class="math inline">\(V_R\)</span> 与<strong>电感电压</strong> <span class="math inline">\(V_L\)</span>：</p><p><span class="math display">\[\begin{aligned}&amp; V_R = I \cdot R = V_S \cdot e^{-t/(L/R)} \\&amp; V_L = L \cdot \frac{dI}{dt} = - V_S \cdot e^{-t/(L/R)}\end{aligned}\]</span></p><p>类似于之前介绍过的 <strong>RL 充电电路</strong>，<strong>RL放电电路</strong>的电流响应也可以采用<strong>时间常数</strong>来进行表示。在<code>5</code> 个时间常数以后，就可以认为电感放电结束。</p><p>本小节<strong>第 1个电路</strong>里的开关断开，电流被切断，导致感性负载的磁场骤降，进而产生一个较大的<strong>同向感应电压</strong>。当该电压增大至一定程度时，开关触点之间的电压也将会变得很大，进而导致电火花的出现，此时的<code>电流</code>与<code>电压</code>响应曲线会比较复杂。而本小节<strong>第2 个电路</strong>中的开关从位置 <strong>A</strong> 移动至位置<strong>B</strong>，导致电源激励从电路当中断开，此时<strong>电流</strong><span class="math inline">\(I\)</span> 与<strong>电阻电压</strong> <span class="math inline">\(V_R\)</span>、<strong>电感电压</strong> <span class="math inline">\(V_L\)</span> 表达式分别为：</p><p><span class="math display">\[\begin{aligned}I = \frac{V_S}{R}e^{-t/(L/R)},\ &amp;\frac{t}{(L/R)} = -\ln \big(\frac{I \times R}{V_S} \big) \\V_R = IR = V_S \cdot e^{-t/(L/R)},\ &amp;\frac{t}{(L/R)} = -\ln \big(\frac{V_R}{V_S} \big)  \\V_L = L \frac{dI}{dt} = - V_S \cdot e^{-t/(L/R)},\ &amp;\frac{t}{(L/R)}= -\ln \big( \frac{V_L}{V_S} \big)\end{aligned}\]</span></p><p>该电路的<strong>电阻</strong> <span class="math inline">\(R =100Ω\)</span> <strong>电感</strong> <span class="math inline">\(L =20mH\)</span>，而上面方程当中的 <span class="math inline">\(L/R =\tau\)</span> 为<strong>时间常数</strong>，常数<code>e = 2.718</code>。<strong>电流</strong>的单位为<strong>安培</strong>，<strong>电源电压</strong><span class="math inline">\(V_S\)</span> 与<strong>电阻电压</strong><span class="math inline">\(V_R\)</span> 以及<strong>电感电压</strong><span class="math inline">\(V_L\)</span>的单位都为<strong>伏特</strong>，<strong>电阻</strong> <span class="math inline">\(R\)</span>的单位为<strong>欧姆</strong>，<strong>电感系数</strong> <span class="math inline">\(L\)</span> 的单位为<strong>亨利</strong>，而 <span class="math inline">\(t\)</span>表示<strong>接入电源之后的时间</strong>，单位为<strong>秒</strong>。</p><p>无论 RL电路里的<strong>电感系数</strong>大小为多少，都会对输出信号造成影响。例如下图所示的RL电路当中，<code>电感</code>与<code>电阻</code>两端的<strong>输出信号</strong>，会随着电感系数的增大（放电时间延长），进而导致波形失真逐渐加剧：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/55.png"></p><p>接下来，把<strong>频率</strong>为<code>1.0kHz</code>，<strong>周期</strong>为 <span class="math inline">\(T = \frac{1}{f} = \frac{1}{1000 Hz} =1ms\)</span>，<strong>电压</strong>为 <code>0 ~ 5V</code>的方波电压源连接至电阻为 <code>10Ω</code> 的 RL电路，然后增大电感系数，观察波形的变化过程：</p><ol type="1"><li><p>电感系数 <span class="math inline">\(L = 0.1mH\)</span>，时间常数<span class="math inline">\(\tau = \frac{0.0001H}{10Ω} =0.01ms\)</span>，此时 RL 电路的<strong>时间常数</strong>为周期的<code>1%</code>，因而在方波<strong>由高到低</strong>和<strong>由低到高</strong>的变化过程当中，<strong>感应电压</strong>表现为<strong>窄尖峰波形</strong>。假设电感的充放电在<code>5</code> 个时间常数（即<code>0.05ms</code>）以后完成，即在半个周期（<code>0.5ms</code>）之内完成充放电，因而<strong>电阻电压</strong>的波形边缘会略带弧度：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/56.png"></p></li><li><p>电感系数 <span class="math inline">\(L = 1mH\)</span>，时间常数<span class="math inline">\(\tau = \frac{0.001H}{10Ω} =0.1ms\)</span>，此时 RL 电路的<strong>时间常数</strong>为周期的<code>10%</code>，因而在电源电压的变化过程当中，感应电压呈指数规律进行升降的效果较为明显。其完全充放电所需的<code>5</code> 个时间常数为<code>0.5ms</code>，正好是周期的一半。所以在每半个周期里，电感都可以完全吸收、释放其磁场能量：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/57.png"></p></li><li><p>电感系数 <span class="math inline">\(L = 10mH\)</span>，时间常数<span class="math inline">\(\tau = \frac{0.01H}{10Ω} =1ms\)</span>，此时 RL电路的<strong>时间常数</strong>与方波周期相等，但由于需要 <code>5</code>个时间常数（即<code>5ms</code>）来完成充放电过程，所以<strong>感应电压</strong>近似为线性变化，其波形按照指数函数进行小幅度升降。在半个周期之内，电感的磁场并不能完全吸收、释放其磁场能量：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/58.png"></p></li><li><p>电感系数 <span class="math inline">\(L = 1H\)</span>，时间常数<span class="math inline">\(\tau = \frac{1H}{10Ω} = 0.1s\)</span>，此时RL 电路的<strong>时间常数</strong>为周期的 <code>100</code>倍，电感完全充放电所需的 <code>5</code> 个时间常数等于周期的<code>500</code>倍。换而言之，电感没有足够的时间来完成充放电。虽然波形仍然呈指数规律升降，但是实际只占据初始值的<span class="math inline">\(\frac{1}{500}\)</span>，其波形可以近似为一条直线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/59.png"></p></li></ol><h4 id="开关尖峰电压">开关尖峰电压</h4><p>携带有诸如<code>继电器</code>、<code>螺线管</code>、<code>电动机</code>等较大感性负载的电路当中，机械或者晶体管的开关操作经常会引发<strong>尖峰状的感应电压</strong>。即使电源电压较小的时候，所形成的尖峰电压也可以高达数百伏。尖峰电压会引发<strong>电弧</strong>，造成开关触点性能下降或者晶体管损坏。下图所示的电路，将一个可以让电流单向流动的<strong>二极管</strong>，并联至<code>继电器</code>的线圈两端，从而在需要断开电路时，为<strong>尖峰电压</strong>提供<strong>缓冲路径</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/60.png"></p><h4 id="直导线电感">直导线电感</h4><p>通电的直线导体（非线圈）周围都会存在<strong>磁场</strong>，因而也就存在着<strong>自感系数</strong>，一段<strong>非磁性材料</strong>制成的直导线电感值为：</p><p><span class="math display">\[电感 L = 0.00508 \times 导线长度 b \bigg[ \ln \bigg(\frac{2 \times导线长度 b}{导线半径 a} \bigg) - 0.75 \bigg]\]</span></p><p>上面公式里的<strong>电感</strong>单位为<strong>毫亨</strong> <span class="math inline">\(\mu H\)</span>，<strong>导线半径</strong> <span class="math inline">\(a\)</span> 与<strong>导线长度</strong> <span class="math inline">\(b\)</span>的单位为英尺（<code>1 inch = 30.48 cm</code>），而 <span class="math inline">\(\ln\)</span> 为<strong>自然对数</strong>。</p><p>直导线的电感值较小，通常被称为<strong>寄生电感</strong>。低频时寄生电感的电抗为零，例如<code>10MHz</code> 的时候，<span class="math inline">\(0.106 \muH\)</span> 电感的电抗仅为 <code>6.6Ω</code>；但是当频率上升至<code>300MHz</code> 时，其电抗就会上升至不容忽视的<code>200Ω</code>。因而在高频电路当中，应当尽可能的<strong>缩短元件的引脚端</strong>。由于导线总是与元件相互串联，一个元件的寄生电感可以通过在该元件上<strong>串联</strong>一枚数值相近的<strong>电感器</strong>来模拟。</p><blockquote><p><strong>注意</strong>：超高频率（<code>30MHz ~ 300MHz</code>）电路当中，由于集肤效应的存在，上面的公式会有一些微小的改变。当频率接近于无穷大时，上述公式中的常数<code>0.75</code> 可以近似为 <code>1</code>。</p></blockquote><h4 id="互感现象">互感现象</h4><p>如果两个电感线圈沿着相同的轴线进行放置，那么流过<strong>线圈1</strong> 的电流所形成的磁通将会通过<strong>线圈2</strong>。当<strong>线圈 1</strong> 的磁场强度发生改变时，<strong>线圈2</strong>上将会产生感应电压。这个感应电压类似于自感电压，由于属于外部<strong>线圈1</strong>的作用结果，因而被称为<strong>互感电压</strong>，而这种现象就被称作<strong>互感</strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/61.png"></p><p>上述两个线圈的关系称为<strong>感应耦合</strong>，它们靠得越近，互感就会越强。如果两个线圈间隔较远，或者并不处于相同的轴线上面，那么互感就会相对较弱，此时两个线圈称为<strong>松耦合</strong>。</p><p>互感系数的<strong>实际值</strong>与其<strong>最大值</strong>的比值，称为<strong>耦合系数</strong>，通常采用分数来进行表示。如果将一个空芯线圈<strong>缠绕</strong>在另一个空芯线圈的上面，那么两个线圈的耦合系数将会达到<code>0.6 ~ 0.7</code>。如果将它们分开进行放置，那么耦合系数就会相对较小。当线圈绕制在<strong>闭合磁芯</strong>上面的时候，其耦合系数甚至可以达到<code>100%</code>。</p><blockquote><p><strong>注意</strong>：互感原理主要应用于<strong>变压器</strong>当中，而在设计电路的时候，互感现象会产生一些不良后果。例如元件位置靠得太近的时候，或者感性负载、大电流交流电缆造成外部磁场波动的时候，电路当中就会出现错误的互感电压信号干扰。</p></blockquote><h4 id="电感的串联">电感的串联</h4><p>当两个或者两个以上的电感器<strong>串联</strong>时（电感之间需要保持一定距离，避免相互之间的磁场干扰）：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/62.png"></p><p><strong>总电感量</strong> <span class="math inline">\(L_{total}\)</span>等于<strong>每一个</strong>串联电感器上面的电感量之<strong>和</strong>：</p><p><span class="math display">\[L_{total} = L_1 + L_2 + L_3 + ... + L_n\]</span></p><p>上述串联电感的计算公式，也可应用<strong>基尔霍夫电压定律</strong>推导得出，将<strong>电感</strong><span class="math inline">\(L_1\)</span> 的电压记为 <span class="math inline">\(L_1 \frac{dI}{dt}\)</span>，<strong>电感</strong><span class="math inline">\(L_2\)</span> 的电压记为 <span class="math inline">\(L_2 \frac{dI}{dt}\)</span>，<strong>电感</strong><span class="math inline">\(L_3\)</span> 的电压记为 <span class="math inline">\(L_3 \frac{dI}{dt}\)</span>，那么下面公式当中的<span class="math inline">\((L_1 + L_2 + L_3)\)</span>部分就是<strong>串联等效电感</strong>：</p><p><span class="math display">\[V = L_1 \frac{dI}{dt} + L_2 \frac{dI}{dt} + L_3 \frac{dI}{dt} = (L_1 +L_2 + L_3) \frac{dI}{dt}\]</span></p><h4 id="电感的并联">电感的并联</h4><p>当两个或者两个以上的电感器进行<strong>并联</strong>时（电感之间同样保持一定距离，避免相互之间的磁场干扰）：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/63.png"></p><p><strong>总电感量</strong> <span class="math inline">\(L_{total}\)</span>的倒数就等于<strong>每一个</strong>并联电感器上面电感量的倒数之<strong>和</strong>：</p><p><span class="math display">\[\frac{1}{L_{total}} = \frac{1}{L_1} + \frac{1}{L_2} + \frac{1}{L_3} +... + \frac{1}{L_n}\]</span></p><p>如果当前只存在<strong>两个电感器进行并联</strong>，那么上述的计算公式就可以简化为如下形式：</p><p><span class="math display">\[L_{total} = \frac{L_1 \times L_2}{L_1 + L_2}\]</span></p><p>该并联电感的计算公式，可以采用<strong>基尔霍夫电流定律</strong>推导获得。由于并联电流<span class="math inline">\(I = I_1 + I_2 + I_3\)</span>，并且电感 <span class="math inline">\(L_1\)</span>、<span class="math inline">\(L_2\)</span>、<span class="math inline">\(L_3\)</span>之间的端电压相等，各个并联电感器上的电流可以分别表示为 <span class="math inline">\(I_1 = \frac{1}{L_1} \int Vdt\)</span>、<span class="math inline">\(I_2 = \frac{1}{L_2} \int Vdt\)</span>、<span class="math inline">\(I_3 = \frac{1}{L_3} \int Vdt\)</span>，那么电流<span class="math inline">\(I\)</span> 就可以表示为如下形式，其中的<span class="math inline">\((\frac{1}{L_1} + \frac{1}{L_2} +\frac{1}{L_3})\)</span> 部分就是<strong>并联等效电感</strong>：</p><p><span class="math display">\[I = I_1 + I_2 + I_3 = \frac{1}{L_1} \int Vdt + \frac{1}{L_2} \int Vdt +\frac{1}{L_3} \int Vdt= \bigg( \frac{1}{L_1} + \frac{1}{L_2} + \frac{1}{L_3} \bigg) \int Vdt\]</span></p><p>▶【例题】下图所示电路的等效总电感值为 <code>70mH</code>，求解电感<span class="math inline">\(L_2\)</span> 的值 ？</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/64.png"></p><p>◉【解】根据上面电路图里的参数与题设条件，经过如下的一系列推导步骤，就可以计算出<span class="math inline">\(L_2\)</span> 的电感值等于<code>30mH</code>：</p><p><span class="math display">\[L_{total} = L_1 + \frac{L_2 \times L_3}{L_2 + L_3}\implies70mH = 50mH + \frac{60mH \times L_2}{60mH + L_2}\impliesL_2 = 30mH\]</span></p><h4 id="电感与交流信号">电感与交流信号</h4><p>当在<strong>理想电感器</strong>两端接入交流电压的时候，经过电感器的<strong>电流</strong>会<strong>滞后</strong>于<strong>电压</strong>，这与交流信号下<strong>电容器</strong>的特性正好相反。下图为理想电感电路当中的交流信号的<strong>电流</strong>、<strong>电压</strong>、<strong>功率</strong>曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/65.png"></p><p>造成滞后的根本原因在于电感器产生了<strong>反向电压</strong>，由于<strong>反向电压的大小与电流的变化率呈正比</strong>：</p><ol type="1"><li>在 <code>0 ~ A</code>时间段，电源电压为正向最大值，反向电压（感应电压）也为最大值，此时经过的电流最小，但是电流的变化率达到了<code>38%</code> 的最大值；</li><li>在 <code>A ~ B</code> 时间段，电流变化了<code>33%</code>，感应电压与电源电压同步减小。该过程会在<code>B ~ C</code> 与 <code>C ~ D</code>时间段持续进行，随着电源电压以及感应电压趋于<strong>零</strong>，电流仅仅只增加了<code>8%</code>；</li><li>在 <code>D ~ E</code>时间段，电源电压改变了方向，感应电压也会相应的改变方向。伴随着磁场的减小，电流开始返回电路，此时电流的方向与电源电压方向相反，但是仍然处于正向。随着电源电压在反方向继续增大，正向的电流值开始减小，当电源电压为反相最大值时电流为<strong>零</strong>；</li><li>接下来，负半周的变化过程与正半周的情况相同，因而可以认为纯电感电路当中的交流信号，其<strong>电流</strong>总是滞后于<strong>电压</strong><code>90°</code>；</li></ol><h4 id="感抗">感抗</h4><p>类似于容抗，<strong>感抗</strong>是<code>电感</code>与交流信号<code>频率</code>的综合效应，其单位也采用<strong>欧姆</strong><code>Ω</code>，具体的计算公式如下面所示：</p><p><span class="math display">\[感抗 X_L = 2 \pi \times 频率 f \times 电感 L\]</span></p><p>上述公式当中的 <span class="math inline">\(\pi =3.1416\)</span>，<strong>频率</strong> <span class="math inline">\(f\)</span> 的单位为<strong>赫兹</strong><code>Hz</code>，<strong>电感</strong> <span class="math inline">\(L\)</span> 的单位为<strong>亨利</strong><code>H</code>。除此之外，感抗还可以采用<strong>角频率</strong>来进行描述：</p><p><span class="math display">\[感抗 X_L = 角频率 \omega \times 电感 L\]</span></p><p>为了使得计算更加简便，可以采用<strong>余弦函数</strong>代替<strong>正弦函数</strong>，例如电源电压的表达式为<span class="math inline">\(V_0 \cos (\omegat)\)</span>，则电感元件上面经过的电流 <span class="math inline">\(I\)</span> 等于：</p><p><span class="math display">\[I = \frac{1}{L} \int Vdt = \frac{1}{L} \int V_0 \cos(\omega t) dt=  \frac{V_0}{\omega L} \sin(\omega t)\]</span></p><p>当上面等式当中的 <span class="math inline">\(\sin(\omega t) =1\)</span> 的时候，电感上经过的<strong>电流</strong>将会达到最大值 <span class="math inline">\(I_0 = \frac{V_0}{\omegaL}\)</span>。<strong>峰值电压</strong>与<strong>峰值电流</strong>的比值具有<strong>欧姆</strong><code>Ω</code>的量纲，其体现了<strong>反向感应电压</strong>抵抗<strong>正向电压</strong>的效应，这种效应就称之为<strong>感抗</strong>：</p><p><span class="math display">\[X_L = \frac{V_0}{I_0} = \frac{V_0}{\frac{V_0}{\omega L}} = \omega L\]</span></p><p>当<strong>角频率</strong> <span class="math inline">\(\omega\)</span>趋向于无穷大时，<strong>感抗</strong> <span class="math inline">\(X_L\)</span>也将会趋于无穷大，此时电感相当于<strong>开路</strong>，说明电感会<strong>阻碍高频信号的通过</strong>。但当<strong>角频率</strong> <span class="math inline">\(\omega\)</span>趋于零的时候，<strong>感抗</strong> <span class="math inline">\(X_L\)</span>也将会趋于<strong>零</strong>，说明<strong>低频信号可以轻松的通过</strong>。</p><blockquote><p><strong>注意</strong>：在<strong>理想电感</strong>通过<strong>直流信号</strong>的情况下，就不需要考虑到<strong>阻抗</strong>的概念。</p></blockquote><p>下图分别为 <span class="math inline">\(1\mu H\)</span>、<span class="math inline">\(10\mu H\)</span>、<span class="math inline">\(100\mu H\)</span>电感器的<code>感抗</code>，伴随着<code>频率</code>进行变化的<strong>对数坐标图</strong>。可以看到其响应曲线呈线性。当<code>频率</code>增大的时候，对应的<code>感抗</code>也会随之呈正比增大：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/66.png"></p><p>由于实际电感器的内部存在着<strong>寄生电阻</strong>与<strong>寄生电容</strong>，因而真实的感抗响应曲线将会比较复杂，下图为实际电感器的<code>阻抗</code>伴随着<code>频率</code>进行变化的曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/67.png"></p><blockquote><p><strong>注意</strong>：当频率接近电路的<strong>振荡频率</strong>时，阻抗曲线就不会再呈现为<strong>线性</strong>，而是达到峰值之后就开始下降，后续振荡电路部分的内容将会对其进行更为详细的介绍。</p></blockquote><h4 id="实际电感模型">实际电感模型</h4><p>实际电感模型可以通过<strong>串联电感</strong> <span class="math inline">\(L\)</span>、<strong>串联电阻</strong> <span class="math inline">\(R_{DC}\)</span>、<strong>并联电容</strong> <span class="math inline">\(C_P\)</span>、<strong>并联电阻</strong> <span class="math inline">\(R_P\)</span> 四个无源理想元件来进行模拟：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/68.png"></p><ul><li><strong>直流电阻</strong> <span class="math inline">\(R_{DC}\)</span>表示的是电感通过直流信号时候的阻值，该参数通常由生产厂商的数据手册提供；</li><li><strong>并联电阻</strong> <span class="math inline">\(R_P\)</span>表示的是<strong>磁芯损耗</strong>，可以根据自谐振频率为 <span class="math inline">\(f_0\)</span> 的时刻，电感的感抗为<code>0</code>（即阻抗表现为纯电阻）求解得到，或者也可以通过<strong>品质因数Q</strong> 进行求解；</li><li><strong>并联电容</strong> <span class="math inline">\(C_P\)</span>表示电感的<code>线圈</code>与<code>引脚</code>之间的分布电容；</li></ul><p>当电感通过交流信号的时候，电感两端的电压将会发生变化，其作用等效于多个<strong>电容</strong>与电感线圈的<strong>并联</strong>。下图展示了<strong>分布电容</strong>与<strong>电感</strong>发生谐振时的曲线，低于谐振频率时阻抗呈<strong>感性</strong>，其值随着频率的增大而减小；而高于谐振频率时阻抗呈<strong>容性</strong>，其值会随着频率的增大而增大：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/69.png"></p><blockquote><p><strong>注意</strong>：<strong>实际电感器</strong>往往存在着多种形式的损耗，例如<code>导线电阻损耗</code>、<code>磁芯损耗</code>、<code>集肤效应损耗</code>。除此之外，当交流信号的频率增大时，电流将会集中到导体的表面，这种特性称为<strong>集肤效应</strong>，因而电感线圈还存在着集肤效应引发的损耗。</p></blockquote><h4 id="品质因数-q-1">品质因数 Q</h4><p><strong>电容</strong>与<strong>电感</strong>这类储能元件的性质，都可以采用<strong>品质因数Q</strong>来进行描述，其值等于储能元件<strong>存储的能量</strong>（感抗）与<strong>消耗能量</strong>（电阻）的比值：</p><p><span class="math display">\[品质因数 Q = \frac{电抗 X}{电阻 R}\]</span></p><blockquote><p><strong>注意</strong>：上述方程当中的<strong>品质因数 Q</strong>没有量纲，而 <span class="math inline">\(X\)</span>为<strong>电抗</strong>（<code>感抗</code>或者<code>容抗</code>），<strong>电阻</strong><span class="math inline">\(R\)</span>表征电感元件实际损耗的全部能量。</p></blockquote><p>电容器通常具备较高的 <strong>Q</strong> 值，例如陶瓷电容器的<strong>Q</strong> 值可以达到 <code>1200</code> 以上。而电感的品质因数为<span class="math inline">\(Q = \frac{2 \pi fL}{R_{DC}}\)</span>，当电路当中同时包含有<code>电感</code>和<code>电容</code>时，电感的<strong>Q</strong> 值并不会等于电容的 <strong>Q</strong> 值。</p><blockquote><p><strong>注意</strong>：多数情况下，电路都会要求使用更高品质因数的电感，然而有些电路则会要求使用比较特殊的<strong>Q</strong> 值参数。</p></blockquote><p><strong>感性分压器</strong>经常被应用在输入交流信号的电路当中，根据电阻分压的原理，交流输入电压将会按照两个电感的电阻关系进行分配，具体请参考下面的电路图与公式：</p><p><img src="/Electronics/Practical_Electronics/Chapter-4/70.png"></p><blockquote><p><strong>注意</strong>：上述电路的<strong>输出电压</strong>与<strong>输入频率</strong>无关，但是如果电感器的<strong>感抗</strong>在指定工作频率上不够高（即电感值不够大），那么并联元件<span class="math inline">\(L_2\)</span>将会如同<strong>短路</strong>，从而产生非常大的电流。</p></blockquote><p>电子学当中，电感器的基本功能是以<strong>磁场</strong>的形式存储电量，<strong>电感器</strong>与<strong>电容器</strong>等其它元件组合起来，就可以形成用于滤除特殊频率信号的<strong>滤波器</strong>。除此之外，两个或者两个以上的耦合线圈，还可以构成用于对交流电压进行升压与降压的<strong>变压器</strong>。而在开关电源当中，电感器可以控制稳压器在开关频率的特定部分进行充电，而在剩余的周期内进行放电，充放电比例决定了输出与输入电压的比值。</p><h2 id="正弦电路分析">正弦电路分析</h2><p>下图所示的电路当中包含有<code>电阻</code>、<code>电容</code>、<code>电感</code>，以及<code>正弦电压源</code>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/1.png"></p><p>应用<strong>基尔霍夫电压定律</strong>就可以得到下面的推导过程：</p><p><span class="math display">\[V_0 \cos (\omega t) = IR + L \frac{dI}{dt} + \frac{1}{C} \int I dt\impliesL\frac{d^2 I}{dt^2} + R \frac{dI}{dt} + \frac{1}{C} I = - \omega V_0\sin(\omega t)\]</span></p><p>上述等式是一个<strong>二阶线性非齐次常微分方程</strong>，通过<code>参数变换</code>或者<code>待定系数法</code>求解方程，并将求解得到的电流代入<strong>电阻</strong>、<strong>电容</strong>、<strong>电感</strong>的<code>电压</code>与<code>电流</code>关系方程，通过繁杂的数学运算就可以求解得到各个元件上的电压。上面这个电路相对较为简单，而对于下图这种较为复杂的电路，如果继续运用基尔霍夫定律对<strong>回路</strong>与<strong>节点</strong>列写微分方程，那么涉及的运算将会变得极为复杂：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/2.png"></p><blockquote><p><strong>注意</strong>：通过<strong>复阻抗</strong>的概念以及相应的复数运算，就可以完全规避复杂的微分方程求解过程。</p></blockquote><h3 id="复阻抗分析正弦电路">复阻抗分析正弦电路</h3><p>一个采用正弦电源作为激励的电路，所有的<code>电压</code>与<code>电流</code>都是正弦量，它们会与正弦电压源的输出同频率变化。如果电路当中存在<strong>电容器</strong>和<strong>电感器</strong>，那么<code>电压</code>与<code>电流</code>的<strong>幅值</strong>与<code>电压源</code>的幅值成正比，而<code>电压</code>与<code>电流</code>的<strong>波形</strong>相对于<code>电压源</code>的波形存在着相位差。利用正弦电路的<code>电压</code>与<code>电流</code>都属于<strong>同频率正弦量</strong>的特点，就可以避免以求解微分方程的方式来分析动态电路。</p><p><strong>叠加原理</strong>指出在具有<strong>多个正弦电源</strong>的线性电路当中，任意一个支路上的<code>电流</code>等于各个<strong>电源</strong>单独作用时产生的电流之和。利用基尔霍夫定律可以证明这个结论，将基尔霍夫定律应用于线性电路，从而得到一组线性方程，将它们简化为只包含有1个未知数的单一方程，如果未知量是支路电流，那么可以将其表达为具有适当系数的各个<strong>电源</strong>的叠加。换而言之，就是无需再计算<strong>时间</strong>相关的未知量，由于这些未知量的形式总是<span class="math inline">\(\cos(\omega t +\varPhi)\)</span>，因而只需要计算其<strong>峰值</strong>（或者<strong>RMS均方根值</strong>）以及<strong>相位角</strong>，再运用叠加原理进行求解即可。</p><p>具有<strong>相同频率</strong>、<strong>不同相位</strong>的两个正弦波叠加，得到的将会是一个具有<strong>相同频率</strong>的新正弦波：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/3.png"></p><p>而对于<strong>频率</strong>不同的正弦波，叠加之后得到的将不再是一个<strong>正弦波</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/4.png"></p><p><strong>频率</strong>相同、<strong>相位</strong>不同的两个方波，叠加之后所获得的并不一定就是一个<strong>方波</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/5.png"></p><p>本文在《数学预备知识》章节，介绍过采用<strong>复数</strong>表示<strong>正弦量</strong>的相关概念。例如，当<span class="math inline">\(\theta\)</span> 在 <span class="math inline">\(0° \sim 360°\)</span> 范围变化时，复数的三角形式<span class="math inline">\(z = r \cdot \cos \theta + j \times r \cdot\sin \theta\)</span>在<strong>复平面</strong>上的轨迹是一个<strong>圆周</strong>。如果取<span class="math inline">\(z\)</span> 相对于 <span class="math inline">\(\theta\)</span>的<strong>实部</strong>来绘制曲线，就可以得到一个<strong>正弦波</strong>；而通过改变<span class="math inline">\(r\)</span>的值，就可以改变正弦波的<strong>幅值</strong>；让 <span class="math inline">\(\theta\)</span>乘以一个系数，就可以改变正弦波的<strong>频率</strong>；让 <span class="math inline">\(\theta\)</span>加上一个数值（<code>度</code>或者<code>弧度</code>)，就能够与同频率的正弦波产生<strong>相位差</strong>。</p><blockquote><p><strong>注意</strong>：如果将 <span class="math inline">\(\theta\)</span> 替换为 <span class="math inline">\(\omega t\)</span>（其中 <span class="math inline">\(\omega = 2 \pi f\)</span>），把 <span class="math inline">\(r\)</span> 替换为 <span class="math inline">\(V_0\)</span>，同时为 <span class="math inline">\(\omega t\)</span>添加相位差，就可以得到以复数形式表示的<strong>电压源</strong>，采用类似的办法也可以表示<strong>电流源</strong>。</p></blockquote><p>相比于<strong>正弦函数</strong>，<strong>复数</strong>的优势在于可以采用多种形式（<code>直角坐标系</code>、<code>三角</code>、<code>指数</code>、<code>极坐标</code>）进行表示，从而简化叠加过程当中的数学运算。例如，将<strong>复数</strong>转化成<code>直角坐标形式</code>之后，就可以容易的进行加减运算，而转化为指数形式与极坐标形式，则可以很容易的进行乘除运算。</p><p><code>电流</code>与<code>电压</code>的值事实上都属于<strong>实数</strong>，并不存在<strong>虚数</strong>的<code>电压</code>与<code>电流</code>。之所以存在<strong>虚部</strong>是因为需要引入<strong>相位</strong>的概念，所以采用复数形式进行叠加之后，所得到的最终结果必须转换为<strong>实数</strong>，即必须将复数结果转换为<code>三角形式</code>、<code>指数形式</code>、<code>极坐标形式</code>，并且移除<strong>虚部</strong>。例如下面等式当中的电压采用RMS 均方根值，将等式左侧的复数，转换为右侧的指数和极坐标形式：</p><p><span class="math display">\[V(t) = 5V + j10V \implies\sqrt{(5.0V)^2 + (10.0V)^2} e^{j 63.4°}\approx (11.2V) e^{j 63.5°}= 11.2V \angle 63.5°\]</span></p><p>经过上述推导过程，就可以得到<strong>电压</strong> <span class="math inline">\(V(t)\)</span> 的 <strong>RMS</strong> 值为<code>11.2V</code>，由于<strong>相位</strong> <span class="math inline">\(\angle 63.5°\)</span>往往无关紧要，所以这里直接将其忽略。</p><h3 id="复数表示正弦电压源">复数表示正弦电压源</h3><p>假设正弦电压为 <span class="math inline">\(V_0 \cos (\omegat)\)</span>，其中 <span class="math inline">\(\omega = 2 \pif\)</span>，将其转换为 <span class="math inline">\(V_0 \cos (\omega t) +j V_0 \sin(\omega t)\)</span>，这个等式当中的 <span class="math inline">\(j V_0 \sin(\omega t)\)</span>是没有任何物理意义的<strong>虚数</strong>，虽然不会影响到实际的电压表达式，但是在叠加计算过程当中会使用到它。接下来为了便于计算，需要使用<strong>欧拉公式</strong><span class="math inline">\(e^{j \theta} = r \cos(\theta) + jr\sin(\theta)\)</span>将<strong>三角形式</strong>转换为<strong>指数形式</strong> <span class="math inline">\(V_0 \cdot e^{j(\omegat)}\)</span>，或者<strong>极坐标形式</strong> <span class="math inline">\(V_0 \angle (\omega t)\)</span>。</p><p>上述的电压可以在<strong>复平面</strong>当中，采用一个角频率为 <span class="math inline">\(\omega\)</span>，并且沿着<strong>逆时针</strong>方向旋转的<strong>矢量</strong>来进行表示。其中，矢量长度表示电压<span class="math inline">\(V_0\)</span>的最大值，而该矢量在<strong>实轴</strong>的投影表示 <span class="math inline">\(V\)</span>的<code>实部</code>或者<code>瞬时值</code>，在<strong>虚轴</strong>上的投影表示的则是<span class="math inline">\(V\)</span> 的<code>虚部</code>:</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/6.png"></p><p>得到电压的复数表达式之后，分别将其代入<strong>电阻</strong>（<span class="math inline">\(I =\frac{V}{R}\)</span>）、<strong>电容</strong>（<span class="math inline">\(I = C\frac{dV}{dt}\)</span>）、<strong>电感</strong>（<span class="math inline">\(I = \frac{1}{L} \intVdt\)</span>）的表达式，进而分别得到<strong>电流</strong>的复数表达式，比较每种元件的<code>电流</code>以及<code>电压</code>的<strong>相位差</strong>，就能够得到下面的示意图：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/7.png"></p><ul><li><strong>电阻</strong>：<code>电压</code>与<code>电流</code>同相，相位差<span class="math inline">\(\varPhi =0°\)</span>，该特性也可以在复平面上表示，其中<code>电压</code>与<code>电流</code>的矢量都具有相同的辐角，两者都以<strong>角频率</strong><span class="math inline">\(\omega = 2 \pi f\)</span>沿逆时针方向进行旋转；</li><li><strong>电容</strong>：<code>电流</code>的相位大于<code>电压</code>有<code>+90°</code>，即<code>电流</code>超前于<code>电压</code>有<code>90°</code>，通常规定<strong>相位差</strong> <span class="math inline">\(\varPhi\)</span>为从<code>电流矢量</code>指向<code>电压矢量</code>的角度，当 <span class="math inline">\(\varPhi\)</span>为<strong>正</strong>时电流超前，当 <span class="math inline">\(\varPhi\)</span>为<strong>负</strong>时电流滞后；</li><li><strong>电感</strong>：<code>电流</code>的相位大于<code>电压</code>有<code>-90°</code>，即<code>电流</code>滞后于<code>电压</code>有<code>90°</code>；</li></ul><p>这种在<strong>复平面</strong>上采用<code>电压</code>与<code>电流</code>的<strong>幅值</strong>与<strong>相位角</strong>表示的图形称为<strong>相量图</strong>，相量与依赖于时间的数学函数不同，它只是提供了某一个瞬间或时刻的<code>相位</code>与<code>幅值</code>。接下来，再介绍一种重要的交流电路分析方法，如果分别将<code>电阻</code>、<code>容抗</code>、<code>感抗</code>元件上的<code>电压</code>除以<code>电流</code>，就可以得到下图所示的结果：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/8.png"></p><blockquote><p><strong>注意</strong>：上图当中的 <span class="math inline">\(V_0\cdot e^{j(\omega t)}\)</span>项被消去，得到<code>电阻</code>、<code>容抗</code>、<code>感抗</code>的复数形式。这些表达式只是<code>频率</code>的函数，而与<code>时间</code>无关，从而避免求解微分方程。</p></blockquote><p>正弦激励电路当中，把<code>容抗</code>与<code>感抗</code>表示为复数，就可以将<code>电容</code>和<code>电感</code>视为频率敏感的电阻，采用这些电阻替代直流电路当中的电阻，再将直流电源切换为正弦电源，并将所有的<code>电压</code>、<code>电流</code>、<code>电阻</code>、<code>阻抗</code>转换为复数形式，分别代入<code>欧姆定律</code>、<code>基尔霍夫定律</code>、<code>戴维南定理</code>等<strong>电路定理</strong>建立方程，通过简单的复数运算就能够进行求解。例如<strong>交流欧姆定律</strong>可以表示为<span class="math inline">\(V(\omega) = I(\omega) \timesZ(\omega)\)</span>，其中的 <span class="math inline">\(Z\)</span>就是<strong>复阻抗</strong>，一种以复数形式描述元件对于电流阻碍作用的方法。复阻抗可以只是<code>电阻</code>、<code>容抗</code>、<code>感抗</code>，也可以是<code>电阻</code>与<code>电抗</code>元件的组合：</p><p><span class="math display">\[\begin{cases}电阻 &amp;V_R = I_R \times R \\电容 &amp;V_C = I_C \times X_C = I_C \big( - j \frac{1}{\omega C} \big)= - j \frac{I_C}{\omega C} = \frac{I_C}{\omega C} \angle -90° \\电感 &amp;V_L = I_L \times X_L = I_L (j \omega L) = j I_L \omega L = I_L\omega L \angle + 90° \\复阻抗 &amp;V_Z = I_Z \times Z\end{cases}\]</span></p><p>下图展示了之前讨论过的<strong>正弦电压源</strong>的相量表示，以及<code>电阻</code>、<code>电容</code>、<code>电感</code>的<strong>复阻抗</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/9.png"></p><p>将<strong>复阻抗</strong>视为频率敏感的电阻，通过串联电阻的等效公式，就可以求解得到<strong>复阻抗串联之后的等效复阻抗</strong><span class="math inline">\(Z_{total}\)</span>：</p><p><span class="math display">\[Z_{total} = Z_1 + Z_2 + Z_3 + ... + Z_N\]</span></p><p>换而言之，之前的<strong>直流分压电路</strong>，可以转变成一个<strong>交流分压电路</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/10.png"></p><p>相应的，将 <span class="math inline">\(N\)</span>个复阻抗进行<strong>并联</strong>，其<strong>等效阻抗</strong> <span class="math inline">\(Z_{total}\)</span> 的表达式如下所示：</p><p><span class="math display">\[Z_{total} = \frac{1}{\frac{1}{Z_1} + \frac{1}{Z_2} + \frac{1}{Z_3} + ...+ \frac{1}{Z_N}}\]</span></p><p>特别的，如果当前只有两个<strong>复阻抗</strong>进行<strong>并联</strong>，那么上述公式可以简化为下面的形式：</p><p><span class="math display">\[Z_{total} = \frac{Z_1 Z_2}{Z_1 + Z_2}\]</span></p><p>同样的，之前的<strong>直流分流电路</strong>，也可以转变为一个<strong>交流分流电路</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/11.png"></p><p>更为重要的是，可以将<strong>复阻抗</strong>代入<strong>基尔霍夫电压定律</strong>，通过建立回路方程来求解拥有<strong>多个节点</strong>的复杂电路：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/12.png"></p><p>▶【例题】下图的 RL 串联电路由一个输出电压为 <code>12VAC</code>（RMS均方根值），频率为 <code>60Hz</code> 的电源激励，已知电路当中的电感<span class="math inline">\(L = 265mH\)</span>，电阻 <span class="math inline">\(R = 50Ω\)</span>，求解 <span class="math inline">\(I_S\)</span>、<span class="math inline">\(I_R\)</span>、<span class="math inline">\(I_L\)</span>、<span class="math inline">\(V_R\)</span>、<span class="math inline">\(V_L\)</span>，以及<code>视在功率</code>、<code>有功功率</code>、<code>无功功率</code>、<code>功率因数</code>？</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/13.png"></p><p>◉【解】首先，计算出<strong>感抗</strong> <span class="math inline">\(X_L\)</span>：</p><p><span class="math display">\[X_L = j \omega L = j(2 \pi \times 60Hz \times 265 \times 10^{-3} H) = j100Ω\]</span></p><p>◉【解】因为该电路当中的<strong>电阻</strong>与<strong>电感</strong>串联，所以采用<strong>直角坐标形式</strong>的复数相加，进而得到<strong>等效阻抗</strong><span class="math inline">\(Z\)</span>：</p><p><span class="math display">\[Z = R + X_L = 50 Ω + j100 Ω\]</span></p><p>◉【解】接下来，再将上面求解得到的<strong>等效阻抗</strong> <span class="math inline">\(Z\)</span> 转换为<strong>极坐标形式</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/14.png"></p><p><span class="math display">\[Z = \sqrt{50^2 + 100^2} \angle \arctan \big( \frac{100}{50} \big) = 112Ω\angle 63.4°\]</span></p><p>◉【解】利用交流欧姆定律，就可以求解得到<strong>电流</strong> <span class="math inline">\(I_S\)</span>：</p><p><span class="math display">\[I_S = \frac{V_S}{Z_{total}} = \frac{12 VAC \angle 0°}{112Ω \angle 63.4°}= 0.107A \angle -63.4°\]</span></p><p>◉【解】上面等式当中的 <code>-63.4°</code>表示电流滞后于电源电压，由于串联电路当中 <span class="math inline">\(I =I_R =I_L\)</span>，利用交流<strong>欧姆定律</strong>和<strong>分压公式</strong>就可以求解出<strong>电阻</strong><span class="math inline">\(R\)</span> 与<strong>电感</strong> <span class="math inline">\(L\)</span> 两端的电压：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/15.png"></p><p><span class="math display">\[\begin{cases}V_R = I \times R = (0.107A \angle -63.4°)(50Ω \angle 0°) = 5.35 VAC\angle -63.4° \\V_L = I \times X_L = (0.107A \angle -63.4°)(100Ω \angle 90°) = 10.7 VAC\angle 26.6°\end{cases}\]</span></p><p>◉【解】以上步骤计算的是当 <span class="math inline">\(t = 0\)</span>时刻，<strong>电源电压</strong> <span class="math inline">\(V_S = 12 VAC\angle 0°\)</span> 情况下的值。如果需要绘制精确的波形，那么就需要将<span class="math inline">\(\omega t\)</span>代入电源电压的表达式，并且将有效值乘以 <code>1.414</code> 得到 <span class="math inline">\(V_S = 17.0V \angle(\omegat)\)</span>，该结果描述了电压随着时间的连续变化过程。接着再将这个结果转换为<strong>三角形式</strong>，去掉虚部就可以得到<span class="math inline">\(V_S = 17.0 V \cos (\omegat)\)</span>。参照电源电压 <span class="math inline">\(V_S\)</span>的推导过程，将其它<code>电压</code>与<code>电流</code>的波形全部列写为<strong>三角形式</strong>，再代入相应的<strong>峰值</strong>与<strong>相位角</strong>，就可以获得如下的波形与计算结果：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/16.png"></p><blockquote><p><strong>注意</strong>：<strong>峰值</strong>电压与电流等于其<strong>有效值</strong>乘以<code>1.414</code>，例如 <span class="math inline">\(V_P = 1.414 \timesV_{RMS}\)</span>。</p></blockquote><p>◉【解】根据上述推导结果，还可以获得该电路上面<strong>总阻抗的视在功率</strong><span class="math inline">\(VA\)</span>、<strong>电阻消耗的有功功率</strong><span class="math inline">\(P_R\)</span>、<strong>电感上的无功功率</strong><span class="math inline">\(VAR\)</span>、<strong>功率因数</strong><span class="math inline">\(PF\)</span>，接下来的章节将会逐一介绍这些内容：</p><p><span class="math display">\[\begin{cases}总阻抗的视在功率 VA &amp;= I_{RMS} \times V_{RMS} = (0.107A) \times (12VAC) = 1.284 VA \\电阻消耗的有功功率 P_R &amp;= I_{RMS}^2 R = (0.107A)^2 \times (50Ω) =0.572 W \\电感上的无功功率 VAR &amp;= I_{RMS}^2 X_L = (0.107A)^2 \times (100Ω) =1.145 VAR \\功率因数 PF &amp;= \frac{P_R}{VA} = \cos(\phi) = \cos(-63.4°) = 0.45\end{cases}\]</span></p><blockquote><p><strong>注意</strong>：上述方程当中的 <span class="math inline">\(\phi\)</span> 表示的是 <span class="math inline">\(V_S\)</span> 与 <span class="math inline">\(I_S\)</span> 之间的<strong>相位差</strong>。</p></blockquote><p>上述示例当中，电阻电压 <span class="math inline">\(V_R\)</span>与电感电压 <span class="math inline">\(V_L\)</span> 的代数和等于 <span class="math inline">\(5.35VAC + 10.70VAC = 16.05VAC\)</span>，该结果要大于电源电压 <span class="math inline">\(V_S =12VAC\)</span>，似乎并不满足<strong>基尔霍夫电压定律</strong>。这是由于没有考虑到<strong>相位角</strong>的因素造成的，纳入相位角之后的正确计算结果如下所示：</p><p><span class="math display">\[\begin{aligned}V_{total} &amp;= V_R + V_L = (5.35 VAC \angle - 63.4°) + (10.70 VAC\angle 26.6°) \\&amp;= 2.4 VAC - j 4.8 VAC + 9.6 VAC + j 4.8 VAC \\&amp;= 12 VAC\end{aligned}\]</span></p><p>下图当中的电压信号波形，非常直观的展示了波形的<strong>幅度</strong>与<strong>相位</strong>之间的对应关系：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/17.png"></p><h3 id="视在功率">视在功率</h3><p>对于含有<code>电阻</code>、<code>电感</code>、<code>电容</code>元件的复杂电路，将之前介绍过的<strong>功率定理</strong><span class="math inline">\(P = I_{RMS} \times V_{RMS}\)</span> 当中的<span class="math inline">\(P\)</span> 更换为 <span class="math inline">\(VA\)</span>，就可以得到<strong>视在功率</strong>的计算公式：</p><p><span class="math display">\[视在功率 VA = I_{RMS} \times V_{RMS}\]</span></p><p>可以看到<strong>视在功率</strong> <code>VA</code>的计算公式与普通交流功率的计算公式相同，之所以使用 <code>VA</code>而不使用<code>P</code>，是由于计算出的功率值并不只是消耗了<strong>有功功率</strong>，因而不能使用以<code>瓦特</code>作为单位的<strong>有功功率</strong>来进行表示，而应当使用<strong>伏安</strong><code>VA</code> 作为其单位。</p><p><strong>视在功率</strong>同时包含了电阻消耗的<strong>有功功率</strong>和<strong>无功功率</strong>。其中，<strong>有功功率</strong>是电流经过电阻时所产生的热损耗，其单位为<strong>瓦特</strong><code>W</code>，可以由<strong>交流欧姆定律</strong>代入<strong>功率定理</strong>之后得到的方程进行定义：</p><p><span class="math display">\[有功功率 P_R = I^2_{RMS} R\]</span></p><p>而<strong>无功功率</strong>不表示功率的消耗，其与<strong>电感器</strong>当中储存的磁场能量，以及<strong>电容器</strong>当中储存的电场能量存在着联系。当电感器的磁场减弱或者电容器进行放电时，它们当中储存的能量又会释放回电路当中。<strong>无功功率</strong>采用<strong>乏</strong><code>VAR</code>来作为其单位，把上述<strong>欧姆功率定理</strong>当中的<code>电阻</code>或<code>阻抗</code>部分更换为<strong>电抗</strong><span class="math inline">\(X\)</span>，就可以得到<strong>无功功率</strong>的定义：</p><p><span class="math display">\[无功功率 VAR = I^2_{RMS} X\]</span></p><p>为了简化计算过程，下面直接给出<strong>无功功率</strong>、<strong>有功功率</strong>、<strong>视在功率</strong>之间相互进行转换的关系式：</p><p><span class="math display">\[视在功率 VA = \sqrt{有功功率 P_R^2  + 无功功率 VAR^2}\]</span></p><h3 id="功率因数">功率因数</h3><p><strong>功率因数</strong>也是一种用于描述<code>视在功率</code>和<code>无功功率</code>的术语，电路的<strong>功率因数</strong><span class="math inline">\(PF\)</span>等于电路消耗的功率与视在功率的比值，通常以<strong>百分数</strong> <span class="math inline">\(\%\)</span> 格式来进行表示：</p><p><span class="math display">\[功率因数 PF = \frac{电路消耗功率 P_{consumed}}{视在功率 P_{apparent}} =\frac{P_R}{VA}\]</span></p><p><strong>纯电阻电路</strong>的功率因数等于 <span class="math inline">\(100\% =1\)</span>，而<strong>纯电抗电路</strong>的功率因数则等于 <span class="math inline">\(0\)</span>。由于功率因数总是为<strong>正数</strong>，所以必须明确的标识当前<code>电压</code>与<code>电流</code>之间的相位关系是<strong>超前</strong>还是<strong>滞后</strong>。除此之外，<strong>功率因数</strong>还可以表示为<code>电压</code>与<code>电流</code>之间<strong>相位差</strong><span class="math inline">\(\phi\)</span> 的形式：</p><p><span class="math display">\[功率因数 PF = \cos \phi\]</span></p><p>除了功率因数之外，还有另外一个用于描述<strong>电抗</strong>当中<code>无功功率</code>所占百分比的术语，称为<strong>无功因数</strong>：</p><p><span class="math display">\[RF = \frac{P_{reactive}}{P_{apparent}} = \frac{无功功率 VAR}{视在功率VA} = \sin(\phi)\]</span></p><h3 id="交流电路戴维南定理">交流电路戴维南定理</h3><p>戴维南定理同样可以应用于<strong>交流线性电路</strong>的分析，对于任意包含有<code>电阻</code>、<code>电容</code>、<code>电感</code>元件的复杂网络，都可以等效为一个<strong>正弦电压源</strong>与<strong>复阻抗</strong>的<strong>串联</strong>。例如求解复杂正弦电路当中两点之间的电压，或者某个元件上的<code>电流</code>与<code>电压</code>，只需要移除该元件，并求解出<strong>戴维南等效电压</strong><span class="math inline">\(V_{THEV}(t)\)</span>，再将原来的正弦电源直接采用导线进行<strong>短路</strong>，进而求解出<strong>戴维南等效复阻抗</strong><span class="math inline">\(Z_{THEV}(t)\)</span>及其对应的戴维南等效电路。下图左侧是一个包含有<code>电阻</code>、<code>电容</code>、<code>电感</code>元件的复杂电路，而右侧是该电路所对应的戴维南等效电路：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/18.png"></p><p>▶【例题】求解下图所示电路当中流过电阻的电流 <span class="math inline">\(I_R\)</span> ？</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/19.png"></p><p>◉【解】首先，<strong>移除电阻</strong>，使得电路成为拥有两个外接端子的黑盒子：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/20.png"></p><p>◉【解】然后，再分别计算其<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 与<strong>感抗</strong> <span class="math inline">\(X_L\)</span> ：</p><p><span class="math display">\[\begin{aligned}&amp;X_L = j \omega L = j(2\pi \times 1000Hz \times 200 \times 10^{-3})= j 1257Ω \\&amp;X_C = - j \frac{1}{\omega C} = -j \frac{1}{2\pi \times 1000Hz\times 20 \times 10^{-9}F} = -j 7958Ω\end{aligned}\]</span></p><p>◉【解】接下来，运用交流分压公式计算出<strong>开路电压</strong>，也就是<strong>戴维南等效电压</strong><span class="math inline">\(V_{THEV}\)</span>：</p><p><span class="math display">\[\begin{aligned}V_{THEV} = V_C &amp;= \bigg( \frac{X_C}{X_C + X_L} \bigg) \times V_S =\bigg( \frac{-j 7958 Ω}{-j 7958 Ω + j 1257 Ω} \bigg) \times 10 VAC \\&amp;= \bigg( \frac{7958 \angle -90°}{6701 \angle -90°} \bigg) \times 10VAC= 11.88 VAC \angle 0°\end{aligned}\]</span></p><p>◉【解】再将正弦电源<strong>短路</strong>，得到其<strong>等效阻抗</strong><span class="math inline">\(Z_{THEV}\)</span>为<code>电容</code>与<code>电感</code>的并联：</p><p><span class="math display">\[\begin{aligned}Z_{THEV} &amp;= \frac{X_C \times X_L}{X_C + X_L} = \frac{-j7958Ω \timesj1257Ω}{-j7958Ω + j1257Ω} \\&amp;= \frac{(7958Ω \angle -90°) \times (1257Ω \angle -90°)}{(6701Ω\angle -90°)}= \frac{10003206Ω^2 \angle 0°}{6702Ω \angle -90°} \\&amp; = 1493 Ω \angle 90° = j(1493)Ω\end{aligned}\]</span></p><p>◉【解】最后，把<strong>负载电阻</strong>与<strong>戴维南等效电路</strong>进行连接，得到如下的等效电路：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/21.png"></p><p>◉【解】根据<strong>戴维南等效电压</strong> <span class="math inline">\(V_{THEV}\)</span> 与<strong>电阻</strong> <span class="math inline">\(R\)</span>的串联关系，就可以求解出<strong>总阻抗</strong> <span class="math inline">\(Z_{total}\)</span>：</p><p><span class="math display">\[Z_{total} = R + Z_{THEV} = 3300Ω + j 1493 Ω = 3622 Ω \angle 24.3°\]</span></p><p>◉【解】基于<strong>交流欧姆定律</strong>，就可以求解得到经过电阻的<strong>电流</strong><span class="math inline">\(I_R\)</span> 等于：</p><p><span class="math display">\[I_R = \frac{V_{THEV}}{Z_{total}} = \frac{11.88 VAC \angle 0°}{3622Ω\angle 24.3°} = 3.28mA \angle -24.3°\]</span></p><p>◉【解】上述的计算结果表明，电阻上的<strong>电流</strong> <span class="math inline">\(I_R\)</span> 等于<code>3.28mA</code>，并且<strong>滞后</strong>于电源电压<code>24.3°</code>。如果需要将瞬时值转换为时间相关的实数函数，那么就要把<span class="math inline">\(\omega t\)</span>添加到每一个相位角表达式，并且将 <strong>RMS</strong>值转换为真实值：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/22.png"></p><p>◉【解】根据上述的计算结果，还可以求解得到该电路对应的<strong>视在功率</strong>、<strong>有功功率</strong>、<strong>无功功率</strong>、<strong>功率因数</strong>：</p><p><span class="math display">\[\begin{cases}视在功率 VA &amp;= I_S^2 \times Z_{total} = (0.00328 A)^2 \times 3622 Ω= 0.039 VA \\有功功率 P_R &amp;= I_R^2 \times R = (0.00328 A)^2 \times 3300 Ω = 0.035W \\无功功率 VAR &amp;= I_R^2 × Z_{THEV} = (0.00328 A)^2 \times 1493 Ω =0.016 VAR \\功率因数 PF &amp;= \frac{P_R}{VA} = \cos(\phi) = \cos(-24.3)° =0.91(滞后)\end{cases}\]</span></p><h3 id="谐振电路">谐振电路</h3><p>如果在 <strong>LC电路</strong>的两端电路添加<strong>正弦电压源</strong>，那么当电源的频率等于<strong>谐振频率</strong>时，就会发生一些有趣的现象。</p><h4 id="lc-串联谐振">LC 串联谐振</h4><p>下图所示的 LC 串联电路的<strong>谐振角频率</strong> <span class="math inline">\(\omega_0 = 1 \sqrt{LC}\)</span>或者<strong>等效谐振频率</strong> <span class="math inline">\(f_0 =\frac{1}{2\pi/LC}\)</span> 的时候，该 LC电路的等效阻抗将会趋于零，即相当于<strong>短路</strong>，此时流过<strong>电源</strong>的电流达到最大值。理想状况下，这个电流将会趋于无穷大，但是实际上电路内电阻会将其限制在一定的范围。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/23.png"></p><p>这里先求解出上述电路的等效阻抗，由于其频率未知，因而<strong>等效阻抗</strong><span class="math inline">\(Z_{total}\)</span> 必须被视为一个变量：</p><p><span class="math display">\[等效阻抗 Z_{total} = 感抗 X_L + 容抗 X_C = j \omega L - j\frac{1}{\omega C} = j \bigg(\omega L - \frac{1}{\omega C} \bigg)\]</span></p><p>这个<strong>等效阻抗</strong> <span class="math inline">\(Z_{total}\)</span>对应的<strong>极坐标形式</strong>如下面所示（任意数除以 <code>0</code>的<strong>反正切</strong>为 <code>90°</code>，所以下面的阻抗相位角也等于<code>90°</code>）：</p><p><span class="math display">\[Z_{total} = \bigg( \omega L - \frac{1}{\omega C} \bigg) \angle 90°\]</span></p><p>此时，经过并联等效阻抗 <span class="math inline">\(Z_{total}\)</span>的电流 <span class="math inline">\(I\)</span> 为：</p><p><span class="math display">\[I = \frac{V_S}{Z_{total}} = \frac{10 VAC \angle 0°}{\omega L -\frac{1}{\omega C}} \angle -90°= \bigg[ \frac{10 VAC}{\omega L - \frac{1}{\omega C}} \bigg] \angle -90°\]</span></p><p>如果代入<strong>电感</strong> <span class="math inline">\(L = 100 \muH\)</span>、<strong>电容</strong> <span class="math inline">\(C =62.5nF\)</span>、<strong>角频率</strong> <span class="math inline">\(\omega = 2 \pif\)</span>，并且不考虑<strong>相位角</strong>的因素，那么<strong>总阻抗</strong><span class="math inline">\(|Z_{total}|\)</span> 与<strong>电流</strong><span class="math inline">\(|I|\)</span> 分别等于：</p><p><span class="math display">\[\begin{cases}|Z_{total}| = 6.28 \times 10^{-4} f - \frac{2546479}{f} Ω \\|I| = 10 VAC \div \big[ 6.28 \times 10^{-4} f - \frac{2546479}{f} \big]Ω\end{cases}\]</span></p><p>可以看到，<strong>阻抗</strong>与<strong>电流</strong>都属于<strong>频率</strong>的函数，其波形如下图所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/24.png"></p><p>值得注意的是，当上述方程当中的<strong>频率</strong>等于<strong>谐振频率</strong><span class="math inline">\(f_0 = \frac{1}{2\pi \sqrt{LC}} =\frac{1}{2\pi \sqrt{(100 \times 10^{-6}H)(62.5 \times 10^{-9}F)}} =63663 Hz\)</span>的时候，其<strong>阻抗</strong>等于零，同时<strong>电流</strong>趋于无穷大（实际情况下，电路内阻会限制电流大小）。电路发生谐振时，<strong>感抗</strong>与<strong>容抗</strong>的<strong>大小相等相位相反</strong>，具体请参见如下方程：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/25.png"></p><blockquote><p><strong>注意</strong>：LC串联电路在发生谐振时，电容与电感两端的电压大小相等相位相反，意味着它们串联之后的<strong>有效电压降</strong>等于<strong>零</strong>，两端的<strong>阻抗</strong>也就一定等于<strong>零</strong>。</p></blockquote><h4 id="lc-并联谐振">LC 并联谐振</h4><p>下图所示并联 LC 电路的<strong>谐振角频率</strong> <span class="math inline">\(\omega_0 =\frac{1}{\sqrt{LC}}\)</span>，等效<strong>谐振频率</strong> <span class="math inline">\(f_0 = \frac{1}{2\pi / \sqrt{LC}}\)</span>，与 LC串联电路谐振频率的表达式相同，但是作用的效果却完全相反，发生谐振时不再是阻抗趋于零，电流趋于无穷大。而是<strong>电阻趋于无穷大，电流趋于零</strong>，即相当于<strong>开路</strong>。实际情况下，由于电路当中<code>内电阻</code>、<code>寄生电容</code>、<code>寄生电感</code>的存在，这种开路现象并不会真实发生。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/26.png"></p><p><span class="math display">\[等效阻抗 Z_{total} = \frac{感抗 X_L \times 容抗 X_C}{感抗 X_L + 容抗X_C}= \frac{(j \omega L)(-j \frac{1}{\omega C})}{j \omega L - j\frac{1}{\omega C}}= \frac{\frac{L}{C}}{j(\omega L - \frac{1}{\omega C})}= -j \frac{\frac{L}{C}}{(\omega L - \frac{1}{\omega C})}\]</span></p><p>将上述结果改写为<strong>极坐标形式</strong>（任意负数除以<code>0</code> 的<strong>反正切</strong>为<code>-90°</code>，所以下面的阻抗相位角也等于 <code>-90°</code>）：</p><p><span class="math display">\[Z_{total} = \frac{\frac{L}{C}}{(\omega L - \frac{1}{\omega C})} \angle-90°\]</span></p><p>此时，流入并联阻抗的电流等于 <span class="math inline">\(I\)</span>：</p><p><span class="math display">\[I = \frac{V_S}{Z_{total}} = \frac{10 VAC \angle 0°}{\frac{L/C}{\omega L- 1 / \omega C}\angle - 90°}= \bigg[ \frac{10 VAC}{\frac{L/C}{(\omega L - 1 / \omega C)}} \bigg]\angle 90°\]</span></p><p>同样代入<strong>电感</strong> <span class="math inline">\(L = 100 \muH\)</span>、<strong>电容</strong> <span class="math inline">\(C =62.5nF\)</span>、<strong>角频率</strong> <span class="math inline">\(\omega = 2 \pif\)</span>，如果不考虑相位角，那么<strong>总阻抗</strong> <span class="math inline">\(|Z_{total}|\)</span> 和<strong>电流</strong> <span class="math inline">\(|I|\)</span> 分别为：</p><p><span class="math display">\[\begin{cases}Z_{total} = 1600 \div \big(6.28 \times 10^{-4} - \frac{1}{3.92 \times10^{-7}} \big) Ω \\I = 0.00625 \times \big(6.28 \times 10^{-4} - \frac{1}{3.92 \times10^{-7}} \big) A\end{cases}\]</span></p><p>可以看到，<strong>阻抗</strong>与<strong>电流</strong>也同样是<strong>频率</strong>的函数，对应的波形如下图所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/27.png"></p><p>当上述方程当中的<strong>频率</strong>等于<strong>谐振频率</strong><span class="math inline">\(f_0 = \frac{1}{2\pi \sqrt{LC}} =\frac{1}{2\pi \sqrt{(100 \times 10^{-6}H)(62.5 \times 10^{-9}F)}} =63663 Hz\)</span>的时候，其<strong>阻抗</strong>趋于无穷大，同时<strong>电流</strong>等于零。当<strong>频率</strong>趋近于<strong>零</strong>的时候，电感相当于短路，电流趋于无穷大；而当<strong>频率</strong>趋近于<strong>无穷大</strong>的时候，电容也相当于短路，同样会导致电流趋于无穷大（实际情况下，<code>电路内阻</code>、<code>寄生电感</code>、<code>寄生电感</code>会限制电流的大小）。</p><p>发生谐振时，由于<strong>电容</strong> <span class="math inline">\(C\)</span> 和<strong>电感</strong> <span class="math inline">\(L\)</span> 的<strong>阻抗</strong> <span class="math inline">\(X_C = X_L\)</span> 与<strong>电压</strong> <span class="math inline">\(V_C = V_L\)</span>相等，但是<strong>相位</strong>相反。由此可知，流过<strong>电感</strong><span class="math inline">\(L\)</span> 与<strong>电容</strong> <span class="math inline">\(C\)</span>的<strong>电流</strong>同样大小相等方向相反。即流过<strong>电感</strong>的电流从<strong>电容</strong>上端流入，经过<strong>电容</strong>之后又从<strong>电感</strong>的下端流入，下一个时刻电流发生<strong>反相</strong>，能量沿着相反的方向释放。此时，<strong>电容</strong>与<strong>电感</strong>的作用类似于振荡器，来回传递相同的能量，该能量的大小取决于<strong>电感</strong>与<strong>电容</strong>的大小，这种在LC回路当中来回流动的电流被称为<strong>循环电流</strong>。此时由于<strong>电源</strong>两端的电位差较小，所以经过电源的电流也比较小。换而言之，如果希望LC电路提供一个外部电流，那么就意味着<strong>电感</strong>与<strong>电容</strong>元件必须存在电位差。但是发生<strong>谐振</strong>的时候，由于流过<strong>电感</strong>与<strong>电容</strong>的电流相等而方向相反，因而无法对外提供电流。</p><p>▶【例题】如果一个谐振电路的电感为 <span class="math inline">\(5.0 \muH\)</span> 而电容为 <span class="math inline">\(35pF\)</span>，试求解电路的<strong>谐振频率</strong>？</p><p>◉【解】根据题设条件，该电路的<strong>谐振频率</strong> <span class="math inline">\(f_0\)</span> 等于：</p><p><span class="math display">\[f_0 = \frac{1}{2 \pi \sqrt{LC}} = \frac{1}{2 \pi \sqrt{(5.0 \times10^{-6}) \times (35 \times 10^{-12})} } = 12 \times 10^6 Hz = 12 MHz\]</span></p><p>▶【例题】如果一个谐振电路的电感为 <span class="math inline">\(2.0 \muH\)</span>，如果谐振频率为 <span class="math inline">\(21.1MHz\)</span>，试求解电路当中<strong>电容</strong>的值 ？</p><p>◉【解】根据题设条件，这个电路当中<strong>电容</strong> <span class="math inline">\(C\)</span> 的值等于：</p><p><span class="math display">\[f_0 = \frac{1}{2 \pi \sqrt{LC}} \implies C = \frac{1}{L} \big(\frac{1}{2 \pi f_0} \big)^2 = \frac{1}{2.0 \times 10^{-6}H} \big[\frac{1}{2 \pi (21.1 \times 10^6 Hz)} \big]^2 = 2.85 \times 10^{-11} F =28.5F\]</span></p><blockquote><p><strong>注意</strong>：上述公式可以在元件允许的误差范围之内，计算出相应的频率与元件参数。除了<code>谐振频率</code>之外，<strong>谐振电路</strong>还具有<code>阻抗</code>、<code>带宽</code>、<code>串联谐振电路当中元件之间的压降</code>、<code>并联谐振电路中的循环电流</code>等重要特性。</p></blockquote><h4 id="rlc-串联谐振">RLC 串联谐振</h4><p>前面讨论的 <strong>LC 串联谐振电路</strong>、<strong>LC并联谐振电路</strong>都属于理想电路，由于电路元件实际上都存在着<code>内电阻</code>或者<code>内阻抗</code>，所以理想电路的谐振与真实发生谐振存在着一定偏差。实际的<strong>LC谐振电路</strong>当中，<strong>电容</strong>的高频<strong>损耗电阻</strong>较小，可以忽略；而<strong>电感</strong>的高频<strong>损耗电阻</strong>较大，不可以忽视，分析电路时需要将其纳入考量。接下来通过下图所示的电路，说明<strong>RLC 串联电路</strong>的工作原理：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/28.png"></p><p>首先，求解出上述 <strong>RLC串联电路</strong>的<strong>总阻抗</strong> <span class="math inline">\(Z_{total}\)</span>：</p><p><span class="math display">\[Z_{total} = R + X_L + X_C = R + j \omega L - j \frac{1}{\omega C} = R +j \bigg( \omega L - \frac{1}{\omega C} \bigg)\]</span></p><p>这里依然把上述结果转换为<strong>极坐标形式</strong>：</p><p><span class="math display">\[Z_{total} = \sqrt{R^2 + (\omega L - \frac{1}{\omega C})^2} \angle\tan^{-1} \bigg( \frac{\omega L - \frac{1}{\omega C}}{R} \bigg)\]</span></p><p>如果不考虑<strong>相位</strong>，那么流过总阻抗的<strong>电流</strong><span class="math inline">\(I\)</span> 等于：</p><p><span class="math display">\[I = \frac{V_S}{Z_{total}} = \frac{10 VAC}{\sqrt{R^2 + \big( \omega L -\frac{1}{\omega C} \big)^2}}\]</span></p><p>将<strong>电感</strong> <span class="math inline">\(L = 100 \muH\)</span>、<strong>电容</strong> <span class="math inline">\(C = 62.5nF\)</span>、<strong>角频率</strong> <span class="math inline">\(\omega= 2 \pi f\)</span> 代入，既可以求解得到一个关于电流的频率函数：</p><p><span class="math display">\[I = \frac{10 VAC}{\sqrt{25 + (6.28 \times 10^{-4} f -\frac{2546479}{f})^2}} Ω\]</span></p><p>当上述方程里的<strong>频率</strong> <span class="math inline">\(f\)</span> 等于<strong>谐振频率</strong> <span class="math inline">\(f_0 = \frac{1}{2\pi \sqrt{LC}} = \frac{1}{2\pi\sqrt{(100 \times 10^{-6}H)(62.5 \times 10^{-9}F)}} = 63663 Hz\)</span>的时候，该 <strong>LCR 串联谐振电路</strong>的<strong>总电流</strong><span class="math inline">\(I = \frac{V_S}{R} = \frac{10 VAC}{5Ω} =2A\)</span>并不会趋于无穷大，而是在发生谐振时<code>感抗</code>与<code>容抗</code>相互抵消，其中<code>电阻</code>可以防止出现阻抗为<strong>零</strong>的情况。</p><p><strong>空载品质因数 <span class="math inline">\(Q_u\)</span></strong>就是指电路发生谐振时的<code>电抗</code>除以<code>电阻</code>：</p><p><span class="math display">\[Q_u = \frac{1}{R} \times \sqrt{\frac{L}{C}} \times \frac{X_{L, 0}}{R} =\frac{\omega_0 L}{R} = \frac{2 \pi f_0 L}{R} = \frac{40Ω}{5Ω} = 8\]</span></p><p>当电路发生谐振的时候，<code>感抗</code>与<code>容抗</code>相互抵消，整个电路的<strong>阻抗</strong>仅由<code>电阻</code>来决定。由此可以推断，发生谐振时的<code>电流</code>与<code>电压</code>同相，类似于只存在一个电阻的正弦电路。如果当前没有发生谐振，由于<code>感抗</code>或者<code>容抗</code>的增加，<code>总阻抗</code>将会增大。如果当前电路的频率<strong>低于</strong>谐振频率，那么<strong>容抗</strong>占据主导地位（电容对于电流的阻碍作用增强）。如果当前电路的频率<strong>高于</strong>谐振频率，则<strong>感抗</strong>占据主导地位（电感对于电流的阻碍作用增强）。当电路没有发生谐振的时候，<strong>电阻</strong>对于电流幅值的影响微不足道。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/29.png"></p><p>上图当中的电流曲线存在着一个<strong>尖锋</strong>，当<code>感抗</code>或者<code>容抗</code>与<code>电阻</code>的大小相当时，如果远离<strong>谐振频率</strong>，那么电流就会缓慢下降，此时电流曲线的尖峰较宽。相反的，当<code>感抗</code>或者<code>容抗</code>比<code>电阻</code>更大时，无论朝哪个方向远离<strong>谐振频率</strong>，电流都会迅速的下降，此时的电流曲线尖峰较窄。<strong>窄带谐振电路</strong>对于谐振频率的响应，要比接近<strong>谐振频率</strong>位置附近的频率响应更大，而<strong>宽带谐振电路</strong>对于谐振频率附近的频率响应基本都相同。</p><p>因此，<strong>窄带谐振电路</strong>具有更好的选择性，可以表现出对于指定频率信号较强的响应能力（幅值），并且能够抑制其它频率的信号。而<strong>宽带谐振电路</strong>可以应用于需要对频带内所有信号进行相同响应的场景（而并非只对单一频率有较强响应）。</p><blockquote><p><strong>注意</strong>：接下来所要讨论的<strong>品质因数</strong>与<strong>带宽</strong>，是体现RLC 谐振电路<strong>频率选择性</strong>的两个重要参数。</p></blockquote><h4 id="品质因数">品质因数</h4><p>之前内容当中有介绍过，<strong>品质因数 Q</strong>是<code>电抗</code>（储能）与<code>电阻</code>（耗能）的比值，在<strong>RLC 串联电路</strong>（其中的 <code>R</code>是元件内阻）当中，<strong>电感器</strong> <code>L</code>的内阻损耗在高频情况下占据主导地位，这意味着电感的 <strong>Q</strong>值在很大程度上决定了谐振电路的 <strong>Q</strong> 值。因为<strong>Q</strong> 值与接收功率的外部负载无关，所以这里更改了谐振电路的<strong>Q</strong> 值，称其为电路的<strong>无负载 <span class="math inline">\(Q\)</span> 值</strong>，并且记作 <strong><span class="math inline">\(Q_u\)</span></strong>。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/30.png"></p><p>使用上面 <strong>RLC串联谐振电路</strong>当中的<code>电阻</code>，除以<code>感抗</code>或者<code>容抗</code>（谐振时的<code>感抗</code>与<code>容抗</code>相等）就可以确定该电路的<strong>无负载Q 值</strong>：</p><p><span class="math display">\[Q_u = \frac{X_{L,0}}{R} = \frac{40Ω}{5Ω} = 8 \ 或者\ Q_u =\frac{X_{C,0}}{R} = \frac{40Ω}{5Ω} = 8\]</span></p><p>上述等式表明，如果增大电阻 <code>R</code>，那么<strong>无负载 Q值</strong> <span class="math inline">\(Q_u\)</span>就会降低，谐振电路的响应曲线就会变宽。例如当电阻分别为<code>10 Ω</code>、<code>20 Ω</code>、<code>50 Ω</code> 时，<span class="math inline">\(Q_u\)</span> 分别会降低至<code>4</code>、<code>2</code>、<code>0.8</code>。相反的，如果减小电阻<code>R</code>，那么<strong>无负载 Q 值</strong> <span class="math inline">\(Q_u\)</span>就会增大，谐振电路的响应曲线就会变窄。例如当电阻减小至 <code>2Ω</code>的时候，<span class="math inline">\(Q_u\)</span> 就会增大到<code>20</code>。</p><h4 id="带宽">带宽</h4><p>除了<strong>品质因数 Q</strong>之外，<strong>带宽</strong>是另外一个用于表征 <strong>RLC谐振电路</strong>频率选择特性的物理量。把上面的<strong>品质因数曲线图</strong>转换为下面的<strong>带宽曲线图</strong>，即将竖轴的<code>电流</code>更换为<code>相对电流</code>，并将用于表示变化<strong>Q</strong>值的曲线簇向上移动，使得所有曲线都具有相同的<strong>峰值电流</strong>。通过假设每一条曲线的峰值电流相等，可以非常容易的比较出不同<strong>Q</strong>值时，电流的变化率以及相关的<code>电抗</code>与<code>电阻</code>之比。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/31.png"></p><p>从上面的曲线可以看出，与 <strong>Q</strong>值较高的电路相比，<strong>Q</strong>值较低的电路可以通过更大带宽的频率。<strong>带宽</strong>被定义为两个频率之间的差值，此时两个频率点上的电流幅值为最大值的<code>0.707</code> 倍或者 <span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>倍。由于电阻消耗的功率与电流的平方成正比，假设这里 <code>R</code>为常数，则电路在这两个频率点位置的功率，是发生谐振时最大功率的一半。在上面的曲线图当中，已经标识出了这个<strong>半功率点</strong>，或者称为<code>-3dB</code> 点。</p><p>由于 <strong>Q</strong> 值大于 <code>10</code>的曲线近乎完全对称，因而可以很容易的得出<strong>带宽</strong>（<span class="math inline">\(WB\)</span>）的计算公式（<code>带宽</code>与<code>频率</code>的单位都是<strong>赫兹</strong><code>Hz</code>）：</p><p><span class="math display">\[带宽\ BW = \frac{谐振频率\ f_0}{无负载品质因数\ Q_u}\]</span></p><p>例如对于本小节开头的 <strong>RLC 串联谐振电路</strong>，其在<code>100KHz</code> 频率时的<strong>带宽</strong>为 <span class="math inline">\(BW_1 = \frac{f_0}{Q_u} = \frac{100000 Hz}{8} =12500Hz\)</span>，而在 <code>1MHz</code> 频率时的<strong>带宽</strong>为<span class="math inline">\(BW_1 = \frac{f_0}{Q_u} = \frac{1000000Hz}{8} = 125000Hz\)</span>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/28.png"></p><h4 id="rlc-谐振电路元件电压">RLC 谐振电路元件电压</h4><p>RLC谐振电路当中，<code>电感</code>与<code>电容</code>两端的电压可以根据<strong>交流欧姆定律</strong>求解得到：</p><p><span class="math display">\[\begin{cases}电容电压\ V_C = X_C \times I = \frac{1}{2 \pi f C} \times I \\电感电压\ V_L = X_L \times I = 2 \pi f L \times I\end{cases}\]</span></p><p>因为电感器与电容器会将其储存的能量返还给电路，所以电感器与电容器两端的电压可能会<strong>大于</strong>电源电压，特别是对于具备高<strong>Q</strong> 值的电路，更是尤为如此。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/28.png"></p><p>例如在发生谐振时，本小节开头所示 <strong>RLC串联电路</strong>里的<code>电容</code>与<code>电感</code>两端电压 <span class="math inline">\(V_C\)</span> 与 <span class="math inline">\(V_L\)</span> 分别为:</p><p><span class="math display">\[\begin{cases}V_C = X_C \times I = (40Ω \angle -90°) \times (2A \angle 0°) = 80° VAC\angle -90°  \\V_L = X_L \times I = (40Ω \angle +90°) \times (2A \angle 0°) = 80° VAC\angle +90°\end{cases}\]</span></p><p>将 <strong>RMS 值</strong>乘以 <code>1.414</code>就可以将其转换为<strong>峰值</strong>，即约等于<code>113V</code>。这样高 <strong>Q</strong>值的电路经常出现在<strong>天线耦合器</strong>当中，由于其功率较大，因而可以承受较高<code>无功电压</code>造成的电弧（<strong>无功电压</strong>是由<strong>电抗元件</strong>在线路上产生的变化电压）。即使电源电压处于元件的额定电压范围以内，但是在考虑<strong>Q</strong> 值大于 <code>10</code> 的情况时，<strong>RLC串联电路</strong>发生谐振时的<strong>无功电压</strong> <span class="math inline">\(V_X\)</span> 可以采用下面公式获得：</p><p><span class="math display">\[无功电压 V_X = 无负载品质因数 \ Q_u \times 电源电压\ V_S\]</span></p><h4 id="电容损耗">电容损耗</h4><p>对于频率低于 <code>30 MHz</code>的串联谐振电路，电容的能量损耗比电感更小。但是在<code>30 MHz ~ 300 MHz</code> 范围以内，电容的损耗可能会影响到电路的<strong>Q</strong>值。<strong>电容损耗</strong>主要来自于电容器极板之间电介质的<strong>泄漏电阻</strong>，其与电感器的内阻损耗存在着区别：<strong>电感器</strong>的<code>导线损耗电阻</code>与<strong>感抗</strong>形成串联关系，而<strong>电容器</strong>的<code>泄漏电阻</code>与<strong>容抗</strong>形成并联关系。如果电容器的泄漏电阻影响到串联谐振电路的<strong>Q</strong>值，则必须将这个并联的<strong>泄漏电阻</strong>，转换为串联的<strong>等效电阻</strong>，其计算公式如下所示：</p><p><span class="math display">\[串联等效电阻\ R_S = \frac{容抗\ X_C^2}{泄露电阻\ R_P} = \frac{1}{R_P\times (2 \pi f C)^2}\]</span></p><blockquote><p><strong>注意</strong>：把该<code>串联等效电阻</code>与电感的<code>导线损耗电阻</code>相加，就可以得到RLC 谐振电路当中<strong>电阻</strong> <span class="math inline">\(R\)</span> 的取值（该书将 RLC 电路中的电阻<code>R</code> 视为电感 <code>L</code> 与电容 <code>C</code> 的内阻之和）。</p></blockquote><p>▶【例题】<code>10.0pF</code> 的电容器在 <code>40.0 MHz</code>频率时的<strong>泄漏电阻</strong>为<code>9000 Ω</code>，求解其<strong>等效串联电阻</strong> <span class="math inline">\(R_S\)</span> ?</p><p>◉【解】根据题设条件，该电路的<strong>等效串联电阻</strong> <span class="math inline">\(R_S\)</span> 等于：</p><p><span class="math display">\[R_S = \frac{1}{R_P \times (2 \pi f C)^2} = \frac{1}{9000Ω \times (6.283\times 40.0 \times 10^6 \times 10.0 \times 10^{-12})^2} = 17.6 Ω\]</span></p><blockquote><p><strong>注意</strong>：计算<strong>串联谐振电路</strong>的<code>阻抗</code>、<code>电流</code>、<code>带宽</code>时，需要把<code>串联泄漏电阻</code>与<code>电感线圈内电阻</code>相加，但是由于<strong>集肤效应</strong>的存在，电感的内阻会随着频率的提高而增大，从而导致<strong>电容</strong>与<strong>电感</strong>的全部损耗，严重降低了电路的<strong>Q</strong> 值。</p></blockquote><p>▶【例题】假设一个串联谐振电路的<strong>损耗电阻</strong>为<code>4Ω</code>，求解<strong>感抗</strong>与<strong>容抗</strong>都为<code>200Ω</code> 时电路的<strong>无负载 Q 值</strong>？以及<strong>感抗</strong>与<strong>容抗</strong>为 <code>20Ω</code>时候的<strong>无负载 Q 值</strong> ？</p><p>◉【解】<strong>感抗</strong>与<strong>容抗</strong>都为<code>200Ω</code> 时电路的<strong>无负载 Q 值</strong> <span class="math inline">\(Q_{u1}\)</span> 等于：</p><p><span class="math display">\[Q_{u1} = \frac{X_1}{R} = \frac{200Ω}{4Ω} =  50\]</span></p><p>◉【解】<strong>感抗</strong>与<strong>容抗</strong>都为<code>20Ω</code> 时电路的<strong>无负载 Q 值</strong> <span class="math inline">\(Q_{u2}\)</span> 等于：</p><p><span class="math display">\[Q_{u2} = \frac{X_2}{R} = \frac{20Ω}{4Ω} =  5\]</span></p><p>▶【例题】如果一个串联谐振电路的工作<strong>频率</strong>为<code>7.75 MHz</code>，工作<strong>带宽</strong>为<code>775 kHz</code>，求解该电路的<strong>无负载 Q 值</strong> ？</p><p>◉【解】根据题设条件，这个电路的<strong>无负载 Q 值</strong> <span class="math inline">\(Q_u\)</span> 等于：</p><p><span class="math display">\[Q_u = \frac{f}{BW} = \frac{7.75MHz}{0.775 MHz} = 10\]</span></p><h4 id="rlc-并联谐振">RLC 并联谐振</h4><p>下图是一个典型的<strong>RLC 并联谐振电路</strong>，类似于 <strong>RLC串联谐振电路</strong>，电感线圈的<code>内阻</code>是主要的功率损耗源，因而在电感支路侧添加了一个串联电阻。<strong>RLC串联谐振电路</strong>的阻抗会在谐振时趋于最小值，而 <strong>RLC并联谐振电路</strong>的阻抗则会在谐振时趋于最大值，所以通常称 RLC并联谐振电路为<strong>反谐振电路</strong>或者<strong>带阻电路</strong>（而RLC 串联谐振电路被称为<strong>带通电路</strong>）。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/32.png"></p><p>LRC 并联电路的<strong>总阻抗</strong> <span class="math inline">\(Z_{total}\)</span> 等于<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 与<strong>电阻</strong> <span class="math inline">\(R\)</span> 串联，再与<strong>容抗</strong> <span class="math inline">\(X_C\)</span> 进行并联：</p><p><span class="math display">\[Z_{total} = \frac{(R + X_L) \times X_C}{(R + X_L) + X_C}= \frac{(R + j \omega L) \times (- j \frac{1}{\omega C})}{(R + j \omegaL) + (- j \frac{1}{\omega C})}= \frac{\frac{L}{C} - j \frac{R}{\omega C}}{R + j (\omega L -\frac{1}{\omega C})}\]</span></p><p>按照惯例，同样将<strong>总阻抗</strong> <span class="math inline">\(Z_{total}\)</span> 转换为极坐标形式：</p><p><span class="math display">\[Z_{total} = \frac{\sqrt{(\frac{L}{C})^2 + (\frac{R}{\omega C})^2} \angle \tan^{-1}\big[\frac{R/(\omega C)}{L/C} \big] }{\sqrt{R^2 + (\omega L - \frac{1}{\omega C})^2} \angle \tan^{-1} \big[\frac{\omega L - \frac{1}{\omega C}}{R} \big]}\]</span></p><p>将<strong>电感</strong> <span class="math inline">\(L =5.0µH\)</span>、<strong>电容</strong> <span class="math inline">\(C =50pF\)</span>、<strong>电阻</strong> <span class="math inline">\(R =10.5Ω\)</span>、<strong>角频率</strong> <span class="math inline">\(ω =2 \pi f\)</span> 分别代入，就可以得到忽略相位的<strong>总阻抗</strong><span class="math inline">\(Z_{total}\)</span>：</p><p><span class="math display">\[Z_{total} = \frac{\sqrt{1.0 \times 10^{10} + \big(\frac{3.34 \times 10^{10}}{f} \big)^2}}{\sqrt{110.3 + \big( 3.14 \times 10^{-5} \times f - \frac{3.18 \times10^9}{f} \big)^2}}\ Ω\]</span></p><p>进一步的就可以得到一个不考虑相位角的<strong>总电流</strong> <span class="math inline">\(I\)</span>：</p><p><span class="math display">\[I_{total} = \frac{V_S}{Z_{total}} = \frac{10 V}{\frac{\sqrt{1.0 \times 10^{10} + \big(\frac{3.34 \times 10^{10}}{f} \big)^2}}{\sqrt{110.3 + \big( 3.14 \times 10^{-5} \times f - \frac{3.18 \times10^9}{f} \big)^2}}\ Ω}\]</span></p><p>将上面的等式输入电路仿真工具，就可以得到如下的谐振频率特性曲线：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/33.png"></p><p>观察上图可以发现，在特定的<code>频率</code>之下，<code>阻抗</code>趋于最大值，<code>总电流</code>趋于最小值。但是这个频率并非位于<span class="math inline">\(X_L = X_C\)</span> 的位置，不属于 <strong>LC并联电路</strong>或者 <strong>RLC串联电路</strong>的谐振频率点。<strong>RLC并联电路</strong>的<strong>谐振频率</strong>表达式较为复杂，总共存在着三种表达方式，在这里我们采用<strong>LC 并联电路</strong>来近似的进行表示：</p><p><span class="math display">\[f_0 = \frac{1}{2 \pi \sqrt{LC}} = 10,070,000 Hz = 10.07 MHz\]</span></p><p>利用<strong>电感</strong> <span class="math inline">\(L\)</span>的感抗，就可以得到<strong>无负载 Q 值</strong> <span class="math inline">\(Q_u\)</span>：</p><p><span class="math display">\[Q_u = \frac{X_{L,0}}{R} = \frac{\omega_0 L}{R} = \frac{2 \pi f_0 L}{R} =\frac{316.4Ω}{10.5Ω} = 30\]</span></p><p>下图所示的曲线展示了电感支路里的<strong>串联电阻</strong>大小，对于<strong>品质因数Q 值</strong>的影响：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/34.png"></p><p><strong>RLC 并联谐振电路</strong>里的<strong>电阻</strong> <span class="math inline">\(R\)</span>改变了电路的谐振条件，例如当<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 与<strong>容抗</strong> <span class="math inline">\(X_C\)</span>相等时，<code>电感</code>与<code>电容</code>支路的阻抗不为零。由于<strong>电阻</strong>的存在，使得电感支路的<code>阻抗</code>比电容支路的<code>容抗</code>更大，并且与<span class="math inline">\(X_C\)</span> 的<strong>相位角</strong>不为<code>180°</code>，因而电路的<strong>总电流</strong>并非最小值，且<code>电流</code>与<code>电压</code>的<strong>相位</strong>也不相同，如下图当中的<strong>直线A</strong> 所示。</p><p>如果稍微调整电感的取值，并且保持 <strong>Q</strong>值为常数，就会得到一个可以使得<strong>电流</strong>达到最小值的频率。我们把<strong>电流达到最小值</strong>作为<strong>RLC并联电路</strong>发生谐振的标志，电流最小值（或者阻抗最大值）所在的频率点称为<strong>反谐振点</strong>。注意不要把<strong>反谐振点</strong>与条件<span class="math inline">\(X_L = X_C\)</span>混淆。电感被微调以后，<code>电流</code>与<code>电压</code>的相位会稍有不同，如下图中的<strong>直线B</strong> 所示。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/35.png"></p><p>当电路的 <strong>Q</strong> 值达到 <code>10</code>以上时，谐振点之间的差异很小，几乎都集中在同一个频率，这种情况下可以采取近似计算，认为最小电流与电压之间的相位几乎相同，从而避免复杂的计算过程。如果假设电路的<strong>Q</strong> 值大于<code>10</code>，那么可以<strong>去掉电感支路上的串联电阻</strong>，改为<strong>采用一个并联电阻来等效电感的内阻</strong>：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/36.png"></p><p>上图左侧的<strong>串联电阻</strong> <span class="math inline">\(R_S\)</span>被右侧等效电路当中的<strong>并联电阻</strong> <span class="math inline">\(R_P\)</span>替代，反之亦然。通常称这个并联等效电阻为<strong>并联谐振电路的动态电阻</strong>，其取值与电感支路的串联电阻成反比。换而言之，并联等效电阻会随着电路<strong>Q</strong> 值的增加而变大，并联等效电阻 <span class="math inline">\(R_P\)</span> 的近似计算公式如下面所示：</p><p><span class="math display">\[R_P = \frac{X_L^2}{R_S} = \frac{(2 \pi f L)^2}{R_S} = Q_u X_L\]</span></p><p>▶【例题】假设上图左侧电路发生谐振时的感抗为<code>316Ω</code>，串联电阻为<code>10.5Ω</code>，求解电感的<strong>并联等效电阻</strong>，以及<strong>无负载Q 值</strong> ？</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/37.png"></p><p>◉【解】根据题设条件，可以得到电感的<strong>并联等效电阻</strong><span class="math inline">\(R_P\)</span> 为：</p><p><span class="math display">\[R_P = \frac{X_L^2}{R_S} = \frac{(316Ω)^2}{10.5Ω} = 9510Ω\]</span></p><p>◉【解】电感线圈的<strong>无负载 Q 值</strong> <span class="math inline">\(Q_u\)</span> 等于电感的<strong>感抗</strong> <span class="math inline">\(X_L\)</span> 除以其<strong>串联电阻</strong> <span class="math inline">\(R_S\)</span>（内阻）：</p><p><span class="math display">\[Q_u = \frac{X_L}{R_S} = \frac{316Ω}{10.5Ω} = 30\]</span></p><blockquote><p><strong>注意</strong>：让 <span class="math inline">\(Q_u\)</span>乘以<strong>电抗</strong>，也可以得到与电感器<strong>串联电阻</strong>近似的<strong>并联等效电阻</strong><span class="math inline">\(R_P\)</span>。</p></blockquote><p>发生谐振的时候，假设并联等效电路满足关系式 <span class="math inline">\(X_L = X_C\)</span>，则 <span class="math inline">\(R_P\)</span>为该并联谐振电路的<strong>等效阻抗</strong>。由于<code>感抗</code>与<code>容抗</code>相等，则<code>电压</code>与<code>电流</code>保持同相。换而言之，发生谐振时电路只呈现并联电阻的特性，因此前述的<strong>并联等效电阻</strong><span class="math inline">\(R_P\)</span>近似计算公式，可以重新改写为下面的形式：</p><p><span class="math display">\[Z = \frac{X_L^2}{R_S} = \frac{(2 \pi f L)^2}{R_S} = Q_u X_L\]</span></p><p>当电路的频率<strong>小于谐振频率</strong>时，<code>感抗</code>小于<code>容抗</code>，此时经过<code>电感</code>的电流比经过<code>电容</code>的电流更大，相互之间仅有一部分被抵消掉，因而<strong>总电流</strong>大于<strong>电阻</strong>的电流。当频率<strong>大于谐振频率</strong>时，则情况正好相反，经过<code>电容</code>的电流比经过<code>电感</code>的电流更大，<strong>总电流</strong>仍然大于<strong>电阻</strong>的电流。而在<strong>发生谐振</strong>时，电流完全由<strong>并联等效电阻</strong><span class="math inline">\(R_P\)</span> 决定，如果 <span class="math inline">\(R_P\)</span> 增大<code>电流</code>就会减小，如果<span class="math inline">\(R_P\)</span>减小<code>电流</code>就会增大。</p><p>随着总电流在谐振之后增大，并联谐振电路的阻抗下降，<code>电压</code>与<code>电流</code>之间的<strong>相位差</strong>增大，阻抗下降的速率是<span class="math inline">\(Q_u\)</span>的函数。本节内容开始位置的曲线簇，就展示了电路的 <strong>Q</strong> 值在<span class="math inline">\(10 \sim 100\)</span>范围内，阻抗由于发生谐振而下降的情况。<strong>并联电路</strong>阻抗的曲线簇本质上与<strong>串联电路</strong>电流的曲线簇相同。</p><p>如果应用<strong>半功率（<code>-3dB</code>）点</strong>来比较和测试电路性能，那么就可以将<strong>串联谐振电路的带宽公式</strong><span class="math inline">\(BW = \frac{f}{Q_u}\)</span>应用到并联谐振电路当中。接下来的表格，对于并联谐振电路的性能特点进行了归纳总结：</p><p><strong>高 Q 值</strong>与<strong>低 Q值</strong>的并联谐振电路比较：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">高 Q 值</th><th style="text-align: center;">低 Q 值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>选择性</strong></td><td style="text-align: center;"><code>高</code></td><td style="text-align: center;"><code>低</code></td></tr><tr class="even"><td style="text-align: center;"><strong>带宽</strong></td><td style="text-align: center;"><code>窄</code></td><td style="text-align: center;"><code>宽</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>阻抗</strong></td><td style="text-align: center;"><code>高</code></td><td style="text-align: center;"><code>低</code></td></tr><tr class="even"><td style="text-align: center;"><strong>线路电流</strong></td><td style="text-align: center;"><code>小</code></td><td style="text-align: center;"><code>大</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>环流</strong></td><td style="text-align: center;"><code>大</code></td><td style="text-align: center;"><code>小</code></td></tr></tbody></table><p>当<strong>电感</strong> <code>L</code> 和<strong>电容</strong><code>C</code>分别为常数时，电路远离<strong>谐振点</strong>之后的特性：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">高于谐振频率</th><th style="text-align: center;">低于谐振频率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>感抗</strong></td><td style="text-align: center;"><code>增大</code></td><td style="text-align: center;"><code>减小</code></td></tr><tr class="even"><td style="text-align: center;"><strong>容抗</strong></td><td style="text-align: center;"><code>减小</code></td><td style="text-align: center;"><code>增大</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>电路电阻</strong></td><td style="text-align: center;"><code>不变</code></td><td style="text-align: center;"><code>不变</code></td></tr><tr class="even"><td style="text-align: center;"><strong>电路阻抗</strong></td><td style="text-align: center;"><code>减小</code></td><td style="text-align: center;"><code>减小</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>线路电流</strong></td><td style="text-align: center;"><code>增大</code></td><td style="text-align: center;"><code>增大</code></td></tr><tr class="even"><td style="text-align: center;"><strong>环流</strong></td><td style="text-align: center;"><code>减小</code></td><td style="text-align: center;"><code>减小</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>电路特性</strong></td><td style="text-align: center;"><code>容性</code></td><td style="text-align: center;"><code>感性</code></td></tr></tbody></table><h4 id="循环电流">循环电流</h4><p>已知理想 <strong>LC并联谐振电路</strong>发生谐振时，<code>电容</code>与<code>电感</code>之间会存在比较大的<strong>循环电流</strong>，而<strong>电源</strong>端输出的电流为<strong>零</strong>。对于实际的<strong>RLC并联谐振电路</strong>，发生谐振时同样会存在<strong>循环电流</strong>，这个电流会比电源输出的电流更大（电源由于负载的存在电流较小，但是不会为<strong>零</strong>）。这是由于尽管谐振时电路的阻抗较大，但并非是无穷大，循环电流在通过<code>电感</code>与<code>电容</code>时产生损耗，而大部分损耗是由<code>电感</code>的内阻所造成。实际的<strong>RLC并联谐振电路</strong>（下图左）及其<strong>等效电路</strong>（下图右）如下图所示：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/38.png"></p><p>根据上图右侧的并联等效电路，可以分别求解得到<strong>电感</strong>、<strong>电容</strong>、<strong>电阻</strong>上面的电流值<span class="math inline">\(I_L\)</span>、<span class="math inline">\(I_C\)</span>、<span class="math inline">\(I_R\)</span>：</p><p><span class="math display">\[\begin{aligned}I_R &amp;= \frac{V_S}{R_P} = \frac{10 VAC}{9510Ω} = 1 mA \\I_L &amp;= \frac{V_S}{X_L} = \frac{V_S}{2 \pi f L} = \frac{10 VAC}{2 \pi\times (10.07 \times 10^6 s^{-1})\times(5.0 \times 10^{-6}H)} = \frac{10VAC}{316Ω} = 32mA \\I_C &amp;= \frac{V_S}{X_C} = \frac{V_S}{\frac{1}{2 \pi f C}} = \frac{10VAC}{\frac{1}{(2 \pi) \times (10.07 \times 10^6 s^{-1}) \times (50.0\times 10^{-12}F)}} = \frac{10 VAC}{316Ω} = 32 mA\end{aligned}\]</span></p><p>当电路工作于<strong>谐振频率</strong>时，<strong>循环电流</strong><span class="math inline">\(I_{circuiting} = I_C =I_L\)</span>，如果并联谐振电路的<strong>无负载 Q 值</strong>大于<code>10</code>，那么<strong>循环电流</strong>可以近似的等于 <span class="math inline">\(I_{circuiting} = Q_u \timesI_{total}\)</span>。在上面的例子当中，<strong>总电流</strong> <span class="math inline">\(I_R = 1 mA\)</span>，电路的 <strong>Q</strong>值等于 <code>30</code>，则<strong>循环电流</strong> <span class="math inline">\(I_{circuiting} \approx 30 \times 1mA =30mA\)</span>。</p><p>▶【例题】假设<strong>并联谐振电路</strong>的总电流为<code>50mA</code>，Q 值等于 <code>100</code>，求解经过元件的循环电流？</p><p>◉【解】根据题设条件，可以求解得到该电路当中的<strong>循环电流</strong><span class="math inline">\(I_C\)</span>：</p><p><span class="math display">\[I_C = Q_u \times I_T = 100 \times 0.05 A = 5 A\]</span></p><h4 id="无负载电路-q-值">无负载电路 Q 值</h4><p>在许多谐振电路的应用当中，实际的功率损耗主要消耗在<strong>谐振电路的内阻</strong>上面，当频率低于<code>30MHz</code>时，这个内阻主要体现为<strong>电感器的内电阻</strong>。增加电感器的线圈匝数，会让<code>感抗</code>比线圈的<code>内阻</code>增加得更快。高<strong>Q</strong> 值电路当中的电感器，通常会具有较大的电感值。</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/39.png"></p><p>当能量通过<strong>谐振电路</strong>传递到<strong>负载</strong>的时候，<strong>谐振电路</strong>消耗的能量通常会比<strong>负载</strong>消耗的能量更小。如果<strong>负载</strong>消耗的能量是<strong>电感</strong>与<strong>电容</strong>消耗能量的<code>10</code>倍以上，那么相比于<code>负载电阻</code>，谐振电路的<code>并联阻抗</code>将会更大，整个电路的<code>实际阻抗</code>等于<code>负载阻抗</code>。在这种情况下计算<strong>Q</strong>值时，可以使用<code>负载电阻</code>代替<code>电路阻抗</code>，此时并联谐振电路的<strong>Q</strong> 值计算公式为：</p><p><span class="math display">\[带负载电路的 Q 值\ Q_{LOAD} = \frac{并联负载电阻\ R_{LOAD}}{电抗\ X}\]</span></p><p>▶【例题】将一个 <code>4000Ω</code>电阻负载连接至<strong>谐振电路</strong>，当电路发生谐振时，<code>感抗</code>和<code>容抗</code>都为<code>316Ω</code>，试计算该电路的<strong>带负载 Q 值</strong> ？</p><p>◉【解】根据题设条件，就可以求解得到该电路的<strong>带负载 Q值</strong> <span class="math inline">\(Q_{LOAD}\)</span>：</p><p><span class="math display">\[Q_{LOAD} = \frac{R_{LOAD}}{X} = \frac{4000Ω}{316Ω} = 13\]</span></p><blockquote><p><strong>注意</strong>：当电路的<strong>电抗</strong>下降时，电路的<strong>带负载Q值</strong>就会增加，因而当一个<strong>带负载电路</strong>的电阻较小（几千欧姆）时，必须使用低电抗值的元件（<strong>大电容</strong>和<strong>小电感</strong>），使得发生谐振时的<strong>Q</strong> 值更大。</p></blockquote><h3 id="分贝">分贝</h3><p>电子学当中，经常需要比较两个信号的<strong>幅值</strong>以及<strong>功率</strong>。例如一个放大器的<code>输出电压</code>为<code>输入电压</code>的<code>10</code> 倍，此时的比值 <span class="math inline">\(\frac{V_{out}}{V_{in}} = \frac{10 VAC}{1 VAC} =10\)</span>被称为<strong>增益</strong>；而一个放大器的<code>输出电压</code>小于<code>输入电压</code>有<code>10</code> 倍，则比值 <span class="math inline">\(\frac{V_{out}}{V_{in}} = \frac{1 VAC}{10 VAC} =0.1\)</span> 被称为<strong>衰减</strong>。</p><p>当两个信号的<code>幅值</code>或者<code>功率</code>比值差距较大的时候，绘制曲线将会变成一件非常困难的事情。在电子学当中，就通过<strong>贝尔</strong>这个单位引入特殊的<strong>对数坐标</strong>解决这个问题，<strong>贝尔</strong><span class="math inline">\(bel\)</span> 是指<strong>比较功率</strong><span class="math inline">\(P_1\)</span> 与<strong>参考功率</strong><span class="math inline">\(P_0\)</span> 的比值：</p><p><span class="math display">\[贝尔\ bel = \log \bigg(\frac{比较功率\ P_1}{参考功率\ P_0}\bigg)\]</span></p><p>电子学当中，<strong>贝尔</strong> <span class="math inline">\(bel\)</span>经常用于比较<strong>功率</strong>的大小，但是应用更为普遍的单位是<strong>分贝</strong><code>dB</code>：</p><p><span class="math display">\[1 分贝dB  = \frac{1}{10} 贝尔bel \implies 1 贝尔bel = 10 分贝dB\]</span></p><p>因而在这里，可以改用<code>分贝</code>来度量<strong>功率</strong>的大小，前面的公式需要改写为下面的形式：</p><p><span class="math display">\[分贝\ dB  = 10 \times \log \bigg(\frac{比较功率\ P_1}{参考功率\P_0}\bigg)\]</span></p><p>▶【例题】如果一个放大器的输入信号功率为<code>1W</code>，而输出信号功率达到<code>50W</code>，试求解该放大器的增益 ？</p><p>◉【解】根据题设条件，可以求解出该放大器的增益为 <span class="math inline">\(17dB\)</span>：</p><p><span class="math display">\[dB = 10 \times \log \bigg( \frac{50W}{1W} \bigg) = 10 \times \log (50) =17 dB\]</span></p><p>比较电路当中的信号大小时，通常已知的是信号的<code>电压</code>或者<code>电流</code>，而并不是<code>功率</code>。虽然可以通过电路的阻抗计算出功率，但是更为简单的办法是将<strong>交流欧姆定律</strong>代入<strong>分贝表达式</strong>中的功率，此处调用<span class="math inline">\(P = \frac{V^2}{Z} =\frac{I^2}{Z}\)</span>（只有当电路的<strong>阻抗</strong>不随<code>电压</code>或<code>电流</code>的变化而波动时，这种情况才会成立），即只要<strong>阻抗</strong>保持不变，就可以用<strong>分贝</strong>来比较<code>电压</code>与<code>电流</code>信号。</p><p><span class="math display">\[\begin{cases}dB = 10 \log \bigg( \frac{V_1^2}{V_0^2} \bigg) = 20 \log \bigg(\frac{V_1}{V_0} \bigg) \\dB = 10 \log \bigg( \frac{I_1^2}{I_0^2} \bigg) = 20 \log \bigg(\frac{I_1}{I_0} \bigg)\end{cases}\]</span></p><p>如果<strong>输出功率</strong>是<strong>输入功率</strong>的<strong>两倍</strong>，那么就是<strong>增益</strong><code>3.01 dB</code>：</p><p><span class="math display">\[dB = 10 \log(2) = 3.01 dB\]</span></p><p>如果<strong>输出功率</strong>是<strong>输入功率</strong>的<strong>一半</strong>，那么就是<strong>衰减</strong><code>-3.01 dB</code>：</p><p><span class="math display">\[dB = 10 \log(0.5) = -3.01 dB\]</span></p><blockquote><p><strong>注意</strong>：通常会省略小数点后面的<code>0.01</code>，即认为功率<strong>翻倍</strong>时的<strong>增益</strong>为<span class="math inline">\(3dB\)</span>，而在功率<strong>减半</strong>时的<strong>衰减</strong>为<span class="math inline">\(-3dB\)</span>。</p></blockquote><p>下面的表格展示了常见的<strong>分贝</strong>值，和对应的<strong>功率</strong>变化情况，以及<strong>电压</strong>与<strong>电流</strong>的变化情况：</p><p><img src="/Electronics/Practical_Electronics/Chapter-5/40.png"></p><blockquote><p><strong>注意</strong>：只有当对应的<strong>阻抗</strong>相等时，上面表格当中所列出的关系才会成立。</p></blockquote><p>我们将以<strong>分贝</strong>作为单位的值，与 <code>1mW</code>功率的比值称为<strong>分贝毫瓦</strong><code>dBm</code>。这是一个用于指代功率的<strong>绝对值</strong>（分贝是一个表示功率的相对值）。例如从天线传递到接收设备的信号功率为<span class="math inline">\(2 \times 10^{-13}mW\)</span>，此时接收设备的信号输入强度则可以表示为：</p><p><span class="math display">\[dB_m = 10 \times \log \bigg( \frac{2 \times 10^{-13} mW}{1mW} \bigg) =-127 dBm\]</span></p><p>除此之外，还可以将使用<strong>分贝</strong>作为单位的值，与<code>1W</code> 功率的比值称为<strong>分贝瓦</strong><code>dBW</code>，而与 <code>1V</code>电压幅值的比值称为<strong>分贝伏</strong><code>dBV</code>，它们各自都拥有着相应的物理意义与用途。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《&lt;strong&gt;实用电子元器件与电路基础&lt;/strong&gt;》的英文原版书籍名称叫做《&lt;strong&gt;Practical
Electronics for
Inventors&lt;/strong&gt;》，全书从电路基本原理入手，围绕各种类型的电子元器件进行了详细介绍。首先是阐述了基本的电路理论，然后重点讨论了包括
&lt;code&gt;电阻&lt;/code&gt;、&lt;code&gt;电容&lt;/code&gt;、&lt;code&gt;电感&lt;/code&gt;、&lt;code&gt;变压器&lt;/code&gt;
在内的基本元器件；接下来介绍了半导体电子技术，并且详细分析了
&lt;code&gt;二极管&lt;/code&gt;、&lt;code&gt;晶体管&lt;/code&gt;、&lt;code&gt;晶闸管&lt;/code&gt;
等半导体元件的性能与参数，以及&lt;code&gt;运算放大器&lt;/code&gt;、&lt;code&gt;滤波电路&lt;/code&gt;、&lt;code&gt;振荡电路&lt;/code&gt;、&lt;code&gt;定时器&lt;/code&gt;、&lt;code&gt;稳压电路与电源&lt;/code&gt;
等经典的模拟电路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Electronics/Practical_Electronics/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后介绍了数字电子技术相关的内容，从基本的&lt;code&gt;逻辑门&lt;/code&gt;电路入手，重点讨论了&lt;strong&gt;组合逻辑电路&lt;/strong&gt;和&lt;strong&gt;时序逻辑电路&lt;/strong&gt;，以及相关的
&lt;code&gt;触发器&lt;/code&gt;，&lt;code&gt;寄存器&lt;/code&gt;、&lt;code&gt;计数器&lt;/code&gt;、&lt;code&gt;缓冲器&lt;/code&gt;、&lt;code&gt;锁存器&lt;/code&gt;、&lt;code&gt;收发器&lt;/code&gt;，乃至于&lt;strong&gt;存储器&lt;/strong&gt;与&lt;strong&gt;微控制器&lt;/strong&gt;。除此之外，该书还简单介绍了&lt;strong&gt;线性函数&lt;/strong&gt;、&lt;strong&gt;二次函数&lt;/strong&gt;、&lt;strong&gt;指数/对数函数&lt;/strong&gt;、&lt;strong&gt;三角函数&lt;/strong&gt;、&lt;strong&gt;复数&lt;/strong&gt;、&lt;strong&gt;微积分&lt;/strong&gt;等数学预备知识。电子元器件的&lt;strong&gt;选型&lt;/strong&gt;与&lt;strong&gt;运用&lt;/strong&gt;是硬件工程师日常工作当中最为主要的内容，希望本篇文章能够对广大电子爱好者有所帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Electronics" scheme="http://www.uinio.com/categories/Electronics/"/>
    
    
    <category term="Circuit Analysis" scheme="http://www.uinio.com/tags/Circuit-Analysis/"/>
    
  </entry>
  
</feed>
