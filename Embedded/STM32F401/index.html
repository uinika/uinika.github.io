<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>基于 HAL 与 LL 的 UINIO-MCU-STM32F401 开发实践 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="相较于前一篇运用标准外设库（Standard Peripherals Library）开发的 STM32F403C8T6 微控制器，采用 UFQFPN48 封装的 STM32F401CCU6 则是基于 ARM Cortex®-M4 内核，内置有浮点运算单元（FPU，Float Point Unit）、自适应实时加速器（ART，Adaptive Realtime Accelerator）"><meta property="og:type" content="blog"><meta property="og:title" content="基于 HAL 与 LL 的 UINIO-MCU-STM32F401 开发实践"><meta property="og:url" content="http://www.uinio.com/Embedded/STM32F401/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="相较于前一篇运用标准外设库（Standard Peripherals Library）开发的 STM32F403C8T6 微控制器，采用 UFQFPN48 封装的 STM32F401CCU6 则是基于 ARM Cortex®-M4 内核，内置有浮点运算单元（FPU，Float Point Unit）、自适应实时加速器（ART，Adaptive Realtime Accelerator）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2019-07-25T16:00:00.000Z"><meta property="article:modified_time" content="2021-11-11T16:00:00.000Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Embedded/STM32F401/"},"headline":"基于 HAL 与 LL 的 UINIO-MCU-STM32F401 开发实践","image":["http://www.uinio.com/Embedded/STM32F401/logo.png"],"datePublished":"2019-07-25T16:00:00.000Z","dateModified":"2021-11-11T16:00:00.000Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"相较于前一篇运用标准外设库（Standard Peripherals\r Library）开发的 STM32F403C8T6 微控制器，采用\r UFQFPN48 封装的 STM32F401CCU6 则是基于\r ARM Cortex®-M4\r 内核，内置有浮点运算单元（FPU，Float Point\r Unit）、自适应实时加速器（ART，Adaptive Realtime\r Accelerator）"}</script><link rel="canonical" href="http://www.uinio.com/Embedded/STM32F401/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-25T16:00:00.000Z" title="2019/7/26 00:00:00">2019-07-26</time>发表</span><span class="level-item"><time dateTime="2021-11-11T16:00:00.000Z" title="2021/11/12 00:00:00">2021-11-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/">嵌入式固件</a></span><span class="level-item">3 小时读完 (大约26381个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">基于 HAL 与 LL 的 UINIO-MCU-STM32F401 开发实践</h1><div class="content"><p>相较于前一篇运用<strong>标准外设库</strong>（Standard Peripherals
Library）开发的 <strong>STM32F403C8T6</strong> 微控制器，采用
<code>UFQFPN48</code> 封装的 <strong>STM32F401CCU6</strong> 则是基于
<strong>ARM Cortex®-M4</strong>
内核，内置有浮点运算单元（<strong>FPU</strong>，Float Point
Unit）、自适应实时加速器（<strong>ART</strong>，Adaptive Realtime
Accelerator）、数字信号处理器（<strong>DSP</strong>，Digital Signal
Processor）指令，内置 <code>16mHz</code> 高速与 <code>32kHz</code>
低速晶体振荡器，工作时钟频率高达 <code>84mHz</code>，采用
<code>1.7V ~ 3.6V</code> 电源进行供电。</p>
<p><img src="/Embedded/STM32F401/logo.png"></p>
<p>因为 <strong>STM32F401CCU6</strong>
提供了较大的数据与程序存储空间，所以本文将会基于<strong>意法半导体
ST</strong>
近年来主推的<strong>硬件抽象层</strong>（<strong>HAL</strong>，Hardware
Abstraction
Layer）以及<strong>底层</strong>（<strong>LL</strong>，Low-layer）开发库，并且结合
<strong>STM32CubeIDE</strong>
提供的便捷图形化配置工具。本文写作过程当中，参考了意法半导体的<strong>《STM32F401xC
Data Sheet》</strong>和<strong>《STM32F401xC Reference
Manual》</strong>以及<strong>《Description of STM32F4 HAL &amp; LL
drivers》</strong>三份官方文档。</p>
<span id="more"></span>
<h2 id="arm-cortex-m4-概要">ARM Cortex M4 概要</h2>
<h3 id="外设资源-peripheral">外设资源 Peripheral</h3>
<p><strong>STM32F401CC</strong> 是一款携带有 DSP 和 FPU、ART 的 ARM
Cortex-M4 内核高性能基本型微控制器，拥有 <code>256kBytes</code> 的
<strong>Flash</strong> 程序存储器、<code>64kBytes</code> 的
<strong>SRAM</strong> 数据存储器、<code>512Bytes</code> 的
<strong>OTP</strong> 一次性可编程存储器，同时内置了 <code>3</code> 组
<strong>I²C</strong>、<code>3</code> 组
<strong>USART</strong>、<code>4</code> 组 <strong>SPI</strong>
总线接口、<code>2</code> 个 <strong>DMA</strong> 控制器、<code>11</code>
个 <strong>Timer</strong> 定时器，以及 <code>81</code> 个带有中断的
GPIO，具体的外设资源请参考下面表格：</p>
<p><img src="/Embedded/STM32F401/ARM/Peripheral-1.png"></p>
<h3 id="引脚定义-pin">引脚定义 Pin</h3>
<p><strong>STM32F401CC</strong> 一共拥有 48
个物理引脚，根据引脚功能的不同，可以划分为如下 5 种类型：</p>
<p><img src="/Embedded/STM32F401/ARM/Peripheral-2.png"></p>
<ol type="1">
<li>（红色）<strong>电源引脚</strong>：其中 <code>VDD 和 VSS</code>
是<strong>数字电源</strong>，主要为片内的数字外设供电；<code>VDDA/VREF+ 和 VSSA/VREF-</code>
为<strong>模拟电源</strong>，主要为片内的模拟外设供电，同时作为 AD/DA
转换器的电压基准；<code>VBAT</code>
用于连接外部的备用电池，确保片内的实时时钟在掉电之后，依然能够正常工作；<code>VCAP_1</code>
用于片内电压调节器输出，通常会接入一枚 <code>2.2uF</code>
电容，然后再连接至 <strong>GND</strong>；</li>
<li>（蓝色）<strong>复位与启动模式引脚</strong>：<code>NRST</code>
为复位引脚，低电平有效；启动模式引脚包括
<code>BOOT0 和 PB2/BOOT1</code>，通过其电平组合来配置微控制器的启动模式；</li>
<li>（绿色）<strong>时钟引脚</strong>：<code>OSC32_IN 和 OSC32_OUT</code>
用于连接芯片外部的低速时钟，通常是一枚工作频率为 <code>32.768 kHz</code>
的晶振；而 <code>OSC_IN 和 OSC_OUT</code>
则用于连接外部高速时钟，通常是工作频率为 <code>4mHz ~ 26mHz</code>
范围的晶振；</li>
<li>（橙色）<strong>仿真调试引脚</strong>：<code>PA13 和 PA14</code>
作为<strong>串行线调试</strong>（SWD，Serial Wire Debug）接口；</li>
<li>（其它）<strong>通用输入输出引脚</strong>：除了作为 GPIO
用途之外，还可以被映射成为片内其它外设的功能引脚；</li>
</ol>
<h3 id="启动模式-boot">启动模式 Boot</h3>
<p><strong>STM32F401CC</strong> 提供了 3
种不同的启动模式，这些模式可以通过组合 <code>BOOT0</code> 和
<code>PB2/BOOT1</code> 引脚的电平状态进行选择：</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 41%">
<col style="width: 45%">
</colgroup>
<thead>
<tr>
<th>BOOT1</th>
<th>BOOT0</th>
<th>启动模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>×</td>
<td><code>0</code></td>
<td>主 <strong>Flash</strong> 存储器模式</td>
<td>选择主 <strong>Flash</strong> 作为启动区域；</td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td>系统存储器模式，即 <strong>ISP</strong> 模式</td>
<td>选择<strong>系统内存</strong>作为启动区域；</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td>内置 <strong>SRAM</strong> 模式</td>
<td>选择内置的 <strong>SRAM</strong> 作为启动区域；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上面表格当中的 <code>BOOT0</code>
是专用引脚，而 <code>BOOT1</code> 复用了 GPIO 引脚
<code>PB2</code>，一旦 <code>PB2</code> 作为 <code>BOOT1</code>
的电平状态被采样之后，就可以作用普通 GPIO 引脚进行使用。</p>
</blockquote>
<h3 id="系统复位-reset">系统复位 Reset</h3>
<p><strong>STM32F401CC</strong> 总共拥有
<strong>系统复位</strong>、<strong>电源复位</strong>、<strong>备份域复位</strong>
三种不同类型的复位方式，下面展示了内部复位电路的简化示意图：</p>
<p><img src="/Embedded/STM32F401/ARM/Reset.png"></p>
<ul>
<li><strong>系统复位</strong>（System
Reset）：除开<strong>时钟控制寄存器</strong> <code>CSR</code>
的重置标志位，以及<strong>备份域</strong>当中的寄存器之外，其它所有寄存器都会被重置为默认值，系统复位通常发生于如下场景：
<ol type="1">
<li>复位引脚 <code>NRST</code>
处于低电平状态时，即<strong>外部复位</strong>；</li>
<li>窗口看门狗计数条件结束，即<strong>窗口看门狗复位</strong>；</li>
<li>独立看门狗计数条件结束，即<strong>独立看门狗复位</strong>；</li>
<li>进入<code>待机</code>或者<code>停止</code>模式时，所发生的<strong>低功耗管理复位</strong>；</li>
<li>出现<strong>软件复位</strong>的情况，复位源可以通过检查 RCC
时钟控制状态寄存器 <code>RCC_CSR</code> 的复位标志来进行识别；</li>
</ol></li>
<li><strong>电源复位</strong>（Power
Reset）：发生如下事件时就会产生电源复位：
<ol type="1">
<li>发生电源开启或者关闭，以及出现低电压的时候；</li>
<li>退出待机模式的时候；</li>
</ol></li>
<li><strong>备份域复位</strong>（Backup Domain Reset）：备份域仅拥有 2
种类型的复位，分别发生在如下的场景：
<ol type="1">
<li>设置 RCC 备份域控制寄存器 <code>RCC_BDCR</code> 的
<code>BDRST</code> 位，触发<strong>软件复位</strong>的情况；</li>
<li>电源 <span class="math inline">\(V_{DD}\)</span> 或者 <span class="math inline">\(V_{BAT}\)</span> 关闭之后再重新上电的时候；</li>
</ol></li>
</ul>
<h3 id="总线架构-bus">总线架构 Bus</h3>
<p><strong>STM32F401CC</strong> 的系统架构由 32 位相互连接的多层
<strong>AHB</strong> 总线矩阵构成，其中 <strong>AHB</strong>
称为<strong>高级高性能总线</strong>（Advanced High-performance
Bus），通常用于连接高速外设；而 <strong>APB</strong>
称为<strong>高级外围总线</strong>（Advanced Peripheral
Bus），通常用于连接低速外设，具体细节可以参考下面的图示：</p>
<p><img src="/Embedded/STM32F401/ARM/Bus-1.png"></p>
<p>其中，整个系统架构主要包含 <strong>6</strong>
条<strong>主设备总线</strong>（Master）：Cortex-M4 的
<strong>I-bus</strong>、<strong>D-bus</strong>、<strong>S-bus</strong>
总线，<strong>DMA1</strong> 和 <strong>DMA2</strong>
内存总线，<strong>DMA2</strong> 外设总线。以及 <strong>5</strong>
条<strong>从设备总线</strong>（Slave）：内部 Flash 内存的
<strong>ICode</strong> 和 <strong>DCode</strong>
总线、<strong>SRAM</strong> 总线、<strong>AHB1</strong> 和（包含
<code>AHB-APB</code> 桥和 <code>APB</code> 外设）、<strong>AHB2</strong>
外设总线，这些总线之间相互连接的情况可以参考接下来的示意图：</p>
<p><img src="/Embedded/STM32F401/ARM/Bus-2.png"></p>
<ul>
<li><strong>I-bus 总线</strong>：将 Cortex-M4
<code>指令总线</code>连接至<code>总线矩阵</code>，该总线被 Cortex-M4
核心用于获取指令，其传输目标是存放有程序代码的内部 Flash/SDRAM
存储器；</li>
<li><strong>D-bus 总线</strong>：将 Cortex-M4
<code>数据总线</code>连接至<code>总线矩阵</code>，该总线被 Cortex-M4
核心用于加载字符和调试访问，其传输目标是存放有数据或者代码的内部
Flash/SDRAM 存储器；</li>
<li><strong>S-bus 总线</strong>：将 Cortex-M4
的<code>系统总线</code>连接至<code>总线矩阵</code>，该总线用于访问外设或者
SRAM 里的数据，也可以用于获取指令（效率比 ICode 要低），其传输目标是内部
SRAM、AHB1 外设（包括 APB 与 AHB2 外设）；</li>
<li><strong>DMA 存储总线</strong>：将
<code>DMA 内存总线主接口</code>连接至<code>总线矩阵</code>，该总线用于<strong>直接存储器存取</strong>（DMA，Direct
Memory Access）执行存储器的存取操作，其传输目标是数据存储器（内部 Flash
或者 SRAM，以及包括 APB 外设在内的 AHB1/AHB2 外设）；</li>
<li><strong>DMA 外设总线</strong>：将
<code>DMA 外设主总线接口</code>连接至<code>总线矩阵</code>，该总线用于访问
AHB 外设或者存储器之间的数据传输，其传输目标是 AHB 和 APB
外设加上数据存储器（Flash 或者 SRAM）；</li>
<li><strong>总线矩阵</strong>：用于<code>主设备</code>之间的访问仲裁，并且使用<strong>轮循算法</strong>作为仲裁机制；</li>
<li><strong>AHB/APB 桥（APB）</strong>：两个 <code>AHB/APB 桥</code>以及
<code>APB1</code> 和 <code>APB2</code>，提供了 <code>AHB</code> 与两条
<code>APB 总线</code>之间的全同步连接，并且允许灵活的选择外围频率；</li>
</ul>
<h3 id="内存映射-memory-mapping">内存映射 Memory Mapping</h3>
<p><strong>STM32F401CC</strong>
的<code>程序存储器</code>、<code>数据存储器</code>、<code>寄存器</code>、<code>I/O 端口</code>都被组织到了一个
<code>4GB</code>
的线性内存地址空间，字节在内存当中以<strong>小端格式</strong>进行编码，这些可寻址的存储空间被分配为
<strong>5</strong> 个大小为 <code>512MB</code>
的<strong>块</strong>（Block），其中所有未分配的内存区域都被认为是<strong>预留</strong>空间，具体映射关系请参考下面的示意图以及后续的表格：</p>
<p><img src="/Embedded/STM32F401/ARM/Memory-Mapping.png"></p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 54%">
<col style="width: 4%">
<col style="width: 24%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">标识颜色</th>
<th style="text-align: center;">块编号</th>
<th style="text-align: left;">功能描述</th>
<th style="text-align: center;">容量</th>
<th style="text-align: center;">地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">绿色</td>
<td style="text-align: center;"><strong>Block 0</strong></td>
<td style="text-align: left;">分配给片上的 <strong>Flash</strong>
以及系统存储器；</td>
<td style="text-align: center;">512MB</td>
<td style="text-align: center;"><code>0x0000 0000 ~ 0x1FFF FFFF</code></td>
</tr>
<tr>
<td style="text-align: center;">粉色</td>
<td style="text-align: center;"><strong>Block 1</strong></td>
<td style="text-align: left;">分配给片上的 <strong>SRAM</strong>
存储器;</td>
<td style="text-align: center;">512MB</td>
<td style="text-align: center;"><code>0x2000 0000 ~ 0x3FFF FFFF</code></td>
</tr>
<tr>
<td style="text-align: center;">蓝色</td>
<td style="text-align: center;"><strong>Block 2</strong></td>
<td style="text-align: left;">分配给片上的
<strong>AHB1</strong>、<strong>AHB2</strong>、<strong>APB1</strong>、<strong>APB2</strong>
总线外设</td>
<td style="text-align: center;">512MB</td>
<td style="text-align: center;"><code>0x4000 0000 ~ 0x5FFF FFFF</code></td>
</tr>
</tbody>
</table>
<h2 id="stm32f401-核心电路分析">STM32F401 核心电路分析</h2>
<p><img src="/Embedded/STM32F401/Schematic/Pin.png"></p>
<h3 id="mcu-微控制器">MCU 微控制器</h3>
<p><strong>STM32F401CC</strong> 的高速时钟引脚 <code>OSC_IN</code> 和
<code>OSC_OUT</code> 连接到一颗贴片封装的 <code>25mHz</code>
无源晶振，并且并联了两颗 <code>8 pF</code>
的负载电容，从而组成了一个完整的晶体震荡电路。类似的，低速时钟引脚
<code>OSC32_IN</code> 和 <code>OSC32_OUT</code> 连接到一颗贴片封装的
<code>32.768kHz</code> 无源晶振，同时并联了两颗 <code>1.5 pF</code>
<strong>负载电容</strong>。而作为电压调节器用途的 <code>VCAP_1</code>
则按照官方数据手册接入了一枚 <code>2.2uF</code> 电容，然后再接入到
<strong>GND</strong>。</p>
<p><img src="/Embedded/STM32F401/Schematic/MCU-1.png"></p>
<p>除此之外，<code>3.3V</code> 电源与 <strong>GND</strong> 之间的 3
颗并联 <code>0.1uF</code>
去耦电容，分别连接到<strong>数字电源引脚</strong> <code>VDD</code> 与
<code>VSS</code> 之间。而由 <code>1uF</code> 并联 <code>0.1uF</code>
电容组成的滤波电路，则连接到了<strong>模拟电源引脚</strong>
<code>VDDA\VREF+</code> 与 <code>VSSA\VREF-</code> 之间，并且
<code>VDDA\VREF+</code> 还串联有一枚 <code>100mHz</code> 频率下感抗为
<code>1kΩ</code> 的滤波电感。</p>
<p><img src="/Embedded/STM32F401/Schematic/MCU-2.png"></p>
<p>而 <strong>STM32F401CC</strong> 的 <code>VBAT</code> 引脚连接到了 RTC
实时时钟电路，然后并联了一枚 <code>0.1uF</code> 去耦电容
<code>C2</code>，而在该电路的一端连接至 <code>3.3V</code>
电源，而另一端则连接至开发板排针的 <code>VB</code>
端，用于外接备用电源；除此之外，该电路中间还逆向并联有 2
枚的肖特基二极管，用于在开发板上电时选择 <code>3.3V</code>
电源供电，而在断电之后选择 <code>VB</code> 排针外接的电源进行供电。</p>
<h3 id="复位电路-reset">复位电路 Reset</h3>
<p>复位引脚 <code>NRST</code> 低电平有效，开发板正常工作时通过一枚
<code>10kΩ</code> 上拉电阻连接到 <code>3.3V</code>
电源，当按键按下时，则引脚电平状态被 GND 拉低产生复位信号，按键并联的
<code>0.1uF</code> 电容用于消除按键被按下时产生的机械抖动。</p>
<p><img src="/Embedded/STM32F401/Schematic/Reset.png"></p>
<h3 id="启动配置按钮-boot">启动配置按钮 Boot</h3>
<p>当按键按下时，<code>BOOT0</code> 高电平 <code>BOOT1/PB2</code>
低电平，开发板会从系统内存启动，即进入 ISP
串口下载模式；而当按键没有被按下时，<code>BOOT0</code> 低电平
<code>BOOT1/PB2</code> 高电平，则开发板将会从 SRAM
启动；该电路当中，<code>10kΩ</code> 电阻与 <code>0.1uF</code>
电容并联成为一个<strong>高通滤波电路</strong>，而另一枚
<code>10kΩ</code> 电阻将会作为下拉电阻，将 <code>BOOT1/PB2</code>
始终控制在低电平状态。</p>
<p><img src="/Embedded/STM32F401/Schematic/Boot.png"></p>
<h3 id="usb-type-c-接口">USB Type-C 接口</h3>
<p>开发板采用支持正反面插入的 16 针 USB Type-C
接口，其模型左右两侧引脚呈对称分布，其中 <code>USB_DP</code> 与
<code>USB_DN</code> 连接到 <strong>STM32F401CC</strong> 的
<code>PA12/RX</code> 和 <code>PA11/TX</code>
作为串口下载接口，而配置通道（Configration Channel）引脚 <code>CC</code>
则通过 <code>5.1kΩ</code> 下拉电阻接入 GND，而 <code>VBUS</code>
电源引脚通过一枚用于防止电涌的 <code>D4</code> 二极管，连接到后续的
<strong>LDO 低压差线性稳压器</strong>，同时并联有一组跳线帽
<strong>SB1</strong>，用于开发板接入较大负载时，防止电流过大导致二极管
<code>D4</code> 损坏。</p>
<p><img src="/Embedded/STM32F401/Schematic/USB.png"></p>
<h3 id="线性稳压器-ldo">线性稳压器 LDO</h3>
<p>开发板采用了一枚日本<strong>特瑞仕</strong> <a target="_blank" rel="noopener" href="https://www.torex.com.cn/file/xc6204/XC6204-XC6205.pdf"><strong>TOREX</strong></a>
公司的 <strong>XC6204</strong> 系列低压差线性稳压器（LDO，Low Dropout
Regulator），该系列是使用 CMOS 工艺制造的高精度、低噪声、正电压 LDO
稳压器，具备高纹波抑制和低压降特性，内部电路主要由<code>标准电压源</code>、<code>误差校正</code>、<code>电流限流器</code>、<code>相位补偿电路</code>加上<code>驱动晶体管</code>组成，输出电压可以在
<code>0.9V ~ 6.0V</code> 范围内按照 <code>0.05V</code>
的步长进行选择。</p>
<p><img src="/Embedded/STM32F401/Schematic/LDO.png"></p>
<h3 id="用户按键-button">用户按键 Button</h3>
<p>开发板提供了一枚可以由用户自定义的功能按键，通过阻值为
<code>33Ω</code> 的下拉电阻连接至
<code>GND</code>，当按下该按键的时候，就会将 <strong>PA0</strong>
引脚（对应于 PCB 丝印为 <code>A0</code> 的排针位置）的电平状态拉低。</p>
<p><img src="/Embedded/STM32F401/Schematic/Button.png"></p>
<h3 id="状态指示-led">状态指示 LED</h3>
<p>由于红色 LED 的典型正向导通电压为 <code>2V</code>，蓝色 LED
的典型正向导通电压为 <code>3.3V</code>，所以电路上分别采用了
<code>1.5kΩ</code> 和 <code>5.1kΩ</code> 两颗不同的限流电阻。</p>
<p><img src="/Embedded/STM32F401/Schematic/LED.png"></p>
<h3 id="串行线调试接口-swd">串行线调试接口 SWD</h3>
<p><strong>串行线调试</strong>（SWD，Serial Wire
Debug）接口的<strong>串行数据线</strong>（SWDIO）和<strong>串行时钟线</strong>（SWDCLK）分别连接至
<strong>STM32F401CC</strong> 的 <code>PA13</code> 和 <code>PA14</code>
引脚，这两个引脚并没有连接到 PCB
排针上面，因而只可以作为仿真调试使用。</p>
<p><img src="/Embedded/STM32F401/Schematic/SWD.png"></p>
<h3 id="板载-nor-flash">板载 NOR Flash</h3>
<p>台湾<strong>华邦</strong>（Winbond）的 <a target="_blank" rel="noopener" href="https://www.winbond.com/hq/product/code-storage-flash-memory/serial-nor-flash/?__locale=zh&amp;partNo=W25Q32JV"><code>W25Q32/64/128JVSSIQ</code></a>
是一款采用 SPI 总线连接的 NOR Flash 存储器芯片，可以选择
<strong>32Mb</strong>、<strong>64Mb</strong>、<strong>128Mb</strong>
三种不同容量，采用 8 个引脚的 SOIC 封装，工作电压介于
<code>2.7V ~ 3.6V</code> 范围。</p>
<p><img src="/Embedded/STM32F401/Schematic/Flash.png"></p>
<p><strong>STM32F401CC</strong> 开发板电路预留有焊接该存储芯片的位置，其
<code>VCC</code> 与 <code>GND</code> 引脚并联了一颗 <code>0.1uF</code>
滤波电容，用于滤除存储芯片工作电流发生变化时造成的电路纹波。而
<strong>SPI
片选</strong>（F_CS）、<strong>串行时钟输入</strong>（SCK）、<strong>数据输入</strong>（MOSI）、<strong>数据输出</strong>（MISO）四个引脚则作为
SPI 总线连接至 <strong>STM32F401CC</strong> 的
<code>PA4</code>、<code>PA5</code>、<code>PA7</code>、<code>PA6</code>，这四个引脚已经被连接到开发板上的排针，复用这几个引脚的功能时时需要特别注意。</p>
<h2 id="hal-硬件抽象层">HAL 硬件抽象层</h2>
<p><strong>硬件抽象层</strong>（HAL，Hardware Abstraction
Layer）驱动程序提供了一组功能丰富，易于与应用上层交互的
API，它们涵盖了常见的外围设备，可以非常方便的向其它型号 STM32
微控制器移植。同时还实现了用户回调函数机制，允许并发调用
<code>USART1</code> 以及 <code>USART2</code>
等外设，并且支持<strong>轮询</strong>、<strong>中断</strong>、<strong>DMA</strong>
三种 API 编程模式，HAL 固件库的驱动程序主要由如下的源代码文件构成：</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">源文件</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_ppp.c</code><br><code>stm32f4xx_hal_ppp.h</code></td>
<td style="text-align: left;">主要外设/模块驱动 <code>.c</code>
源文件以及 <code>.h</code> 头文件，包括所有设备通用的 API，例如
<code>stm32f4xx_hal_adc.c</code>、<code>stm32f4xx_hal_irda.c</code> 以及
<code>stm32f4xx_hal_adc.h</code>、<code>stm32f4xx_hal_irda.h</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_ppp_ex.c</code><br><code>stm32f4xx_hal_ppp_ex.h</code></td>
<td style="text-align: left;">外设/模块驱动程序扩展的 <code>.c</code>
源文件以及 <code>.h</code> 头文件，通常用于定义某个指定型号独有的
API，例如 <code>stm32f4xx_hal_adc_ex.c</code> 以及
<code>stm32f4xx_hal_flash_ex.c</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal.c</code><br><code>stm32f4xx_hal.h</code></td>
<td style="text-align: left;">用于初始化 HAL 固件库的 <code>.c</code>
源文件以及 <code>.h</code> 头文件，包含有
<code>DBGMCU</code>、<code>Remap</code> 和基于 <code>SysTick</code>
的时间延迟函数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_msp_template.c</code></td>
<td style="text-align: left;">需要复制到用户应用工程目录的模板文件，包含有外设的<strong>主堆栈指针</strong>（<strong>MSP</strong>，Main
Stack Pointer）的初始化和反向初始化；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_conf_template.h</code></td>
<td style="text-align: left;">用于配置指定应用驱动的模板文件；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_def.h</code></td>
<td style="text-align: left;">通用的 HAL 固件库资源，例如通用的
<code>语句</code>、<code>枚举</code>、<code>结构体</code>、<code>宏</code>
等定义；</td>
</tr>
</tbody>
</table>
<p>下面的表格列出了通过 HAL 固件库，构建用户应用程序所需的最小 HAL
固件库文件集合：</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">源文件</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>system_stm32f4xx.c</code></td>
<td style="text-align: left;">包含系统启动时调用的
<code>SystemInit()</code> 方法，该方法允许重新定位内部 SRAM
中的向量表，并且配置 FSMC/FMC（如果可用）使用外置的 SRAM 或者 SDRAM
作为数据存储器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>startup_stm32f4xx.s</code></td>
<td style="text-align: left;">包含有<code>重置处理器</code>与<code>异常向量</code>在内的，工具链指定的文件；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_flash.icf</code></td>
<td style="text-align: left;"><strong>（可选）</strong>EWARM
工具链的链接器文件，允许调整堆/栈大小以适应程序的需求；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_msp.c</code></td>
<td style="text-align: left;">包含用户应用程序当中使用到的外设<strong>主堆栈指针</strong>
MSP
的<code>初始化</code>与<code>反向初始化</code>（主程序与回调函数）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_hal_conf.h</code></td>
<td style="text-align: left;">该文件允许用户为特定的应用程序定制 HAL
驱动程序；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_it.c</code> <br>
<code>stm32f4xx_it.c.h</code></td>
<td style="text-align: left;">包含异常处理程序与外围设备中断服务程序；</td>
</tr>
<tr>
<td style="text-align: left;"><code>main.c</code> <br>
<code>main.c.h</code></td>
<td style="text-align: left;">用户主程序，除了放置用户程序代码之外，还会调用
<code>HAL_Init()</code>、实现
<code>assert_failed()</code>、配置系统时钟、初始化指定外设；</td>
</tr>
</tbody>
</table>
<h3 id="包含的数据结构">包含的数据结构</h3>
<p>每一个 HAL 固件驱动程序都会包含有如下三种类型的数据结构：</p>
<ol type="1">
<li><strong>外设操作结构体</strong>：<code>PPP_HandleTypeDef</code> 是
HAL
驱动程序当中主要的实现结构，用于配置外设、注册和嵌入外设相关的结构体与变量，例如
<code>stm32f4xx_hal_usart.c</code> 固件库文件当中定义的
<code>USART_HandleTypeDef</code> 结构体： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    USART_TypeDef *Instance;               <span class="comment">/* USART 寄存器基地址 */</span></span><br><span class="line">    USART_InitTypeDef Init;                <span class="comment">/* USART 通信参数 */</span></span><br><span class="line">    <span class="type">uint8_t</span> *pTxBuffPtr;                   <span class="comment">/* 指向 USART Tx 发送缓冲区的指针 */</span></span><br><span class="line">    <span class="type">uint16_t</span> TxXferSize;                   <span class="comment">/* USART 发送大小 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> TxXferCount;             <span class="comment">/* USART 发送计数器 */</span></span><br><span class="line">    <span class="type">uint8_t</span> *pRxBuffPtr;                   <span class="comment">/* 指向 USART Rx 传输缓冲区的指针 */</span></span><br><span class="line">    <span class="type">uint16_t</span> RxXferSize;                   <span class="comment">/* USART Rx 传输大小 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> RxXferCount;             <span class="comment">/* USART Rx 传输计数器 */</span></span><br><span class="line">    DMA_HandleTypeDef *hdmatx;             <span class="comment">/* USART Tx 的 DMA 处理参数 */</span></span><br><span class="line">    DMA_HandleTypeDef *hdmarx;             <span class="comment">/* USART Rx 的 DMA 处理参数 */</span></span><br><span class="line">    HAL_LockTypeDef Lock;                  <span class="comment">/* 对象锁定 */</span></span><br><span class="line">    __IO HAL_USART_StateTypeDef State;     <span class="comment">/* USART 通信状态 */</span></span><br><span class="line">    __IO HAL_USART_ErrorTypeDef ErrorCode; <span class="comment">/* USART 错误代码 */</span></span><br><span class="line">&#125; USART_HandleTypeDef;</span><br></pre></td></tr></table></figure></li>
<li><strong>初始化与配置结构体</strong>：<code>PPP_InitTypeDef</code>
结构体定义在通用固件驱动程序的 <code>.h</code> 头文件当中；
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> BaudRate;     <span class="comment">/* 配置 UART 通信波特率 */</span></span><br><span class="line">    <span class="type">uint32_t</span> WordLength;   <span class="comment">/* 指定接收或者发送数据的长度 */</span></span><br><span class="line">    <span class="type">uint32_t</span> StopBits;     <span class="comment">/* 指定传输的停止位数 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Parity;       <span class="comment">/* 指定校验模式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Mode;         <span class="comment">/* 启用或者禁用收发模式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> HwFlowCtl;    <span class="comment">/* 启用或者禁用硬件流控制模式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OverSampling; <span class="comment">/* 启用或者禁用过采样，以达到更高的速度（可以达到 fPCLK/8）*/</span></span><br><span class="line">&#125; UART_InitTypeDef;</span><br></pre></td></tr></table></figure> 除此之外，<strong>配置结构体</strong>
<code>HAL_PPP_Config</code>
用于初始化<code>子模块</code>或者<code>子实例</code>，例如下面 ADC
模数转换器外设示例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_ConfigChannel (ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)</span><br></pre></td></tr></table></figure></li>
<li><strong>指定流程结构体</strong>：<code>HAL_PPP_Process</code>
用于通用 API 当中的特定流程，通常被定义在通用固件驱动程序的
<code>.h</code> 头文件当中； <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_Process (PPP_HandleTypeDef* hadc,PPP_ProcessConfig* sConfig)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="hal-库-api-的分类">HAL 库 API 的分类</h3>
<p>HAL 固件库的 API
可以被划分为<strong>通用</strong>（Generic）和<strong>扩展</strong>（Extension）两种类型：</p>
<ul>
<li><strong>通用 API</strong>：适用于所有 STM32 微控制器，主要出现在 HAL
固件库的<strong>通用</strong>（Generic）驱动程序源文件当中；
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_Init</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_DeInit</span><span class="params">(ADC_HandleTypeDef *hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_Start</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_Stop</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_Start_IT</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_Stop_IT</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_IRQHandler</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>扩展
API</strong>：可以进一步划分为<strong>指定系列</strong>与<strong>指定型号</strong>两种类型，处于
HAL 固件库的<strong>扩展</strong>（Extension）驱动程序源文件
<code>stm32f4xx_hal_ppp_ex.c</code> 和
<code>stm32f4xx_hal_ppp_ex.h</code> 当中； <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定系列的扩展 API */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStop</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStop_IT</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStart</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStart_IT</span><span class="params">(ADC_HandleTypeDef* hadc)</span>;</span><br><span class="line"><span class="comment">/* 指定型号的扩展 API */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_OB_SelectPCROP</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_OB_DeSelectPCROP</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || */</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面表格总结了不同类型的 HAL 固件库 API
在驱动程序源代码文件当中的位置：</p>
<table>
<thead>
<tr>
<th style="text-align: center;"> </th>
<th style="text-align: center;">通用驱动源文件</th>
<th style="text-align: center;">扩展驱动源文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>公用 API</strong></td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
</tr>
<tr>
<td style="text-align: center;"><strong>产品系列 API</strong></td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
</tr>
<tr>
<td style="text-align: center;"><strong>指定型号 API</strong></td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
</tr>
</tbody>
</table>
<h3 id="hal-驱动规范">HAL 驱动规范</h3>
<h4 id="hal-api-命名规则">HAL API 命名规则</h4>
<p>HAL 固件库当中所使用的驱动程序命名规则如下面表格所示：</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 28%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;"> </th>
<th style="text-align: left;">通用</th>
<th style="text-align: left;">系列指定</th>
<th style="text-align: left;">具体型号指定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">模块名称</td>
<td style="text-align: left;"><code>stm32f4xx_hal_ppp (c/h)</code></td>
<td style="text-align: left;"><code>stm32f4xx_hal_ppp_ex (c/h)</code></td>
<td style="text-align: left;"><code>stm32f4xx_ hal_ppp_ex (c/h)</code></td>
</tr>
<tr>
<td style="text-align: left;">函数名称</td>
<td style="text-align: left;"><code>HAL_PPP_ MODULE</code></td>
<td style="text-align: left;"><code>HAL_PPP_ MODULE</code></td>
<td style="text-align: left;"><code>HAL_PPP_ MODULE</code></td>
</tr>
<tr>
<td style="text-align: left;">头文件名称</td>
<td style="text-align: left;"><code>HAL_PPP_Function</code><br><code>HAL_PPP_FeatureFunction_MODE</code></td>
<td style="text-align: left;"><code>HAL_PPPEx_Function</code><br><code>HAL_PPPEx_FeatureFunction_MODE</code></td>
<td style="text-align: left;"><code>HAL_PPPEx_Function</code><br><code>HAL_PPPEx_FeatureFunction_MODE</code></td>
</tr>
<tr>
<td style="text-align: left;">指针名称</td>
<td style="text-align: left;"><code>PPP_HandleTypedef</code></td>
<td style="text-align: left;"><strong>NA</strong></td>
<td style="text-align: left;"><strong>NA</strong></td>
</tr>
<tr>
<td style="text-align: left;">初始化结构体名称</td>
<td style="text-align: left;"><code>PPP_InitTypeDef</code></td>
<td style="text-align: left;"><strong>NA</strong></td>
<td style="text-align: left;"><code>PPP_InitTypeDef</code></td>
</tr>
<tr>
<td style="text-align: left;">枚举名称</td>
<td style="text-align: left;"><code>HAL_PPP_StructnameTypeDef</code></td>
<td style="text-align: left;"><strong>NA</strong></td>
<td style="text-align: left;"><strong>NA</strong></td>
</tr>
</tbody>
</table>
<p>对于上面表格当中所描述的驱动程序命名规则，需要特别注意如下几个事项：</p>
<ul>
<li><strong>PPP</strong>
前缀指代的是外设的功能模式，而非外设本身，例如使用 USART 串口时,
该前缀可以是
<code>USART</code>、<code>IRDA</code>、<code>UART</code>、<code>SMARTCARD</code>；</li>
<li>一个源文件当中使用的常量，就定义在该源文件内部，而多个源文件共用的常量定义在头文件当中；除外设驱动的函数参数以外，所有常量都需要大写；</li>
<li><code>typedef</code> 类型的变量名称应当以 <code>_TypeDef</code>
作为后缀；</li>
<li>HAL
固件库认为<strong>寄存器</strong>属于常量，大多数情况下常量名称是大写的，并且使用与官方参考手册当中相同的首字母缩写；</li>
<li>外设寄存器被声明在 <code>stm32f4xx_hal_PPP.h</code> 头文件的
<code>PPP_TypeDef</code> 结构体当中，例如
<code>ADC_TypeDef</code>；</li>
<li>外设函数的名称以 <code>HAL_</code>
作为前缀，然后是相应外设的首字母缩写（大写），然后再跟上一条下划线，接下来的每个单词首字母大写，例如
<code>HAL*UART_Transmit()</code>；</li>
<li>包含指定 PPP 外设初始化参数的结构体被命名为
<code>PPP_InitTypeDef</code>，例如 <code>ADC_InitTypeDef</code>；</li>
<li>包含指定 PPP 外设配置参数的结构体被命名为
<code>PPP_xxxxConfTypeDef</code>，例如
<code>ADC_ChannelConfTypeDef)</code>；</li>
<li>外设指针结构体被命名为 <code>PPP_HandleTypedef</code>，例如
<code>DMA_HandleTypeDef</code>；</li>
<li>根据 <code>PPP_InitTypeDef</code> 当中的参数，用于初始化 PPP
外设的函数被命名为 <code>HAL_PPP_Init</code>，例如
<code>HAL_TIM_Init()</code>；</li>
<li>采用默认值重置 <strong>PPP</strong> 外设寄存器的函数被命名为
<code>HAL_PPP_DeInit</code>，例如 <code>HAL_TIM_DeInit()</code>；</li>
<li>后缀 <code>MODE</code>
是指处理模式（轮询、中断、DMA），例如在本地资源以外使用 DMA
时，就应当调用 <code>HAL_PPP_Function_DMA()</code> 函数；</li>
<li>前缀 <code>Feature</code> 是指新的特性，例如
<code>HAL_ADCEx_InjectedStart()()</code> 表示的是 ADC
开始注入通道；</li>
</ul>
<h4 id="hal-通用命名规则">HAL 通用命名规则</h4>
<p>对于共有的系统外设，无需使用指针或者实例对象，这个规则适用于
<strong>GPIO</strong>、<strong>SYSTICK</strong>、<strong>NVIC</strong>、<strong>RCC</strong>、<strong>FLASH</strong>
外设，例如函数 <code>HAL_GPIO_Init()</code> 只需要 GPIO
的地址及其配置参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *Init)</span> &#123;</span><br><span class="line">  <span class="comment">/* GPIO 初始化体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个外设驱动程序当中都定义有处理中断和特定时钟配置的<strong>宏</strong>，这些宏会被导出到外设驱动的<strong>头文件</strong>，以便于<strong>扩展文件</strong>使用，这些用于处理中断和特定时钟配置的宏如下所示：</p>
<table>
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">宏定义</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_ENABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个特定的外设中断；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_DISABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个特定的外设中断；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_GET_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的中断状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的中断状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_GET_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的标志位状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的标志位状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_ENABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个外设；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_DISABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个外设；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_XXXX (__HANDLE__, __PARAM__)</code></td>
<td style="text-align: left;">指定 PPP
外设驱动的<strong>宏</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>__HAL_PPP_GET_ IT_SOURCE (__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;">检查指定的<strong>中断源</strong>；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>NVIC</strong> 和
<strong>SYSTICK</strong> 是 ARM Cortex-M4 提供的两个核心功能，与之相关的
API 都位于 <code>stm32f4xx_hal_cortex.c</code> 源文件。</p>
</blockquote>
<p>当从寄存器读取<strong>状态标志位</strong>时，其结果由移位值组成，具体取决于读取值的数量与大小。这种情况下，返回的状态宽度为
<strong>32</strong> 位，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATUS = XX | (YY &lt;&lt; <span class="number">16</span>)</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line">STATUS = XX | (YY &lt;&lt; <span class="number">8</span>) | (YY &lt;&lt; <span class="number">16</span>) | (YY &lt;&lt; <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>外设 PPP 的指针在调用 <code>HAL_PPP_Init()</code>
之前有效，初始化函数会在修改指针字段之前进行检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_Init(PPP_HandleTypeDef)</span><br><span class="line"><span class="keyword">if</span> (hppp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<strong>条件式宏定义</strong>或者<strong>伪代码宏定义</strong>：</p>
<ul>
<li>条件式宏定义： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(x) (((x) &gt; 0) ? (x) : -(x))</span></span><br></pre></td></tr></table></figure></li>
<li>伪代码宏定义（多指令宏）： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_) \</span></span><br><span class="line"><span class="meta">  do &#123;                                                             \</span></span><br><span class="line"><span class="meta">    (__HANDLE__)-&gt;__PPP_DMA_FIELD_ = &amp;(__DMA_HANDLE_);             \</span></span><br><span class="line"><span class="meta">    (__DMA_HANDLE_).Parent = (__HANDLE__);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="中断处理程序与回调函数">中断处理程序与回调函数</h4>
<p>除了各种 API 函数之外，HAL 固件库外设驱动程序当中还包含有：</p>
<ul>
<li>用户回调函数；</li>
<li>由 <code>stm32f4xx_it.c</code> 调用的
<code>HAL_PPP_IRQHandler()</code> 外设中断处理程序；</li>
</ul>
<p>回调函数被定义为带有 <code>weak</code>
属性的空函数，使用时必须在用户代码当中进行定义，HAL
固件库当中存在三种类型的用户回调函数：</p>
<ul>
<li>外围系统级初始化与反向初始化回调函数 <code>HAL_PPP_MspInit()</code>
和 <code>HAL_PPP_MspDeInit</code>；</li>
<li>外理完成回调函数 <code>HAL_PPP_ProcessCpltCallback</code>；</li>
<li>错误的回调函数 <code>HAL_PPP_ErrorCallback</code>；</li>
</ul>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">回调函数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_PPP_MspInit()</code><br><code>HAL_PPP_MspDeInit()</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_MspInit()</code>，由
API 函数 <code>HAL_PPP_Init()</code>
进行调用，用于进行外设的系统级初始化（GPIO、时钟、DMA、中断）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_PPP_ProcessCpltCallback</code></td>
<td style="text-align: left;">例如
<code>HAL_USART_TxCpltCallback</code>，当处理执行完成时，由外设或者 DMA
中断处理程序进行调用；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_PPP_ErrorCallback</code></td>
<td style="text-align: left;">例如
<code>HAL_USART_ErrorCallback</code>，当发生错误时，由外设或者 DMA
中断处理程序进行调用；</td>
</tr>
</tbody>
</table>
<h3 id="hal-通用-api">HAL 通用 API</h3>
<p>HAL 通用 API 为 <strong>STM32F401CC</strong>
微控制器提供了一系列公共通用的函数，其主要由四组不同类型的 API
组成：</p>
<ol type="1">
<li><strong>初始化与反向初始化函数</strong>
<code>HAL_PPP_Init()</code>、<code>HAL_PPP_DeInit()</code>：<strong>初始化函数</strong>
<code>HAL_PPP_Init()</code>
用于初始化外设并且配置底层硬件资源，主要是时钟、GPIO、AF 以及可能的 DMA
与中断，而<strong>反向初始化函数</strong> <code>HAL_PPP_DeInit()</code>
则用于恢复外设的默认状态，释放底层硬件资源；</li>
<li><strong>IO 操作函数</strong>
<code>HAL_PPP_Read()</code>、<code>HAL_PPP_Write()</code>、<code>HAL_PPP_Transmit()</code>、<code>HAL_PPP_Receive()</code>：通过读/写操作来访问外设上的各种负载数据；</li>
<li><strong>控制函数</strong>
<code>HAL_PPP_Set()</code>、<code>HAL_PPP_Get()</code>：控制函数用于动态调整外设的配置，以及设置其它的操作模式；</li>
<li><strong>状态与错误函数</strong>
<code>HAL_PPP_GetState()</code>、<code>HAL_PPP_GetError()</code>：允许在运行时检索外设和数据流的状态，并且识别发生的错误类型；</li>
</ol>
<p>下面表格当中，展示了 <strong>ADC</strong> 外设的部分<strong>通用
API</strong>：</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 22%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">功能分组</th>
<th style="text-align: left;">通用 API 名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">初始化函数</td>
<td style="text-align: left;"><code>HAL_ADC_Init()</code></td>
<td style="text-align: left;">初始化外设，配置时钟、GPIO、AF
等底层资源；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_DeInit()</code></td>
<td style="text-align: left;">恢复外设的默认状态，释放底层资源，并且消除与硬件的全部直接依赖；</td>
</tr>
<tr>
<td style="text-align: left;">IO 操作函数</td>
<td style="text-align: left;"><code>HAL_ADC_Start()</code></td>
<td style="text-align: left;">在使用<strong>轮询模式</strong>时<strong>启用</strong>
ADC 转换；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_Stop ()</code></td>
<td style="text-align: left;">在使用<strong>轮询模式</strong>时<strong>停止</strong>
ADC 转换；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_PollForConversion()</code></td>
<td style="text-align: left;">在使用<strong>轮询模式</strong>时，等待<strong>转换结束</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_Start_IT()</code></td>
<td style="text-align: left;">在使用<strong>中断模式</strong>时<strong>启用</strong>
ADC 转换；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_Stop_IT()</code></td>
<td style="text-align: left;">在使用<strong>中断模式</strong>时<strong>停止</strong>
ADC 转换；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_IRQHandler()</code></td>
<td style="text-align: left;">处理 <strong>ADC</strong> 中断请求；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_ConvCpltCallback()</code></td>
<td style="text-align: left;">在中断子程序内调用的回调函数，用于标识<strong>当前处理的结束</strong>或者
<strong>DMA 传输在何时完成</strong>；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_ErrorCallback()</code></td>
<td style="text-align: left;">当发生外设错误或者 <strong>DMA</strong>
传输错误的时候，该回调函数会在中断子程序当中被调用；</td>
</tr>
<tr>
<td style="text-align: left;">控制函数</td>
<td style="text-align: left;"><code>HAL_ADC_ConfigChannel()</code></td>
<td style="text-align: left;">用于配置当前选择的 <strong>ADC</strong>
常规通道，序列发生器当中相应的 <code>Rank</code> 与采样时间；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_AnalogWDGConfig</code></td>
<td style="text-align: left;">该功能为选定的 <strong>ADC</strong>
配置<strong>模拟看门狗</strong>；</td>
</tr>
<tr>
<td style="text-align: left;">状态与错误函数</td>
<td style="text-align: left;"><code>HAL_ADC_GetState()</code></td>
<td style="text-align: left;">用于在运行时获取<strong>外设</strong>与<strong>数据流</strong>的状态；</td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"><code>HAL_ADC_GetError()</code></td>
<td style="text-align: left;">获得发生在<strong>中断子程序</strong>当中的<strong>运行时错误</strong>；</td>
</tr>
</tbody>
</table>
<h3 id="hal-扩展-api">HAL 扩展 API</h3>
<p>HAL 固件库的<strong>扩展 API</strong> 用于提供某个特定系列或者型号的
API，其代码定义在 <code>stm32f4xx_hal_ppp_ex.c</code>
源文件里，下面的表格展示了 <strong>ADC</strong> 外设的<strong>扩展
API</strong>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">API 名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_ADCEx_InjectedStart()</code></td>
<td style="text-align: left;">用于<strong>轮询</strong>模式下，<strong>开始</strong>注入
ADC 转换通道；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_ADCEx_InjectedStop()</code></td>
<td style="text-align: left;">用于<strong>轮询</strong>模式下，<strong>停止</strong>注入
ADC 转换通道；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_ADCEx_InjectedStart_IT()</code></td>
<td style="text-align: left;">用于<strong>中断</strong>模式下，<strong>开始</strong>注入
ADC 转换通道；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_ADCEx_InjectedStop_IT()</code></td>
<td style="text-align: left;">用于<strong>中断</strong>模式下，<strong>停止</strong>注入
ADC 转换通道；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_ADCEx_InjectedConfigChannel()</code></td>
<td style="text-align: left;">配置所选择 ADC
的注入通道（序列发生器当中相应的 <code>Rank</code> 与采样时间）；</td>
</tr>
</tbody>
</table>
<p>HAL
固件驱动程序会采用五种不同的方式<strong>处理特定的外设功能</strong>，接下来将分别对它们进行描述：</p>
<h4 id="添加指定型号的功能">添加指定型号的功能</h4>
<p>当需要为指定型号的 STM32 微控制器添加新特性时，这些新的 API
将会被添加至 <code>stm32f4xx_hal_ppp_ex.c</code>
扩展源文件当中，然后被命名为 <code>HAL_PPPEx_Function()</code>：</p>
<p><img src="/Embedded/STM32F401/Library/Extension-API-1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stm32f4xx_hal_flash_ex.c/h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) ||</span></span><br><span class="line">defined(STM32F439xx)</span><br><span class="line">    HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_OB_SelectPCROP</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_OB_DeSelectPCROP</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F427xx ||STM32F437xx || STM32F429xx || STM32F439xx */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="添加产品系列的功能">添加产品系列的功能</h4>
<p>当为某个产品系列的 STM32 微控制器添加新特性时，API
会被添加至扩展驱动程序的 <code>.c</code> 源文件，并且被命名为
<code>HAL_PPPEx_Function()</code>：</p>
<p><img src="/Embedded/STM32F401/Library/Extension-API-2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stm32f4xx_hal_adc_ex.c/h */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStop</span><span class="params">(ADC_HandleTypeDef *hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStop_IT</span><span class="params">(ADC_HandleTypeDef *hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStart</span><span class="params">(ADC_HandleTypeDef *hadc)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADCEx_InjectedStart_IT</span><span class="params">(ADC_HandleTypeDef *hadc)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="添加新的外设">添加新的外设</h4>
<p>当需要添加一个新的外设 <code>newppp</code> 时，与之相对应的 API
需要添加到 <code>stm32f4xx_hal_newppp.c</code>，然后在
<code>stm32f4xx_hal_conf.h</code> 通过宏定义包含该源文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_NEWPPP_MODULE_ENABLED</span></span><br></pre></td></tr></table></figure>
<p><img src="/Embedded/STM32F401/Library/Extension-API-3.png"></p>
<h4 id="更新现存的通用-api">更新现存的通用 API</h4>
<p>当一个通用 API
被定义为<strong>弱函数</strong>的时候，子程序会采用相同的名称定义将其在
<code>stm32f4xx_hal_ppp_ex.c</code>
扩展源文件，这样编译器就会采用这个新的函数来覆盖原来的定义：</p>
<p><img src="/Embedded/STM32F401/Library/Extension-API-4.png"></p>
<h4 id="更新现存的数据结构">更新现存的数据结构</h4>
<p>HAL 固件库的外设数据结构（例如
<code>PPP_InitTypeDef</code>）可以拥有不同字段，这些数据结构被定义在扩展头文件当中，并通过
STM32 微控制器型号进行分隔：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(STM32F401xx)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  (…)</span><br><span class="line">&#125; PPP_InitTypeDef;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F401xx */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="源文件包含关系">源文件包含关系</h3>
<p>通用 HAL 固件驱动程序的 <code>stm32f4xx_hal.h</code>
头文件，包含有整个 HAL 固件库的配置，它既是用户源代码文件
<code>main.h</code> 唯一包含的头文件，同时也使得 HAL 固件库的
<code>.c</code> 源文件能够使用其它 HAL
库资源，下面的示意图展示了源文件之间的这种依赖关系：</p>
<p><img src="/Embedded/STM32F401/Library/File-Inclusion-Model.png"></p>
<h3 id="公用资源定义">公用资源定义</h3>
<p>头文件 <code>stm32f4xx_hal_def.h</code> 当中定义了 HAL
固件库里的公用资源，例如公用的枚举、结构体、宏定义，其中最为重要的是枚举类型
<code>HAL_StatusTypeDef</code>。</p>
<ol type="1">
<li><strong>HAL 状态</strong>被几乎所有 API 使用，用于返回当前 API
操作的状态，其具有如下 <strong>4</strong> 个可能的值：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   HAL_OK = <span class="number">0x00</span>,</span><br><span class="line">   HAL_ERROR = <span class="number">0x01</span>,</span><br><span class="line">   HAL_BUSY = <span class="number">0x02</span>,</span><br><span class="line">   HAL_TIMEOUT = <span class="number">0x03</span></span><br><span class="line">&#125; HAL_StatusTypeDef;</span><br></pre></td></tr></table></figure></li>
<li><strong>HAL 锁</strong>同样也被所有 API
使用，用于防止意外的访问共享资源，其具有如下 <strong>2</strong>
个可能的值： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    HAL_UNLOCKED = <span class="number">0x00</span>, <span class="comment">/*!&lt;Resources unlocked */</span></span><br><span class="line">    HAL_LOCKED = <span class="number">0x01</span>    <span class="comment">/*!&lt; Resources locked */</span></span><br><span class="line">&#125; HAL_LockTypeDef;</span><br></pre></td></tr></table></figure></li>
<li>通用的<strong>宏定义</strong>，例如 <code>HAL_MAX_DELAY</code>：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_MAX_DELAY 0xFFFFFFFF</span></span><br></pre></td></tr></table></figure> 链接名称为 <code>PPP</code> 的外设至 DMA
结构体指针的<strong>宏</strong>: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_) \</span></span><br><span class="line"><span class="meta">  do &#123;                                                             \</span></span><br><span class="line"><span class="meta">    (__HANDLE__)-&gt;__PPP_DMA_FIELD_ = &amp;(__DMA_HANDLE_);             \</span></span><br><span class="line"><span class="meta">    (__DMA_HANDLE_).Parent = (__HANDLE__);                         \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>注意</strong>：除此之外，<code>stm32f4xx_hal_def.h</code>
文件还会调用 <strong>CMSIS</strong> 库中的 <code>stm32f4xx.h</code>
文件来获取所有外设的<strong>数据结构</strong>与<strong>地址映射</strong>。</p>
</blockquote>
<h3 id="配置-hal-固件库">配置 HAL 固件库</h3>
<p>头文件 <code>stm32f4xx_hal_conf.h</code> 用于配置 HAL
固件库，其中可以进行修改的选项如下面的表格所示：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 26%">
<col style="width: 51%">
<col style="width: 21%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">配置项</th>
<th style="text-align: left;">功能描述</th>
<th style="text-align: left;">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HSE_VALUE</code></td>
<td style="text-align: left;">定义外部晶振的值（<strong>HSE</strong>），单位为<strong>赫兹</strong>
<code>Hz</code>；</td>
<td style="text-align: left;"><code>25 000 000</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>HSE_STARTUP_TIMEOUT</code></td>
<td style="text-align: left;">HSE
启动<strong>超时时间</strong>，单位为<strong>毫秒</strong>
<code>ms</code>；</td>
<td style="text-align: left;"><code>5000</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>HSI_VALUE</code></td>
<td style="text-align: left;">定义内部晶振的值（<strong>HSI</strong>），单位为<strong>赫兹</strong>
<code>Hz</code>；</td>
<td style="text-align: left;"><code>16 000 000</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>EXTERNAL_CLOCK_VALUE</code></td>
<td style="text-align: left;">用于 I2S/SAI
模块计算其<strong>时钟源</strong>频率</td>
<td style="text-align: left;"><code>12288000</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>VDD_VALUE</code></td>
<td style="text-align: left;"><strong>VDD</strong>
的值，单位为<strong>毫伏</strong> <code>mV</code>；</td>
<td style="text-align: left;"><code>3300</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>USE_RTOS</code></td>
<td style="text-align: left;">使能嵌入式实时系统
<strong>RTOS</strong>；</td>
<td style="text-align: left;"><code>FALSE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>PREFETCH_ENABLE</code></td>
<td style="text-align: left;">使能<strong>预获取特性</strong>；</td>
<td style="text-align: left;"><code>TRUE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>INSTRUCTION_CACHE_ENABLE</code></td>
<td style="text-align: left;">使能<strong>指令缓存</strong>；</td>
<td style="text-align: left;"><code>TRUE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>DATA_CACHE_ENABLE</code></td>
<td style="text-align: left;">使能<strong>数据缓存</strong>；</td>
<td style="text-align: left;"><code>TRUE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>USE HAL_PPP_MODULE</code></td>
<td style="text-align: left;">使能模块在 HAL 驱动程序当中使用；</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;"><code>MAC_ADDRx</code></td>
<td style="text-align: left;">配置<strong>以太网</strong>外设的 MAC
地址；</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;"><code>ETH_RX_BUF_SIZE</code></td>
<td style="text-align: left;">配置<strong>以太网</strong>数据接收缓冲区的大小；</td>
<td style="text-align: left;"><code>ETH_MAX_PACKET_SIZE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>ETH_TX_BUF_SIZE</code></td>
<td style="text-align: left;">配置<strong>以太网</strong>数据发送缓冲区的大小；</td>
<td style="text-align: left;"><code>ETH_MAX_PACKET_SIZE</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>ETH_RXBUFNB</code></td>
<td style="text-align: left;"><strong>以太网</strong>数据接收缓冲区的数量；</td>
<td style="text-align: left;"><code>4</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>ETH_TXBUFNB</code></td>
<td style="text-align: left;"><strong>以太网</strong>数据发送缓冲区的数量；</td>
<td style="text-align: left;"><code>4</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>DP83848_PHY_ADDRESS</code></td>
<td style="text-align: left;">DB83848 <strong>以太网</strong> PHY
地址；</td>
<td style="text-align: left;"><code>0x01</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>PHY_RESET_DELAY</code></td>
<td style="text-align: left;">PHY 复位延迟；</td>
<td style="text-align: left;"><code>0x000000FF</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>PHY_CONFIG_DELAY</code></td>
<td style="text-align: left;">PHY 配置延迟；</td>
<td style="text-align: left;"><code>0x000000FF</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>PHY_BCR PHY_BSR</code></td>
<td style="text-align: left;">通用 PHY 寄存器；</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;"><code>PHY_SR PHY_MICR PHY_MISR</code></td>
<td style="text-align: left;">扩展 PHY 寄存器；</td>
<td style="text-align: left;"> </td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<code>stm32f4xx_hal_conf_template.h</code>
文件位于 <code>STM32Cube_FW_F4_V1.26.2</code> 固件库的
<code>Drivers\STM32F4xx_HAL_Driver\Inc</code>
目录下面，使用时需要将其复制到用户工程当中（STM32 Cube IDE
可以自动完成该操作），并且将其重命名为
<code>stm32f4xx_hal_conf.h</code>。</p>
</blockquote>
<h3 id="如何使用-hal-驱动">如何使用 HAL 驱动</h3>
<p>下面的示意图展示了 HAL 固件驱动的典型使用方法，以及用户应用程序、HAL
固件驱动、中断服务之间的交互过程。</p>
<p><img src="/Embedded/STM32F401/Library/HAL-Driver-Model.png"></p>
<blockquote>
<p><strong>注意</strong>：HAL
驱动程序当中实现的函数用<strong>绿色</strong>表示，从中断处理程序中调用的函数用<strong>虚线</strong>表示，在用户应用程序中实现的主堆栈
MSP
函数用<strong>红色框</strong>表示，<strong>实线</strong>表示用户应用程序功能之间的交互。</p>
</blockquote>
<h4 id="hal-全局初始化">HAL 全局初始化</h4>
<p><code>stm32f4xx_hal.c</code> 提供了一组 API 来初始化 HAL
核心实现：</p>
<ul>
<li><code>HAL_Init()</code>：该函数必须在应用程序启动时调用，用于初始化数据和指令，缓存预获取队列，设置
SysTick 定时器（基于 HSI 时钟）每间隔 <code>1ms</code>
产生一个最低优先级中断，将优先级分组设置为 <code>4</code> 位，调用
<code>HAL_MspInit()</code>
用户回调函数来执行系统级初始化（时钟、GPIO、DMA、中断）；</li>
<li><code>HAL_DeInit()</code>：重置所有外设，调用用户回调函数
<code>HAL_MspDeInit()</code> 执行系统级反向初始化；</li>
<li><code>HAL_GetTick()</code>：获取当前 <strong>SysTick</strong>
定时器的计数值（在 SysTick
中断内递增），用于外设驱动程序处理<strong>超时</strong>；</li>
<li><code>HAL_Delay()</code>：通过 <strong>SysTick</strong>
定时器实现一个以毫秒为单位的延迟；</li>
</ul>
<h4 id="时钟配置">时钟配置</h4>
<p>时钟配置要在用户代码的开头部分完成，下面的示例代码体现了一个典型的时钟配置顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct;</span><br><span class="line">  <span class="comment">/* 使能 HSE 晶振，并且以其作为时钟源激活 PLL */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">  RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLM = <span class="number">25</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLN = <span class="number">336</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLQ = <span class="number">7</span>;</span><br><span class="line">  HAL_RCC_OscConfig(&amp;RCC_OscInitStruct);</span><br><span class="line">  <span class="comment">/* 选择 PLL 作为系统时钟源，并且配置 HCLK、PCLK1、PCLK2 分频器 */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">  HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-msp">初始化 MSP</h4>
<p>外设的初始化是通过 <code>HAL_PPP_Init()</code>
完成的，而外设所使用硬件资源的初始化是通过调用 MSP 回调函数
<code>HAL_PPP_MspInit()</code> 来执行的，<code>MspInit</code>
回调函数用于执行 RCC、GPIO、NVIC、DMA
等各种附加硬件资源相关的低级初始化。所有带有指针的 HAL
驱动程序，都包含有两个分别用于<strong>初始化</strong>与<strong>反向初始化</strong>
MSP 的回调函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 初始化 PPP 外设主堆栈指针 MSP</span></span><br><span class="line"><span class="comment">* @param hppp: 外设 PPP 指针</span></span><br><span class="line"><span class="comment">* @retval 无 */</span></span><br><span class="line"><span class="type">void</span> __weak <span class="title function_">HAL_PPP_MspInit</span><span class="params">(PPP_HandleTypeDef *hppp)</span> &#123;</span><br><span class="line">  <span class="comment">/* 该函数不能修改，当需要使用回调时，可以在用户代码当中实现 HAL_PPP_MspInit */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 反向初始化 PPP 外设主堆栈指针 MSP</span></span><br><span class="line"><span class="comment">* @param hppp: 外设 PPP 指针</span></span><br><span class="line"><span class="comment">* @retval 无 */</span></span><br><span class="line"><span class="type">void</span> __weak <span class="title function_">HAL_PPP_MspDeInit</span><span class="params">(PPP_HandleTypeDef *hppp)</span> &#123;</span><br><span class="line">  <span class="comment">/* 该函数不能修改，当需要使用回调时，可以在用户代码当中实现 HAL_PPP_MspDeInit */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MSP 回调由用户工程当中的 <code>stm32f4xx_hal_msp.c</code>
实现，该文件可以通过 STM32 Cube IDE
自动生成与修改，其中主要包含有如下四个函数：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void HAL_MspInit()</code></td>
<td style="text-align: left;"><strong>全局</strong> MSP
初始化函数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void HAL_MspDeInit()</code></td>
<td style="text-align: left;"><strong>全局</strong> MSP
反向初始化函数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void HAL_PPP_MspInit()</code></td>
<td style="text-align: left;"><strong>外设 PPP</strong> 的 MSP
初始化函数；</td>
</tr>
<tr>
<td style="text-align: left;"><code>void HAL_PPP_MspDeInit()</code></td>
<td style="text-align: left;"><strong>外设 PPP</strong> 的 MSP
反向初始化函数；</td>
</tr>
</tbody>
</table>
<h4 id="io-操作">IO 操作</h4>
<p>带有内部数据处理（发送、接收、读/写）的 HAL
函数，通常具备<code>轮询（Polling）</code>、<code>中断（Interrupt）</code>、<code>DMA</code>
三种处理方式：</p>
<h5 id="轮询模式">轮询模式</h5>
<p>在轮询模式下，当处于阻塞模式的数据被处理完成时，HAL
函数就会返回处理状态；函数返回 <code>HAL_OK</code>
状态表示操作完成，否则就会返回一个错误状态；用户可以通过
<code>HAL_PPP_GetState()</code> 函数获取更多信息；由于所有数据都是在
<code>while</code>
循环内部进行处理，所以还需要加入以<strong>毫秒</strong>为单位的超时判断变量，以防止处理过程被挂起；在接下来的示例代码当中，就展示了一个典型的轮询处理方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_PPP_Transmit</span><span class="params">(PPP_HandleTypeDef *phandle, <span class="type">uint8_t</span> pData, int16_tSize, uint32_tTimeout)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((pData == <span class="literal">NULL</span>) || (Size == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  (…)</span><br><span class="line">  <span class="keyword">while</span> (data processing is running) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout reached) &#123;</span><br><span class="line">      <span class="keyword">return</span> HAL_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (…) <span class="keyword">return</span> HAL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中断模式">中断模式</h5>
<p>在中断模式下，HAL
函数会在启动数据处理并且响应中断之后返回处理的状态；操作的结束由声明为弱函数的回调来指示，该回调函数可以由用户自定义，以实时通知流程的完成情况；除此之外，用户还可以通过
<code>HAL_PPP_GetState()</code>
函数来获取处理状态。在中断模式下，驱动程序当中声明有下面四个函数：</p>
<ol type="1">
<li><code>HAL_PPP_Process_IT()</code>：启用中断处理；</li>
<li><code>HAL_PPP_IRQHandler()</code>：全局 PPP 外设中断；</li>
<li><code>weak HAL_PPP_ProcessCpltCallback()</code>：处理完成回调函数；</li>
<li><code>weak HAL_PPP_ProcessErrorCallback()</code>：处理错误回调函数；</li>
</ol>
<p>一个中断模式下的处理过程，会调用到用户代码当中的
<code>HAL_PPP_Process_IT()</code>，以及 <code>stm32f4xx_it.c</code>
库文件当中的 <code>HAL_PPP_IRQHandler</code>，而
<code>HAL_PPP_ProcessCpltCallback()</code> 函数由于在 HAL
固件驱动当中被声明为弱函数，这意味着用户可以在应用程序当中再次进行声明，下面是一个代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line">UART_HandleTypeDef UartHandle;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置用户参数 */</span></span><br><span class="line">  UartHandle.Init.BaudRate = <span class="number">9600</span>;</span><br><span class="line">  UartHandle.Init.WordLength = UART_DATABITS_8;</span><br><span class="line">  UartHandle.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">  UartHandle.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">  UartHandle.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">  UartHandle.Init.Instance = USART3;</span><br><span class="line">  HAL_UART_Init(&amp;UartHandle);</span><br><span class="line">  HAL_UART_SendIT(&amp;UartHandle, TxBuffer, <span class="keyword">sizeof</span>(TxBuffer));</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_ErrorCallback</span><span class="params">(UART_HandleTypeDef *huart)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stm32f4xx_it.c */</span></span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef UartHandle;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  HAL_UART_IRQHandler(&amp;UartHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dma-模式">DMA 模式</h5>
<p>HAL 可以通过 DMA 执行数据处理，并且在启用相应的 DMA
中断之后返回处理状态；操作的结束由一个声明为弱函数的回调来标识，用户可以自定义该回调函数，以便实时通知处理情况。除此之外，用户还可以通过
<code>HAL_PPP_GetState()</code> 函数来获取处理状态；在 DMA
模式下，驱动程序当中主要声明有如下四个函数:</p>
<ol type="1">
<li><code>HAL_PPP_Process_DMA()</code>：启用 DMA 处理</li>
<li><code>HAL_PPP_DMA_IRQHandler()</code>：外设 PPP 使用的 DMA
中断；</li>
<li><code>__weak HAL_PPP_ProcessCpltCallback()</code>：处理完成回调函数；</li>
<li><code>__weak HAL_PPP_ErrorCpltCallback()</code>：处理错误回调函数；</li>
</ol>
<p>一个 DMA 模式下的处理过程，需要调用用户文件当中的
<code>HAL_PPP_Process_DMA()</code>，以及 <code>stm32f4xx_it.c</code>
当中的 <code>HAL_PPP_DMA_IRQHandler()</code>；除此之外，DMA 的初始化在
<code>HAL_PPP_MspInit()</code> 回调函数当中完成；用户同样也可以将
<strong>DMA 指针</strong>关联到外设 <strong>PPP
的指针</strong>，因而所有使用到 DMA
的外设驱动程序指针必须声明为下面的形式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PPP_TypeDef *Instance;   <span class="comment">/* 寄存器基地址 */</span></span><br><span class="line">  PPP_InitTypeDef Init;    <span class="comment">/* 外设 PPP 通信参数 */</span></span><br><span class="line">  HAL_StateTypeDef State;  <span class="comment">/* 外设 PPP 通信状态 */</span></span><br><span class="line">  (…)</span><br><span class="line">  DMA_HandleTypeDef *hdma; <span class="comment">/* 关联的 DMA 指针 */</span></span><br><span class="line">&#125; PPP_HandleTypeDef;</span><br></pre></td></tr></table></figure>
<p>以 <strong>UART</strong>
外设为例，其对应的初始化过程如下面代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置用户参数 */</span></span><br><span class="line">  UartHandle.Init.BaudRate = <span class="number">9600</span>;</span><br><span class="line">  UartHandle.Init.WordLength = UART_DATABITS_8;</span><br><span class="line">  UartHandle.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">  UartHandle.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">  UartHandle.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">  UartHandle.Init.Instance = UART3;</span><br><span class="line">  HAL_UART_Init(&amp;UartHandle);</span><br><span class="line">  (..)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_USART_MspInit</span><span class="params">(UART_HandleTypeDef *huart)</span> &#123;</span><br><span class="line">  <span class="type">static</span> DMA_HandleTypeDef hdma_tx;</span><br><span class="line">  <span class="type">static</span> DMA_HandleTypeDef hdma_rx;</span><br><span class="line">  (…)</span><br><span class="line">  __HAL_LINKDMA(UartHandle, DMA_Handle_tx, hdma_tx);</span><br><span class="line">  __HAL_LINKDMA(UartHandle, DMA_Handle_rx, hdma_rx);</span><br><span class="line">  (…)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>HAL_PPP_ProcessCpltCallback()</code> 函数在 HAL
固件驱动程序当中被声明为<strong>弱函数</strong>，这意味着用户可以在代码当中再次进行声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line">UART_HandleTypeDef UartHandle;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置用户参数 */</span></span><br><span class="line">  UartHandle.Init.BaudRate = <span class="number">9600</span>;</span><br><span class="line">  UartHandle.Init.WordLength = UART_DATABITS_8;</span><br><span class="line">  UartHandle.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">  UartHandle.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">  UartHandle.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">  UartHandle.Init.Instance = USART3;</span><br><span class="line">  HAL_UART_Init(&amp;UartHandle);</span><br><span class="line">  HAL_UART_Send_DMA(&amp;UartHandle, TxBuffer, <span class="keyword">sizeof</span>(TxBuffer));</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *phuart)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxErrorCallback</span><span class="params">(UART_HandleTypeDef *phuart)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stm32f4xx_it.c */</span></span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef UartHandle;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAx_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  HAL_DMA_IRQHandler(&amp;UartHandle.DMA_Handle_tx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HAL_USART_TxCpltCallback()</code> 和
<code>HAL_USART_ErrorCallback()</code> 应当通过类似下面这样的语句链接到
<code>HAL_PPP_Process_DMA()</code> 函数的 DMA
传输<strong>完成</strong>与<strong>错误</strong>回调函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_Process_DMA(PPP_HandleTypeDef *hppp, Params….) &#123;</span><br><span class="line">  (…)</span><br><span class="line">  hppp-&gt;DMA_Handle-&gt;XferCpltCallback = HAL_UART_TxCpltCallback;</span><br><span class="line">  hppp-&gt;DMA_Handle-&gt;XferErrorCallback = HAL_UART_ErrorCallback;</span><br><span class="line">  (…)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="超时与错误管理">超时与错误管理</h4>
<h5 id="超时管理">超时管理</h5>
<p><strong>超时</strong>（Timeout）通常用于在轮询模式下操作的
API，其中定义了处理过程被阻塞直至错误被返回的延迟时间，下面代码是一个具有超时参数的函数调用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_DMA_PollForTransfer</span><span class="params">(DMA_HandleTypeDef *hdma, <span class="type">uint32_t</span> CompleteLevel, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure>
<p><strong>超时</strong>的时间取值范围，具体如下面的表格所示：</p>
<table>
<thead>
<tr>
<th>超时值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>没有轮询，立刻检查并且退出；</td>
</tr>
<tr>
<td><code>1 ~ (HAL_MAX_DELAY -1)</code></td>
<td>以毫秒作为单位的超时值；</td>
</tr>
<tr>
<td><code>HAL_MAX_DELAY</code></td>
<td>无限轮询直至处理成功；</td>
</tr>
</tbody>
</table>
<p>其中 <code>HAL_MAX_DELAY</code> 在 HAL 固件库头文件
<code>stm32f4xx_hal_def.h</code> 当中被定义为
<code>0xFFFFFFFF</code>；此外，在某些情况下，系统外设或者内部 HAL
驱动程序操作会使用一个<strong>固定的超时时间</strong>，这种情况下的超时都具备相同的意义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL_PROCESS_TIMEOUT 100</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_PPP_Process</span><span class="params">(PPP_HandleTypeDef)</span> &#123;</span><br><span class="line">  (…)</span><br><span class="line">  timeout = HAL_GetTick() + LOCAL_PROCESS_TIMEOUT;</span><br><span class="line">  (…)</span><br><span class="line">  <span class="keyword">while</span> (ProcessOngoing) &#123;</span><br><span class="line">    (…)</span><br><span class="line">    <span class="keyword">if</span> (HAL_GetTick() ≥ timeout) &#123;</span><br><span class="line">      <span class="comment">/* 处理没有被锁定 */</span></span><br><span class="line">      __HAL_UNLOCK(hppp);</span><br><span class="line">      hppp-&gt;State = HAL_PPP_STATE_TIMEOUT;</span><br><span class="line">      <span class="keyword">return</span> HAL_PPP_STATE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (…)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的示例展示了如何在<strong>轮询函数</strong>当中使用超时时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_StateTypeDef <span class="title function_">HAL_PPP_Poll</span><span class="params">(PPP_HandleTypeDef *hppp, <span class="type">uint32_t</span> Timeout)</span> &#123;</span><br><span class="line">  (…)</span><br><span class="line">  timeout = HAL_GetTick() + Timeout;</span><br><span class="line">  (…)</span><br><span class="line">  <span class="keyword">while</span> (ProcessOngoing) &#123;</span><br><span class="line">    (…)</span><br><span class="line">    <span class="keyword">if</span> (Timeout != HAL_MAX_DELAY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HAL_GetTick() ≥ timeout) &#123;</span><br><span class="line">        <span class="comment">/* 处理没有被锁定 */</span></span><br><span class="line">        __HAL_UNLOCK(hppp);</span><br><span class="line">        hppp-&gt;State = HAL_PPP_STATE_TIMEOUT;</span><br><span class="line">        <span class="keyword">return</span> hppp-&gt;State;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (…)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="错误管理">错误管理</h5>
<p>HAL 固件驱动程序在代码当中，实现了针对如下内容的检查：</p>
<ul>
<li><strong>参数有效性</strong>：某些处理所使用的<strong>参数</strong>应当是有效并且已经定义过的，否则系统可能发生崩溃或者进入未定义状态，这些关键参数在使用前都会经过检查：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_PPP_Process</span><span class="params">(PPP_HandleTypeDef *hppp, <span class="type">uint32_t</span> *pdata, uint32 Size)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((pData == <span class="literal">NULL</span>) || (Size == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>指针有效性</strong>：外设 <strong>PPP</strong>
指针是一个非常重要的变量，因为其中保存了外设驱动程序的重要参数，因此总是在
<code>HAL_PPP_Init()</code> 函数的开头进行检查： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_PPP_Init</span><span class="params">(PPP_HandleTypeDef *hppp)</span> &#123;</span><br><span class="line">  <span class="comment">/* 指针不能为空 */</span></span><br><span class="line">  <span class="keyword">if</span> (hppp == <span class="literal">NULL</span>)  &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>超时错误</strong>：当发生<strong>超时</strong>错误时，会使用下面的语句进行处理：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Process ongoing) &#123;</span><br><span class="line">timeout = HAL_GetTick() + Timeout;</span><br><span class="line"><span class="keyword">while</span> (data processing is running) &#123;</span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_TIMEOUT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当外设操作过程当中发生错误时，<code>HAL_PPP_Process()</code>
将会返回一个 <code>HAL_ERROR</code> 状态，HAL 的 <strong>PPP</strong>
外设驱动程序会通过 <code>HAL_PPP_GetError()</code>
函数来检索错误来源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_ErrorTypeDef <span class="title function_">HAL_PPP_GetError</span><span class="params">(PPP_HandleTypeDef *hppp)</span>;</span><br></pre></td></tr></table></figure>
<p>所有外设指针都定义有一个用于保存最后错误代码的
<code>HAL_PPP_ErrorTypeDef</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PPP_TypeDef *Instance;               <span class="comment">/* 外设 PPP 寄存器基地址 */</span></span><br><span class="line">  PPP_InitTypeDef Init;                <span class="comment">/* 外设 PPP 初始化参数 */</span></span><br><span class="line">  HAL_LockTypeDef Lock;                <span class="comment">/* 外设 PPP 对象锁定 */</span></span><br><span class="line">  __IO HAL_PPP_StateTypeDef State;     <span class="comment">/* 外设 PPP 状态 */</span></span><br><span class="line">  __IO HAL_PPP_ErrorTypeDef ErrorCode; <span class="comment">/* 外设 PPP 错误代码 */</span></span><br><span class="line">  (…)</span><br><span class="line">  <span class="comment">/* 外设 PPP 指定参数 */</span></span><br><span class="line">&#125; PPP_HandleTypeDef;</span><br></pre></td></tr></table></figure>
<p>外设的状态以及错误状态码，总是会在返回一个错误之前进行更新:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PPP-&gt;State = HAL_PPP_READY;    <span class="comment">/* 设置外设状态为就绪 */</span></span><br><span class="line">PP-&gt;ErrorCode = HAL_ERRORCODE; <span class="comment">/* 设置错误代码 */</span></span><br><span class="line">_HAL_UNLOCK(PPP);              <span class="comment">/* 解锁该外设资源 */</span></span><br><span class="line"><span class="keyword">return</span> HAL_ERROR;              <span class="comment">/* 返回 HAL error 状态 */</span></span><br></pre></td></tr></table></figure>
<p><code>HAL_PPP_GetError()</code>
方法必须在<strong>中断模式</strong>下的错误回调函数里面使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_PPP_ProcessCpltCallback</span><span class="params">(PPP_HandleTypeDef *hspi)</span> &#123;</span><br><span class="line">  <span class="comment">/* 检索错误代码 */</span></span><br><span class="line">  ErrorCode = HAL_PPP_GetError(hppp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行时检查">运行时检查</h5>
<p>HAL 通过检查所有 HAL
驱动程序函数的<strong>输入值</strong>来实现运行时错误检查，该特性通过
<code>assert_param</code> 宏定义来实现，针对所有具有输入参数的 HAL
固件驱动函数，用于验证输入值是否处于参数的允许值范围以内。通过
<code>assert_param</code> 宏启用运行时检查以后，还需要使得
<code>stm32f4xx_hal_conf.h</code> 当中的 <code>USE_FULL_ASSERT</code>
处于未注释状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_Init</span><span class="params">(UART_HandleTypeDef *huart)</span> &#123;</span><br><span class="line">  (..)</span><br><span class="line">  <span class="comment">/* 参数检查 */</span></span><br><span class="line">  assert_param(IS_UART_INSTANCE(huart-&gt;Instance));</span><br><span class="line">  assert_param(IS_UART_BAUDRATE(huart-&gt;Init.BaudRate));</span><br><span class="line">  assert_param(IS_UART_WORD_LENGTH(huart-&gt;Init.WordLength));</span><br><span class="line">  assert_param(IS_UART_STOPBITS(huart-&gt;Init.StopBits));</span><br><span class="line">  assert_param(IS_UART_PARITY(huart-&gt;Init.Parity));</span><br><span class="line">  assert_param(IS_UART_MODE(huart-&gt;Init.Mode));</span><br><span class="line">  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart-&gt;Init.HwFlowCtl));</span><br><span class="line">  (..)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @defgroup UART_Word_Length *</span></span><br><span class="line"><span class="comment">@&#123;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_WORDLENGTH_8B ((uint32_t)0x00000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_WORDLENGTH_9B ((uint32_t)USART_CR1_M)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UART_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B) ||</span></span><br><span class="line">\ ((LENGTH) == UART_WORDLENGTH_9B))</span><br></pre></td></tr></table></figure>
<p>如果向 <code>assert_param</code> 宏传递
<code>false</code>，那么就会调用 <code>assert_failed</code>
函数，并且返回调用失败的源文件名称以及相应的行号；而传递的是
<code>true</code>，则不会返回任何值。宏 <code>ssert_param</code> 定义在
<code>stm32f4xx_hal_conf.h</code> 头文件当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被导出的宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FULL_ASSERT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏 assert_param 用于函数的参数检查 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 被导出的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span> *file, <span class="type">uint32_t</span> line)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert_param(expr) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br></pre></td></tr></table></figure>
<p><code>assert_failed</code> 函数可以定义在 <code>main.c</code>
或者其它任意的用户源代码文件当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FULL_ASSERT</span></span><br><span class="line"><span class="comment">/**                                                                      \</span></span><br><span class="line"><span class="comment">* @brief  发生 assert_param 错误时，报告源文件的名称与行号；                   \</span></span><br><span class="line"><span class="comment">* @param file: 指向源文件的指针；                                           \</span></span><br><span class="line"><span class="comment">* @param line: assert_param 错误行号；                                     \</span></span><br><span class="line"><span class="comment">* @retval None */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span> *file, <span class="type">uint32_t</span> line)</span> &#123;</span><br><span class="line">  <span class="comment">/* 用户可以添加自定义实现来报告错误文件名与行号, 例如 printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">  <span class="comment">/* 执行无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：由于<strong>运行时检查</strong>会带来额外的性能开销，所以建议仅在开发调试阶段进行使用。</p>
</blockquote>
<h2 id="ll-底层库">LL 底层库</h2>
<p><strong>底层</strong>（<strong>LL</strong>，low-layer）固件库驱动程序是一款比
HAL 更为接近硬件的库，其 API
并不会提供非关键特性，以及需要大量软件配置或者上层堆栈较为复杂的外设（例如
USB）的优化访问。它主要基于 STM32
片上外设的硬件特性来提供相关服务，这些服务准确的反映了硬件的功能，提供了官方手册所描述编程模型的一次性操作。由于其中并没有实现任何额外的处理业务，所以也就无需耗费额外的内存资源来保存<code>状态</code>、<code>计数器</code>、<code>数据指针</code>，所有操作都是通过修改硬件相关的<strong>寄存器</strong>来完成的。在
LL 固件库当中，主要提供有如下四种功能函数：</p>
<ol type="1">
<li>一组根据指定数据结构当中的参数，<strong>初始化</strong>外设主要特性的函数；</li>
<li>一组用于填充初始化数据结构各个字段<strong>重置值</strong>的函数；</li>
<li>执行外设<strong>反向初始化</strong>（将外设相关的寄存器恢复至默认值）的函数；</li>
<li>一组可以用于直接进行<strong>细粒度</strong>寄存器访问的内联函数；</li>
</ol>
<h3 id="ll-底层库文件">LL 底层库文件</h3>
<p>LL 固件库主要由片上外设的 <code>.h</code> 和 <code>.c</code>
驱动程序源文件，以及与 <code>System</code> 和 <code>Cortex-M4</code>
相关的源文件组成：</p>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">LL 固件库源文件</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>stm32f4xx_ll_bus.h</code></td>
<td style="text-align: left;">用于核心总线控制与外设时钟的使能与失能，例如：<code>LL_AHB2_GRP1_EnableClock</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_ll_ppp.h/.c</code></td>
<td style="text-align: left;"><code>stm32f4xx_ll_ppp.c</code> 提供了
<code>LL_PPP_Init()</code>、<code>LL_PPP_StructInit()</code>、<code>LL_PPP_DeInit()</code>
等外设初始化函数，所有 API 都定义在 <code>stm32f4xx_ll_ppp.h</code>
头文件当中；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_ll_cortex.h</code></td>
<td style="text-align: left;">包含系统滴答定时器 <code>SysTick</code>
与低功耗在内的 Cortex-M4 相关寄存器操作 API，例如
<code>LL_SYSTICK_xxxxx</code>、<code>LL_LPM_xxxxx</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_ll_utils.h/.c</code></td>
<td style="text-align: left;">该文件当中放置的是通用
API，可以用于读取设备 ID
和电子签名、时间基准与延迟管理、系统时钟配置；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32f4xx_ll_system.h</code></td>
<td style="text-align: left;">系统相关的操作，例如：<code>LL_SYSCFG_xxx</code>、<code>LL_DBGMCU_xxx</code>、<code>LL_FLASH_xxx</code>、<code>LL_VREFBUF_xxx</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>stm32_assert_template.h</code></td>
<td style="text-align: left;">定义用于使能<strong>运行时检查</strong>的
<code>assert_param</code> 宏模板文件，只会在独立使用 LL
固件驱动的场景下使用，使用时需要将其复制到用户工程当中，并且重命名为
<code>stm32_assert.h</code>；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：LL 固件驱动并没有配置文件，其库文件可以位于与
HAL 固件驱动程序相同的目录。</p>
</blockquote>
<p>LL 底层固件驱动程序当中只包含有 STM32 的 <strong>CMSIS</strong>
设备文件
<code>#include "stm32yyxx.h"</code>，而用户应用程序里则只需要包含 LL
底层驱动程序的头文件：</p>
<p><img src="/Embedded/STM32F401/Library/Low-Layer-Driver-CMSIS-Files.png"></p>
<h3 id="外设初始化函数">外设初始化函数</h3>
<p>LL 固件驱动程序在 <code>stm32f4xx_ll_ppp.c</code>
源文件当中提供了三组外设<strong>初始化</strong>相关的函数：</p>
<ol type="1">
<li>用于初始化外设主要特性，并以指定数据结构作为参数的函数；</li>
<li>一系列采用各字段预设值，填充初始化数据结构的函数；</li>
<li>用于外设初始化与反向初始化的函数，所谓<strong>反向初始化</strong>就是将外设相关的寄存器恢复至默认值；</li>
</ol>
<p>这些 LL
初始化函数及其相关资源（结构体、字面量、原型）定义可以通过编译开关
<code>USE_FULL_LL_DRIVER</code>
进行切换，当需要使用这些函数时，必须将这个编译<strong>开关</strong>添加至工具链编译器的预处理当中，或者将其放置到先于任意
LL 固件驱动之前调用的通用头文件里面，下面表格展示了 LL
固件库所支持外设的通用功能：</p>
<p><strong>常用的外设初始化功能</strong>：</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 5%">
<col style="width: 24%">
<col style="width: 61%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">返回类型</th>
<th style="text-align: left;">参数</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_PPP_Init</code></td>
<td style="text-align: left;"><code>ErrorStatus</code></td>
<td style="text-align: left;"><code>PPP_TypeDef* PPPx</code><br><code>LL_PPP_InitTypeDef* PPP_InitStruct</code></td>
<td style="text-align: left;">根据 <code>PPP_InitStruct</code>
当中指定的参数，初始化外设的主要特性，例如：<code>LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_StructInit</code></td>
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>LL_PPP_InitTypeDef* PPP_InitStruct</code></td>
<td style="text-align: left;">采用默认值填充 <code>PPP_InitStruct</code>
结构体的每一个成员，例如：<code>LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_DeInit</code></td>
<td style="text-align: left;"><code>ErrorStatus</code></td>
<td style="text-align: left;"><code>PPP_TypeDef* PPPx</code></td>
<td style="text-align: left;">反向初始化外设寄存器，即将其恢复至默认值，例如：<br><code>LL_USART_DeInit(USART_TypeDef *USARTx)</code>；</td>
</tr>
</tbody>
</table>
<p><strong>可选的外设初始化功能</strong>：</p>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 1%">
<col style="width: 12%">
<col style="width: 81%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">返回类型</th>
<th style="text-align: left;">参数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_PPP&#123;_CATEGORY&#125;_Init</code></td>
<td style="text-align: left;"><code>ErrorStatus</code></td>
<td style="text-align: left;"><code>PPP_TypeDef* PPPx</code><br><code>LL_PPP&#123;_CATEGORY&#125;_InitTypeDef* PPP&#123;_CATEGORY&#125;_InitStruct</code></td>
<td style="text-align: left;">根据 <code>PPP_InitStruct</code>
结构体当中指定的参数初始化外设特性，例如：<br><code>LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)</code><br><code>LL_RTC_TIME_Init(RTC_TypeDef *RTCx, uint32_t RTC_Format, LL_RTC_TimeTypeDef *RTC_TimeStruct)</code><br><code>LL_RTC_DATE_Init(RTC_TypeDef *RTCx, uint32_t RTC_Format, LL_RTC_DateTypeDef *RTC_DateStruct)</code><br><code>LL_TIM_IC_Init(TIM_TypeDef* TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef* TIM_IC_InitStruct)</code><br><code>LL_TIM_ENCODER_Init(TIM_TypeDef* TIMx, LL_TIM_ENCODER_InitTypeDef* TIM_EncoderInitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP&#123;_CATEGORY&#125;_StructInit</code></td>
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>LL_PPP&#123;_CATEGORY&#125;_InitTypeDef* PPP&#123;_CATEGORY&#125;_InitStruct</code></td>
<td style="text-align: left;">采用缺省值填充
<code>PPP&#123;_CATEGORY&#125;_InitStruct</code>
结构体的每一个成员，例如：<br><code>LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_CommonInit</code></td>
<td style="text-align: left;"><code>ErrorStatus</code></td>
<td style="text-align: left;"><code>PPP_TypeDef* PPPx</code><br><code>LL_PPP_CommonInitTypeDef* PPP_CommonInitStruct</code></td>
<td style="text-align: left;">初始化相同外设不同实例之间共享的公共特性，例如：<br><code>LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_CommonStructInit</code></td>
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>LL_PPP_CommonInitTypeDef* PPP_CommonInitStruct</code></td>
<td style="text-align: left;">采用缺省值填充
<code>PPP&#123;_CATEGORY&#125;_InitStruct</code>
结构体的每一个成员，例如：<br><code>LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_ClockInit</code></td>
<td style="text-align: left;"><code>ErrorStatus</code></td>
<td style="text-align: left;"><code>PPP_TypeDef* PPPx</code><br><code>LL_PPP_ClockInitTypeDef* PPP_ClockInitStruct</code></td>
<td style="text-align: left;">通过同步模式，初始化外设时钟的配置，例如：<br><code>LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct)</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>LL_PPP_ClockStructInit</code></td>
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>LL_PPP_ClockInitTypeDef* PPP_ClockInitStruct</code></td>
<td style="text-align: left;">采用缺省值填充
<code>ppp_clockkinitstruct</code>
结构体的每一个成员，例如：<br><code>LL_USART_ClockStructInit(LL_USART_ClockInitTypeDef *USART_ClockInitStruct)</code>；</td>
</tr>
</tbody>
</table>
<h3 id="运行时检查-1">运行时检查</h3>
<p>类似于 HAL 固件驱动，LL
初始化函数同样通过检查函数的输入值来实现运行时错误检查。当独立使用 LL
驱动程序（不调用任何 HAL
函数）的时候，需要执行如下操作来进行<strong>运行时检查</strong>：</p>
<ol type="1">
<li>复制 <code>stm32_assert_template.h</code>
到用户工程目录，并将其重命名为
<code>stm32_assert.h</code>，该文件当中定义了运行时错误检查所需的
<code>assert_param</code> 宏；</li>
<li>在用户应用程序入口的 <code>main.h</code> 头文件当中包含
<code>stm32_assert.h</code> 文件；</li>
<li>在工具链编译器预处理，或者位于 <code>stm32_assert.h</code>
之前执行的任意通用头文件当中，添加 <code>USE_FULL_ASSERT</code>
编译开关；</li>
</ol>
<blockquote>
<p><strong>注意</strong>：运行时错误检查对于 LL
固件库的内联函数无效。</p>
</blockquote>
<h3 id="外设的寄存器级配置">外设的寄存器级配置</h3>
<p>在外设初始化函数的基础之上，LL
固件库提供了一系列能够细粒度操作寄存器的内联函数，其格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__STATIC_INLINE return_type <span class="title function_">LL_PPP_Function</span><span class="params">(PPPx_TypeDef *PPPx, args)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：此处的 <code>Function</code>
是根据其行为类别来进行命名的。</p>
</blockquote>
<ul>
<li><p><strong>指定的中断与 DMA
请求、状态标志管理</strong>，即<strong>设置</strong>、<strong>获取</strong>、<strong>清除</strong>、<strong>启用</strong>、<strong>禁用</strong>中断与状态寄存器上的标志：</p>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_PPP_&#123;_CATEGORY&#125;_ActionItem_BITNAME</code><br><code>LL_PPP&#123;_CATEGORY&#125;_IsItem_BITNAME_Action</code></td>
<td style="text-align: left;"><code>LL_RCC_IsActiveFlag_LSIRDY</code><br><code>LL_RCC_IsActiveFlag_FWRST()</code><br><code>LL_ADC_ClearFlag_EOC(ADC1)</code><br><code>LL_DMA_ClearFlag_TCx(DMA_TypeDef* DMAx)</code></td>
</tr>
</tbody>
</table>
<p>可以使用的函数格式如下面表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">类型</th>
<th style="text-align: left;">行为</th>
<th style="text-align: left;">格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>标志</strong></td>
<td style="text-align: left;">获取</td>
<td style="text-align: left;"><code>LL_PPP_IsActiveFlag_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;">清除</td>
<td style="text-align: left;"><code>LL_PPP_ClearFlag_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>中断</strong></td>
<td style="text-align: left;">启用</td>
<td style="text-align: left;"><code>LL_PPP_EnableIT_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;">禁用</td>
<td style="text-align: left;"><code>LL_PPP_DisableIT_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;">获取</td>
<td style="text-align: left;"><code>LL_PPP_IsEnabledIT_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>DMA</strong></td>
<td style="text-align: left;">启用</td>
<td style="text-align: left;"><code>LL_PPP_EnableDMAReq_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;">禁用</td>
<td style="text-align: left;"><code>LL_PPP_DisableDMAReq_BITNAME</code></td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;">获取</td>
<td style="text-align: left;"><code>LL_PPP_IsEnabledDMAReq_BITNAME</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上面表格当中的 <code>BITNAME</code>
是指官方参考手册当中所描述外设寄存器的位名称。</p>
</blockquote></li>
<li><p><strong>外设时钟激活与失活管理</strong>，即<strong>启用</strong>、<strong>禁用</strong>、<strong>重置</strong>外设时钟：</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 82%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_BUS_GRPx_ActionClock&#123;Mode&#125;</code></td>
<td style="text-align: left;"><code>LL_AHB2_GRP1_EnableClock (LL_AHB2_GRP1_PERIPH_GPIOA │ LL_AHB2_GRP1_PERIPH_GPIOB)</code><br><code>LL_APB1_GRP1_EnableClockSleep (LL_APB1_GRP1_PERIPH_DAC1)</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上面表格当中的 <code>x</code>
对应于组索引，即关联到指定总线上被修改寄存器的索引，而 <code>bus</code>
则对应于总线的名称。</p>
</blockquote></li>
<li><p><strong>外设的激活与失活管理</strong>，即<strong>启用/禁用</strong>外设，或者<strong>激活/失活</strong>指定的外设功能：</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_PPP&#123;_CATEGORY&#125;_Action&#123;Item&#125;</code><br><code>LL_PPP&#123;_CATEGORY&#125;_IsItemAction</code></td>
<td style="text-align: left;"><code>LL_ADC_Enable()</code><br><code>LL_ADC_StartCalibration()</code><br><code>LL_ADC_IsCalibrationOnGoing</code><br><code>LL_RCC_HSI_Enable()</code><br><code>LL_RCC_HSI_IsReady()</code></td>
</tr>
</tbody>
</table></li>
<li><p><strong>外设配置管理</strong>，即<strong>设置/获取</strong>外设的配置：</p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 61%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>LL_PPP&#123;_CATEGORY&#125;_&#123;Set/Get&#125;ConfigItem</code></td>
<td style="text-align: left;"><code>LL_USART_SetBaudRate(USART2, Clock, LL_USART_BAUDRATE_9600)</code></td>
</tr>
</tbody>
</table></li>
<li><p><strong>外设寄存器管理</strong>，即<strong>读/写</strong>一个寄存器的内容，或者返回
<strong>DMA</strong> 相关的寄存器地址：</p>
<table>
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>LL_PPP_WriteReg(__INSTANCE__, __REG__, __VALUE__)</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>LL_PPP_ReadReg(__INSTANCE__, __REG__)</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>LL_PPP_DMA_GetRegAddr(PPP_TypeDef *PPPx, &#123; Sub Instance if any ex : Channel &#125;, &#123;uint32_t Propriety&#125;)</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上面表格当中的 <code>proper</code>
是一个用于识别 DMA 传输方向或者数据寄存器类型的变量。</p>
</blockquote></li>
</ul>
<h2 id="hal-ll-组合运用">HAL &amp; LL 组合运用</h2>
<p><strong>LL</strong> 固件库当中的 API 可以独立进行使用，也可以与
<strong>HAL</strong> 结合起来使用，但是并不能与 <strong>HAL</strong>
一起作用于相同的外设实例，换而言之，可以在一个外设实例上使用
<strong>LL</strong> 库的 API，而另一个外设实例上使用
<strong>HAL</strong> 库的 <strong>API，注意，LL</strong> 库的 API
可能会重写一些内容被映射至 <strong>HAL</strong> 指针的寄存器。</p>
<h3 id="单独使用-ll-固件库">单独使用 LL 固件库</h3>
<p>LL 固件库的 API
可以独立的在工程当中进行使用，只需要在用户应用程序内包含
<code>stm32f4xx_ll_ppp.h</code> 头文件即可，调用指定外设 LL 库 API
的顺序与官方参考手册里推荐的顺序相同。在这种情况之下，可以删除用户工程里与
LL 库操作外设相关联的 HAL 驱动程序，但是与 <strong>STM32CubeF4</strong>
的 ARM Cortex-M4 核心开发框架相关联的
<code>系统文件</code>、<code>启动文件</code>、<code>CMSIS</code>
代码仍然需要保留。</p>
<blockquote>
<p><strong>注意</strong>：当工程中包含有<strong>板级支持包</strong>（BSP，Board
level Support Package）时，与其相关联的 HAL
固件驱动程序应当也包含在用户工程当中，即使它们并没有直接被用户应用所调用。</p>
</blockquote>
<h3 id="组合运用-hal-和-ll-固件库">组合运用 HAL 和 LL 固件库</h3>
<p>当 <strong>HAL</strong> 和 <strong>LL</strong>
两个固件库组合在一起使用时，同样可以达到直接操作<strong>寄存器</strong>的目的。虽然官方文档里允许进行这样的混合使用，但是应当考虑到如下因素：</p>
<ol type="1">
<li>建议避免同时通过 HAL 和 LL 的 API
操作相同的外设实例，如果必须要执行类似的操作，则需要修改 HAL 外设
<strong>PPP</strong> 结构体上的相应的私有字段设置；</li>
<li>对于不会修改指针字段（包含初始化结构体）的处理和操作，则可以让 HAL
库与 LL 库的 API 共同作用于相同的外设实例；</li>
<li>LL 驱动程序可以不受限制的与所有不基于指针对象的 HAL
驱动程序（包括<code>RCC</code>、<code>公用的 HAL</code>、<code>Flash</code>、<code>GPIO</code>）一起共同使用；</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<strong>STM32F401CC</strong> 固件包里
<code>Projects</code> 目录下的 <code>Examples_MIX</code>
示例工程，展示了在同一个用户工程当中组合运用 HAL 和 LL 库的示例。</p>
</blockquote>
<p>除了上述注意事项之后，还需要再额外注意以下几点事项：</p>
<ul>
<li>当 HAL 的初始化与反向初始化 API 没有被使用，而是被 LL
库的宏定义替换掉的时候，此时 <code>InitMsp()</code>
函数并不会被调用，而需要用户自行在应用程序当中初始化<strong>主堆栈指针
MSP</strong>；</li>
<li>当某个 HAL 的处理 API 没有被使用，而是通过 LL 的 API
执行相应的函数时，此时 HAL
的回调函数并不会被自动调用，后期的处理以及错误管理都需要由用户应用程序来完成；</li>
<li>当 LL 库的 API 被用于指定的操作过程时，与 HAL 库 API 相关的 IRQ
处理程序不会被调用，此时 IRQ 需要由用户应用程序来实现，每个 LL
驱动程序实现的<strong>宏</strong>需要去读取和清除相关的中断标志；</li>
</ul>
<h2 id="stm32-cube-ide-开发环境">STM32 Cube IDE 开发环境</h2>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeide.html"><strong>STM32
Cube IDE</strong></a> 是由<strong>意法半导体</strong>推出的一款基于
<code>Eclipse/CDT</code> 框架和 <code>GCC/GDB</code> 工具链打造的
<strong>C/C++</strong> 集成开发环境，内部整合了 <a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/stm32cubemx.html"><strong>STM32CubeMX</strong></a>
代码生成器，可以方便的用于 STM32
系列微控制器的<strong>外设配置</strong>和<strong>代码生成、编译、调试</strong>。</p>
<p><img src="/Embedded/STM32F401/Cube/Logo.png"></p>
<p>除此之外，<strong>STM32 Cube IDE</strong>
还集成有<strong>构建分析器</strong>【Build
Analyzer】，用于为开发者提供编译构建相关的有效信息：</p>
<p><img src="/Embedded/STM32F401/Cube/Build-Analyzer.png"></p>
<p>以及<strong>静态堆栈分析器</strong>【Static Stack
Analyzer】，用于为用户提供<strong>内存堆栈</strong>方面的有用参考信息：</p>
<p><img src="/Embedded/STM32F401/Cube/Static-Stack-Analyzer.png"></p>
<h3 id="新建工程">新建工程</h3>
<p>开始新建工程之前，需要进入 <strong>STM32 Cube IDE</strong>
的偏好设置界面设置 <code>STM32Cube</code>
固件安装的位置，鼠标依次点击【Preferences → STM32Cube → Firmware
Updater】，这里选择将固件库保存至
<code>C:\Software\Tech\STM32\Repository</code>
目录，然后再点击<strong>应用并且关闭</strong>【Apply and
Close】按钮：</p>
<p><img src="/Embedded/STM32F401/Cube/IDE-1.png"></p>
<p>首先，选中 <strong>STM32 Cube IDE</strong> 左侧项目管理器上的【Create
a New STM32 project】链接，进入如下的 <strong>STM32 MCU/MPU
选择器</strong>界面，选中 <strong>STM32F401CCUx</strong>
之后点击<strong>下一步</strong>【Next&gt;】按钮：</p>
<p><img src="/Embedded/STM32F401/Cube/IDE-2.png"></p>
<p>然后，设置用户工程的<strong>名称</strong>，其它的设置项保持默认即可，继续点击<strong>下一步</strong>【Next&gt;】按钮：</p>
<p><img src="/Embedded/STM32F401/Cube/IDE-3.png"></p>
<p>接下来，选择 <code>STM32Cube</code>
的<strong>固件版本</strong>，并且检查固件库保存的<strong>位置</strong>，选择<strong>仅拷贝工程所需的库文件</strong>，点击<strong>完成</strong>【Finish】按钮：</p>
<p><img src="/Embedded/STM32F401/Cube/IDE-4.png"></p>
<p>最后，返回到下面的 <strong>STM32 Cube IDE</strong>
主界面，此时点击工具栏上的【🔨】按钮就可以编译当前工程。这里可以通过切换【Build
'Debug' for project 'Test'】和【Build 'Release' for project
'Test'】菜单，选择当前工程的编译方式为 <strong>Debug 调试</strong> 还是
<strong>Release 编译</strong>：</p>
<p><img src="/Embedded/STM32F401/Cube/IDE-5.png"></p>
<p>此处如果选择的是 <strong>Debug
调试</strong>选项，那么生成的代码将会位于 <code>Test</code> 用户工程下的
<code>Debug</code> 目录；而如果选择 <strong>Release
编译</strong>选项，则生成的代码将会保存在 <code>Test</code> 工程下的
<code>Release</code> 目录，而 <code>Debug</code> 和 <code>Release</code>
目录当中的 <code>Test.bin</code> 二进制文件就是将要被下载到
<strong>STM32F401CC</strong> 微控制器当中运行的固件。</p>
<h3 id="工程源码结构">工程源码结构</h3>
<p>通过 <a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeide.html"><strong>STM32CubeIDE</strong></a>
新建一个 <strong>STM32F401CC</strong>
基本工程的项目代码结构如下所示，这些库文件主要拷贝自
<code>STM32Cube_FW_F4_V1.26.2</code> 固件库的 <code>Drivers\CMSIS</code>
和 <code>Drivers\STM32F4xx_HAL_Driver</code>
两个目录，而其它文件则是由开发工具自动生成的工程辅助文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[ Test ]</span><br><span class="line">│  .cproject                <span class="comment"># Eclipse CDT 项目描述文件；</span></span><br><span class="line">│  .mxproject               <span class="comment"># CubeMX 项目描述文件；</span></span><br><span class="line">│  .project                 <span class="comment"># Eclipse 项目描述文件；</span></span><br><span class="line">│  STM32F401CCUX_FLASH.ld   <span class="comment"># STM32F401CCUx 的链接器脚本（256Kbytes FLASH 和 64Kbytes RAM），根据程序要求设置堆栈的大小与位置，如果使用外部存储器，则还可以用于设置存储器 Bank 的大小；</span></span><br><span class="line">│  Test.ioc                 <span class="comment"># MicroXplorer 代码生成器配置；</span></span><br><span class="line">│</span><br><span class="line">├─.settings</span><br><span class="line">│      language.settings.xml        <span class="comment"># 集成开发环境语言配置文件；</span></span><br><span class="line">│      stm32cubeide.project.prefs   <span class="comment"># STM32 Cube IDE 配置文件；</span></span><br><span class="line">│</span><br><span class="line">├─Core</span><br><span class="line">│  ├─Inc</span><br><span class="line">│  │      main.h                 <span class="comment"># main.c 的头文件，包含了应用程序的通用定义；</span></span><br><span class="line">│  │      stm32f4xx_hal_conf.h   <span class="comment"># HAL 配置模板文件，拷贝自 stm32f4xx_hal_conf.h 文件；</span></span><br><span class="line">│  │      stm32f4xx_it.h         <span class="comment"># 中断处理程序 stm32f4xx_it.c 的头文件；</span></span><br><span class="line">│  │</span><br><span class="line">│  ├─Src</span><br><span class="line">│  │      main.c                 <span class="comment"># 应用程序的入口文件；</span></span><br><span class="line">│  │      stm32f4xx_hal_msp.c    <span class="comment"># 包含主堆栈指针 MSP 的初始化与反向初始化代码；</span></span><br><span class="line">│  │      stm32f4xx_it.c         <span class="comment"># 中断处理程序；</span></span><br><span class="line">│  │      syscalls.c             <span class="comment"># STM32CubeIDE 最小系统调用；</span></span><br><span class="line">│  │      sysmem.c               <span class="comment"># STM32CubeIDE 内存调用；</span></span><br><span class="line">│  │      system_stm32f4xx.c     <span class="comment"># CMSIS Cortex-M4 外设访问层系统源文件；</span></span><br><span class="line">│  │</span><br><span class="line">│  └─Startup</span><br><span class="line">│          startup_stm32f401ccux.s   <span class="comment"># STM32F401xCxx 基于 GCC 工具链的设备向量表，用于设置初始化堆栈 SP、程序计数器 PC、异常中断服务程序地址的向量表，最后调用程序入口文件 main.c；</span></span><br><span class="line">│</span><br><span class="line">└─Drivers</span><br><span class="line">    ├─CMSIS</span><br><span class="line">    │  ├─Device</span><br><span class="line">    │  │  └─ST</span><br><span class="line">    │  │      └─STM32F4xx</span><br><span class="line">    │  │          ├─Include</span><br><span class="line">    │  │          │      stm32f401xc.h        <span class="comment"># CMSIS STM32F401xC 外设访问层头文件，包含了所有外设的数据结构与地址映射、外设寄存器的声明与位定义、宏访问外设的寄存器硬件；</span></span><br><span class="line">    │  │          │      stm32f4xx.h          <span class="comment"># CMSIS STM32F401xC 外设操作层头文件，用于选择 STM32F4xx 为目标应用程序、应用程序代码中是否使用外设驱动程序；</span></span><br><span class="line">    │  │          │      system_stm32f4xx.h   <span class="comment"># 用于 STM32F4xx 的 CMSIS Cortex-M4 设备系统源文件；</span></span><br><span class="line">    │  │          │</span><br><span class="line">    │  │          └─Source</span><br><span class="line">    │  │              └─Templates</span><br><span class="line">    │  └─Include</span><br><span class="line">    │          cmsis_armcc.h     <span class="comment"># CMSIS 编译器 ARMCC（Arm compiler 5）的头文件；</span></span><br><span class="line">    │          cmsis_armclang.h  <span class="comment"># CMSIS 编译器 armclang（Arm compiler 6）的头文件；</span></span><br><span class="line">    │          cmsis_compiler.h  <span class="comment"># CMSIS 编译器通用头文件；</span></span><br><span class="line">    │          cmsis_gcc.h       <span class="comment"># CMSIS 编译器 GCC 头文件；</span></span><br><span class="line">    │          cmsis_iccarm.h    <span class="comment"># CMSIS 编译器 ICCARM（针对 ARM 的 IAR 编译器）头文件；</span></span><br><span class="line">    │          cmsis_version.h   <span class="comment"># CMSIS 核心版本定义；</span></span><br><span class="line">    │          core_armv8mbl.h   <span class="comment"># CMSIS Armv8-M 基准核心外设访问层头文件；</span></span><br><span class="line">    │          core_armv8mml.h   <span class="comment"># CMSIS Armv8-M 主线核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm0.h        <span class="comment"># CMSIS Cortex-M0 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm0plus.h    <span class="comment"># CMSIS Cortex-M0+ 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm1.h        <span class="comment"># CMSIS Cortex-M1 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm23.h       <span class="comment"># CMSIS Cortex-M23 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm3.h        <span class="comment"># CMSIS Cortex-M3 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm33.h       <span class="comment"># CMSIS Cortex-M33 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm4.h        <span class="comment"># CMSIS Cortex-M4 核心外设访问层头文件；</span></span><br><span class="line">    │          core_cm7.h        <span class="comment"># CMSIS Cortex-M7 核心外设访问层头文件；</span></span><br><span class="line">    │          core_sc000.h      <span class="comment"># CMSIS SC000 核心外设访问层头文件；</span></span><br><span class="line">    │          core_sc300.h      <span class="comment"># CMSIS SC300 核心外设访问层头文件；</span></span><br><span class="line">    │          mpu_armv7.h       <span class="comment"># 针对 Armv7-M MPU 的 CMSIS MPU API；</span></span><br><span class="line">    │          mpu_armv8.h       <span class="comment"># 针对 Armv8-M MPU 的 CMSIS MPU API；</span></span><br><span class="line">    │          tz_context.h      <span class="comment"># 针对 Armv8-M 的 TrustZone 管理；</span></span><br><span class="line">    │</span><br><span class="line">    └─STM32F4xx_HAL_Driver</span><br><span class="line">        ├─Inc</span><br><span class="line">        │  │  stm32f4xx_hal.h                 <span class="comment"># 包含 HAL 模块驱动程序的所有函数原型；</span></span><br><span class="line">        │  │  stm32f4xx_hal_cortex.h          <span class="comment"># CORTEX 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_def.h             <span class="comment"># 包含 HAL 通用的预定义、枚举、宏和结构体的定义；</span></span><br><span class="line">        │  │  stm32f4xx_hal_dma.h             <span class="comment"># DMA 扩展模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_dma_ex.h          <span class="comment"># DMA 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_exti.h            <span class="comment"># EXTI 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_flash.h           <span class="comment"># FLASH 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_flash_ex.h        <span class="comment"># FLASH 扩展模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_flash_ramfunc.h   <span class="comment"># FLASH RAMFUNC 驱动程序的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_gpio.h            <span class="comment"># FLASH 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_gpio_ex.h         <span class="comment"># FLASH 扩展模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_pwr.h             <span class="comment"># PWR 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_pwr_ex.h          <span class="comment"># PWR 扩展模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_rcc.h             <span class="comment"># RCC 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_rcc_ex.h          <span class="comment"># RCC 扩展模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_tim.h             <span class="comment"># TIM 模块的头文件；</span></span><br><span class="line">        │  │  stm32f4xx_hal_tim_ex.h          <span class="comment"># TIM 扩展模块的头文件；</span></span><br><span class="line">        │  │</span><br><span class="line">        │  └─Legacy</span><br><span class="line">        │          stm32_hal_legacy.h   <span class="comment"># 包含 STM32Cube HAL 的常量宏，以及出于兼容性目的而维护的函数别名定义；</span></span><br><span class="line">        │</span><br><span class="line">        └─Src</span><br><span class="line">                stm32f4xx_hal.c                 <span class="comment"># HAL 固件库初始化的公共部分；</span></span><br><span class="line">                stm32f4xx_hal_cortex.c          <span class="comment"># 管理 CORTEX 的初始化/反向初始化、外设控制函数；</span></span><br><span class="line">                stm32f4xx_hal_dma.c             <span class="comment"># 直接存储器访问（DMA，Direct Memory Access）的初始化/反向初始化、IO 操作、外设状态与错误函数；</span></span><br><span class="line">                stm32f4xx_hal_dma_ex.c          <span class="comment"># DMA 外设的扩展功能函数；</span></span><br><span class="line">                stm32f4xx_hal_exti.c            <span class="comment"># 扩展中断与事件控制器（EXTI，Extended Interrupts and events controller）的初始化/反向初始化、IO 操作函数；</span></span><br><span class="line">                stm32f4xx_hal_flash.c           <span class="comment"># 内置 FLASH 存储器的程序操作、存储控制、外设错误函数；</span></span><br><span class="line">                stm32f4xx_hal_flash_ex.c        <span class="comment"># 扩展 FLASH 存储器的编程操作函数；</span></span><br><span class="line">                stm32f4xx_hal_flash_ramfunc.c   <span class="comment"># 提供从内部 SRAM 执行的 FLASH 函数，包括在系统运行时停止/启动 FLASH 接口、启用/禁用 FLASH 休眠；</span></span><br><span class="line">                stm32f4xx_hal_gpio.c            <span class="comment"># 通用输入输出（GPIO，General Purpose Input/Output）的初始化/反向初始化、IO 操作函数；</span></span><br><span class="line">                stm32f4xx_hal_pwr.c             <span class="comment"># 功率控制器（PWR，Power Controller）的初始化/反向初始化、外设控制函数；</span></span><br><span class="line">                stm32f4xx_hal_pwr_ex.c          <span class="comment"># PWR 外设特性扩展函数；</span></span><br><span class="line">                stm32f4xx_hal_rcc.c             <span class="comment"># 复位和时钟控制（RCC，Reset and Clock Control）的初始化/反向初始化、外设控制函数；</span></span><br><span class="line">                stm32f4xx_hal_rcc_ex.c          <span class="comment"># RCC 扩展外设控制函数；</span></span><br><span class="line">                stm32f4xx_hal_tim.c             <span class="comment"># 定时器（Timer）的时基、PWM 输出、输入捕获、脉冲、编码器等相关功能的函数与配置；</span></span><br><span class="line">                stm32f4xx_hal_tim_ex.c          <span class="comment"># 定时器扩展外设相关的函数，例如时间霍尔传感器的初始化与启动、时间互补信号中断和死区时间配置、时间主从同步配置、定时器重映射功能配置；</span></span><br></pre></td></tr></table></figure>
<p><strong>STM32CubeIDE</strong> 自动生成的工程当中，默认的
<code>main.h</code> 和 <code>main.c</code> 源文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 初始化系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用程序入口 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  HAL_Init();             <span class="comment">// 重置所有外设，初始 Flash 接口和 Systick</span></span><br><span class="line">  SystemClock_Config();   <span class="comment">// 配置系统时钟</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;            <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 系统时钟配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 配置内部主稳压器的输出电压 */</span></span><br><span class="line">  __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 根据 RCC_OscInitTypeDef 结构体当中的指定参数，初始化 RCC 振荡器 */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 MCU、AHB、APB 总线时钟 */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发生错误时执行该函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 用户可以添加自定义的实现来报告 HAL 错误返回状态 */</span></span><br><span class="line">  __disable_irq();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line"><span class="comment">/* 返回发生 assert_param 错误源文件的名称与源行号，参数 file 是指向源文件名的指针，参数 line 是 assert_param 错误行号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span> *file, <span class="type">uint32_t</span> line)</span> &#123;</span><br><span class="line">  <span class="comment">/* 用户可以添加自定义实现来报告源文件名称和行号，例如：printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="st-link-下载调试">ST-Link 下载调试</h3>
<p><strong>STM32 Cube IDE</strong> 默认集成了 <strong>ST-Link</strong>
升级工具，操作之前需要先安装意法半导体官方的 <a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stsw-link009.html">ST-Link
驱动程序</a>，并且将 <strong>ST-Link</strong> 插入电脑的 USB
接口，然后依次选择 <strong>STM32 Cube IDE</strong> 主菜单上的【Help →
ST-Link 更新】：</p>
<p><img src="/Embedded/STM32F401/Cube/ST-Link-1.png"></p>
<p>在弹出的 <strong>ST-Link</strong>
升级界面当中，鼠标依次点击<strong>打开升级模式</strong>【Open in update
mode】和<strong>升级</strong>【Upgrade】按钮，就可以开始联网进行升级：</p>
<p><img src="/Embedded/STM32F401/Cube/ST-Link-2.png"></p>
<p>当对话框的绿色滚动条消失，就表示此时升级操作已经执行完毕，界面上会显示升级成功的提示信息：</p>
<p><img src="/Embedded/STM32F401/Cube/ST-Link-3.png"></p>
<p>接下来，从电脑 USB 接口上拔出 <strong>ST-Link</strong>
再重新插入上电，就可以开始进行程序的调试与下载工作，将
<strong>ST-Link</strong> 与 <strong>STM32F401CC</strong>
开发板的<strong>SWD
串行线调试</strong>接口（<code>GND</code>、<code>SWCLK</code>、<code>SWDIO</code>、<code>3.3V</code>）
连接在一起：</p>
<p><img src="/Embedded/STM32F401/Cube/ST-Link-4.png"></p>
<p>然后，选择工具栏上的【Run】或者【Debug】按钮下面的【Run/Debug
Configration】菜单项，在打开的界面当中勾选【接口】为
<strong>SWD</strong>，如果当前电脑连接有多台
<strong>ST-Link</strong>，则这里还需要指定当前所使用的那台 ST-Link
序列号：</p>
<p><img src="/Embedded/STM32F401/Cube/ST-Link-5.png"></p>
<p>最后，鼠标点击界面上的【Run】运行按钮，就可以通过 ST-Link 的 SWD
调试接口，实时的将程序下载到 <strong>STM32F401CC</strong>
开发板当中运行。</p>
<h3 id="cmsis-dap-下载调试">CMSIS-DAP 下载调试</h3>
<p><a target="_blank" rel="noopener" href="https://os.mbed.com/handbook/CMSIS-DAP"><strong>CMSIS-DAP</strong></a>提供了一种通过
USB 访问 ARM Cortex 微控制器 <strong>Coresight</strong>
调试端口（DAP，Coresight Debug Access Port）的标准化方法，CMSIS-DAP
通常以板载接口芯片的方式进行实现，提供了从开发板到主机调试器的直接 USB
连接，并且通过<strong>联合测试行动组</strong>（JTAG，Joint Test Action
Group）或者<strong>串行线调试</strong>（SWD，Serial Wire
Debug）接口完成双方的相互连接。</p>
<p><img src="/Embedded/STM32F401/Cube/CMSIS-DAP-1.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>Coresight</strong> 是 ARM
公司提出的，用于对复杂的片上系统进行<strong>调试</strong>（Debug）与<strong>跟踪</strong>（Trace）的芯片设计架构。</p>
</blockquote>
<p>Windows 10 操作系统上使用 CMSIS-DAP 调试器，需要下载适用于 Windows
的预编译包 <a target="_blank" rel="noopener" href="https://gnutoolchains.com/arm-eabi/openocd/"><strong>OpenOCD</strong></a>，这是一款开源的芯片调试工具，允许使用
JTAG 通过 GDB 调试各种 ARM 设备。下载并解压安装包之后，将其
<code>bin</code> 目录添加到 Windows 的 <code>PATH</code>
环境变量当中，重新启动电脑之后，在命令行界面输入
<code>openocd --help</code>，如果提示如下结果就说明安装成功：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">λ openocd --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Open On-Chip Debugger <span class="number">0</span>.<span class="number">11</span>.<span class="number">0</span> (<span class="number">2021</span>-<span class="number">07</span>-<span class="number">29</span>) [https://github.com/sysprogs/openocd]</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">libusb1 <span class="number">09</span>e75e98b4d9ea7909e8837b7a3f00dda4589dc3</span><br><span class="line"><span class="keyword">For</span> bug reports, read</span><br><span class="line"><span class="function">        http://<span class="title">openocd.org</span>/<span class="title">doc</span>/<span class="title">doxygen</span>/<span class="title">bugs.html</span></span></span><br><span class="line"><span class="function"><span class="title">Open</span> <span class="title">On</span>-<span class="title">Chip</span> <span class="title">Debugger</span></span></span><br><span class="line"><span class="function"><span class="title">Licensed</span> <span class="title">under</span> <span class="title">GNU</span> <span class="title">GPL</span> <span class="title">v2</span></span></span><br><span class="line"><span class="function">--<span class="title">help</span>       | -<span class="title">h</span>       <span class="title">display</span> <span class="title">this</span> <span class="title">help</span></span></span><br><span class="line"><span class="function">--<span class="title">version</span>    | -<span class="title">v</span>       <span class="title">display</span> <span class="title">OpenOCD</span> <span class="title">version</span></span></span><br><span class="line"><span class="function">--<span class="title">file</span>       | -<span class="title">f</span>       <span class="title">use</span> <span class="title">configuration</span> <span class="title">file</span> &lt;<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="function">--<span class="title">search</span>     | -<span class="title">s</span>       <span class="title">dir</span> <span class="title">to</span> <span class="title">search</span> <span class="title">for</span> <span class="title">config</span> <span class="title">files</span> <span class="title">and</span> <span class="title">scripts</span></span></span><br><span class="line"><span class="function">--<span class="title">debug</span>      | -<span class="title">d</span>       <span class="title">set</span> <span class="title">debug</span> <span class="title">level</span> <span class="title">to</span> 3</span></span><br><span class="line"><span class="function">             | -<span class="title">d</span>&lt;<span class="title">n</span>&gt;    <span class="title">set</span> <span class="title">debug</span> <span class="title">level</span> <span class="title">to</span> &lt;<span class="title">level</span>&gt;</span></span><br><span class="line"><span class="function">--<span class="title">log_output</span> | -<span class="title">l</span>       <span class="title">redirect</span> <span class="title">log</span> <span class="title">output</span> <span class="title">to</span> <span class="title">file</span> &lt;<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="function">--<span class="title">command</span>    | -<span class="title">c</span>       <span class="title">run</span> &lt;<span class="title">command</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，将 CMSIS-DAP 调试器连接到电脑 USB 接口，此时 Windows 10
操作系统会自动适配其驱动程序。再执行下面的命令，在本地 <code>3333</code>
端口上启动 GDB 调试服务。注意命令参数 <code>--search</code>
后面的目录，需要指向当前 <strong>OpenOCD</strong> 安装的绝对路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openocd --search D:/software/Tech/OpenOCD --file share/openocd/scripts/interface/cmsis-dap.cfg --file share/openocd/scripts/target/stm32f4x.cfg</span><br></pre></td></tr></table></figure>
<p>方便起见，也可以将上述命令保存为一个单独的 <code>.bat</code>
批处理文件，以便于鼠标随时双击启动 GDB 调试服务。上述命令执行之后，如果
Windows 命令行界面提示如下信息，就表明 GDB 服务已经正确的启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Open On-Chip Debugger 0.11.0 (2021-07-29) [https://github.com/sysprogs/openocd]</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">libusb1 09e75e98b4d9ea7909e8837b7a3f00dda4589dc3</span><br><span class="line">For bug reports, <span class="built_in">read</span></span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">Info : auto-selecting first available session transport <span class="string">&quot;swd&quot;</span>. To override use <span class="string">&#x27;transport select &lt;transport&gt;&#x27;</span>.</span><br><span class="line">Info : Listening on port 6666 <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port 4444 <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : CMSIS-DAP: SWD  Supported</span><br><span class="line">Info : CMSIS-DAP: FW Version = 2.0.0</span><br><span class="line">Info : CMSIS-DAP: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1</span><br><span class="line">Info : CMSIS-DAP: Interface ready</span><br><span class="line">Info : clock speed 2000 kHz</span><br><span class="line">Info : SWD DPIDR 0x1ba01477</span><br><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> stm32f4x.cpu on 3333</span><br><span class="line">Info : Listening on port 3333 <span class="keyword">for</span> gdb connections</span><br></pre></td></tr></table></figure>
<p>接下来，连接 <strong>CMSIS-DAP</strong> 调试器和
<strong>STM32F401CC</strong> 开发板 ，打开 <strong>STM32 Cube
IDE</strong> 工程的<strong>设备配置工具</strong>【Device Configration
Tool】，然后选择当前所采用的 Debug 连接模式：</p>
<p><img src="/Embedded/STM32F401/Cube/CMSIS-DAP-2.png"></p>
<p>最后，选择 <strong>STM32 Cube IDE</strong>
工具栏上的【Run】或者【Debug】按钮下面的【Run/Debug
Configration】菜单项，切换至【调试器】选项卡，将端口号码设置为
<code>3333</code>，调试探头设置为
<code>ST-Link (OpenOCD)</code>，并且取消
<code>Enable live expressions</code>
的勾选，按下【Apply】应用这些设置，选择【Run】即可开始下载程序：</p>
<p><img src="/Embedded/STM32F401/Cube/CMSIS-DAP-3.png"></p>
<h2 id="stm32-cube-programmer-编程器">STM32 Cube Programmer 编程器</h2>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeprog.html"><strong>STM32
Cube Programmer</strong></a> 是意法半导体公司推出的一款 STM32
系列微控制器编程下载工具，可以支持摩托罗拉的 <code>S19</code> 和英特尔的
<code>HEX</code>、<code>ELF</code> 二进制文件格式，提供了
<strong>Debug</strong> 接口（<code>JTAG</code> 和 <code>SWD</code>）和
<strong>Bootloader</strong>
接口（<code>UART</code>、<code>USB DFU</code>、<code>I2C</code>、<code>SPI</code>、<code>CAN</code>）两种下载方式，能够同时支持
STM32 内部 <code>Flash</code>、<code>RAM</code>、<code>OTP</code>
以及外部存储器的下载编程。</p>
<p><img src="/Embedded/STM32F401/Programmer/Logo.png"></p>
<h3 id="进入-bootloader-模式">进入 Bootloader 模式</h3>
<p><strong>STM32F401CC</strong> 开发板经过如下的 3
个操作步骤，就可以进入 <strong>Bootloader</strong>
下载模式，从而正常使用 <strong>STM32 Cube Programmer</strong> 执行
<strong>USB</strong> 或 <strong>UART</strong> 下载：</p>
<ol type="1">
<li>首先，同时按住 开发板上的 <strong>BOOT0</strong> 和
<strong>NRST</strong> 按键；</li>
<li>然后，松开 <strong>NRST</strong> 按键；</li>
<li>最后，在 <code>0.5</code> 秒之后再松开 <strong>BOOT0</strong>
按键；</li>
</ol>
<h3 id="通过-usb-下载">通过 USB 下载</h3>
<p>打开 <strong>STM32 Cube Programmer</strong>，通过 USB 接口连接
<strong>STM32F401CC</strong> 开发板，让开发板进入
<strong>Bootloader</strong> 下载模式：</p>
<p><img src="/Embedded/STM32F401/Programmer/USB-1.png"></p>
<p>单击界面当中的【刷新】按钮，使得 <strong>STM32 Cube
Programmer</strong> 扫描到当前所连接的 USB
端口，然后按下【Connect】连接按钮开始建立连接：</p>
<p><img src="/Embedded/STM32F401/Programmer/USB-2.png"></p>
<p>连接成功之后，选择界面上的【Open
file】按钮，打开需要下载到开发板上运行的 <code>Test.bin</code>
二进制文件：</p>
<p><img src="/Embedded/STM32F401/Programmer/USB-3.png"></p>
<p>鼠标点击界面上的【Download】下载按钮就可以开始执行下载操作：</p>
<p><img src="/Embedded/STM32F401/Programmer/USB-4.png"></p>
<p>下载完成之后，<strong>STM32 Cube Programmer</strong>
的主界面上将会弹出下面的<code>下载完成</code>提示信息：</p>
<p><img src="/Embedded/STM32F401/Programmer/USB-5.png"></p>
<p>STM32 的 <strong>Bootloader 自举程序</strong>存放在系统 ROM
存储器当中，由意法半导体公司在 STM32 芯片生产期间预置，用于通过
<code>USART</code>、<code>CAN</code>、<code>USB</code>、<code>I²C</code>
等串行外设，下载程序至 STM32 内部的 Flash 存储器。由于 USB
下载程序时使用的是 <strong>HSE</strong> 外部高速晶振
，而<strong>Bootloader 自举程序</strong>是通过 <strong>HSI</strong>
内部高速晶振测量 <strong>HSE</strong> 频率之后再配置时钟。如果
<strong>HSI</strong> 受到环境温度影响误差过大，就会导致
<strong>HSE</strong> 测量的频率不准确，进而导致 USB
下载时序出现错误，<strong>STM32 Cube Programmer</strong>
会提示如下错误信息：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error: <span class="title">failed</span> <span class="title">to</span> <span class="title">download</span> <span class="title">Segment</span>[0]</span></span><br><span class="line"><span class="function"><span class="title">Error</span>: <span class="title">failed</span> <span class="title">to</span> <span class="title">download</span> <span class="title">the</span> <span class="title">File</span></span></span><br></pre></td></tr></table></figure>
<h3 id="通过-uart-下载">通过 UART 下载</h3>
<p>如果使用 USB 下载时遇到前面所述的错误，那么就可以选择稳定性更高的
UART 下载方式。首先将开发板与电脑的 USB 连接断开，然后插入一个 USB
转串口模块，将其 <code>TX</code> 引脚连接至开发板的
<code>PA10/RX1</code> 引脚，而 <code>RX</code> 引脚连接至开发板的
<code>PA9/TX1</code> 引脚，<code>3.3V</code> 和 <code>GND</code> 则分别
Pin to Pin 对应连接，然后打开 <strong>STM32 Cube Programmer</strong>
工具选择【UART】下载方式：</p>
<p><img src="/Embedded/STM32F401/Programmer/UART-1.png"></p>
<p>然后点击【Connect】连接按钮，使得 <strong>STM32 Cube
Programmer</strong> 通过 UART
与开发板建立连接，完成之后的界面如下图所示：</p>
<p><img src="/Embedded/STM32F401/Programmer/UART-2.png"></p>
<p>类似于前面所讨论的 USB 下载方式，这里依然选择界面上的【Open
file】按钮，打开 <code>Test.bin</code>
二进制文件，然后点击【Download】下载按钮，下载成功之后主界面同样会弹出
<code>File download complete</code> 的提示信息。让 <strong>STM32 Cube
Programmer</strong> 通过 <strong>UART</strong>
实现程序下载，并不会受到环境温度的影响，下载编程的稳定性较高。</p>
<h2 id="rcc-复位时钟控制">RCC 复位时钟控制</h2>
<h3 id="外设分析">外设分析</h3>
<p><strong>STM32F401CC</strong> 的<strong>系统时钟</strong>
<code>SYSCLK</code>
可以由<strong>高速内部</strong>（<strong>HSI</strong>，High Speed
Internal）与<strong>高速外部</strong>（<strong>HSE</strong>，High Speed
External）时钟，以及<strong>主锁相环</strong>（<strong>PLL</strong>，Phase
Locking
Loop）三种不同的时钟源来进行驱动；而<strong>实时时钟</strong>可以选择
<code>40kHz</code>
的<strong>低速内部</strong>（<strong>LSI</strong>，Low Speed
Internal）以及 <code>32.768kHz</code>
的<strong>低速外部</strong>（<strong>LSE</strong>，Low Speed
External）时钟，每一个时钟源都可以按需进行独立开关，从而优化系统的功耗特性。</p>
<ol type="1">
<li><strong>高速外部</strong>（<strong>HSE</strong>，High Speed
External）时钟：使用外部晶振作为时钟源，可以选择的频率范围在
<code>4mHz ~ 26mHz</code> 之间；</li>
<li><strong>高速内部</strong>（<strong>HSI</strong>，High Speed
Internal）时钟：由内部的 <code>16mHz</code> RC
振荡器产生，可以直接用于系统时钟，或者是输入到锁相环，虽然其启动较为迅速，但是频率精度和温度飘移性能不如
<strong>HSE</strong>；</li>
<li><strong>锁相环</strong>（<strong>PLL</strong>，Phase Locking
Loop）时钟：<strong>STM32F401CC</strong>
拥有两个锁相环，其中<strong>主锁相环</strong> <code>PLL</code> 由
<strong>HSE</strong> 或者 <strong>HSI</strong> 进行驱动，可以输出
<code>84mHz</code> 的高速系统时钟，或者是 <code>48mHz</code> 的全速 USB
OTG 信号、小于或等于 <code>48mHz</code> 的随机模拟信号、小于或等于
<code>48mHz</code> 的 SDIO 信号；</li>
<li><strong>低速外部</strong>（<strong>LSE</strong>，Low Speed
External）时钟：通过 <code>32.768kHz</code>
的低速外部晶振产生，用于为<strong>计时</strong>与<strong>日历</strong>功能的<strong>实时时钟</strong>（RTC，Real-Time
Clock）提供低功耗高精度的时钟信号源；</li>
<li><strong>低速内部</strong>（<strong>LSI</strong>，Low Speed
Internal）时钟：由 <code>32kHz</code>
的内置低功耗时钟源产生，可以在<strong>停止</strong>和<strong>待机</strong>模式下，保持<strong>独立看门狗</strong>（IWDG，Independent
Watch Dog）和<strong>自动唤醒单元</strong>（AWU，Auto Wakeup
Unit）的正常运行；</li>
</ol>
<p><img src="/Embedded/STM32F401/ARM/Clock.png"></p>
<p><strong>时钟控制器</strong>（Clock
Control）可以高度灵活的选择外部晶振，并且同时能够确保
USB、OTG、I2S、SDIO
等外设工作在指定的频率范围。除此之外，还会通过多个预分频器来配置
<strong>AHB</strong>（最大频率范围 <code>84mHz</code>）、<strong>高速
APB</strong>（APB2，最大频率范围 <code>84mHz</code>）、<strong>低速
APB</strong>（APB1，最大频率范围
<code>42mHz</code>）的总线工作频率。排除下面的两种情况之外，其它所有外设的时钟频率均来自于<strong>系统时钟</strong>
<code>SYSCLK</code>：</p>
<ol type="1">
<li>来自于锁相环 <code>PLL48CLK</code> 输出的全速 USB OTG
系统时钟（<code>48mHz</code>）与 SDIO 时钟（小于
<code>48mHz</code>）；</li>
<li>为实现高质量的音频性能，<strong>I2S</strong> 时钟可以由指定的
<strong>PLL</strong>（<code>PLLI2S</code>）或者映射至
<code>I2S_CKIN</code> 引脚的外部时钟源派生而来;</li>
</ol>
<p><strong>STM32F401CC</strong> 采用 <strong>AHB</strong> 总线时钟
<code>HCLK</code> 除以 <code>8</code> 来作为 Cortex-M4 系统定时器
<code>SysTick</code> 的外部时钟源，通过配置 <code>SysTick</code>
的控制状态寄存器，可以选择 <code>SysTick</code> 与该时钟源还是
<code>HCLK</code> 时钟源一起工作。而 <strong>STM32F401CC</strong>
的<strong>定时器时钟频率</strong>则是由硬件自动进行设置，当 APB 分频器为
<code>1</code> 时，定时器时钟频率与所连接 APB
总线的时钟频率保持一致，否则就会被设置为 APB 时钟频率的 <code>2</code>
倍。</p>
<p>当硬件自动设置<strong>定时器</strong>的时钟频率时，根据
<code>RCC_DCKCFGR</code> 寄存器当中 <code>TIMPRE</code>
位的取值，可以具体划分为下面两种情况:</p>
<ol type="1">
<li>如果 <code>TIMPRE</code> 被<strong>重置</strong>：当 APB
预分器的分频系数配置为 <code>1</code>，则定时器时钟频率
<code>TIM x CLK</code> 被设置为
<code>HCLK</code>，否则就会被设置为所连接 APB 总线频率的
<strong>2</strong> 倍 <code>TIM x CLK = 2 x PCLKx</code>；</li>
<li>如果 <code>TIMPRE</code> 被<strong>置位</strong>：当 APB
分频器配置为 <code>1</code> 或者 <code>2</code>，则定时器时钟频率
<code>TIM x CLK</code> 被设置为
<code>HCLK</code>，否则就会被设置为所连接 APB 总线频率的
<strong>4</strong> 倍 <code>TIM x CLK = 4 x PCLKx</code>；</li>
</ol>
<h3 id="api-描述">API 描述</h3>
<h4 id="指定特性">指定特性</h4>
<p>当设备复位之后，<strong>STM32F401CC</strong>
将会通过<strong>内部高速振荡器</strong>（HSI
<code>16MHz</code>）启动运行，此时微控制器处于 <code>Flash 0</code>
等待状态，并且 Flash 开始预获取缓冲区、同时 <code>D-Cache</code> 和
<code>I-Cache</code> 都被禁用，内部 SRAM、Flash、JTAG
之外的所有外设都将会被关闭。</p>
<ul>
<li><strong>AHB 高速总线</strong>和 <strong>APB
低速总线</strong>上都没有预分频器，这意味着映射到这些总线上的外设都会以
<strong>HSI</strong> 的频率运行；</li>
<li>除了 SRAM 和 FLASH 之外的所有外设时钟都将会被关闭；</li>
<li>除了 JTAG 引脚被分配用于调试之外，所有 GPIO
都将会处于<strong>浮空输入</strong>状态；</li>
</ul>
<p>一旦设备从复位状态开始重新启动，则用户应用程序必须进行如下一系列操作：</p>
<ul>
<li>配置用于驱动系统时钟的时钟源；</li>
<li>配置系统时钟频率与 Flash 设置；</li>
<li>配置 AHB 和 APB 总线的预分频器；</li>
<li>启动当前所要使用的外设时钟；</li>
<li>配置非系统时钟派生外设的时钟源 (I2S、RTC、ADC、全速 USB OTG 或者
SDIO、RNG) ；</li>
</ul>
<h4 id="使用限制">使用限制</h4>
<p>管理 <strong>STM32F401CC</strong>
外设对于寄存器进行的各种读写操作，需要考虑到
<code>RCC 外设时钟使能</code> 与 <code>有效外设使能</code>
之间的延迟：</p>
<ul>
<li>首先，这个延迟取决于外设映射；</li>
<li>其次，如果外设映射到 <strong>AHB</strong>
上，那么在设置寄存器时钟<strong>使能位</strong>之后，会被延迟为
<code>2</code> 个 <strong>AHB</strong> 时钟周期；</li>
<li>最后，如果外设映射到 <strong>APB</strong>
上，那么在设置寄存器时钟<strong>使能位</strong>之后，会被延迟为
<code>2</code> 个 <strong>APB</strong> 时钟周期；</li>
</ul>
<p>解决方案是在每个 <code>_HAL_RCC_PPP_CLK_ENABLE()</code>
宏定义当中插入一个对于外设寄存器的虚拟读取。</p>
<h4 id="内外部晶振与锁相环配置">内外部晶振与锁相环配置</h4>
<p><strong>内/外部晶振与锁相环</strong> 包括
HSE、HSI、LSE、LSI、PLL、CSS、MCO：</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 9%">
<col style="width: 80%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">英文缩写</th>
<th style="text-align: center;">英文全名</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>HSI</strong></td>
<td style="text-align: center;">high-speed internal</td>
<td style="text-align: left;">直接使用 <code>16 MHz</code> 工厂校准的 RC
振荡电路或者通过 PLL 锁相环作为系统时钟源；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>LSI</strong></td>
<td style="text-align: center;">low-speed internal</td>
<td style="text-align: left;"><code>32 KHz</code> 低功耗 RC
振荡电路用于<strong>独立看门狗</strong> IWDG
或者<strong>实时时钟</strong> RTC 的时钟源；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>HSE</strong></td>
<td style="text-align: center;">high-speed external</td>
<td style="text-align: left;">直接使用 <code>4 ~ 26MHz</code>
晶振或者通过 PLL 锁相环作为系统时钟源，也可以作为 RTC 时钟源；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>LSE</strong></td>
<td style="text-align: center;">low-speed external</td>
<td style="text-align: left;"><code>32 KHz</code> 晶振作为 RTC
实时时钟源；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>PLL</strong></td>
<td style="text-align: center;">phase Locking Loop</td>
<td style="text-align: left;">以 HSI 或 HSE
作为时钟的<strong>锁相环</strong>，具有<strong>两个不同用途</strong>的输出时钟，一种用于输出高达
<code>168 MHz</code> 的高速系统时钟，另一种用于生成全速 USB OTG 的
<code>48 MHz</code> 的时钟、随机模拟发生器的 <code>≤ 48 MHz</code>
的时钟、安全数字输入输出接口 SDIO 的 <code>≤ 48 MHz</code> 的时钟；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>CSS</strong></td>
<td style="text-align: center;">clock security system</td>
<td style="text-align: left;">使能宏定义
<code>__HAL_RCC_CSS_ENABLE()</code> 之后，如果发生 HSE
时钟故障（直接使用 HSE 或者通过 PLL
作为系统时钟源），系统时钟将会自动切换到 HSI 并且产生中断，该中断链接至
Cortex-M4 的非可屏蔽中断异常向量；</td>
</tr>
<tr>
<td style="text-align: center;"><strong>MCO1</strong></td>
<td style="text-align: center;">microcontroller clock output</td>
<td style="text-align: left;">用于通过 <strong>PA8</strong> 引脚输出
HSI、LSE、HSE、PLL 时钟（通过一个可配置的预分频器）；</td>
</tr>
<tr>
<td style="text-align: center;">  <strong>MCO2</strong>  </td>
<td style="text-align: center;">microcontroller clock output</td>
<td style="text-align: left;">用于通过 <strong>PC9</strong> 引脚输出
HSE、PLL、SYSCLK 、PLLI2S 时钟（通过一个可配置的预分频器）；</td>
</tr>
</tbody>
</table>
<h4 id="系统总线时钟配置">系统总线时钟配置</h4>
<p><strong>系统总线时钟</strong> 包括
<strong>SYSCLK</strong>、<strong>AHB</strong>、<strong>APB1</strong>、<strong>APB2</strong>
总线：</p>
<ul>
<li>系统时钟 <strong>SYSCLK</strong> 可以使用 HSI、HSE、PLL
多个时钟源，<strong>AHB</strong> 时钟 <code>HCLK</code>
是由系统时钟经过可配置的预分频器派生而来，作为微控制器核心的主要时钟源，而内存和外设则被映射至
AHB 总线（挂载有 DMA、GPIO
等外设）；除此之外，<strong>APB1（PCLK1）</strong>和
<strong>APB2（PCLK2）</strong>时钟则是通过可配置预分频器，从
<strong>AHB</strong>
时钟派生而来作为映射到这些总线上的外设时钟；通过调用
<code>HAL_RCC_GetSysClockFreq()</code>
函数，可以方便的检索到这些时钟的频率状态；</li>
<li><strong>STM32F401CC</strong> 的 <strong>SYSCLK</strong> 与
<strong>HCLK</strong> 最高频率为
<code>84 MHz</code>、<strong>PCLK2</strong> 为
<code>84 MHz</code>、<strong>PCLK1</strong> 为
<code>42 MHz</code>，具体可以根据 MCU
的功率因素，相应的调整最高运行频率；</li>
</ul>
<h3 id="hal-库-api">HAL 库 API</h3>
<h4 id="寄存器结构体">寄存器结构体</h4>
<p><code>RCC_OscInitTypeDef</code> 被定义在
<code>stm32f4xx_hal_rcc.h</code> 头文件当中：</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 72%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">RCC_OscInitTypeDef 结构体成员</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::OscillatorType</code></td>
<td style="text-align: left;">当前所需要配置的振荡器类型，该参数可以是
<code>RCC_Oscillator_Type</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::HSEState</code></td>
<td style="text-align: left;"><strong>HSE</strong>
的新状态，该参数可以是 <code>RCC_HSE_Config</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::LSEState</code></td>
<td style="text-align: left;"><strong>LSE</strong>
的新状态，该参数可以是 <code>RCC_LSE_Config</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::HSIState</code></td>
<td style="text-align: left;"><strong>HSI</strong>
的新状态，该参数可以是 <code>RCC_HSI_Config</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::HSICalibrationValue</code></td>
<td style="text-align: left;">HSI 校准微调值，默认为
<code>RCC_HSICALIBRATION_DEFAULT</code>，<br>该参数必须是位于
<code>Min_Data = 0x00</code> 和 <code>Max_Data = 0x1F</code>
之间的一个数值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_OscInitTypeDef::LSIState</code></td>
<td style="text-align: left;"><strong>LSI</strong>
的新状态，该参数可以是 <code>RCC_LSI_Config</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>RCC_PLLInitTypeDef RCC_OscInitTypeDef::PLL</code></td>
<td style="text-align: left;">锁相环 PLL 结构体参数；</td>
</tr>
</tbody>
</table>
<p><code>RCC_ClkInitTypeDef</code> 被定义在
<code>stm32f4xx_hal_rcc.h</code> 头文件当中：</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">RCC_ClkInitTypeDef 结构体成员</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_ClkInitTypeDef::ClockType</code></td>
<td style="text-align: left;">当前所需要配置的时钟，该参数可以是
<code>RCC_System_Clock_Type</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_ClkInitTypeDef::SYSCLKSource</code></td>
<td style="text-align: left;">将时钟源 <code>SYSCLKS</code>
用于系统时钟，该参数可以是 <code>RCC_System_Clock_Source</code>
里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_ClkInitTypeDef::AHBCLKDivider</code></td>
<td style="text-align: left;">AHB 时钟 <code>HCLK</code>
的分频器，该时钟由系统时钟 <code>SYSCLK</code> 派生而来，可以是
<code>RCC_AHB_Clock_Source</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_ClkInitTypeDef::APB1CLKDivider</code></td>
<td style="text-align: left;">APB1 时钟 <code>PCLK1</code>
的分频器，该时钟由 AHB 时钟 <code>HCLK</code> 派生而来，可以是
<code>RCC_APB1_APB2_Clock_Source</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t RCC_ClkInitTypeDef::APB2CLKDivider</code></td>
<td style="text-align: left;">APB2 时钟 <code>PCLK2</code>
的分频器，该时钟由 AHB 时钟 <code>HCLK</code> 派生而来，可以是
<code>RCC_APB1_APB2_Clock_Source</code> 里的值；</td>
</tr>
</tbody>
</table>
<h4 id="初始化与反向初始化">初始化与反向初始化</h4>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_RCC_DeInit()</code></td>
<td style="text-align: left;">重置 RCC 时钟为默认状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_OscConfig()</code></td>
<td style="text-align: left;">根据 <code>RCC_OscInitTypeDef</code>
当中的指定参数初始化 RCC 振荡器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_ClockConfig()</code></td>
<td style="text-align: left;">根据 <code>RCC_ClkInitStruct</code>
当中指定的参数初始化微控制器、AHB、APB 总线的时钟；</td>
</tr>
</tbody>
</table>
<h4 id="外设控制函数">外设控制函数</h4>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 67%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_RCC_MCOConfig()</code></td>
<td style="text-align: left;">选择 <code>MCO1/PA8</code>
引脚或者<code>MCO2/PC9</code> 引脚上输出的时钟源；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_EnableCSS()</code></td>
<td style="text-align: left;">打开<strong>时钟安全系统</strong>（CSS，Clock
Security System）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_DisableCSS()</code></td>
<td style="text-align: left;">关闭<strong>时钟安全系统</strong>（CSS，Clock
Security System）；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetSysClockFreq()</code></td>
<td style="text-align: left;">返回 <code>syscclk</code> 时钟频率；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetHCLKFreq()</code></td>
<td style="text-align: left;">返回 <code>HCLK</code> 时钟频率；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetPCLK1Freq()</code></td>
<td style="text-align: left;">返回 <code>PCLK1</code> 时钟频率；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetPCLK2Freq()</code></td>
<td style="text-align: left;">返回 <code>PCLK2</code> 时钟频率；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetOscConfig()</code></td>
<td style="text-align: left;">通过内部 RCC 寄存器配置
<code>RCC_OscInitStruct</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_GetClockConfig()</code></td>
<td style="text-align: left;">通过内部 RCC 寄存器配置
<code>RCC_ClkInitStruct</code>；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_NMI_IRQHandler()</code></td>
<td style="text-align: left;">用于处理 RCC 的 CSS
时钟安全系统中断请求；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_RCC_CSSCallback()</code></td>
<td style="text-align: left;">RCC 时钟安全系统 CSS 的中断回调函数；</td>
</tr>
</tbody>
</table>
<h4 id="示例代码">示例代码</h4>
<h2 id="gpio-通用输入输出">GPIO 通用输入输出</h2>
<h3 id="外设分析-1">外设分析</h3>
<p>每个通用 GPIO 端口都拥有四个 32
位<strong>配置寄存器</strong>（<code>GPIOx_MODER</code>、<code>GPIOx_OTYPER</code>、<code>GPIOx_OSPEEDR</code>、<code>GPIOx_PUPDR</code>)，两个
32
位<strong>数据寄存器</strong>（<code>GPIOx_IDR</code>、<code>GPIOx_ODR</code>），一个
32
位的<strong>设置与重置寄存器</strong>（<code>GPIOx_BSRR</code>），一个
32 位的<strong>锁定寄存器</strong>（<code>GPIOx_LCKR</code>），两个 32
位<strong>可复用功能的选择寄存器</strong>（<code>GPIOx_AFRH</code>、<code>GPIOx_AFRL</code>）。根据每个
GPIO 端口的硬件特性，它们可以分别被配置为如下几种工作模式：</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">中文名称</th>
<th style="text-align: left;">英文名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>浮空输入</strong></td>
<td style="text-align: left;">Input floating</td>
</tr>
<tr>
<td style="text-align: center;"><strong>上拉输入</strong></td>
<td style="text-align: left;">Input pull-up</td>
</tr>
<tr>
<td style="text-align: center;"><strong>下拉输入</strong></td>
<td style="text-align: left;">Input pull-down</td>
</tr>
<tr>
<td style="text-align: center;"><strong>模拟功能</strong></td>
<td style="text-align: left;">Analog</td>
</tr>
<tr>
<td style="text-align: center;"><strong>带上下拉的开漏输出</strong></td>
<td style="text-align: left;">Output open-drain with pull-up or
pull-down capability</td>
</tr>
<tr>
<td style="text-align: center;"><strong>带上下拉的推挽输出</strong></td>
<td style="text-align: left;">Output push-pull with pull-up or pull-down
capability</td>
</tr>
<tr>
<td style="text-align: center;"><strong>带上下拉的可复用推挽</strong></td>
<td style="text-align: left;">Alternate function push-pull with pull-up
or pull-down capability</td>
</tr>
<tr>
<td style="text-align: center;"><strong>带上下拉的可复用开漏</strong></td>
<td style="text-align: left;">Alternate function open-drain with pull-up
or pull-down capability</td>
</tr>
</tbody>
</table>
<h4 id="输入配置">输入配置</h4>
<p>当 GPIO
作处于输入模式时：<strong>输出缓冲区</strong>被禁用；<strong>施密特触发器</strong>的输入被激活；根据
<code>GPIOx_PUPDR</code> 寄存器的设置决定上下拉电阻是否激活；在 AHB
时钟周期当中，每个 GPIO
引脚的<strong>状态值</strong>将会被采样至<strong>输入数据寄存器</strong>；通过读取<strong>输入数据寄存器</strong>，就可以获得
GPIO 的状态；浮空/上拉/下拉输入的配置如下图所示：</p>
<p><img src="/Embedded/STM32F401/GPIO/Input.png"></p>
<h4 id="输出配置">输出配置</h4>
<p>当 GPIO
作处于输出模式时：<strong>输出缓冲区</strong>被启用（在<strong>开漏模式</strong>下，输出寄存器激活
N-MOS，但是输出寄存器当中的 <code>1</code> 会让端口保持高阻抗状态，此时
<strong>P-MOS</strong>
永远不会被激活；而在<strong>推挽模式</strong>下，输出寄存器激活
<strong>N-MOS</strong>，但是输出寄存器当中的 <code>1</code> 会激活
<strong>P-MOS</strong>；），<strong>施密特触发器</strong>的输入被激活，<strong>弱上下拉电阻</strong>是否被激活取决于
<code>GPIOx_PUPDR</code> 寄存器的值；在每个 AHB 时钟周期，GPIO
引脚上的<strong>状态值</strong>将会被采样至<strong>输入数据寄存器</strong>；通过访问<strong>输入数据寄存器</strong>可以获得
GPIO
的状态，而通过<strong>输出数据寄存器</strong>可以获得最后一次被写入的值；输出的配置如下图所示：</p>
<p><img src="/Embedded/STM32F401/GPIO/Output.png"></p>
<h4 id="复用功能配置">复用功能配置</h4>
<p>当 GPIO
被编程为复用功能模式时：<strong>输出缓冲区</strong>可以被配置为开漏或者推挽模式，此时输出缓冲区由外设的信号驱动，<strong>施密特触发器</strong>的输入被激活，<strong>弱上下拉电阻</strong>是否被激活取决于
<code>GPIOx_PUPDR</code> 寄存器的设置；GPIO
引脚上的<strong>状态值</strong>将会被采样至<strong>输入数据寄存器</strong>；通过访问<strong>输入数据寄存器</strong>，就可以获得
GPIO 引脚上的状态值；复用功能的配置如下图所示：</p>
<p><img src="/Embedded/STM32F401/GPIO/Alternate.png"></p>
<h4 id="模拟配置">模拟配置</h4>
<p>当 GPIO
端口被编程为模拟配置：<strong>输出缓冲区</strong>被禁用；施密特触发器的输入被禁用，为
GPIO
引脚的每个模拟值提供零消费，施密特触发器的输出被强制定义为一个常数值
<code>0</code>；<strong>弱上下拉电阻</strong>被禁用；此时对输入数据寄存器进行读取操作，所获得的值为
<code>0</code>；高阻态模拟配置如下图所示：</p>
<p><img src="/Embedded/STM32F401/GPIO/Analog.png"></p>
<h3 id="api-描述-1">API 描述</h3>
<h4 id="外设特性">外设特性</h4>
<p>根据数据手册当中每一个 GPIO 端口的硬件特性，每个 GPIO
端口可以被分别配置为：<strong>输入模式</strong>（Input
mode）、<strong>模拟模式</strong>（Analog
mode）、<strong>输出模式</strong>（Output
mode）、<strong>复用功能模式</strong>（Alternate function
mode）、<strong>外部中断事件线</strong>（External interrupt/event
lines）。</p>
<p>复位期间和复位以后，复用功能和外部中断线没有激活，并且 GPIO
端口被配置为<strong>浮空输入</strong>模式；所有 GPIO
引脚都拥有可以被激活的内部弱上下拉电阻；在输出或者可复用模式下，每个
GPIO
都可以被配置为<strong>开漏</strong>或者<strong>推挽</strong>模式，并且输入输出速度可以通过
<code>VDD</code> 的值进行选择。</p>
<p>所有 GPIO
端口都拥有外部中断/事件能力，但是必须配置为<strong>输入模式</strong>才能够进行使用。所有可用的
GPIO 引脚，都被连接到了 <code>EXTI0 ~ EXTI15</code> 共 16
条外部中断/事件线。外部中断事件控制器，可以通过 23 个边缘检测器（其中 16
线连接至
GPIO）生成事件/中断请求（每条输入线都可以被独立配置为指定类型的中断/事件），并且触发相应的事件（上升、下降或者两者兼有），其中每一条输入线都可以单独进行屏蔽。</p>
<h4 id="驱动使用">驱动使用</h4>
<ol type="1">
<li>使用函数 <code>__HAL_RCC_GPIOx_CLK_ENABLE()</code> 使能 GPIO 的 AHB
时钟源；</li>
<li>使用 <code>HAL_GPIO_Init()</code> 配置 GPIO 引脚；
<ul>
<li>通过 <code>GPIO_InitTypeDef</code> 结构体的 <code>Mode</code>
成员配置 IO 模式；</li>
<li>通过 <code>GPIO_InitTypeDef</code> 结构体的 <code>Pull</code>
成员激活上下拉电阻；</li>
<li>如果选择<strong>输出模式</strong>或者<strong>复用模式</strong>，<code>GPIO_InitTypeDef</code>
结构体的 <code>Speed</code> 成员用于配置速度；</li>
<li>如果选择复用模式，<code>GPIO_InitTypeDef</code> 结构体的
<code>Alternate</code> 成员用于配置 GPIO 引脚的复用功能；</li>
<li>当 GPIO 引脚以 ADC 通道或 DAC
输出方式使用时，则需要使用模拟模式；</li>
<li>如果选择外部中断/事件，<code>GPIO_InitTypeDef</code> 的
<code>Mode</code>
成员可以用于选择中断和事件的类型，并且相应的触发事件（上升、下降或者两者兼有）；</li>
</ul></li>
<li>选择外部中断/事件模式的情况下，使用
<code>HAL_NVIC_SetPriority()</code> 配置映射到 EXTI 线的 NVIC IRQ
优先级，并且通过 <code>HAL_NVIC_EnableIRQ()</code> 启用；</li>
<li>使用 <code>HAL_GPIO_ReadPin()</code>
可以获得输入模式下引脚的电平状态；</li>
<li>使用 <code>HAL_GPIO_WritePin()</code> 或者
<code>HAL_GPIO_TogglePin()</code>
在输出模式下<strong>设置</strong>引脚的电平状态；</li>
<li>使用 <code>HAL_GPIO_LockPin()</code>
在下一次重置之前一直锁定引脚配置；</li>
<li>在复位期间和复位之后，GPIO 复用功能没有激活，并且 GPIO
引脚被配置为<strong>浮空输入模式</strong>（除了 JTAG 引脚）；</li>
<li>当 LSE 晶振关闭时，LSE 晶振引脚 <code>OSC32_IN/PC14</code> 和
<code>OSC32_OUT/PC15</code> 可以被配置为 GPIO 引脚，因为 LSE
功能的优先级要高于 GPIO 功能；</li>
<li>当 HSE 晶振关闭时，HSE 晶振引脚 <code>OSC_IN/PH0</code> 和
<code>OSC_OUT/PH1</code> 可以被配置为 GPIO 引脚，因为 HSE
功能的优先级同样高于 GPIO 功能；</li>
</ol>
<h3 id="hal-库-api-1">HAL 库 API</h3>
<p><code>stm32f4xx_hal_gpio.h</code> 头文件当中定义了
<code>GPIO_InitTypeDef</code>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">GPIO_InitTypeDef 结构体成员</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>uint32_t GPIO_InitTypeDef::Pin</code></td>
<td style="text-align: left;">需要配置的振荡器，该参数可以是
<code>GPIO_pins_define</code> 的任意值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t GPIO_InitTypeDef::Mode</code></td>
<td style="text-align: left;">指定所选引脚的工作模式，该参数可以是
<code>GPIO_mode_define</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t GPIO_InitTypeDef::Pull</code></td>
<td style="text-align: left;">指定所选引脚的上拉或下拉电阻激活状态，取值可以为
<code>GPIO_pull_define</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t GPIO_InitTypeDef::Speed</code></td>
<td style="text-align: left;">指定所选引脚的工作速度，该参数可以是
<code>GPIO_speed_define</code> 里的值；</td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t GPIO_InitTypeDef::Alternate</code></td>
<td style="text-align: left;">连接外设的指定引脚，该参数为
<code>GPIO_Alternate_function_selection</code> 里的值；</td>
</tr>
</tbody>
</table>
<h4 id="寄存器结构体-1">寄存器结构体</h4>
<h4 id="初始化与反向初始化-1">初始化与反向初始化</h4>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_Init()</code></td>
<td style="text-align: left;">基于 <code>GPIO_Init</code>
当中指定的参数初始化 <code>GPIOx</code> 外设；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_DeInit()</code></td>
<td style="text-align: left;">反向初始化 <code>GPIOx</code>
外设寄存器为默认重置值；</td>
</tr>
</tbody>
</table>
<h4 id="io-操作函数">IO 操作函数</h4>
<table>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_ReadPin()</code></td>
<td style="text-align: left;">读取指定输入端口的引脚状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_WritePin()</code></td>
<td style="text-align: left;">设置或者清除指定的数据端口位；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_TogglePin()</code></td>
<td style="text-align: left;">切换指定的 GPIO 引脚状态；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_LockPin()</code></td>
<td style="text-align: left;">锁定 GPIO 引脚配置寄存器；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_EXTI_IRQHandler()</code></td>
<td style="text-align: left;">该函数用于处理 EXTI 中断请求；</td>
</tr>
<tr>
<td style="text-align: left;"><code>HAL_GPIO_EXTI_Callback()</code></td>
<td style="text-align: left;">EXTI 线检测回调函数；</td>
</tr>
</tbody>
</table>
<h2 id="nvic-与-exti-中断">NVIC 与 EXTI 中断</h2>
<h2 id="tim-定时器">TIM 定时器</h2>
<h2 id="systick-系统滴答定时器">SysTick 系统滴答定时器</h2>
<h2 id="dma-直接存储控制">DMA 直接存储控制</h2>
<h2 id="rtc-实时时钟">RTC 实时时钟</h2>
<h2 id="usart-通用同异步收发">USART 通用同/异步收发</h2>
<h2 id="i²c-内置集成电路总线">I²C 内置集成电路总线</h2>
<h2 id="spi-串行外设接口">SPI 串行外设接口</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div><div class="article-licensing box"><div class="licensing-title"><p>基于 HAL 与 LL 的 UINIO-MCU-STM32F401 开发实践</p><p><a href="http://www.uinio.com/Embedded/STM32F401/">http://www.uinio.com/Embedded/STM32F401/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-07-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Electronics/Altium/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">运用 Altium Designer 进行 PCB 电路的绘制与仿真</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Embedded/Android/"><span class="level-item">Android 物联网应用开发实例</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#arm-cortex-m4-概要"><span class="level-left"><span class="level-item">1</span><span class="level-item">ARM Cortex M4 概要</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外设资源-peripheral"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">外设资源 Peripheral</span></span></a></li><li><a class="level is-mobile" href="#引脚定义-pin"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">引脚定义 Pin</span></span></a></li><li><a class="level is-mobile" href="#启动模式-boot"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">启动模式 Boot</span></span></a></li><li><a class="level is-mobile" href="#系统复位-reset"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">系统复位 Reset</span></span></a></li><li><a class="level is-mobile" href="#总线架构-bus"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">总线架构 Bus</span></span></a></li><li><a class="level is-mobile" href="#内存映射-memory-mapping"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">内存映射 Memory Mapping</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stm32f401-核心电路分析"><span class="level-left"><span class="level-item">2</span><span class="level-item">STM32F401 核心电路分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mcu-微控制器"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">MCU 微控制器</span></span></a></li><li><a class="level is-mobile" href="#复位电路-reset"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">复位电路 Reset</span></span></a></li><li><a class="level is-mobile" href="#启动配置按钮-boot"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">启动配置按钮 Boot</span></span></a></li><li><a class="level is-mobile" href="#usb-type-c-接口"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">USB Type-C 接口</span></span></a></li><li><a class="level is-mobile" href="#线性稳压器-ldo"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">线性稳压器 LDO</span></span></a></li><li><a class="level is-mobile" href="#用户按键-button"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">用户按键 Button</span></span></a></li><li><a class="level is-mobile" href="#状态指示-led"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">状态指示 LED</span></span></a></li><li><a class="level is-mobile" href="#串行线调试接口-swd"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">串行线调试接口 SWD</span></span></a></li><li><a class="level is-mobile" href="#板载-nor-flash"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">板载 NOR Flash</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hal-硬件抽象层"><span class="level-left"><span class="level-item">3</span><span class="level-item">HAL 硬件抽象层</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#包含的数据结构"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">包含的数据结构</span></span></a></li><li><a class="level is-mobile" href="#hal-库-api-的分类"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">HAL 库 API 的分类</span></span></a></li><li><a class="level is-mobile" href="#hal-驱动规范"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">HAL 驱动规范</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#hal-api-命名规则"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">HAL API 命名规则</span></span></a></li><li><a class="level is-mobile" href="#hal-通用命名规则"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">HAL 通用命名规则</span></span></a></li><li><a class="level is-mobile" href="#中断处理程序与回调函数"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">中断处理程序与回调函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hal-通用-api"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">HAL 通用 API</span></span></a></li><li><a class="level is-mobile" href="#hal-扩展-api"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">HAL 扩展 API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#添加指定型号的功能"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">添加指定型号的功能</span></span></a></li><li><a class="level is-mobile" href="#添加产品系列的功能"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">添加产品系列的功能</span></span></a></li><li><a class="level is-mobile" href="#添加新的外设"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">添加新的外设</span></span></a></li><li><a class="level is-mobile" href="#更新现存的通用-api"><span class="level-left"><span class="level-item">3.5.4</span><span class="level-item">更新现存的通用 API</span></span></a></li><li><a class="level is-mobile" href="#更新现存的数据结构"><span class="level-left"><span class="level-item">3.5.5</span><span class="level-item">更新现存的数据结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#源文件包含关系"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">源文件包含关系</span></span></a></li><li><a class="level is-mobile" href="#公用资源定义"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">公用资源定义</span></span></a></li><li><a class="level is-mobile" href="#配置-hal-固件库"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">配置 HAL 固件库</span></span></a></li><li><a class="level is-mobile" href="#如何使用-hal-驱动"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">如何使用 HAL 驱动</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#hal-全局初始化"><span class="level-left"><span class="level-item">3.9.1</span><span class="level-item">HAL 全局初始化</span></span></a></li><li><a class="level is-mobile" href="#时钟配置"><span class="level-left"><span class="level-item">3.9.2</span><span class="level-item">时钟配置</span></span></a></li><li><a class="level is-mobile" href="#初始化-msp"><span class="level-left"><span class="level-item">3.9.3</span><span class="level-item">初始化 MSP</span></span></a></li><li><a class="level is-mobile" href="#io-操作"><span class="level-left"><span class="level-item">3.9.4</span><span class="level-item">IO 操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#轮询模式"><span class="level-left"><span class="level-item">3.9.4.1</span><span class="level-item">轮询模式</span></span></a></li><li><a class="level is-mobile" href="#中断模式"><span class="level-left"><span class="level-item">3.9.4.2</span><span class="level-item">中断模式</span></span></a></li><li><a class="level is-mobile" href="#dma-模式"><span class="level-left"><span class="level-item">3.9.4.3</span><span class="level-item">DMA 模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#超时与错误管理"><span class="level-left"><span class="level-item">3.9.5</span><span class="level-item">超时与错误管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#超时管理"><span class="level-left"><span class="level-item">3.9.5.1</span><span class="level-item">超时管理</span></span></a></li><li><a class="level is-mobile" href="#错误管理"><span class="level-left"><span class="level-item">3.9.5.2</span><span class="level-item">错误管理</span></span></a></li><li><a class="level is-mobile" href="#运行时检查"><span class="level-left"><span class="level-item">3.9.5.3</span><span class="level-item">运行时检查</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#ll-底层库"><span class="level-left"><span class="level-item">4</span><span class="level-item">LL 底层库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ll-底层库文件"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">LL 底层库文件</span></span></a></li><li><a class="level is-mobile" href="#外设初始化函数"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">外设初始化函数</span></span></a></li><li><a class="level is-mobile" href="#运行时检查-1"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">运行时检查</span></span></a></li><li><a class="level is-mobile" href="#外设的寄存器级配置"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">外设的寄存器级配置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hal-ll-组合运用"><span class="level-left"><span class="level-item">5</span><span class="level-item">HAL &amp; LL 组合运用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单独使用-ll-固件库"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">单独使用 LL 固件库</span></span></a></li><li><a class="level is-mobile" href="#组合运用-hal-和-ll-固件库"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">组合运用 HAL 和 LL 固件库</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stm32-cube-ide-开发环境"><span class="level-left"><span class="level-item">6</span><span class="level-item">STM32 Cube IDE 开发环境</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#新建工程"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">新建工程</span></span></a></li><li><a class="level is-mobile" href="#工程源码结构"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">工程源码结构</span></span></a></li><li><a class="level is-mobile" href="#st-link-下载调试"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">ST-Link 下载调试</span></span></a></li><li><a class="level is-mobile" href="#cmsis-dap-下载调试"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">CMSIS-DAP 下载调试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stm32-cube-programmer-编程器"><span class="level-left"><span class="level-item">7</span><span class="level-item">STM32 Cube Programmer 编程器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#进入-bootloader-模式"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">进入 Bootloader 模式</span></span></a></li><li><a class="level is-mobile" href="#通过-usb-下载"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">通过 USB 下载</span></span></a></li><li><a class="level is-mobile" href="#通过-uart-下载"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">通过 UART 下载</span></span></a></li></ul></li><li><a class="level is-mobile" href="#rcc-复位时钟控制"><span class="level-left"><span class="level-item">8</span><span class="level-item">RCC 复位时钟控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外设分析"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">外设分析</span></span></a></li><li><a class="level is-mobile" href="#api-描述"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">API 描述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#指定特性"><span class="level-left"><span class="level-item">8.2.1</span><span class="level-item">指定特性</span></span></a></li><li><a class="level is-mobile" href="#使用限制"><span class="level-left"><span class="level-item">8.2.2</span><span class="level-item">使用限制</span></span></a></li><li><a class="level is-mobile" href="#内外部晶振与锁相环配置"><span class="level-left"><span class="level-item">8.2.3</span><span class="level-item">内外部晶振与锁相环配置</span></span></a></li><li><a class="level is-mobile" href="#系统总线时钟配置"><span class="level-left"><span class="level-item">8.2.4</span><span class="level-item">系统总线时钟配置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hal-库-api"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">HAL 库 API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#寄存器结构体"><span class="level-left"><span class="level-item">8.3.1</span><span class="level-item">寄存器结构体</span></span></a></li><li><a class="level is-mobile" href="#初始化与反向初始化"><span class="level-left"><span class="level-item">8.3.2</span><span class="level-item">初始化与反向初始化</span></span></a></li><li><a class="level is-mobile" href="#外设控制函数"><span class="level-left"><span class="level-item">8.3.3</span><span class="level-item">外设控制函数</span></span></a></li><li><a class="level is-mobile" href="#示例代码"><span class="level-left"><span class="level-item">8.3.4</span><span class="level-item">示例代码</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#gpio-通用输入输出"><span class="level-left"><span class="level-item">9</span><span class="level-item">GPIO 通用输入输出</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外设分析-1"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">外设分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入配置"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">输入配置</span></span></a></li><li><a class="level is-mobile" href="#输出配置"><span class="level-left"><span class="level-item">9.1.2</span><span class="level-item">输出配置</span></span></a></li><li><a class="level is-mobile" href="#复用功能配置"><span class="level-left"><span class="level-item">9.1.3</span><span class="level-item">复用功能配置</span></span></a></li><li><a class="level is-mobile" href="#模拟配置"><span class="level-left"><span class="level-item">9.1.4</span><span class="level-item">模拟配置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#api-描述-1"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">API 描述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外设特性"><span class="level-left"><span class="level-item">9.2.1</span><span class="level-item">外设特性</span></span></a></li><li><a class="level is-mobile" href="#驱动使用"><span class="level-left"><span class="level-item">9.2.2</span><span class="level-item">驱动使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#hal-库-api-1"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">HAL 库 API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#寄存器结构体-1"><span class="level-left"><span class="level-item">9.3.1</span><span class="level-item">寄存器结构体</span></span></a></li><li><a class="level is-mobile" href="#初始化与反向初始化-1"><span class="level-left"><span class="level-item">9.3.2</span><span class="level-item">初始化与反向初始化</span></span></a></li><li><a class="level is-mobile" href="#io-操作函数"><span class="level-left"><span class="level-item">9.3.3</span><span class="level-item">IO 操作函数</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#nvic-与-exti-中断"><span class="level-left"><span class="level-item">10</span><span class="level-item">NVIC 与 EXTI 中断</span></span></a></li><li><a class="level is-mobile" href="#tim-定时器"><span class="level-left"><span class="level-item">11</span><span class="level-item">TIM 定时器</span></span></a></li><li><a class="level is-mobile" href="#systick-系统滴答定时器"><span class="level-left"><span class="level-item">12</span><span class="level-item">SysTick 系统滴答定时器</span></span></a></li><li><a class="level is-mobile" href="#dma-直接存储控制"><span class="level-left"><span class="level-item">13</span><span class="level-item">DMA 直接存储控制</span></span></a></li><li><a class="level is-mobile" href="#rtc-实时时钟"><span class="level-left"><span class="level-item">14</span><span class="level-item">RTC 实时时钟</span></span></a></li><li><a class="level is-mobile" href="#usart-通用同异步收发"><span class="level-left"><span class="level-item">15</span><span class="level-item">USART 通用同/异步收发</span></span></a></li><li><a class="level is-mobile" href="#i²c-内置集成电路总线"><span class="level-left"><span class="level-item">16</span><span class="level-item">I²C 内置集成电路总线</span></span></a></li><li><a class="level is-mobile" href="#spi-串行外设接口"><span class="level-left"><span class="level-item">17</span><span class="level-item">SPI 串行外设接口</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Cadence-Skill/"><img src="/Electronics/Cadence-Skill/logo.png" alt="Cadence SPB OrCAD/Allegro 17.4 进阶技巧总结"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-06-09T16:00:00.000Z">2025-06-10</time></p><p class="title"><a href="/Electronics/Cadence-Skill/">Cadence SPB OrCAD/Allegro 17.4 进阶技巧总结</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/CAN/"><img src="/Electronics/CAN/logo.png" alt="控制器区域网络 CAN 总线协议图解"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-30T16:00:00.000Z">2025-05-01</time></p><p class="title"><a href="/Electronics/CAN/">控制器区域网络 CAN 总线协议图解</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Embedded/FOC/"><img src="/Embedded/FOC/logo.png" alt="剖析无刷电机的 FOC 磁场定向控制算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-14T16:00:00.000Z">2025-04-15</time></p><p class="title"><a href="/Embedded/FOC/">剖析无刷电机的 FOC 磁场定向控制算法</a></p><p class="categories"><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Power-Switching/"><img src="/Electronics/Power-Switching/logo.png" alt="开关电源 SMPS 基本原理 &amp; 拓扑结构剖析"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-05T16:00:00.000Z">2025-03-06</time></p><p class="title"><a href="/Electronics/Power-Switching/">开关电源 SMPS 基本原理 &amp; 拓扑结构剖析</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Embedded/PID/"><img src="/Embedded/PID/logo.png" alt="闭环控制算法 PID 的原理剖析与实现"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-02-04T16:00:00.000Z">2025-02-05</time></p><p class="title"><a href="/Embedded/PID/">闭环控制算法 PID 的原理剖析与实现</a></p><p class="categories"><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BA%BF/"><span class="tag">总线</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>