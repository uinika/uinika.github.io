<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>意法半导体 UINIO-MCU-STM32F103 标准库典型实例 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO.com 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO.com 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="博主之前文章介绍的STC51系列单片机是一款结构简单、易于学习的嵌入式微控制器，但是由于标准 8051 架构诞生于 70 年代，其硬件架构、资源数量以及编程方式都已显老旧，成本和性能方面也皆落后于其它架构产品，市场占有率逐步遭到侵蚀，目前仅常见于一些教学与发烧友使用的范畴。伴随近几年物联网行业的快速兴起，STM32等基于 ARM Cortex 内核的微控制器，凭借丰富的片上资源与简单易用的"><meta property="og:type" content="blog"><meta property="og:title" content="意法半导体 UINIO-MCU-STM32F103 标准库典型实例"><meta property="og:url" content="http://www.uinio.com/Embedded/STM32F103/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="博主之前文章介绍的STC51系列单片机是一款结构简单、易于学习的嵌入式微控制器，但是由于标准 8051 架构诞生于 70 年代，其硬件架构、资源数量以及编程方式都已显老旧，成本和性能方面也皆落后于其它架构产品，市场占有率逐步遭到侵蚀，目前仅常见于一些教学与发烧友使用的范畴。伴随近几年物联网行业的快速兴起，STM32等基于 ARM Cortex 内核的微控制器，凭借丰富的片上资源与简单易用的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2015-03-19T16:00:00.000Z"><meta property="article:modified_time" content="2019-07-10T16:00:00.000Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Embedded/STM32F103/"},"headline":"意法半导体 UINIO-MCU-STM32F103 标准库典型实例","image":["http://www.uinio.com/Embedded/STM32F103/logo.png"],"datePublished":"2015-03-19T16:00:00.000Z","dateModified":"2019-07-10T16:00:00.000Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO.com"}}},"description":"博主之前文章介绍的STC51系列单片机是一款结构简单、易于学习的嵌入式微控制器，但是由于标准\r 8051 架构诞生于 70\r 年代，其硬件架构、资源数量以及编程方式都已显老旧，成本和性能方面也皆落后于其它架构产品，市场占有率逐步遭到侵蚀，目前仅常见于一些教学与发烧友使用的范畴。伴随近几年物联网行业的快速兴起，STM32等基于\r ARM Cortex\r 内核的微控制器，凭借丰富的片上资源与简单易用的"}</script><link rel="canonical" href="http://www.uinio.com/Embedded/STM32F103/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO.com</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/projects/index.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-03-19T16:00:00.000Z" title="2015/3/20 00:00:00">2015-03-20</time>发表</span><span class="level-item"><time dateTime="2019-07-10T16:00:00.000Z" title="2019/7/11 00:00:00">2019-07-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Embedded/">Embedded</a></span><span class="level-item">7 小时读完 (大约62885个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">意法半导体 UINIO-MCU-STM32F103 标准库典型实例</h1><div class="content"><p>博主之前文章介绍的<strong>STC51</strong>系列单片机是一款结构简单、易于学习的嵌入式微控制器，但是由于标准
8051 架构诞生于 70
年代，其硬件架构、资源数量以及编程方式都已显老旧，成本和性能方面也皆落后于其它架构产品，市场占有率逐步遭到侵蚀，目前仅常见于一些教学与发烧友使用的范畴。伴随近几年物联网行业的快速兴起，<strong>STM32</strong>等基于
ARM Cortex
内核的微控制器，凭借丰富的片上资源与简单易用的标准外设库，逐步成为消费与工业领域中的主流产品。</p>
<p><img src="/Embedded/STM32F103/logo.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.st.com">意法半导体</a>成立于 1987 年，由意大利
<strong>S</strong>GS 和法国 <strong>T</strong>homson
两家半导体企业合并而成，本文所介绍的<a target="_blank" rel="noopener" href="https://www.st.com/en/microcontrollers-microprocessors/stm32f103c8.html#"><strong>STM32F103C8T6</strong></a>属于该公司应用极为广泛的型号，其提供的<code>STM32F10x Standard Peripheral Library</code>标准外设库对
STM32 片上资源进行了完善的封装，相对于 ST
公司目前力推的<strong>HAL/LL</strong>库，标准外设库更加接近于传统的寄存器操作，因而也较为容易向<a target="_blank" rel="noopener" href="https://www.gigadevice.com">兆易创新</a>的<a target="_blank" rel="noopener" href="https://www.gigadevice.com/products/microcontrollers/gd32/"><strong>GD32</strong></a>等国产微控制器移植。</p>
<span id="more"></span>
<h2 id="片上资源概览">片上资源概览</h2>
<p><strong>STM32F103C8T6</strong>基于 ARM 32 位 Cortex™-M3
内核，使用<code>2.0V ~ 3.6V</code>电压供电，工作频率最高可以达到<code>72MHz</code>，内部采用<code>64K</code>或<code>128K</code>字节
Flash 程序存储器，以及高达<code>20K</code>字节的 SRAM 数据存储器；内置
CRC 循环冗余校验以及 96 位编码（即 24
位的十六进制数）的芯片唯一序列号（例如：<code>52FF69067871515237582567</code>）。</p>
<p>其主系统主要由 4 个<strong>控制单元</strong>（DCode
总线<strong>D-bus</strong>、系统总线<strong>S-bus</strong>、通用<strong>DMA1</strong>、通用<strong>DMA2</strong>）以及
4
个<strong>受控单元</strong>（内部<strong>SRAM</strong>、内部<strong>Flash</strong>、<strong>FSMC</strong>、AHB
到 APB 的桥<strong>AHB2APBx</strong>）组成，它们通过一个多级的 AHB
总线相互进行连接，如下图所示：</p>
<p><img src="/Embedded/STM32F103/overview/architecture.png"></p>
<ul>
<li><strong>ICode</strong> 总线：连接 M3 内核指令总线与 Flash
的指令接口，用于进行指令预取。</li>
<li><strong>DCode</strong> 总线：连接 M3 内核 DCode 总线与 Flash
的数据接口，用于完成常量加载和调试访问。</li>
<li><strong>System</strong> 总线：连接 M3 内核系统总线与总线矩阵 Bus
Matrix，用于协调内核与 DMA 之间的通信。</li>
<li><strong>DMA</strong> 总线：连接 DMA 的 AHB 主接口与总线矩阵 Bus
Matrix，用于协调 DCode 和 DMA 对 SRAM、Flash 以及其它外设的访问。</li>
<li><strong>Bus Matrix</strong> 总线矩阵：利用轮换算法管理内核系统总线与
DMA 主总线之间访问的仲裁，由 4 个控制单元（DCode、系统总线、DMA1 和 DMA2
总线）以及 4 个受控单元（FLITF、SRAM、FSMC、AHB2APB 桥）组成。</li>
<li><strong>AHB/APB bridges</strong>：两个 AHB/APB 桥提供了 AHB 与 2 条
APB
总线之间的同步连接，<strong>APB1</strong>操作速度低于<code>36MHz</code>，<strong>APB2</strong>操作速度最高可达<code>72MHz</code>。每次复位以后，除
SRAM 和 FLITF
以外的外设都会被关闭。使用外设之前，必须通过设置寄存器<strong>RCC_AHBENR</strong>打开该外设的时钟。</li>
</ul>
<blockquote>
<p><strong>AHB（高级高性能总线，Advanced High performance
Bus）</strong>是一种系统总线，主要用于连接 CPU、DMA、DSP
等高性能模块，由主模块、从模块、基础结构三部分组成，数据传输总是由主模块发起从模块回应。<strong>APB（高级外围总线，Advanced
Peripheral Bus）</strong>是一种外围总线，主要用于 UART
等低带宽外设之间的连接，其唯一的主模块是 APB 桥；两者都遵循 ARM
公司推出的<strong>AMBA</strong>芯片总线规范。</p>
</blockquote>
<h3 id="时钟系统">时钟系统</h3>
<p>由于 STM32 外设资源众多，工作的时钟频率各不相同，所以采用了多达 5
个时钟源：片上经过出厂调校的<code>8MHz</code> RC
振荡器系统时钟<strong>HSI</strong>，以及带校准的<code>40kHz</code> RC
振荡器作为实时时钟<strong>LSI</strong>，也可以采用外置<code>4 ~ 16MHz</code>晶体振荡器作为系统时钟<strong>HSE</strong>，以及带校准功能的<code>32kHz</code>
RTC 振荡器作为实时时钟<strong>LSE</strong>；最后还内置了用于对 CPU
时钟进行倍频的的<strong>PLL</strong>锁相环。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 29%">
<col style="width: 13%">
<col style="width: 15%">
<col style="width: 16%">
<col style="width: 5%">
<col style="width: 8%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">缩写</th>
<th style="text-align: right;">名称</th>
<th style="text-align: right;">频率</th>
<th style="text-align: right;">外部连接</th>
<th style="text-align: right;">功能</th>
<th style="text-align: right;">用途</th>
<th style="text-align: right;">特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>HSE</strong>，High-Speed External
Clock Signal</td>
<td style="text-align: right;">外部高速晶体振荡器</td>
<td style="text-align: right;"><code>4 ~ 16MHz</code></td>
<td style="text-align: right;"><code>4 ~ 16MHz</code>晶振</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">系统时钟/RTC</td>
<td style="text-align: right;">成本高，温漂小</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>LSE</strong>，Low-Speed External
Clock Signal</td>
<td style="text-align: right;">外部低速晶体振荡器</td>
<td style="text-align: right;"><code>32.768kHz</code></td>
<td style="text-align: right;"><code>32.768kHz</code>晶振</td>
<td style="text-align: right;">带校准</td>
<td style="text-align: right;">RTC</td>
<td style="text-align: right;">成本高，温漂小</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>HSI</strong>，High-Speed Internal
Clock Signal</td>
<td style="text-align: right;">内部高速 RC 振荡器</td>
<td style="text-align: right;"><code>8MHz</code></td>
<td style="text-align: right;">无</td>
<td style="text-align: right;">出厂调校</td>
<td style="text-align: right;">系统时钟</td>
<td style="text-align: right;">成本低，温漂大</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>LSI</strong>，Low-Speed Internal
Clock Signal</td>
<td style="text-align: right;">内部低速 RC 振荡器</td>
<td style="text-align: right;"><code>40kHz</code></td>
<td style="text-align: right;">无</td>
<td style="text-align: right;">带校准</td>
<td style="text-align: right;">RTC</td>
<td style="text-align: right;">成本低，温漂大</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>PLL</strong>，Phase Locked
Loop</td>
<td style="text-align: right;">锁相环倍频输出</td>
<td style="text-align: right;"><code>2~16</code>倍，小于<code>72MHz</code></td>
<td style="text-align: right;"><code>HSI÷2</code>、<code>HSE</code>、<code>HSE÷2</code></td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">RTC</td>
<td style="text-align: right;">成本低，温漂大</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>HSI</strong>、<strong>HSE</strong>、<strong>PLL</strong>属于高速时钟源，<strong>LSI</strong>、<strong>LSE</strong>属于低速时钟源，任何时钟源都可以根据需要，独立进行启动或者关闭，从而优化芯片功耗。</p>
</blockquote>
<p>下面是外部高速时钟源<strong>HSE</strong>的交流时序图，注意图中<code>Tʜsᴇ</code>标识的部分为一个系统时钟周期。</p>
<p><img src="/Embedded/STM32F103/overview/HSE-sequence.png"></p>
<p>下图当中，当<strong>HSI</strong>作为<strong>PLL</strong>时钟的输入时，最高系统时钟频率只能达到<code>64MHz</code>。当使用
USB 功能时，必须同时使用<strong>HSE</strong>和<strong>PLL</strong>，并且
CPU
的频率必须为<code>48MHz</code>或<code>72MHz</code>。当需要的<strong>ADC</strong>采样时间为<code>1μs</code>的时候，**APB2**必须设置为<code>14MHz</code>、<code>28MHz</code>或<code>56MHz</code>。</p>
<p><img src="/Embedded/STM32F103/overview/clock-tree.png"></p>
<h3 id="gpio">GPIO</h3>
<p><strong>STM32F103C8T6</strong>采用 LQFP48 方式封装，一共拥有 37 个
I/O 引脚，被分为<strong>PA</strong>(15 个)、<strong>PB</strong>(15
个)、<strong>PC</strong>(3 个)、<strong>PD</strong>(2
个)、<strong>PE</strong>(0 个)五个组，所有 I/O 接口可以映像到 16
个外部中断，并且大部份端口都可以可以兼容<code>5V</code>信号。每个 I/O
端口可以接受或输出<code>8mA</code>电流，灌电流则可达到<code>20mA</code>，下面是详细的引脚定义图：</p>
<p><img src="/Embedded/STM32F103/overview/LQFP48.png"></p>
<p>每个 GPIO 端口都拥有两个 32
位配置寄存器<code>GPIOx_CRL</code>和<code>GPIOx_CRH</code>，两个 32
位数据寄存器<code>GPIOx_IDR</code>和<code>GPIOx_ODR</code>，一个 32
位置位/复位寄存器<code>GPIOx_BSRR</code>和一个 16
位复位寄存器<code>GPIOx_BRR</code>和一个 32
位锁定寄存器<code>GPIOx_LCKR</code>。</p>
<p>GPIO
端口的每个位都可以通过软件将其配置为<strong>输出</strong>（推挽输出<code>GPIO_Mode_Out_PP</code>、开漏输出<code>GPIO_Mode_Out_OD</code>）、<strong>输入</strong>（浮空输入<code>GPIO_Mode_IN_FLOATING</code>、上拉输入<code>GPIO_Mode_IPU</code>、下拉输入<code>GPIO_Mode_IPD</code>、模拟输入<code>GPIO_Mode_AIN</code>）、<strong>复用</strong>（复用推挽输出<code>GPIO_Mode_AF_PP</code>、复用开漏输出<code>GPIO_Mode_AF_OD</code>）功能。</p>
<p><img src="/Embedded/STM32F103/overview/GPIO-structure.png"></p>
<p>除具有模拟输入功能的引脚之外，所有 GPIO
都拥有大电流通过能力。必要时可以对 GPIO 进行锁定，以避免意外擦写 GPIO
相关的寄存器。位于<strong>APB2</strong>上的 GPIO
引脚，其脉冲转换速度可达<code>18MHz</code>。</p>
<h3 id="定时器">定时器</h3>
<p><strong>STM32F103C8T6</strong>拥有 7 个定时器，其中 1
个用于电机控制的 16 位 PWM 高级控制定时器、3 个 16 位通用定时器、2
个看门狗定时器（包含独立型的和窗口型）、1 个 24
位自减型系统嘀嗒定时器。</p>
<p><img src="/Embedded/STM32F103/overview/interrupt.png"></p>
<ol type="1">
<li><strong>高级控制定时器
TIM1</strong>：<strong>TIM1</strong>可以被视为分配到 6 个通道的三相 PWM
发生器，具有带死区插入的互补 PWM
输出，还可以用作完整的通用定时器；其四个独立通道可分别用于：<strong>输入捕获</strong>、<strong>输出比较</strong>、产生边缘或中心对齐模式的<strong>PWM</strong>、<strong>单脉冲输出</strong>。当配置为
16
位普通定时器时，与<strong>TIM2</strong>、<strong>TIM3</strong>、<strong>TIM4</strong>具有相同功能；配置为
16 位 PWM 发生器时，具有<code>0 ~ 100%</code>的全调制能力。</li>
<li><strong>通用定时器 TIM2、TIM3、TIM4</strong>：STM32F103C8T6 内置有 3
个可同步运行的标准定时器，每个定时器都拥有一个 16
位自动加载递加/递减计数器、一个 16 位预分频器、4
个独立通道，每个通道都可用于<strong>输入捕获</strong>、<strong>输出比较</strong>、<strong>PWM</strong>、<strong>单脉冲输出</strong>，它们还可以通过定时器链接功能与高级控制定时器
TIM1 协同工作，从而提供同步或事件链接功能。</li>
<li><strong>独立看门狗定时器
IWDG</strong>：用于发生问题时复位整个系统，或作为一个自由定时器为应用程序提供超时管理；内部基于
12 位递减计数器和 8 位预分频器，并由内置<code>40kHz</code>的 RC
振荡器提供时钟，由于该 RC
振荡器独立于主时钟，因此可以运行在停机和待机模式。可通过程序配置为软件或者硬件启动的看门狗。</li>
<li><strong>窗口看门狗定时器
WWDG</strong>：用于在发生问题时复位整个系统，它由主时钟驱动，具有早期预警中断功能；其内置有
7 位的递减计数器，并且可以设置为自由运行。</li>
<li><strong>系统嘀嗒定时器
SysTick</strong>：仅用于实时操作系统，也可作为一个标准的递减计数器，具有
24 位的递减计数器、自动重加载功能、当计数器为 0
时能产生一个可屏蔽系统中断、可编程时钟源等特性。</li>
</ol>
<h3 id="通信接口">通信接口</h3>
<p><strong>STM32F103C8T6</strong>拥有 <strong>2</strong> 个 I²C
接口、<strong>3</strong> 个 USART 接口、<strong>2</strong> 个 SPI
接口、<strong>1</strong> 个 CAN 接口、<strong>1</strong> 个 USB 2.0
全速接口。</p>
<p><img src="/Embedded/STM32F103/overview/communication.png"></p>
<ul>
<li><strong>I²C</strong>：内置 I²C
总线接口能够工作于多主模式或从模式，支持标准和快速模式；I²C 接口支持 7
位或 10 位寻址，7 位从模式时支持双从地址寻址，并且内置了硬件 CRC
发生器/校验器，支持使用 DMA 操作并支持 SMBus 总线 2.0 版/PMBus 总线。I²C
总线的连接线一般不超过 2
米，并且理论上数据线需要增加<code>2KΩ</code>上拉电阻，所有与<strong>STM32F103C8T6</strong>连接的设备都需要共同接地。</li>
<li><strong>USART</strong>：片上的 USART 接口具有硬件 CTS 和 RTS
信号管理、支持 IrDA SIR ENDEC 传输编解码、兼容 ISO7816 的智能卡并提供
LIN 主/从功能；其中，USART1
接口通信速率可达<code>4.5 Mbit/S</code>，而其它 USART 接口可达
<code>2.25 Mbit/S</code>；所有 USART 接口都可以使用 DMA 操作。</li>
<li><strong>SPI</strong>：<strong>STM32F103C8T6</strong>拥有 2 个 SPI
接口，主、从模式下全双工和半双工通信速率可达<code>18 Mbit/S</code>。3
位预分频器可以产生 8 种主模式频率，并且每帧可配置为 8 位或 16 位，所有
SPI 接口依然可以使用 DMA 操作。</li>
<li><strong>CAN</strong>：同时兼容 CAN 2.0A 和 2.0B
规范，位速率高达<code>1Mbit/S</code>，可以接收和发送 11
位标识符的标准帧，也可以收发 29 位标识符的扩展帧。</li>
<li><strong>USB 2.0</strong>：内嵌 1 个全速 USB
控制器（12Mbit/S），具有待机/唤醒功能，其专用<code>48MHz</code>时钟由内部主锁相环<strong>PLL</strong>直接产生（时钟源必须为<strong>HSE</strong>晶体振荡器）。</li>
</ul>
<blockquote>
<p>51 架构单片机内置的 UART 是通用异步收发器，没有同步时钟线；而 STM32
中的 USART
是通用同步/异步收发器，带有同步时钟线<strong>USART_CK</strong>；由于异步模式更加常用，而同步模式使用频率较少，所以二者区别不大。</p>
</blockquote>
<h3 id="dma">DMA</h3>
<p><strong>DMA</strong>（直接内存存取，Direct Memory
Access）用来提供在外设与存储器或者存储器与存储器之间的高速数据传输，传输过程无需经过
CPU 进行干预，数据直接通过 DMA 快速进行操作，从而节省大量 CPU 资源。</p>
<p><img src="/Embedded/STM32F103/overview/DMA.png"></p>
<blockquote>
<p>STM32F103 拥有 2 个 DMA 控制器共 12
个通道，其中<strong>DMA1</strong>拥有 7
个通道，<strong>DMA2</strong>拥有 5
个通道，每个通道都用来管理外部设备对片内存储器的访问请求，此外还有一个仲裁器来协调各个
DMA
请求的优先级。除了管理外部设备（Timer、ADC、SPI、I²C、USART）到储存器之间数据的双向传输，DMA
还能够管理存储器之间的数据传输。</p>
</blockquote>
<h2 id="stm32f103-最小系统">STM32F103 最小系统</h2>
<p><strong>STM32F103C8T6</strong>的最小系统电路由<strong>电源电路</strong>、<strong>复位电路</strong>、<strong>时钟电路</strong>、<strong>程序下载电路</strong>4
部份组成，具体请参考下面的电路图：</p>
<p><img src="/Embedded/STM32F103/minimum/mcu.png"></p>
<p><strong>电源电路</strong>：<strong>STM32F103C8T6</strong>拥有三路逻辑电源<strong>VDD_1</strong>、<strong>VDD_2</strong>、<strong>VDD_3</strong>和一路模拟电源<strong>VDDA</strong>（由于当前实验电路对于模拟电压的读取精度无特殊要求，所以模拟电源与逻辑电源可以共用）。此外，<strong>VBAT</strong>引脚上还连接了一枚<code>3V</code>纽扣电池<strong>BT1</strong>，用于为内部的
RTC
时钟供电。而后续串接的去耦电容<strong>C1</strong>、<strong>C3</strong>、<strong>C3</strong>、<strong>C4</strong>则主要用于稳定电源以及滤除杂波。<strong>STM32F103C8T6</strong>使用的<code>3V</code>电压是通过<strong>AMS1117-3V</strong>稳压芯片获得，该芯片将计算机
Micro USB
接口的<code>5V</code>供电电压转换为<code>3.3V</code>电压，然后将这个<code>3.3V</code>电压连接至继电器<strong>J1</strong>的开关控制位。</p>
<p><img src="/Embedded/STM32F103/minimum/power.png"></p>
<blockquote>
<p><strong>注意</strong>：上面电路原理图当中的<strong>VCC</strong>是指<code>C = Circuit</code>，表示接入电路的电压；<strong>VDD</strong>是指<code>D = Device</code>，表示元件内部的工作电压；<strong>VSS</strong>是指<code>S = Series</code>，表示公共连接，通常指公共接地端。</p>
</blockquote>
<p><strong>复位电路</strong>：<strong>STM32F103C8T6</strong>内部已经拥有一个上电复位电路，但是生产环境下为了防止复位引脚悬空，通常还是会连接一组由电容<strong>C9</strong>电阻<strong>R7</strong>共同组成的
RC
外部复位电路，而手动外部复位则是通过后续连接的微动开关<strong>K1</strong>（即实验电路里的复位按键）来完成。</p>
<p><img src="/Embedded/STM32F103/minimum/reset.png"></p>
<p><strong>时钟电路</strong>：频率为<code>8MHz</code>的晶振<strong>TX1</strong>是外部系统时钟，由<strong>C5</strong>和<strong>C6</strong>两枚电容协助起震；频率为<code>32.768KHz</code>的晶振<strong>TX2</strong>用于外部<strong>RTC</strong>实时时钟电路，由<strong>C7</strong>和<strong>C8</strong>两枚电容协助起震。</p>
<p><img src="/Embedded/STM32F103/minimum/oscillator.png"></p>
<p><strong>程序下载电路</strong>：芯片<strong>STC15W201S</strong>用于切换单片机启动模式，实现
ASP 程序自动下载；<strong>STM32F103C8T6</strong>使用 USART
串口为单片机下载程序，实验电路中 USB 转 TTL
电平模块的<strong>TXD</strong>和<strong>RXD</strong>引脚分别连接至单片机的<strong>PA10/USART1_RX</strong>和<strong>PA9/USART1_TX</strong>，<strong>GND</strong>引脚与单片机的<strong>VSS_1</strong>、<strong>VSS_2</strong>、<strong>VSS_3</strong>、<strong>VSSA</strong>共同接地。</p>
<p><img src="/Embedded/STM32F103/minimum/asp.png"></p>
<p><strong>STM32F103C8T6</strong>通过<strong>BOOT0</strong>与<strong>BOOT1</strong>两个引脚的电平状态组合，选择何时接收串口传送过来的程序以及何时运行这些程序，即设置微控制器的启动方式。当按键<strong>K1</strong>处于弹起状态时，将会拉低<strong>STC15W201S</strong>的<strong>ASPK</strong>引脚的电平状态，而<strong>STC15W201S</strong>的<strong>ASPL</strong>引脚连接了一枚
LED 状态指示灯并接入
GND，通过<strong>STC15W201S</strong>单片机控制<strong>STM32F103C8T6</strong>的<strong>BOOT0</strong>、<strong>BOOT1</strong>引脚电平状态，进而实现程序的自动下载。</p>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 10%">
<col style="width: 6%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">启动模式</th>
<th style="text-align: center;">BOOT1</th>
<th style="text-align: center;">BOOT0</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Flash ISP</strong></td>
<td style="text-align: center;">任意电平</td>
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;">从闪存启动，即从 Flash
开始执行用户程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Bootloader</strong></td>
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;">擦写 Bootloader 接收串口传送的程序</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>RAM ISP</strong></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;">从 SRAM
启动，下载速度较快，主要用于调试阶段。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>ISP</strong>在线系统编程（In-System
Programming）是一种无需将程序存储芯片从嵌入式设备上取出就能对其进行编程与程序下载的方法。</p>
</blockquote>
<h2 id="keil-mdk-arm-设置">Keil MDK-ARM 设置</h2>
<p>虽然当前 ST 公司正在力推<strong>STM32Cube（HAL &amp;
LL）</strong>固件库，但是出于使用习惯，这里依然选择了<a target="_blank" rel="noopener" href="https://www.st.com/en/embedded-software/stm32-standard-peripheral-libraries.html#products">STM32
Standard Peripheral
Libraries</a>标准固件库来编写实验代码，新建一个<code>Merkava</code>文件夹，并添加<strong>CMSIS</strong>、<strong>Lib</strong>、<strong>Startup</strong>、<strong>User</strong>四个子文件夹，具体目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Merkava：</span><br><span class="line">  ├─CMSIS</span><br><span class="line">  ├─Lib</span><br><span class="line">  │  ├─inc</span><br><span class="line">  │  └─src</span><br><span class="line">  ├─Startup</span><br><span class="line">  └─User</span><br></pre></td></tr></table></figure>
<p>将<code>STM32F10x_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x</code>目录下的<code>stm32f10x.h</code>、<code>system_stm32f10x.c</code>、<code>system_stm32f10x.h</code>三个文件，以及<code>STM32F10x_V3.5.0\Libraries\CMSIS\CM3\CoreSupport</code>目录下的所有文件复制到刚才新建的<strong>CMSIS</strong>目录下，完成后目录结构如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Workspace</span>\<span class="title">merkava</span>\<span class="title">CMSIS</span> (<span class="title">master</span> -&gt; <span class="title">origin</span>)</span></span><br><span class="line"><span class="function">λ <span class="title">ls</span></span></span><br><span class="line"><span class="function"><span class="title">core_cm3.c</span>  <span class="title">core_cm3.h</span>  <span class="title">stm32f10x.h</span>  <span class="title">system_stm32f10x.c</span>  <span class="title">system_stm32f10x.h</span></span></span><br></pre></td></tr></table></figure>
<p>然后进入<code>STM32F10x_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm</code>目录将所有文件复制到刚才新建的<strong>Startup</strong>目录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Workspace</span>\<span class="title">merkava</span>\<span class="title">Startup</span> (<span class="title">master</span> -&gt; <span class="title">origin</span>)</span></span><br><span class="line"><span class="function">λ <span class="title">ls</span></span></span><br><span class="line"><span class="function"><span class="title">startup_stm32f10x_cl.s</span>  <span class="title">startup_stm32f10x_hd_vl.s</span>  <span class="title">startup_stm32f10x_ld_vl.s</span>  <span class="title">startup_stm32f10x_md_vl.s</span></span></span><br><span class="line"><span class="function"><span class="title">startup_stm32f10x_hd.s</span>  <span class="title">startup_stm32f10x_ld.s</span>     <span class="title">startup_stm32f10x_md.s</span>     <span class="title">startup_stm32f10x_xl.s</span></span></span><br></pre></td></tr></table></figure>
<p>接下来再将<code>STM32F10x_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver</code>目录下的<code>src</code>和<code>inc</code>两个子文件夹拷贝到刚才新建的<strong>Lib</strong>目录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Workspace</span>\<span class="title">merkava</span>\<span class="title">Lib</span> (<span class="title">master</span> -&gt; <span class="title">origin</span>)</span></span><br><span class="line"><span class="function">λ <span class="title">ls</span></span></span><br><span class="line"><span class="function"><span class="title">inc</span>/  <span class="title">src</span>/</span></span><br></pre></td></tr></table></figure>
<p>最后将<code>STM32F10x_V3.5.0\Project\STM32F10x_StdPeriph_Template</code>目录下的<code>main.c</code>、<code>stm32f10x_conf.h</code>、<code>stm32f10x_it.c</code>、<code>stm32f10x_it.h</code>四个文件拷贝至刚才新建的<strong>User</strong>目录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Workspace</span>\<span class="title">merkava</span>\<span class="title">User</span> (<span class="title">master</span> -&gt; <span class="title">origin</span>)</span></span><br><span class="line"><span class="function">λ <span class="title">ls</span></span></span><br><span class="line"><span class="function"><span class="title">main.c</span>  <span class="title">stm32f10x_conf.h</span>  <span class="title">stm32f10x_it.c</span>  <span class="title">stm32f10x_it.h</span></span></span><br></pre></td></tr></table></figure>
<p>完成 STM32 官方标准库文件的拷贝与复制之后，还需要对 Keil uVision
进行相应设置。首先新建一个【New uVision Project】，由于 Keil uVision
5.28.0.0 并未内置 STM32F103C8T6 支持包，因此需要点击菜单栏上的【Pack
Installer】功能手动进行安装。当建立好 uVision 项目之后，再点击【Manage
Project Items】图标将刚才建立的代码目录添加至 Keil uVision 项目。</p>
<p><img src="/Embedded/STM32F103/keil/manage-project-items.png"></p>
<blockquote>
<p>将<code>CMSIS</code>目录下的 2 个<code>.c</code>文件全部添加至 Keil
uVision
项目的<strong>CMSIS</strong>组，然后将<code>Lib\src</code>目录下的所有文件添加至<strong>Lib</strong>组，将<code>Startup</code>目录下的<code>startup_stm32f10x_md.s</code>汇编文件添加至<strong>Startup</strong>组，最后将<code>User</code>下的
2 个<code>.c</code>文件添加至<strong>User</strong>组，最后保存退出。</p>
</blockquote>
<p>接下来进一步对 Keil uVision
进行一些初始化的设置，这里首先设置【Target】选项卡下面的外部晶振频率为<code>8.0 MHz</code>，然后勾选【Output】选项卡下的<code>Create HEX File</code>。</p>
<p><img src="/Embedded/STM32F103/keil/options-for-target-1.png"></p>
<p>然后在【C/C++】选项卡下的【Preprocessor
Symbols】内的【Define】输入框内填入<code>USE_STDPERIPH_DRIVER,STM32F10X_MD</code>。</p>
<p><img src="/Embedded/STM32F103/keil/options-for-target-2.png"></p>
<p>最后点击【Include
Paths】左侧的添加按钮，把刚才新建的那些文件夹逐一选入。</p>
<p><img src="/Embedded/STM32F103/keil/options-for-target-3.png"></p>
<p>官方库文件添加完毕之后，还需要新建<code>Basic</code>和<code>Hardware</code>两个目录来放置开发人员编写的代码，同样按照以上步骤将其添加至
Keil uVision 开发环境当中，至此项目中所有目录的功能说明如下：</p>
<ul>
<li><strong>CMSIS</strong>：内核驱动程序；</li>
<li><strong>Lib</strong>：内部功能基本函数库；</li>
<li><strong>Startup</strong>：汇编编写的启动程序；</li>
<li><strong>User</strong>：用户主函数以及其它用户程序；</li>
<li><strong>Basic</strong>：内部功能驱动函数；</li>
<li><strong>Hardware</strong>：外部硬件驱动函数。</li>
</ul>
<h2 id="led-发光二极管">LED 发光二极管</h2>
<h3 id="led-闪烁">LED 闪烁</h3>
<ul>
<li><code>delay_us()</code>：微秒级延时函数；</li>
<li><code>delay_ms()</code>：毫秒级延时函数；</li>
<li><code>delay_s()</code>：秒级延时函数；</li>
</ul>
<p><img src="/Embedded/STM32F103/minimum/led.png"></p>
<h4 id="main.c">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟设置</span></span><br><span class="line">  LED_Init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/** 方式 1</span></span><br><span class="line"><span class="comment">      typedef enum &#123;</span></span><br><span class="line"><span class="comment">        Bit_RESET = 0,</span></span><br><span class="line"><span class="comment">        Bit_SET</span></span><br><span class="line"><span class="comment">      &#125; BitAction; // 位于 stm32f10x_gpio.h</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// LED1 输出高电平 1</span></span><br><span class="line"></span><br><span class="line">    delay_us(<span class="number">50000</span>);                              <span class="comment">// 延时 1 秒</span></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// LED1 输出低电平 0</span></span><br><span class="line">    delay_us(<span class="number">50000</span>);                              <span class="comment">// 延时 1 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方式 2 */</span></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span> - GPIO_ReadOutputDataBit(LEDPORT, LED1))); <span class="comment">// 取反 LED1</span></span><br><span class="line">    delay_ms(<span class="number">500</span>);                                                                        <span class="comment">// 延时 1 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方式 3 */</span></span><br><span class="line">    GPIO_SetBits(LEDPORT, LED1);   <span class="comment">// LED 置为高电平 1</span></span><br><span class="line">    delay_s(<span class="number">1</span>);                    <span class="comment">// 延时 1 秒</span></span><br><span class="line">    GPIO_ResetBits(LEDPORT, LED1); <span class="comment">// LED 重置为低电平 0</span></span><br><span class="line">    delay_s(<span class="number">1</span>);                    <span class="comment">// 延时 1 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方式 4 */</span></span><br><span class="line">    GPIO_Write(LEDPORT, <span class="number">0x0001</span>); <span class="comment">// 将 32 位状态值写入整组 GPIO</span></span><br><span class="line">    delay_s(<span class="number">2</span>);                  <span class="comment">// 延时 1 秒</span></span><br><span class="line">    GPIO_Write(LEDPORT, <span class="number">0x0000</span>); <span class="comment">// 将 32 位状态值写入整组 GPIO</span></span><br><span class="line">    delay_s(<span class="number">2</span>);                  <span class="comment">// 延时 1 秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="led.h">led.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/LED/led.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 通过 PXout() 函数直接操作 GPIO 底层寄存器</span></span><br><span class="line"><span class="comment">  #define LED1 PBout(0) // 直接操作 PB0，使用方式：LED1 = 0</span></span><br><span class="line"><span class="comment">  #define LED2 PBout(1) // 直接操作 PB1，使用方式：LED2 = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDPORT GPIOB   <span class="comment">// 定义 GPIOB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 GPIO_Pin_0 <span class="comment">// 定义 GPIO_Pin_0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 GPIO_Pin_1 <span class="comment">// 定义 GPIO_Pin_1</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="led.c">led.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/LED/led.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  LED 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    typedef struct &#123;</span></span><br><span class="line"><span class="comment">      uint16_t GPIO_Pin;            // GPIO 编号</span></span><br><span class="line"><span class="comment">      GPIOSpeed_TypeDef GPIO_Speed; // GPIO 速度</span></span><br><span class="line"><span class="comment">      GPIOMode_TypeDef GPIO_Mode;   // GPIO 模式</span></span><br><span class="line"><span class="comment">    &#125; GPIO_InitTypeDef;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">// GPIO 初始化参数结构体的声明</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* AHB 外设时钟使能 */</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO 初始化参数结构体 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = LED1 | LED2; <span class="comment">// 选择 GPIO 编号（0~15 / all）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    GPIO_Mode_AIN 模拟输入       GPIO_Mode_IN_FLOATING 浮空输入     GPIO_Mode_IPD 下拉输入</span></span><br><span class="line"><span class="comment">    GPIO_Mode_IPU 上拉输入       GPIO_Mode_Out_PP 推挽输出          GPIO_Mode_Out_OD 开漏输出</span></span><br><span class="line"><span class="comment">    GPIO_Mode_AF_PP 复用推挽输出  GPIO_Mode_AF_OD 复用开漏输出</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// 选择 GPIO 工作模式为推挽输出</span></span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">// 设置 GPIO 接口速度（2MHz / 10MHz / 50MHz）</span></span><br><span class="line"></span><br><span class="line">  GPIO_Init(LEDPORT, &amp;GPIO_InitStructure); <span class="comment">// 运行 GPIO 初始化库函数，将设置写入寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="delay.h">delay.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/delay/delay.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_s</span><span class="params">(u16 s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 us)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="delay.c">delay.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/delay/delay.c</span></span><br><span class="line"><span class="comment"> * 基于系统时基定时器SysTick的延时函数，出于性能考量，采用了寄存器操作实现，并未使用库函数。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHB_INPUT 72 <span class="comment">// RCC 里设置的 AHB 时钟频率，单位为 MHz</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 微秒 us 级延时，参数最大值为 233015 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 uS)</span> &#123;</span><br><span class="line">  SysTick-&gt;LOAD = AHB_INPUT * uS;        <span class="comment">// 计数器重装初值，当前频率为 72MHz，即 72 次为 1us</span></span><br><span class="line">  SysTick-&gt;VAL = <span class="number">0x00</span>;                   <span class="comment">// 定时器计数器清零</span></span><br><span class="line">  SysTick-&gt;CTRL = <span class="number">0x00000005</span>;            <span class="comment">// 时钟源 HCLK，打开定时器</span></span><br><span class="line">  <span class="keyword">while</span> (!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>)); <span class="comment">// 等待计数值归 0</span></span><br><span class="line">  SysTick-&gt;CTRL = <span class="number">0x00000004</span>;            <span class="comment">// 关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毫秒 ms 级延时，参数最大值为 65535 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (ms-- != <span class="number">0</span>) &#123;</span><br><span class="line">    delay_us(<span class="number">1000</span>); <span class="comment">// 调用 1000us 延时函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒 s 级延时，参数最大值为 65535 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_s</span><span class="params">(u16 s)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (s-- != <span class="number">0</span>) &#123;</span><br><span class="line">    delay_ms(<span class="number">1000</span>); <span class="comment">// 调用 1000ms 延时函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="led-呼吸灯">LED 呼吸灯</h3>
<p><code>uX</code>类型变量存放在 SRAM 当中，程序中可以任意进行修改。</p>
<ul>
<li><code>u8</code> ：8 位无符号变量；</li>
<li><code>u16</code> ：16 位无符号变量；</li>
<li><code>u32</code> ：32 位无符号变量；</li>
</ul>
<p><code>vuX</code>类型变量主要用于中断处理函数。</p>
<ul>
<li><code>vu8</code> ：易变的 8 位无符号变量；</li>
<li><code>vu16</code> ：易变的 16 位无符号变量；</li>
<li><code>vu32</code> ：易变的 32 位无符号变量；</li>
</ul>
<p><code>ucX</code>类型变量存放在 Flash 当中，程序里只能读不能写。</p>
<ul>
<li><code>uc8</code> ：只读的 8 位无符号变量；</li>
<li><code>uc16</code> ：只读的 16 位无符号变量；</li>
<li><code>uc32</code> ：只读的 32 位无符号变量；</li>
</ul>
<h4 id="main.c-1">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 变量定义 */</span></span><br><span class="line">  u8 MENU;</span><br><span class="line">  u16 t, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化程序 */</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟设置</span></span><br><span class="line">  LED_Init();</span><br><span class="line">  MENU = <span class="number">0</span>; <span class="comment">// 设置初始值</span></span><br><span class="line">  t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 变亮循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (MENU == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// LED1 输出高电平 1</span></span><br><span class="line">        delay_us(t);                                  <span class="comment">// 延时</span></span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// LED1 输出低电平 0</span></span><br><span class="line">        delay_us(<span class="number">501</span> - t);                            <span class="comment">// 延时</span></span><br><span class="line">      &#125;</span><br><span class="line">      t++;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="number">500</span>) &#123;</span><br><span class="line">        MENU = <span class="number">1</span>;                                     <span class="comment">// 切换至变暗循环</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变暗循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (MENU == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// LED1 输出高电平 1</span></span><br><span class="line">        delay_us(t);                                  <span class="comment">// 延时</span></span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// LED1 输出低电平 0</span></span><br><span class="line">        delay_us(<span class="number">501</span> - t);                            <span class="comment">// 延时</span></span><br><span class="line">      &#125;</span><br><span class="line">      t--;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">        MENU = <span class="number">0</span>;                                     <span class="comment">// 切换至变亮循环</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="led-按键">LED 按键</h3>
<p>GPIO
通常为高电平状态，当按键<strong>K2</strong>和<strong>K3</strong>按下时，<strong>PA0</strong>和<strong>PA1</strong>将分别被下拉为低电平状态。</p>
<p><img src="/Embedded/STM32F103/minimum/key.png"></p>
<h4 id="main.c-2">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟设置</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化按键</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 示例 1：无锁存 */</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123; <span class="comment">// 读按键接口的电平</span></span><br><span class="line">      GPIO_ResetBits(LEDPORT, LED1);            <span class="comment">// LED灯都为低电平（0）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      GPIO_SetBits(LEDPORT, LED1);              <span class="comment">// LED灯都为高电平（1）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 示例 2：无锁存 */</span></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(!GPIO_ReadInputDataBit(KEYPORT, KEY1)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 示例 3：有锁存（较为常用） */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;                                              <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                                                           <span class="comment">// 调用延时函数消除按键抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;                                            <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span> - GPIO_ReadOutputDataBit(LEDPORT, LED1))); <span class="comment">// 采用 1 减去状态值的方式使 LED 状态取反</span></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1))</span><br><span class="line">          ; <span class="comment">// 等待按键松开</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 示例 4：有锁存 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;       <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                    <span class="comment">// 调用延时函数消除按键抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;     <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">        a++;                                           <span class="comment">// 变量自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">          a = <span class="number">0</span>; <span class="comment">// 当变量大于 3 时清零</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GPIO_Write(LEDPORT, a);                        <span class="comment">// 将变量值写入 LED 对应的 GPIO 上的 PB0 和 PB1</span></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)); <span class="comment">// 等待按键松开</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="key.h">key.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/KEY/key.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPORT GPIOA   <span class="comment">// 定义 GPIO 组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 GPIO_Pin_0 <span class="comment">// 定义具体的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2 GPIO_Pin_1 <span class="comment">// 定义具体的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 初始化按键</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="key.c">key.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/KEY/key.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微动开关的接口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;                  <span class="comment">// 定义 GPIO 初始化枚举结构</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); <span class="comment">// 启动相应的总线时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = KEY1 | KEY2;            <span class="comment">// 定时按键对应的 GPIO 编号，0~15 或者 all</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;         <span class="comment">// 选择 GPIO 工作方式为上拉输入，让按键在未按下时上拉至高电平状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  // 此处注释该语句，是由于 GPIO 设置为输入状态时，不需要对 GPIO 速度进行设置</span></span><br><span class="line"></span><br><span class="line">  GPIO_Init(KEYPORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="flash-闪存">Flash 闪存</h2>
<p>使用 Flash 存储器保存上面 LED 按键实验当中示例 4
的按键状态，需要向<strong>Lib</strong>目录下添加<code>stm32f10x_flash.c</code>库文件，操作
Flash 存储器时有以下注意事项：</p>
<ul>
<li>必须严格遵循<strong>先擦后写</strong>的操作顺序；</li>
<li>Flash 每页拥有 1024 个地址，但整个 Flash
的起始地址为<code>0x08000000</code>；</li>
<li>Flash 的擦除操作必须以<strong>页</strong>为单位，写入时必须以 16
位宽度为单位，允许跨页进行写入；</li>
<li>进行 Flash 擦写操作时，必须打开内/外部的高速晶振；</li>
<li>由于 Flash 存储器可以擦写 10
万次左右，所以不能进行死循环擦写数据，造成该页的损坏；</li>
<li>擦写 Flash
时需要避开已经使用了的用户程序存储区，否则错误的擦除用户程序导致错误；</li>
<li>Flash
每擦除一页（<code>1k</code>大小）需要耗费<code>10ms</code>，操作起来速度较慢，并且不能进行单个字节的擦写。</li>
</ul>
<h3 id="main.c-3">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_START_ADDR 0x0801f000                    <span class="comment">// 预定义待操作的 Flash 地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 a;                                               <span class="comment">// 控制 LED 状态的 16 位变量 a</span></span><br><span class="line">  RCC_Configuration();                                 <span class="comment">// 时钟设置</span></span><br><span class="line">  LED_Init();                                          <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();                                          <span class="comment">// 初始化按键</span></span><br><span class="line"></span><br><span class="line">  a = FLASH_R(FLASH_START_ADDR);                       <span class="comment">// 从指定的 Flash 页地址读取数据</span></span><br><span class="line"></span><br><span class="line">  GPIO_Write(LEDPORT, a);                              <span class="comment">// 将变量值写入 LED 对应 GPIO 的 PB0 和 PB1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 有锁存按键 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;       <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                    <span class="comment">// 调用延时函数消除按键抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;     <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">        a++;                                           <span class="comment">// 变量自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">          a = <span class="number">0</span>; <span class="comment">// 当变量大于 3 时清零</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GPIO_Write(LEDPORT, a);                        <span class="comment">// 将变量值写入 LED 对应的 GPIO 上的 PB0 和 PB1</span></span><br><span class="line">        FLASH_W(FLASH_START_ADDR, a);                  <span class="comment">// 将控制 LED 状态的变量 a 写入到 Flash 的指定页地址</span></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)); <span class="comment">// 等待按键松开</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flash.h">flash.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/flash/flash.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_W</span><span class="params">(u32 add, u16 dat)</span>;</span><br><span class="line">u16 <span class="title function_">FLASH_R</span><span class="params">(u32 add)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="flash.c">flash.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/flash/flash.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FLASH 写数据函数，参数 add 是 32 位的 Flash 地址，参数 dat 是待写入的 16 位数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_W</span><span class="params">(u32 add, u16 dat)</span> &#123;</span><br><span class="line">  <span class="comment">// RCC_HSICmd(ENABLE); // 由于 Flash 操作必须在高速时钟下进行，由于目前已经使用了外部高速时钟，所以就无需再开启内部的高速时钟</span></span><br><span class="line"></span><br><span class="line">  FLASH_Unlock();                                                                            <span class="comment">// Flash 存放了用户下载程序，为了防止误操作，STM32 设置了操作锁定功能，每次操作之前必须先解锁才能进行操作</span></span><br><span class="line">  FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR); <span class="comment">// 解锁后清除标志位</span></span><br><span class="line">  FLASH_ErasePage(add);                                                                      <span class="comment">// 擦除 add 地址所在的 Flash 页，擦除以后才可以进行写入</span></span><br><span class="line">  FLASH_ProgramHalfWord(add, dat);                                                           <span class="comment">// 向指定页的 addr 地址写入数据 dat</span></span><br><span class="line">  FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR); <span class="comment">// 清除标志位</span></span><br><span class="line">  FLASH_Lock();                                                                              <span class="comment">// 重新将 Flash 上锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FLASH 读数据函数，参数 add 是 32 位的 Flash 地址，返回待读取的 16 位数据 */</span></span><br><span class="line">u16 <span class="title function_">FLASH_R</span><span class="params">(u32 add)</span> &#123;</span><br><span class="line">  u16 a;</span><br><span class="line">  a = *(u16 *)(add); <span class="comment">// 从指定 Flash 页的 addr 地址开始进行读取</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：如果需要使用 Flash
存储临时数据，需要考虑到当前单片机程序所占用的空间大小，然后在用户程序没有占用的空白区域里，相对靠后的位置放置临时的自定义数据。</p>
</blockquote>
<h2 id="buzzer-无源蜂鸣器">Buzzer 无源蜂鸣器</h2>
<p>蜂鸣器<strong>BP1</strong>一端通过限流电阻<strong>R1</strong>连接到
3V 电源，另外一端通过 PNP
三极管<strong>VT1</strong>进行控制，该三极管的集电极连接至
GND，基极通过限流电阻<strong>R3</strong>连接至 STM32
的<strong>PB5</strong>引脚；当<strong>PB5</strong>输出高电平时，三极管的集电极<strong>C</strong>端与发射极<strong>E</strong>端断开，蜂鸣器处于断开状态；当<strong>PB5</strong>输出低电平时，三极管的集电极<strong>C</strong>端与发射极<strong>E</strong>端导通，蜂鸣器开始上电工作。如果要发出<code>1KHz</code>频率的声音，需要
1 秒需要经过 1000 个周期，即<code>1000us</code>。</p>
<p><img src="/Embedded/STM32F103/minimum/buzzer.png"></p>
<h3 id="按键控制蜂鸣器">按键控制蜂鸣器</h3>
<h4 id="main.c-4">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_START_ADDR 0x0801f000 <span class="comment">// 写入的起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 a;</span><br><span class="line">  RCC_Configuration();           <span class="comment">// 配置时钟</span></span><br><span class="line">  LED_Init();                    <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();                    <span class="comment">// 初始化按键</span></span><br><span class="line"></span><br><span class="line">  BUZZER_Init();                 <span class="comment">// 初始化蜂鸣器</span></span><br><span class="line">  BUZZER_BEEP1();                <span class="comment">// 蜂鸣器响 1 声，用于上电提示</span></span><br><span class="line"></span><br><span class="line">  a = FLASH_R(FLASH_START_ADDR); <span class="comment">// 从指定的 Flash 页地址读取数据</span></span><br><span class="line"></span><br><span class="line">  GPIO_Write(LEDPORT, a | <span class="number">0xfffc</span> &amp; GPIO_ReadOutputData(LEDPORT)); <span class="comment">// 将变量值写入 LED 对应 GPIOB 的 PB0 和 PB1 上面，并且保持其它 GPIOB 引脚的状态不变</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 有锁存按键 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;   <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                <span class="comment">// 调用延时函数消除按键抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123; <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">        a++;                                       <span class="comment">// 变量自增 1</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">          a = <span class="number">0</span>;                                   <span class="comment">// 当变量大于 3 时清零</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GPIO_Write(LEDPORT, a | <span class="number">0xfffc</span> &amp; GPIO_ReadOutputData(LEDPORT)); <span class="comment">// 将变量值写入 LED 对应 GPIOB 的 PB0 和 PB1 上面，并且保持其它 GPIOB 引脚的状态不变</span></span><br><span class="line">        BUZZER_BEEP1();                                                 <span class="comment">// 蜂鸣器响一声</span></span><br><span class="line"></span><br><span class="line">        FLASH_W(FLASH_START_ADDR, a);                                   <span class="comment">// 将控制 LED 状态的变量 a 写入到 Flash 的指定页地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1));                  <span class="comment">// 等待按键松开</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="buzzer.h">buzzer.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/BUZZER/buzzer.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BUZZER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BUZZER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZERPORT GPIOB  <span class="comment">// 预定义 GPIO 组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZER GPIO_Pin_5 <span class="comment">// 预定义控制蜂鸣器的 GPIO 端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_Init</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 蜂鸣器初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_BEEP1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 蜂鸣器响一声函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="buzzer.c">buzzer.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/BUZZER/buzzer.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器接口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = BUZZER;                <span class="comment">// 设置 GPIO 引脚号</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;     <span class="comment">// 选择 GPIO 工作方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    <span class="comment">// 设置 GPIO 工作速度（2MHz / 10MHz / 50MHz）</span></span><br><span class="line">  GPIO_Init(BUZZERPORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">1</span>));   <span class="comment">// 蜂鸣器端口初始化默认输出高电平 1，确保三极管处于断开状态，防止蜂鸣器损坏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器响 1 声工作函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_BEEP1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 i;</span><br><span class="line">  <span class="comment">/* 产生 200 个频率周期，让蜂鸣器鸣响一段时间 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 高低电平各持续 500us，一个周期就是 1000us */</span></span><br><span class="line">    GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">0</span>)); <span class="comment">// 向蜂鸣器接口输出低电平 0</span></span><br><span class="line">    delay_us(<span class="number">500</span>);                                     <span class="comment">// 保持低电平持续 500us</span></span><br><span class="line">    GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">1</span>)); <span class="comment">// 向蜂鸣器接口输出高电平 1，高电平放置在最后是为了防止蜂鸣器损坏</span></span><br><span class="line">    delay_us(<span class="number">500</span>);                                     <span class="comment">// 保持高电平持续 500us</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="播放-midi">播放 MIDI</h3>
<p>MIDI（乐器数字接口，Musical Instrument Digital
Interface）采用音符的数字控制信号来记录音乐，即 MIDI
音乐传输的并非声音信号本身，而是 MIDI 控制指令, MIDI
信号传输时通常采用异步串行方式,
波特率为<code>31.25 × (1 ± 0.01) KBaud</code>。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">音符</th>
<th style="text-align: center;">频率</th>
<th style="text-align: left;">音符</th>
<th style="text-align: center;">频率</th>
<th style="text-align: left;">音符</th>
<th style="text-align: center;">频率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">低音 1</td>
<td style="text-align: center;">262 Hz</td>
<td style="text-align: left;">中音 1</td>
<td style="text-align: center;">523 Hz</td>
<td style="text-align: left;">高音 1</td>
<td style="text-align: center;">1046 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 1#</td>
<td style="text-align: center;">277 Hz</td>
<td style="text-align: left;">中音 1#</td>
<td style="text-align: center;">554 Hz</td>
<td style="text-align: left;">高音 1#</td>
<td style="text-align: center;">1109 Hz</td>
</tr>
<tr class="odd">
<td style="text-align: left;">低音 2</td>
<td style="text-align: center;">294 Hz</td>
<td style="text-align: left;">中音 2</td>
<td style="text-align: center;">587 Hz</td>
<td style="text-align: left;">高音 2</td>
<td style="text-align: center;">1175 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 2#</td>
<td style="text-align: center;">311 Hz</td>
<td style="text-align: left;">中音 2#</td>
<td style="text-align: center;">622 Hz</td>
<td style="text-align: left;">高音 2#</td>
<td style="text-align: center;">1245 Hz</td>
</tr>
<tr class="odd">
<td style="text-align: left;">低音 3</td>
<td style="text-align: center;">330 Hz</td>
<td style="text-align: left;">中音 3</td>
<td style="text-align: center;">659 Hz</td>
<td style="text-align: left;">高音 3</td>
<td style="text-align: center;">1318 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 4</td>
<td style="text-align: center;">349 Hz</td>
<td style="text-align: left;">中音 4</td>
<td style="text-align: center;">698 Hz</td>
<td style="text-align: left;">高音 4</td>
<td style="text-align: center;">1397 Hz</td>
</tr>
<tr class="odd">
<td style="text-align: left;">低音 4#</td>
<td style="text-align: center;">370 Hz</td>
<td style="text-align: left;">中音 4#</td>
<td style="text-align: center;">740 Hz</td>
<td style="text-align: left;">高音 4#</td>
<td style="text-align: center;">1480 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 5</td>
<td style="text-align: center;">392 Hz</td>
<td style="text-align: left;">中音 5</td>
<td style="text-align: center;">784 Hz</td>
<td style="text-align: left;">高音 5</td>
<td style="text-align: center;">1568 Hz</td>
</tr>
<tr class="odd">
<td style="text-align: left;">低音 5#</td>
<td style="text-align: center;">415 Hz</td>
<td style="text-align: left;">中音 5#</td>
<td style="text-align: center;">831 Hz</td>
<td style="text-align: left;">高音 5#</td>
<td style="text-align: center;">1661 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 6</td>
<td style="text-align: center;">440 Hz</td>
<td style="text-align: left;">中音 6</td>
<td style="text-align: center;">880 Hz</td>
<td style="text-align: left;">高音 6</td>
<td style="text-align: center;">1760 Hz</td>
</tr>
<tr class="odd">
<td style="text-align: left;">低音 6#</td>
<td style="text-align: center;">466 Hz</td>
<td style="text-align: left;">中音 6#</td>
<td style="text-align: center;">932 Hz</td>
<td style="text-align: left;">高音 6#</td>
<td style="text-align: center;">1865 Hz</td>
</tr>
<tr class="even">
<td style="text-align: left;">低音 7</td>
<td style="text-align: center;">494 Hz</td>
<td style="text-align: left;">中音 7</td>
<td style="text-align: center;">988 Hz</td>
<td style="text-align: left;">高音 7</td>
<td style="text-align: center;">1976 Hz</td>
</tr>
</tbody>
</table>
<blockquote>
<p>本实验代码基于前一个蜂鸣器实验的代码，仅仅是添加了 MIDI
播放相关的头文件与函数，并在主函数中对该函数进行了调用。</p>
</blockquote>
<h4 id="main.c-5">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_START_ADDR 0x0801f000 <span class="comment">// 写入的起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 a;</span><br><span class="line">  RCC_Configuration();           <span class="comment">// 配置时钟</span></span><br><span class="line">  LED_Init();                    <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();                    <span class="comment">// 初始化按键</span></span><br><span class="line"></span><br><span class="line">  BUZZER_Init();                 <span class="comment">// 初始化蜂鸣器</span></span><br><span class="line">  MIDI_PLAY();                   <span class="comment">// 开始播放 MIDI 音乐</span></span><br><span class="line"></span><br><span class="line">  a = FLASH_R(FLASH_START_ADDR); <span class="comment">// 从指定的 Flash 页地址读取数据</span></span><br><span class="line"></span><br><span class="line">  GPIO_Write(LEDPORT, a | <span class="number">0xfffc</span> &amp; GPIO_ReadOutputData(LEDPORT)); <span class="comment">// 将变量值写入 LED 对应 GPIOB 的 PB0 和 PB1 上面，并且保持其它 GPIOB 引脚的状态不变</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 有锁存按键 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;   <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                <span class="comment">// 调用延时函数消除按键抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123; <span class="comment">// 读取按键对应 GPIO 引脚的电平状态</span></span><br><span class="line">        a++;                                       <span class="comment">// 变量自增 1</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">          a = <span class="number">0</span>;                                   <span class="comment">// 当变量大于 3 时清零</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GPIO_Write(LEDPORT, a | <span class="number">0xfffc</span> &amp; GPIO_ReadOutputData(LEDPORT)); <span class="comment">// 将变量值写入 LED 对应 GPIOB 的 PB0 和 PB1 上面，并且保持其它 GPIOB 引脚的状态不变</span></span><br><span class="line">        BUZZER_BEEP1();                                                 <span class="comment">// 蜂鸣器响一声</span></span><br><span class="line"></span><br><span class="line">        FLASH_W(FLASH_START_ADDR, a);                                   <span class="comment">// 将控制 LED 状态的变量 a 写入到 Flash 的指定页地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1));                  <span class="comment">// 等待按键松开</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="buzzer.h-1">buzzer.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/xx/xx.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BUZZER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BUZZER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZERPORT GPIOB  <span class="comment">// 预定义 GPIO 组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZER GPIO_Pin_5 <span class="comment">// 预定义控制蜂鸣器的 GPIO 端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_Init</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 蜂鸣器初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_BEEP1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 蜂鸣器响一声函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MIDI_PLAY</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 播放 MIDI 音乐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="buzzer.c-1">buzzer.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/xx/xx.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器接口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = BUZZER;             <span class="comment">// 设置 GPIO 引脚号</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// 选择 GPIO 工作方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">// 设置 GPIO 工作速度（2MHz / 10MHz / 50MHz）</span></span><br><span class="line">  GPIO_Init(BUZZERPORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">1</span>)); <span class="comment">// 蜂鸣器端口初始化默认输出高电平 1，确保三极管处于断开状态，防止蜂鸣器损坏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器响 1 声工作函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BUZZER_BEEP1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 i;</span><br><span class="line">  <span class="comment">/* 产生 200 个频率周期，让蜂鸣器鸣响一段时间 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 高低电平各持续 500us，一个周期就是 1000us */</span></span><br><span class="line">    GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">0</span>)); <span class="comment">// 向蜂鸣器接口输出低电平 0</span></span><br><span class="line">    delay_us(<span class="number">500</span>);                                     <span class="comment">// 保持低电平持续 500us</span></span><br><span class="line">    GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">1</span>)); <span class="comment">// 向蜂鸣器接口输出高电平 1，高电平放置在最后是为了防止蜂鸣器损坏</span></span><br><span class="line">    delay_us(<span class="number">500</span>);                                     <span class="comment">// 保持高电平持续 500us</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIDI 控制信号表，数组奇数位为音调频率，偶数位为时间长度 */</span></span><br><span class="line">uc16 music1[<span class="number">78</span>] = &#123; <span class="number">330</span>, <span class="number">750</span>, <span class="number">440</span>, <span class="number">375</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">523</span>, <span class="number">750</span>, <span class="number">587</span>, <span class="number">375</span>, <span class="number">659</span>, <span class="number">375</span>, <span class="number">587</span>, <span class="number">750</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">392</span>, <span class="number">375</span>, <span class="number">440</span>, <span class="number">1500</span>, <span class="number">330</span>, <span class="number">750</span>, <span class="number">440</span>, <span class="number">375</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">523</span>, <span class="number">750</span>, <span class="number">587</span>, <span class="number">375</span>, <span class="number">659</span>, <span class="number">375</span>, <span class="number">587</span>, <span class="number">750</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">392</span>, <span class="number">375</span>, <span class="number">784</span>, <span class="number">1500</span>, <span class="number">659</span>, <span class="number">750</span>, <span class="number">698</span>, <span class="number">375</span>, <span class="number">784</span>, <span class="number">375</span>, <span class="number">880</span>, <span class="number">750</span>, <span class="number">784</span>, <span class="number">375</span>, <span class="number">698</span>, <span class="number">375</span>, <span class="number">659</span>, <span class="number">750</span>, <span class="number">587</span>, <span class="number">750</span>, <span class="number">659</span>, <span class="number">750</span>, <span class="number">523</span>, <span class="number">375</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">440</span>, <span class="number">750</span>, <span class="number">440</span>, <span class="number">375</span>, <span class="number">494</span>, <span class="number">375</span>, <span class="number">523</span>, <span class="number">750</span>, <span class="number">523</span>, <span class="number">750</span>, <span class="number">494</span>, <span class="number">750</span>, <span class="number">392</span>, <span class="number">750</span>, <span class="number">440</span>, <span class="number">3000</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIDI 音乐播放函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MIDI_PLAY</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 i, e;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">39</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for 循环中的算式决定了 MIDI 控制信号的持续时间长度，算式 1 * 2 和 i * 2 + 1 分别用于获取数组偶、奇数位的数据，频率乘以时间最后除以 1000 将单位转换为毫秒 */</span></span><br><span class="line">    <span class="keyword">for</span> (e = <span class="number">0</span>; e &lt; music1[i * <span class="number">2</span>] * music1[i * <span class="number">2</span> + <span class="number">1</span>] / <span class="number">1000</span>; e++) &#123;</span><br><span class="line">      GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">0</span>)); <span class="comment">// 向蜂鸣器接口输出低电平 0</span></span><br><span class="line">      delay_us(<span class="number">500000</span> / music1[i * <span class="number">2</span>]);                  <span class="comment">// 确定当前播放的音符，其中 500000 是 50 万微秒即 0.5 秒，除以振动次数可以得到 0.5 秒内要振动的次数，以及对应的延时时间长度</span></span><br><span class="line">      GPIO_WriteBit(BUZZERPORT, BUZZER, (BitAction)(<span class="number">1</span>)); <span class="comment">// 向蜂鸣器接口输出高电平 1，高电平放置在最后是为了防止蜂鸣器损坏</span></span><br><span class="line">      delay_us(<span class="number">500000</span> / music1[i * <span class="number">2</span>]);                  <span class="comment">// 确定当前播放的音符，原理同上</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="usart-串行通信">USART 串行通信</h2>
<h3 id="usart-发送">USART 发送</h3>
<p>本程序示例代码基于上一步播放 MIDI
音乐的项目构建，只是往<strong>Lib</strong>文件夹内增加了<code>stm32f10x_usart.c</code>库文件，以及向<strong>Basic</strong>文件夹添加了
USART 相关的支持代码。</p>
<h4 id="main.c-6">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a = <span class="number">7</span>, b = <span class="number">8</span>;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟配置</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>); <span class="comment">// 使用波特率为参数初始化 USART1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送方式 1 */</span></span><br><span class="line">    USART_SendData(USART1, <span class="number">0x55</span>); <span class="comment">// 发送单个数值</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)</span><br><span class="line">      ; <span class="comment">//检查发送中断标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送方式 2 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STM32F103 &quot;</span>);         <span class="comment">// 发送字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STM32 %d %d &quot;</span>, a, b); <span class="comment">// 发送带有格式化字符的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送方式 3 */</span></span><br><span class="line">    USART1_printf(<span class="string">&quot;STM32 %d %d &quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">1000</span>); <span class="comment">// 延时</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="usart.h">usart.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_n USART1 <span class="comment">// 定义使用 printf() 函数使用的串口，其它串口可以同时使用 USART_printf() 函数进行操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART1_REC_LEN 200 <span class="comment">// 定义 USART1 最大接收字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2_REC_LEN 200 <span class="comment">// 定义 USART2 最大接收字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART3_REC_LEN 200 <span class="comment">// 定义 USART3 最大接收字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用掉不需要的串口，可以有效减少编译量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART1 1 <span class="comment">// 使能(1)或者禁止(0)串口 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART2 0 <span class="comment">// 使能(1)或者禁止(0)串口 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART3 0 <span class="comment">// 使能(1)或者禁止(0)串口 3</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 USART1_RX_BUF[USART1_REC_LEN]; <span class="comment">// 设置接收缓冲区最大数据量为 USART_REC_LEN 个字节，最后的字节为换行符</span></span><br><span class="line"><span class="keyword">extern</span> u8 USART2_RX_BUF[USART2_REC_LEN]; <span class="comment">// 设置接收缓冲区最大数据量为 USART_REC_LEN 个字节，最后的字节为换行符</span></span><br><span class="line"><span class="keyword">extern</span> u8 USART3_RX_BUF[USART3_REC_LEN]; <span class="comment">// 设置接收缓冲区最大数据量为 USART_REC_LEN 个字节，最后的字节为换行符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u16 USART1_RX_STA; <span class="comment">// 接收状态标记</span></span><br><span class="line"><span class="keyword">extern</span> u16 USART2_RX_STA; <span class="comment">// 接收状态标记</span></span><br><span class="line"><span class="keyword">extern</span> u16 USART3_RX_STA; <span class="comment">// 接收状态标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span>;        <span class="comment">// 串口 1 初始化并启动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_Init</span><span class="params">(u32 bound)</span>;        <span class="comment">// 串口 2 初始化并启动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_Init</span><span class="params">(u32 bound)</span>;        <span class="comment">// 串口 3 初始化并启动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span>; <span class="comment">// 串口 1 的 printf() 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span>; <span class="comment">// 串口 2 的 printf() 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span>; <span class="comment">// 串口 3 的 printf() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="usart.c">usart.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 重写 printf() 函数用于发送 UART 串口数据，可以在 usart.h 文件内修改串口号 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准库所需的支持函数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line">FILE __stdout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 _sys_exit() 函数，避免使用半主机模式 */</span></span><br><span class="line">_sys_exit(<span class="type">int</span> x) &#123;</span><br><span class="line">  x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新定义 fputc() 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> ((USART_n-&gt;SR &amp; <span class="number">0X40</span>) == <span class="number">0</span>); <span class="comment">// 循环发送数据，直至发送完毕</span></span><br><span class="line">  USART_n-&gt;DR = (u8)ch;</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ----- USART1 相关的工具函数 ----- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1                       <span class="comment">// USART1 是否使能</span></span></span><br><span class="line">u8 USART1_RX_BUF[USART1_REC_LEN];   <span class="comment">// 数据接收缓冲区，最大值为 USART_REC_LEN 字节</span></span><br><span class="line">u16 USART1_RX_STA = <span class="number">0</span>;              <span class="comment">// 接收状态标记，bit15 是接收完成标志，bit14 表示接收到 0x0d，bit13~0 表示接收到的有效字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART1 的 printf() 函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[USART1_REC_LEN + <span class="number">1</span>];  <span class="comment">// 数据的长度</span></span><br><span class="line">  u8 i = <span class="number">0</span>;</span><br><span class="line">  va_list arg_ptr;</span><br><span class="line">  va_start(arg_ptr, fmt);</span><br><span class="line">  vsnprintf(buffer, USART1_REC_LEN + <span class="number">1</span>, fmt, arg_ptr);</span><br><span class="line">  <span class="keyword">while</span> ((i &lt; USART1_REC_LEN) &amp;&amp; (i &lt; <span class="built_in">strlen</span>(buffer))) &#123;</span><br><span class="line">    USART_SendData(USART1, (u8)buffer[i++]);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* GPIO端口设置 */</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  USART_InitTypeDef USART_InitStructure;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);   <span class="comment">// 使能 USART1(PA9/USART1_TX) 和 GPIOA 时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USART1 发送引脚 PA9/USART1_TX 配置 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;                                 <span class="comment">// 推挽输出</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*USART1 接收引脚 PA10/USART1_RX 配置*/</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;                           <span class="comment">// 浮空输入</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 Usart1 的 NVIC 向量中断控制器 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">3</span>;                       <span class="comment">// 设置抢占优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;                              <span class="comment">// 设置子优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                                 <span class="comment">// 使能 IRQ 通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);                                                 <span class="comment">// 始化 NVIC 寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 USART1 设置 */</span></span><br><span class="line">  USART_InitStructure.USART_BaudRate = bound;                                     <span class="comment">// 一般设置为 9600;</span></span><br><span class="line">  USART_InitStructure.USART_WordLength = USART_WordLength_8b;                     <span class="comment">// 字长为 8 位数据格式</span></span><br><span class="line">  USART_InitStructure.USART_StopBits = USART_StopBits_1;                          <span class="comment">// 一个停止位</span></span><br><span class="line">  USART_InitStructure.USART_Parity = USART_Parity_No;                             <span class="comment">// 不使用奇偶校验位</span></span><br><span class="line">  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">// 不使用硬件数据流控制</span></span><br><span class="line">  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;                 <span class="comment">// 设置收发模式</span></span><br><span class="line">  USART_Init(USART1, &amp;USART_InitStructure);                                       <span class="comment">// 初始化串口</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);                                  <span class="comment">// 开启 ENABLE 或者关闭 DISABLE 中断</span></span><br><span class="line">  USART_Cmd(USART1, ENABLE);                                                      <span class="comment">// 串口使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART1 串口中断服务程序，主函数可以通过判断 if(USART1_RX_STA &amp; 0xC000) 是否为 true，然后读取 USART1_RX_BUF[] 数组，如果读取到 0x0d 0x0a 就表示数据接收完成，即超级终端按下回车键；注意主函数完成串口数据处理之后，需要将 USART1_RX_STA 置为零 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 Res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接收到的数据必须以 0x0d 0x0a 结尾 */</span></span><br><span class="line">  <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123;</span><br><span class="line">    Res = USART_ReceiveData(USART1);                   <span class="comment">// 读取接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, Res);                                 <span class="comment">// 将接收到的数据发送回电脑</span></span><br><span class="line">    <span class="comment">/* 如果接收没有完成 */</span></span><br><span class="line">    <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x8000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果接收到 0x0d */</span></span><br><span class="line">      <span class="keyword">if</span> (USART1_RX_STA &amp; <span class="number">0x4000</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Res != <span class="number">0x0a</span>)</span><br><span class="line">          USART1_RX_STA = <span class="number">0</span>;                           <span class="comment">// 接收错误,重新开始</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          USART1_RX_STA |= <span class="number">0x8000</span>;                     <span class="comment">// 接收完成</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果没有接收到 0X0D */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Res == <span class="number">0x0d</span>)</span><br><span class="line">          USART1_RX_STA |= <span class="number">0x4000</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          USART1_RX_BUF[USART1_RX_STA &amp; <span class="number">0X3FFF</span>] = Res; <span class="comment">// 将接收到的数据存放至 USART1_RX_BUF[] 数组，其中 USART1_RX_STA &amp; 0x3FFF 是不包括回车的数据长度</span></span><br><span class="line">          USART1_RX_STA++;                             <span class="comment">// 数据长度计数自增 1</span></span><br><span class="line">          <span class="keyword">if</span> (USART1_RX_STA &gt; (USART1_REC_LEN - <span class="number">1</span>))</span><br><span class="line">            USART1_RX_STA = <span class="number">0</span>;                         <span class="comment">// 如果接收到的数据错误，那么重新开始接收</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ----- USART2 相关的工具函数 ----- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART2                       <span class="comment">// USART2 是否使能</span></span></span><br><span class="line">u8 USART2_RX_BUF[USART2_REC_LEN];   <span class="comment">// 数据接收缓冲区，最大值为 USART_REC_LEN 字节</span></span><br><span class="line">u16 USART2_RX_STA = <span class="number">0</span>;              <span class="comment">// 接收状态标记，bit15 是接收完成标志，bit14 表示接收到 0x0d，bit13~0 表示接收到的有效字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART2 的 printf() 函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[USART2_REC_LEN + <span class="number">1</span>];  <span class="comment">// 数据的长度</span></span><br><span class="line">  u8 i = <span class="number">0</span>;</span><br><span class="line">  va_list arg_ptr;</span><br><span class="line">  va_start(arg_ptr, fmt);</span><br><span class="line">  vsnprintf(buffer, USART2_REC_LEN + <span class="number">1</span>, fmt, arg_ptr);</span><br><span class="line">  <span class="keyword">while</span> ((i &lt; USART2_REC_LEN) &amp;&amp; (i &lt; <span class="built_in">strlen</span>(buffer))) &#123;</span><br><span class="line">    USART_SendData(USART2, (u8)buffer[i++]);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化并启动 USART2 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* GPIO端口设置 */</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  USART_InitTypeDef USART_InitStructure;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);                           <span class="comment">// 使能 USART2 所在的 GPIOA 时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);                          <span class="comment">// 使能串口 RCC 时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USART2 发送引脚 PA2/USART2_TX 配置 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;                                 <span class="comment">// 推挽输出</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*USART2 接收引脚 PA3/USART2_RX 配置*/</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;                           <span class="comment">// 浮空输入</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 USART2 的 NVIC 向量中断控制器 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">3</span>;                       <span class="comment">// 设置抢占优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;                              <span class="comment">// 设置子优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                                 <span class="comment">// 使能 IRQ 通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);                                                 <span class="comment">// 始化 NVIC 寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 USART2 设置 */</span></span><br><span class="line">  USART_InitStructure.USART_BaudRate = bound;                                     <span class="comment">// 一般设置为 9600;</span></span><br><span class="line">  USART_InitStructure.USART_WordLength = USART_WordLength_8b;                     <span class="comment">// 字长为 8 位数据格式</span></span><br><span class="line">  USART_InitStructure.USART_StopBits = USART_StopBits_1;                          <span class="comment">// 一个停止位</span></span><br><span class="line">  USART_InitStructure.USART_Parity = USART_Parity_No;                             <span class="comment">// 不使用奇偶校验位</span></span><br><span class="line">  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">// 不使用硬件数据流控制</span></span><br><span class="line">  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;                 <span class="comment">// 设置收发模式</span></span><br><span class="line">  USART_Init(USART2, &amp;USART_InitStructure);                                       <span class="comment">// 初始化串口</span></span><br><span class="line">  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);                                  <span class="comment">// 开启 ENABLE 或者关闭 DISABLE 中断</span></span><br><span class="line">  USART_Cmd(USART2, ENABLE);                                                      <span class="comment">// 串口使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART2 串口中断服务程序，主函数可以通过判断 if(USART2_RX_STA &amp; 0xC000) 是否为 true，然后读取 USART2_RX_BUF[] 数组，如果读取到 0x0d 0x0a 就表示数据接收完成，即超级终端按下回车键；注意主函数完成串口数据处理之后，需要将 USART2_RX_STA 置为零 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 Res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接收到的数据必须以 0x0d 0x0a 结尾 */</span></span><br><span class="line">  <span class="keyword">if</span> (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) &#123;</span><br><span class="line">    Res = USART_ReceiveData(USART2);                   <span class="comment">// 读取接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, Res);                                 <span class="comment">// 将接收到的数据发送回电脑</span></span><br><span class="line">    <span class="comment">/* 如果接收没有完成 */</span></span><br><span class="line">    <span class="keyword">if</span> ((USART2_RX_STA &amp; <span class="number">0x8000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果接收到 0x0d */</span></span><br><span class="line">      <span class="keyword">if</span> (USART2_RX_STA &amp; <span class="number">0x4000</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Res != <span class="number">0x0a</span>)</span><br><span class="line">          USART2_RX_STA = <span class="number">0</span>;                           <span class="comment">// 接收错误,重新开始</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          USART2_RX_STA |= <span class="number">0x8000</span>;                     <span class="comment">// 接收完成</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果没有接收到 0X0D */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Res == <span class="number">0x0d</span>)</span><br><span class="line">          USART2_RX_STA |= <span class="number">0x4000</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          USART2_RX_BUF[USART2_RX_STA &amp; <span class="number">0X3FFF</span>] = Res; <span class="comment">// 将接收到的数据存放至 USART2_RX_BUF[] 数组，其中 USART2_RX_STA &amp; 0x3FFF 是不包括回车的数据长度</span></span><br><span class="line">          USART2_RX_STA++;                             <span class="comment">// 数据长度计数自增 1</span></span><br><span class="line">          <span class="keyword">if</span> (USART2_RX_STA &gt; (USART2_REC_LEN - <span class="number">1</span>))</span><br><span class="line">            USART2_RX_STA = <span class="number">0</span>;                         <span class="comment">// 如果接收到的数据错误，那么重新开始接收</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ----- USART3 相关的工具函数 ----- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART3                       <span class="comment">// USART3 是否使能</span></span></span><br><span class="line">u8 USART3_RX_BUF[USART3_REC_LEN];   <span class="comment">// 数据接收缓冲区，最大值为 USART_REC_LEN 字节</span></span><br><span class="line">u16 USART3_RX_STA = <span class="number">0</span>;              <span class="comment">// 接收状态标记，bit15 是接收完成标志，bit14 表示接收到 0x0d，bit13~0 表示接收到的有效字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART3 的 printf() 函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[USART3_REC_LEN + <span class="number">1</span>];  <span class="comment">// 数据的长度</span></span><br><span class="line">  u8 i = <span class="number">0</span>;</span><br><span class="line">  va_list arg_ptr;</span><br><span class="line">  va_start(arg_ptr, fmt);</span><br><span class="line">  vsnprintf(buffer, USART3_REC_LEN + <span class="number">1</span>, fmt, arg_ptr);</span><br><span class="line">  <span class="keyword">while</span> ((i &lt; USART3_REC_LEN) &amp;&amp; (i &lt; <span class="built_in">strlen</span>(buffer))) &#123;</span><br><span class="line">    USART_SendData(USART3, (u8)buffer[i++]);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(arg_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化并启动 USART3 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* GPIO端口设置 */</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  USART_InitTypeDef USART_InitStructure;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);                           <span class="comment">// 使能 USART3 所在的 GPIOA 时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);                          <span class="comment">// 使能串口 RCC 时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USART3 发送引脚 PA9/USART3_TX 配置 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;                                 <span class="comment">// 推挽输出</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*USART3 接收引脚 PA10/USART3_RX 配置*/</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;                           <span class="comment">// 浮空输入</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 USART3 的 NVIC 向量中断控制器 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">3</span>;                       <span class="comment">// 设置抢占优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;                              <span class="comment">// 设置子优先级 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                                 <span class="comment">// 使能 IRQ 通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);                                                 <span class="comment">// 始化 NVIC 寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 USART3 设置 */</span></span><br><span class="line">  USART_InitStructure.USART_BaudRate = bound;                                     <span class="comment">// 一般设置为 9600;</span></span><br><span class="line">  USART_InitStructure.USART_WordLength = USART_WordLength_8b;                     <span class="comment">// 字长为 8 位数据格式</span></span><br><span class="line">  USART_InitStructure.USART_StopBits = USART_StopBits_1;                          <span class="comment">// 一个停止位</span></span><br><span class="line">  USART_InitStructure.USART_Parity = USART_Parity_No;                             <span class="comment">// 不使用奇偶校验位</span></span><br><span class="line">  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">// 不使用硬件数据流控制</span></span><br><span class="line">  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;                 <span class="comment">// 设置收发模式</span></span><br><span class="line">  USART_Init(USART3, &amp;USART_InitStructure);                                       <span class="comment">// 初始化串口</span></span><br><span class="line">  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);                                  <span class="comment">// 开启 ENABLE 或者关闭 DISABLE 中断</span></span><br><span class="line">  USART_Cmd(USART3, ENABLE);                                                      <span class="comment">// 串口使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART3 串口中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 Res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123;</span><br><span class="line">    Res = USART_ReceiveData(USART3);                       <span class="comment">// 读取接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span> (Res == <span class="string">&#x27;S&#x27;</span>) &#123;                                      <span class="comment">// 判断数据是否为S，即 STOP</span></span><br><span class="line">      USART3_RX_STA = <span class="number">1</span>;                                   <span class="comment">// 如果为 STOP 则标志位置为 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Res == <span class="string">&#x27;K&#x27;</span>) &#123;                               <span class="comment">// 判断数据是否为K，即 OK</span></span><br><span class="line">      USART3_RX_STA = <span class="number">2</span>;                                   <span class="comment">// 如果为 OK 则标志位置为 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="usart-接收">USART 接收</h3>
<p>单片机接收数据主要有<strong>中断</strong>和<strong>查询</strong>两种方式，本实验工程基于上一步
USART 数据发送的代码。</p>
<h4 id="查询方式">查询方式</h4>
<p>采用查询方式实现 USART
串口数据的接收，这里的查询是指在主循环中不断的检测数据接收标志位，如果标志位为<code>1</code>就表示接收到了串口数据，然后再来对接收到的数据进行处理。</p>
<h5 id="main.c-7">main.c</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟配置</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>); <span class="comment">// 使用波特率为参数初始化 USART1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以查询方式接收 USART 数据，参数 USART1 是待查询的串口，参数 USART_FLAG_RXNE 表示待查询的串口数据接收寄存器非空标志位 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET) &#123;</span><br><span class="line">      a = USART_ReceiveData(USART1);                             <span class="comment">// 读取接收到的数据</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a);                                           <span class="comment">// 返回接收到的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delay_ms(1000);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="usart.c-1">usart.c</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1</span></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, DISABLE); <span class="comment">// 关闭串口中断，避免 USART 接收到数据时自动跳转至中断函数</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="中断方式">中断方式</h4>
<p>查询方式实现比较简单，但是多任务处理时需要等待主函数查询标志位，实时性较差。为了解决这个问题，需要使用中断方式进行串口数据的接收。</p>
<h5 id="usart.c-2">usart.c</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1</span></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">// 开启串口中断，当串口接收到数据时自动跳转到串口中断服务函数 USART1_IRQHandler</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART1 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  u8 a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USART_GetITStatus 是库函数提供的中断标志位判断函数，参数 USART_IT_RXNE 表示接收中断 */</span></span><br><span class="line">  <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)&#123;</span><br><span class="line">    a =USART_ReceiveData(USART1);               <span class="comment">// 读取接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);                             <span class="comment">// 将接收到的数据返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="usart-控制-led">USART 控制 LED</h3>
<h4 id="main.c-8">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 配置时钟</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化 按键</span></span><br><span class="line">  BUZZER_Init();       <span class="comment">// 初始化 蜂鸣器</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>); <span class="comment">// 初始化 串口</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 采用查询方式接收，需要关闭 usart.c 当中的串口中断 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET) &#123;</span><br><span class="line">      a = USART_ReceiveData(USART1);                  <span class="comment">// 读取接收到的数据</span></span><br><span class="line">      <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// 控制 LED</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c:LED1 OFF &quot;</span>, a);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 控制 LED</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c:LED1 ON &quot;</span>, a);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        BUZZER_BEEP1();                               <span class="comment">// 蜂鸣器响一声</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c:BUZZER &quot;</span>, a);                      <span class="comment">// 将接收到的数据返回给发送方</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按键控制 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;       <span class="comment">// 读按键接口的电平</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                    <span class="comment">// 延时 20ms 去除抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;     <span class="comment">// 读取按键状态</span></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)); <span class="comment">// 等待按键松开</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;KEY1 &quot;</span>); <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY2)) &#123;       <span class="comment">// 读取按键状态</span></span><br><span class="line">      delay_ms(<span class="number">20</span>);                                    <span class="comment">// 去除抖动</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY2)) &#123;     <span class="comment">// 去除抖动</span></span><br><span class="line">        <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY2)); <span class="comment">// 等待按键松开</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;KEY2 &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  delay_ms(1000); //延时</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="usart.c-3">usart.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1</span></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, DISABLE); <span class="comment">// 关闭串口中断，避免 USART 接收到数据时自动跳转至中断函数</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="终端-usart-控制-led">终端 USART 控制 LED</h3>
<h4 id="main.c-9">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration();</span><br><span class="line">  LED_Init();             <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();             <span class="comment">// 初始化 按键</span></span><br><span class="line">  BUZZER_Init();          <span class="comment">// 初始化 蜂鸣器</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>);    <span class="comment">// 初始化 串口</span></span><br><span class="line">  USART1_RX_STA = <span class="number">0xC000</span>; <span class="comment">// 初始值设置为回车键按下的状态，使启动时可以自动显示菜单</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果接收状态标志位为 0xC000，则表示已经接收到数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART1_RX_STA &amp; <span class="number">0xC000</span>) &#123;</span><br><span class="line">      <span class="comment">/* 直接按下回车键，将会重新展示功能菜单 */</span></span><br><span class="line">      <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;47;33m\r\n&quot;</span>);                        <span class="comment">// 设置颜色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1y--开LED1灯      1n--关LED1灯 \r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2y--开LED2灯      2n--关LED2灯 \r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 请输入控制指令，按回车键执行！ \033[0m\r\n&quot;</span>); <span class="comment">// 将颜色恢复到默认值，并且切换到下一行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断终端输入的是否为 2 个字符，输入的第 1 个字符是否为&quot;1&quot;，第 2 个字符是否为&quot;y&quot; */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">2</span> &amp;&amp; USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; USART1_RX_BUF[<span class="number">1</span>] == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">        GPIO_SetBits(LEDPORT, LED1);        <span class="comment">// 点亮 LED1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1y -- LED1灯已经点亮！\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断终端输入的是否为 2 个字符，输入的第 1 个字符是否为&quot;1&quot;，第 2 个字符是否为&quot;n&quot; */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">2</span> &amp;&amp; USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; USART1_RX_BUF[<span class="number">1</span>] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">        GPIO_ResetBits(LEDPORT, LED1);      <span class="comment">// 熄灭 LED1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1n -- LED1灯已经熄灭！\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断终端输入的是否为 2 个字符，输入的第 1 个字符是否为&quot;2&quot;，第 2 个字符是否为&quot;y&quot; */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">2</span> &amp;&amp; USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; USART1_RX_BUF[<span class="number">1</span>] == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">        GPIO_SetBits(LEDPORT, LED2);        <span class="comment">// 点亮 LED2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2y -- LED2灯已经点亮！\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断终端输入的是否为 2 个字符，输入的第 1 个字符是否为&quot;2&quot;，第 2 个字符是否为&quot;n&quot; */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">2</span> &amp;&amp; USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; USART1_RX_BUF[<span class="number">1</span>] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">        GPIO_ResetBits(LEDPORT, LED2);      <span class="comment">// 熄灭 LED2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2n -- LED2灯已经熄灭！\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果以上条件都不成立，就打印一个指令错误提示信息 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指令错误！\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      USART1_RX_STA = <span class="number">0</span>;                    <span class="comment">// 将接收状态标志位清零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="usart.c-4">usart.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1</span></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);       <span class="comment">// 打开串口中断，当串口接收到数据时自动跳转至串口中断服务函数</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART1 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 Res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USART_GetITStatus 是库函数提供的中断标志位判断函数，参数 USART_IT_RXNE 表示当前为接收中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123;</span><br><span class="line">    Res = USART_ReceiveData(USART1);                   <span class="comment">// 将接收到的数据存放至 Res</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, Res);                                 <span class="comment">// 将接收到的数据 Res 返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果接收未完成 */</span></span><br><span class="line">    <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x8000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果接收到 0x0d */</span></span><br><span class="line">      <span class="keyword">if</span> (USART1_RX_STA &amp; <span class="number">0x4000</span>) &#123;</span><br><span class="line">        <span class="comment">/* 回车键是由 0x0a/换行与 0x0d/回车两个 ASCII 码组合而成 */</span></span><br><span class="line">        <span class="keyword">if</span> (Res != <span class="number">0x0a</span>)</span><br><span class="line">          USART1_RX_STA = <span class="number">0</span>;                           <span class="comment">// 接收数据错误，状态位清零，重新开始接收</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          USART1_RX_STA |= <span class="number">0x8000</span>;                     <span class="comment">// 状态变量的最高位置 1 ，接收完成</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果未接收到 0x0d */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果按下回车，0x0d 表示 ASCII 码的回车键，*/</span></span><br><span class="line">        <span class="keyword">if</span> (Res == <span class="number">0x0d</span>)</span><br><span class="line">          USART1_RX_STA |= <span class="number">0x4000</span>;                     <span class="comment">// 将状态标志位的最高位的第 2 位置 1，该标志位用于标记串口是否接收到回车键</span></span><br><span class="line">        <span class="comment">/* 如果按下的并不是回车，那么执行下面程序 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          USART1_RX_BUF[USART1_RX_STA &amp; <span class="number">0X3FFF</span>] = Res; <span class="comment">// 将接收到的数据存放到全局变量数组当中，USART1_RX_STA &amp; 0X3FFF 表示要存放的数组索引位置</span></span><br><span class="line">          USART1_RX_STA++;                             <span class="comment">// 数据长度自增 1</span></span><br><span class="line">          <span class="keyword">if</span> (USART1_RX_STA &gt; (USART1_REC_LEN - <span class="number">1</span>))</span><br><span class="line">            USART1_RX_STA = <span class="number">0</span>;                         <span class="comment">// 如果读取的数据超出限定长度，那么状态标志位置 0，重新开始接收</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="rtc-实时时钟">RTC 实时时钟</h2>
<p>STM32F103 的备份寄存器可以保存<code>20 Byte</code>的用户数据，而且与
RTC 实时时钟一样独立工作，并不会被系统、电源等复位方式复位。RTC
拥有多个时钟源输入，可以使用外部的<code>32.768KHz</code>晶振配合 20
位预分频器产生一个 1 秒的时间基准信号。</p>
<p>STM32 的 RTC 实时时钟使用一个 32 位计数器（可计时 136
年）进行计时，计时的起始基准时间为 Unix
的<code>1970年1月1日 0时0分0秒</code>。如果要读取当前的时间值，可以先读取
32 位的 RTC 计数值，然后以前面的 Unix
时间作为起点，加上计数器中的秒数，再换算为年月日时分秒格式，即可得到当前的实时时间。</p>
<p>本实验继续延用前面的工程项目，但是向<strong>Basic</strong>文件夹添加了<code>rtc.c</code>和<code>rtc.h</code>两个文件，并引入了<code>stm32f10x_rtc.c</code>库文件。实验电路中的<strong>LED1</strong>以秒为单位，当秒数值为奇数时
LED 点亮，为偶数时 LED
熄灭，<strong>LED2</strong>以分钟为单位，当分钟值为奇数时 LED
点亮，为偶数时 LED 熄灭。</p>
<h3 id="led-间隔-1-秒分-闪烁">LED 间隔 1 秒/分 闪烁</h3>
<h4 id="main.c-10">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RTC_Config();        <span class="comment">// 初始化实时时钟</span></span><br><span class="line"></span><br><span class="line">  LED_Init();             <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();             <span class="comment">// 初始化 按键</span></span><br><span class="line">  BUZZER_Init();          <span class="comment">// 初始化 蜂鸣器</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>);    <span class="comment">// 初始化串口，参数为波特率</span></span><br><span class="line">  USART1_RX_STA = <span class="number">0xC000</span>; <span class="comment">// 初始值设置为回车，从而展示选项菜单</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取时间值，并判断返回值是否为 0，非 0 时表示读取错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (RTC_Get() == <span class="number">0</span>) &#123;</span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED1, (BitAction)(rsec % <span class="number">2</span>)); <span class="comment">// 控制 LED1，将RTC读取的秒钟值除以 2，秒数为奇数时 LED1 输出高电平点亮，为偶数时输出低电平熄灭，从而达到间隔 1 秒亮灭闪烁的效果</span></span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED2, (BitAction)(rmin % <span class="number">2</span>)); <span class="comment">// 控制 LED2，同样的原理，LED2 以分钟为单位进行点亮和熄灭</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rtc.h">rtc.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/rtc/rtc.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用 extern 关键字声明全局变量，用于存放时钟的年、月、日、时、分、秒结果 */</span></span><br><span class="line"><span class="keyword">extern</span> u16 ryear;</span><br><span class="line"><span class="keyword">extern</span> u8 rmon, rday, rhour, rmin, rsec, rweek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由于 RTC 同时使用了主电源和备用电池两种方式供电，所以这里定义了两个不同的配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_First_Config</span><span class="params">(<span class="type">void</span>)</span>;                                      <span class="comment">// 备用电池断开，RTC 内部数据丢失，进行首次上电配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由用户直接调用的函数，先初始化，然后进行读写 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Config</span><span class="params">(<span class="type">void</span>)</span>;                                            <span class="comment">//  备用电池未断开，进行基本初始化，维持基本走时即可</span></span><br><span class="line">u8 <span class="title function_">RTC_Get</span><span class="params">(<span class="type">void</span>)</span>;                                                 <span class="comment">// 读取当前时间，并保存到上面声明的全局变量当中</span></span><br><span class="line">u8 <span class="title function_">RTC_Set</span><span class="params">(u16 syear, u8 smon, u8 sday, u8 hour, u8 min, u8 sec)</span>; <span class="comment">// 设置时间，将参数所传递的时间转换为32位 RTC 计数器值</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">Is_Leap_Year</span><span class="params">(u16 year)</span>;                                        <span class="comment">// 判断是否为闰年</span></span><br><span class="line">u8 <span class="title function_">RTC_Get_Week</span><span class="params">(u16 year, u8 month, u8 day)</span>;                      <span class="comment">// 基于年、月、日来计算星期数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="rtc.c">rtc.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/rtc/rtc.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存放时钟结果的全局变量 */</span></span><br><span class="line">u16 ryear;                               <span class="comment">// 4 位的年</span></span><br><span class="line">u8 rmon, rday, rhour, rmin, rsec, rweek; <span class="comment">// 2 位的月、日、时、分、秒、周</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首次启用 RTC 时的设置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_First_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); <span class="comment">// 启用 PWR 和 BKP 的时钟</span></span><br><span class="line">  PWR_BackupAccessCmd(ENABLE);                                             <span class="comment">// 解锁 RTC 与备用寄存器访问</span></span><br><span class="line">  BKP_DeInit();                                                            <span class="comment">// 复位备用寄存器为默认值</span></span><br><span class="line">  RCC_LSEConfig(RCC_LSE_ON);                                               <span class="comment">// 启用外部 32.768KHZ 晶振</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET); <span class="comment">// 等待晶振稳定工作</span></span><br><span class="line">  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);              <span class="comment">// RTC 时钟源配置为 LSE，即 32.768KHz 外部低速晶振</span></span><br><span class="line">  RCC_RTCCLKCmd(ENABLE);                               <span class="comment">// 启动 RTC</span></span><br><span class="line"></span><br><span class="line">  RTC_WaitForSynchro();    <span class="comment">// 等待 APB1 时钟与 RTC 时钟同步</span></span><br><span class="line">  RTC_WaitForLastTask();   <span class="comment">// 读写寄存器之前确认之前操作已经结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分频值计算公式：RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767 + 1) */</span></span><br><span class="line">  RTC_SetPrescaler(<span class="number">32767</span>); <span class="comment">// 设置 RTC 分频器，从而自动将 RTC 时钟转换为 1Hz，即每秒计数 1 次，</span></span><br><span class="line">  RTC_WaitForLastTask();   <span class="comment">// 等待寄存器写入完成</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不需要使用 RTC 秒中断，可以屏蔽下面 2 条语句 */</span></span><br><span class="line">  <span class="comment">// RTC_ITConfig(RTC_IT_SEC, ENABLE); // 秒中断使能，即每间隔 1 秒触发一次 RTC 中断</span></span><br><span class="line">  <span class="comment">// RTC_WaitForLastTask();            // 等待寄存器写入完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 RTC 实时时钟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 预先向后备寄存器 1 存放了一个特殊字符 0xA5A5，通过读取并判断该字符是否存在，可以得知 RTC 当前是否属于首次上电，如果是则需要重新对其进行配置 */</span></span><br><span class="line">  <span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>) &#123;</span><br><span class="line">    RTC_First_Config();                       <span class="comment">// 重新配置RTC</span></span><br><span class="line">    BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>); <span class="comment">// 配置完成以后，重新向后备寄存器写入特殊字符 0xA5A5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*  如果后备寄存器未掉电，则无需重新配置 RTC */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 调用 RCC_GetFlagStatus() 函数判断当前的复位类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET) &#123;</span><br><span class="line">      <span class="comment">// 上电复位后执行的内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET) &#123;</span><br><span class="line">      <span class="comment">// 外部 RST 引脚复位后执行的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RCC_ClearFlag();       <span class="comment">// 清除 RCC 当中的复位标志</span></span><br><span class="line">    RCC_RTCCLKCmd(ENABLE); <span class="comment">// 虽然无需进行 RTC 配置，且其掉电后依靠后备电池正常运行，但是每次上电以后依然要重新使能 RTCCLK</span></span><br><span class="line">    RTC_WaitForSynchro();  <span class="comment">// 等待 APB1 时钟与 RTC 时钟同步</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不需要使用 RTC 秒中断，可以屏蔽下面 2 条语句 */</span></span><br><span class="line">    <span class="comment">// RTC_ITConfig(RTC_IT_SEC, ENABLE); // 秒中断使能，即每间隔 1 秒触发一次 RTC 中断</span></span><br><span class="line">    <span class="comment">// RTC_WaitForLastTask();            // 等待寄存器写入完成</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 是否启动 RTC 的输出功能，通常不会使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTCClockOutput_Enable</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line">  PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">  BKP_TamperPinCmd(DISABLE);</span><br><span class="line">  BKP_RTCOutputConfig(BKP_RTCOutputSource_CalibClock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RTC 实时时钟 1 秒触发中断函数，需要启用 RTC 秒中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (RTC_GetITStatus(RTC_IT_SEC) != RESET) &#123;</span><br><span class="line">    <span class="comment">// 将进入秒中断以后需要执行的程序放置在此处</span></span><br><span class="line">  &#125;</span><br><span class="line">  RTC_ClearITPendingBit(RTC_IT_SEC);</span><br><span class="line">  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 闹钟中断处理函数，需要启用闹钟中断，并且调高优先级使用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTCAlarm_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (RTC_GetITStatus(RTC_IT_ALR) != RESET) &#123;</span><br><span class="line">    <span class="comment">// 将进入闹钟中断以后需要执行的程序放置在此处</span></span><br><span class="line">  &#125;</span><br><span class="line">  RTC_ClearITPendingBit(RTC_IT_ALR);</span><br><span class="line">  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 闰年判断函数，参数 year 是输入的年份，返回 1 说明是闰年，返回 0 说明不是 */</span></span><br><span class="line">u8 <span class="title function_">Is_Leap_Year</span><span class="params">(u16 year)</span> &#123;</span><br><span class="line">  <span class="comment">/* 闰年判断的计算公式 */</span></span><br><span class="line">  <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 月份相关的数据表 */</span></span><br><span class="line">u8 <span class="type">const</span> table_week[<span class="number">12</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;            <span class="comment">// 月修正数据表</span></span><br><span class="line"><span class="type">const</span> u8 mon_table[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;; <span class="comment">// 平年月份日期表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 RTC 实时时间，参数以 1970 年 1 月 1 日为基准，在 1970 ~ 2099 年范围内有效，返回 0 表示成功，返回其它表示错误 */</span></span><br><span class="line">u8 <span class="title function_">RTC_Set</span><span class="params">(u16 syear, u8 smon, u8 sday, u8 hour, u8 min, u8 sec)</span> &#123;</span><br><span class="line">  u16 t;</span><br><span class="line">  u32 seccount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将传入参数转换为 RTC 计数器值的转换算法 */</span></span><br><span class="line">  <span class="keyword">if</span> (syear &lt; <span class="number">2000</span> || syear &gt; <span class="number">2099</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">// 参数 syear 的取值范围在 1970 ~ 2099，此处将判断范围设定为 2000 ~ 2099</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 累加所有年份的秒数 */</span></span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">1970</span>; t &lt; syear; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Is_Leap_Year(t))</span><br><span class="line">      seccount += <span class="number">31622400</span>;                 <span class="comment">// 闰年秒钟数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      seccount += <span class="number">31536000</span>;                 <span class="comment">// 平年秒钟数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  smon -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; smon; t++) &#123;</span><br><span class="line">    seccount += (u32)mon_table[t] * <span class="number">86400</span>;  <span class="comment">// 将前面月份的秒钟数累加</span></span><br><span class="line">    <span class="keyword">if</span> (Is_Leap_Year(syear) &amp;&amp; t == <span class="number">1</span>)</span><br><span class="line">      seccount += <span class="number">86400</span>;                    <span class="comment">// 闰年 2 月份增加一天时的秒钟数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  seccount += (u32)(sday - <span class="number">1</span>) * <span class="number">86400</span>;      <span class="comment">// 将前面日期的秒钟数相加</span></span><br><span class="line">  seccount += (u32)hour * <span class="number">3600</span>;             <span class="comment">// 小时的秒钟数</span></span><br><span class="line">  seccount += (u32)min * <span class="number">60</span>;                <span class="comment">// 分钟的秒钟数</span></span><br><span class="line">  seccount += sec;                          <span class="comment">// 最后的秒钟数</span></span><br><span class="line"></span><br><span class="line">  RTC_First_Config();                       <span class="comment">// 重置 RTC 时钟</span></span><br><span class="line">  BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>); <span class="comment">// 重新将识别符 0xA5A5 写入后备寄存器</span></span><br><span class="line">  RTC_SetCounter(seccount);                 <span class="comment">// 将转换算后的计数器值写入 RTC 计数器</span></span><br><span class="line">  RTC_WaitForLastTask();                    <span class="comment">// 等待寄存器写入完成</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 RTC 实时时间，返回 0 表示成功 */</span></span><br><span class="line">u8 <span class="title function_">RTC_Get</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u16 daycnt = <span class="number">0</span>;</span><br><span class="line">  u32 timecount = <span class="number">0</span>;</span><br><span class="line">  u32 temp = <span class="number">0</span>;</span><br><span class="line">  u16 temp1 = <span class="number">0</span>;</span><br><span class="line">  timecount = RTC_GetCounter();</span><br><span class="line">  temp = timecount / <span class="number">86400</span>;                   <span class="comment">// 得到秒钟数对应的天数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果超过 1 天 */</span></span><br><span class="line">  <span class="keyword">if</span> (daycnt != temp) &#123;</span><br><span class="line">    daycnt = temp;</span><br><span class="line">    temp1 = <span class="number">1970</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">365</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果是闰年 */</span></span><br><span class="line">      <span class="keyword">if</span> (Is_Leap_Year(temp1)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">366</span>)</span><br><span class="line">          temp -= <span class="number">366</span>;                        <span class="comment">// 闰年秒钟数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          temp1++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果是平年 */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        temp -= <span class="number">365</span>;</span><br><span class="line">      temp1++;</span><br><span class="line">    &#125;</span><br><span class="line">    ryear = temp1;                             <span class="comment">// 获取年份</span></span><br><span class="line">    temp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">28</span>) &#123;                       <span class="comment">// 超过了一个月</span></span><br><span class="line">      <span class="keyword">if</span> (Is_Leap_Year(ryear) &amp;&amp; temp1 == <span class="number">1</span>) &#123; <span class="comment">// 当年是否为闰年</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">29</span>)</span><br><span class="line">          temp -= <span class="number">29</span>;                          <span class="comment">// 闰年秒钟数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= mon_table[temp1])</span><br><span class="line">          temp -= mon_table[temp1];             <span class="comment">// 平年秒钟数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      temp1++;</span><br><span class="line">    &#125;</span><br><span class="line">    rmon = temp1 + <span class="number">1</span>;                           <span class="comment">// 获取月份</span></span><br><span class="line">    rday = temp + <span class="number">1</span>;                            <span class="comment">// 获取日期</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  temp = timecount % <span class="number">86400</span>;                     <span class="comment">// 获取全部秒钟数</span></span><br><span class="line">  rhour = temp / <span class="number">3600</span>;                          <span class="comment">// 获取小时</span></span><br><span class="line">  rmin = (temp % <span class="number">3600</span>) / <span class="number">60</span>;                    <span class="comment">// 获取分钟</span></span><br><span class="line">  rsec = (temp % <span class="number">3600</span>) % <span class="number">60</span>;                    <span class="comment">// 获取秒钟</span></span><br><span class="line">  rweek = RTC_Get_Week(ryear, rmon, rday);      <span class="comment">// 获取星期值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据传入的年、月、日参数，计算出相应的星期值，允许时间范围为 1901-2099 年，该函数由 RTC_Get() 调用 */</span></span><br><span class="line">u8 <span class="title function_">RTC_Get_Week</span><span class="params">(u16 year, u8 month, u8 day)</span> &#123;</span><br><span class="line">  u16 temp2;</span><br><span class="line">  u8 yearH, yearL;</span><br><span class="line">  yearH = year / <span class="number">100</span>;</span><br><span class="line">  yearL = year % <span class="number">100</span>;</span><br><span class="line">  <span class="comment">/* 如果传入的年份数据位于 21 世纪，那么年份数加 100 */</span></span><br><span class="line">  <span class="keyword">if</span> (yearH &gt; <span class="number">19</span>)</span><br><span class="line">    yearL += <span class="number">100</span>;</span><br><span class="line">  <span class="comment">/* 闰年数只计算 1900 年之后的 */</span></span><br><span class="line">  temp2 = yearL + yearL / <span class="number">4</span>;</span><br><span class="line">  temp2 = temp2 % <span class="number">7</span>;</span><br><span class="line">  temp2 = temp2 + day + table_week[month - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (yearL % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; month &lt; <span class="number">3</span>)</span><br><span class="line">    temp2--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (temp2 % <span class="number">7</span>);  <span class="comment">// 返回由 0 ~ 6 表示的星期值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="终端日历程序">终端日历程序</h3>
<p>本示例基于上一步实验的工程文件，仅在<code>main()</code>函数开始位置定义了一个
8
位变量<code>bya</code>，然后在主函数的<code>while()</code>循环当中，加入了串口识别以及
RTC
操作相关的代码，最后在<code>usart.c</code>初始化代码的尾部使能了串口中断。</p>
<h4 id="main.c-11">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 bya;</span><br><span class="line">  RCC_Configuration();    <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  RTC_Config();           <span class="comment">// 初始化 实时时钟</span></span><br><span class="line">  LED_Init();             <span class="comment">// 初始化 LED</span></span><br><span class="line">  KEY_Init();             <span class="comment">// 初始化 按键</span></span><br><span class="line">  BUZZER_Init();          <span class="comment">// 初始化 蜂鸣器</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>);    <span class="comment">// 初始化 串口</span></span><br><span class="line">  USART1_RX_STA = <span class="number">0xC000</span>; <span class="comment">// 初始值设置为回车键按下的状态，使启动时可以自动显示菜单</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 标志位为 0xC000 表示数据接收完成，可以开始进行处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART1_RX_STA &amp; <span class="number">0xC000</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 按下回车键显示功能菜单 */</span></span><br><span class="line">      <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取时间值，同时判断返回值是否为 0，不为 0 读取的值是错误的 */</span></span><br><span class="line">        <span class="keyword">if</span> (RTC_Get() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; RTC 实时时钟测试程序   \r\n&quot;</span>);</span><br><span class="line">          <span class="comment">/*  打印日期时间 */</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; 现在实时时间：%d-%d-%d %d:%d:%d  &quot;</span>, ryear, rmon, rday, rhour, rmin, rsec);</span><br><span class="line">          <span class="comment">/*  打印星期时间 */</span></span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期日   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期一   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期二   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期三   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">4</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期四   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期五   \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (rweek == <span class="number">6</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;星期六   \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; 按下回车键更新时间，输入字母 C 初始化时钟 \r\n&quot;</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; 设置时间，格式为 20170806120000，并按回车键确定 \r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;读取失败\r\n&quot;</span>);                     <span class="comment">// 时钟读取错误时打印提示信息</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断接收数据的数量是否为 2 个 */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 通过判断数组的起始位是否为 &#x27;c&#x27; 或 &#x27;C&#x27; 来判断当前是否按下 C 键 */</span></span><br><span class="line">        <span class="keyword">if</span> (USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> || USART1_RX_BUF[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">          RTC_First_Config();                        <span class="comment">// 重新初始化实时时钟</span></span><br><span class="line">          BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);  <span class="comment">// 配置完成以后，将标识字符 0xA5A5 写入后备寄存器</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;初始化成功！      \r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;指令错误！        \r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 判断接收数据的数量是否为 14 个，表示接收到的是重新设置 RTC 时间的操作 */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((USART1_RX_STA &amp; <span class="number">0x3FFF</span>) == <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="comment">/* 将终端发送来的数据转换并写入 RTC，可以通过减去 0x30 得到十进制的 0 ~ 9 数据 */</span></span><br><span class="line">        ryear = (USART1_RX_BUF[<span class="number">0</span>] - <span class="number">0x30</span>) * <span class="number">1000</span> + (USART1_RX_BUF[<span class="number">1</span>] - <span class="number">0x30</span>) * <span class="number">100</span> + (USART1_RX_BUF[<span class="number">2</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">3</span>] - <span class="number">0x30</span>;</span><br><span class="line">        rmon = (USART1_RX_BUF[<span class="number">4</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">5</span>] - <span class="number">0x30</span>;</span><br><span class="line">        rday = (USART1_RX_BUF[<span class="number">6</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">7</span>] - <span class="number">0x30</span>;</span><br><span class="line">        rhour = (USART1_RX_BUF[<span class="number">8</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">9</span>] - <span class="number">0x30</span>;</span><br><span class="line">        rmin = (USART1_RX_BUF[<span class="number">10</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">11</span>] - <span class="number">0x30</span>;</span><br><span class="line">        rsec = (USART1_RX_BUF[<span class="number">12</span>] - <span class="number">0x30</span>) * <span class="number">10</span> + USART1_RX_BUF[<span class="number">13</span>] - <span class="number">0x30</span>;</span><br><span class="line">        bya = RTC_Set(ryear, rmon, rday, rhour, rmin, rsec);  <span class="comment">// 将结果写入 RTC 计数器，并将返回值赋予 bya 变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bya == <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;写入成功！      \r\n&quot;</span>);  <span class="comment">// 显示写入成功</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;写入失败！      \r\n&quot;</span>);  <span class="comment">// 显示写入失败</span></span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指令错误！        \r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      USART1_RX_STA = <span class="number">0</span>;        <span class="comment">// 串口接收状态标志位清零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="usart.c-5">usart.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/usart/usart.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1</span></span><br><span class="line"><span class="comment">/* 初始化并启动 USART1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(u32 bound)</span> &#123;</span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">// 传入 ENABLE 使能了串口中断</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="rcc-复位与时钟控制器">RCC 复位与时钟控制器</h2>
<p>RCC 是复位和时钟控制器（Reset Clock
Control）的英文缩写，用于设置单片机的复位以及系统时钟的分配（选择输入的时钟源），上面的实验程序开头部分都会调用到
RCC 设置函数。</p>
<h3 id="rtc.c-1">rtc.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/rtc/rtc.c  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_First_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;                                              <span class="comment">// 首次启用RTC的设置</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); <span class="comment">// 启用 PWR 和 BKP 的时钟</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">  RCC_LSEConfig(RCC_LSE_ON);                                               <span class="comment">// 启用外部 32.768KHZ 晶振</span></span><br><span class="line">  <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);                     <span class="comment">// 等待晶振稳定工作</span></span><br><span class="line">  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);                                  <span class="comment">// RTC 时钟源配置为 LSE，即 32.768KHz 外部低速晶振</span></span><br><span class="line">  RCC_RTCCLKCmd(ENABLE);                                                   <span class="comment">// 启动 RTC</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-12">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration();  <span class="comment">// 初始化 RCC 系统时钟，配置时钟输入源</span></span><br><span class="line">  <span class="comment">/* ...... 省略 ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys.c">sys.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/sys/sys.c */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RCC时钟的设置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ErrorStatus HSEStartUpStatus;</span><br><span class="line">  RCC_DeInit();                               <span class="comment">// 将 RCC 寄存器设置为默认值</span></span><br><span class="line">  RCC_HSEConfig(RCC_HSE_ON);                  <span class="comment">// 使能外部高速晶振</span></span><br><span class="line">  HSEStartUpStatus = RCC_WaitForHSEStartUp(); <span class="comment">// 等待外部高速晶振使能完成，并获取其状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HSEStartUpStatus == SUCCESS) &#123;</span><br><span class="line">    <span class="comment">/* 设置 PLL 时钟源以及倍频系数</span></span><br><span class="line"><span class="comment">       参数 RCC_PLLSource_HSE_Div1 表示使用的 PLL 类型为外部晶振不除以 2 方式；</span></span><br><span class="line"><span class="comment">       参数 RCC_PLLMul_x 表示要设置的倍频系数为 9，即 PLLCLK = 72MHZ */</span></span><br><span class="line">    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 AHB 总线时钟 HCLK，主要负责外部存储器时钟，参数 RCC_SYSCLK_Div1 是 AHB 总线的分频系数，设置为 1 表示不分频，即等于 72MHz */</span></span><br><span class="line">    RCC_HCLKConfig(RCC_SYSCLK_Div1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 APB1(负责DA、USB、SPI、I2C、CAN、USART2/3/4/5、普通定时器) 与 APB2(负责AD、GPIO、高级定时器、USART1) 总线的时钟 */</span></span><br><span class="line">    RCC_PCLK1Config(RCC_HCLK_Div2); <span class="comment">// 设置 APB1 总线时钟为 2 分频，即 PCLK1 = HCLK ÷ 2 = 36MHz</span></span><br><span class="line">    RCC_PCLK2Config(RCC_HCLK_Div1); <span class="comment">// 设置 APB2 总线时钟为 1 分频，即 PCLK2 = HCLK = 72MHz</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 Flash 存储器延时时钟的周期数值 */</span></span><br><span class="line">    FLASH_SetLatency(FLASH_Latency_2);                    <span class="comment">// 单片机频率为 0~24MHz 时设置为 Latency_0；为 24~48MHz 时设置为 Latency_1；为 48~72MHz 时设置为 Latency_2</span></span><br><span class="line">    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class="comment">// 开启 Flash 功能的预取缓存模式，预取缓存是指将需要使用的数据，提前从 Flash 中读取并存放至 SRAM 当中</span></span><br><span class="line"></span><br><span class="line">    RCC_PLLCmd(ENABLE); <span class="comment">// 锁相环倍频器 PLL 使能</span></span><br><span class="line">    <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);  <span class="comment">// 等待 PLL 进入稳定工作状态</span></span><br><span class="line">    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);            <span class="comment">// 将系统时钟源 SYSCLK 设置为 PLL</span></span><br><span class="line">    <span class="keyword">while</span> (RCC_GetSYSCLKSource() != <span class="number">0x08</span>)</span><br><span class="line">      ; <span class="comment">// 等待 SYSCLK 时钟源切换 PLL 并进入稳定状态</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设备外设时钟，通常将这些代码放置到该功能的初始化函数当中 */</span></span><br><span class="line">  <span class="comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE);</span></span><br><span class="line">  <span class="comment">// RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);</span></span><br><span class="line">  <span class="comment">// RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);</span></span><br><span class="line">  <span class="comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);</span></span><br><span class="line">  <span class="comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ttp223-触摸按键">TTP223 触摸按键</h2>
<p><strong>TTP223</strong>是一款单通道电容触摸按键检测芯片，工作电压在<code>2.0V ~ 5.5V</code>范围之间，灵敏度可由<code>0 ~ 50pF</code>的外部电容进行调节。</p>
<p><img src="/Embedded/STM32F103/touch-key/diagram.png"></p>
<p>上面电路图当中，触摸按键<strong>TTP223_1</strong>、<strong>TTP223_2</strong>、<strong>TTP223_3</strong>、<strong>TTP223_4</strong>经过
P10 跳线座，分别连接到 STM32 的
<strong>PA0</strong>、<strong>PA1</strong>、<strong>PA2</strong>、<strong>PA3</strong>四个引脚，并且中间并联了一枚
LED
指示灯以及限流电阻。按键电路上<code>15pF</code>的<strong>C3</strong>电容用来进行灵敏度调节，而<strong>C4</strong>则属于滤波电容。</p>
<p><img src="/Embedded/STM32F103/touch-key/TTP223.png"></p>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 8%">
<col style="width: 4%">
<col style="width: 82%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">编号</th>
<th style="text-align: left;">名称</th>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;"><strong>Q</strong></td>
<td>O</td>
<td>触摸按键的输出管脚</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;"><strong>VSS</strong></td>
<td>P</td>
<td>电源负极接地端</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;"><strong>I</strong></td>
<td>IO</td>
<td>传感器输入，连接至金属触摸按键上面</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: left;"><strong>AHLB</strong></td>
<td>I-PL</td>
<td>选择输出电平，默认为<code>1</code>表示低电平有效，如果为<code>0</code>表示高电平有效</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: left;"><strong>VDD</strong></td>
<td>P</td>
<td>电源正极输入引脚</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: left;"><strong>TOG</strong></td>
<td>I-PL</td>
<td>输出类型选择，默认为高电平<code>1</code>触发模式（即带有按键锁存），如果为<code>0</code>表示直接模式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong>TTP223
电容触摸芯片在上电瞬间，会读取感测电极的电容状态，并以此作为按键没有按下时的初始状态；因此，上电的一瞬间手指不能放置到按键上面。</p>
</blockquote>
<h3 id="单击控制核心板-led">单击控制核心板 LED</h3>
<h4 id="main.c-13">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化 LED</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化 按键</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 读触摸按键 A 的电平状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>));           <span class="comment">// 控制 LED，无需按键去抖处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读触摸按键 B 的电平状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>));           <span class="comment">// LED 控制，无需按键去抖处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读触摸按键 B 的电平状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>));    <span class="comment">// LED 控制，无需按键去抖处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读触摸按键 B 的电平状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">1</span>));    <span class="comment">// LED 控制，无需按键去抖处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="touch_key.h">touch_key.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/TOUCH_KEY/touch_key.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TOUCH_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TOUCH_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_KEYPORT GPIOA <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_KEY_A GPIO_Pin_0 <span class="comment">// 定义 GPIO 接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_KEY_B GPIO_Pin_1 <span class="comment">// 定义 GPIO 接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_KEY_C GPIO_Pin_2 <span class="comment">// 定义 GPIO 接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_KEY_D GPIO_Pin_3 <span class="comment">// 定义 GPIO 接口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TOUCH_KEY_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 触摸按键初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="touch_key.c">touch_key.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/TOUCH_KEY/touch_key.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 触摸按键初始化函数  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TOUCH_KEY_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;                                                 <span class="comment">// 定义 GPIO 初始化枚举结构</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = TOUCH_KEY_A | TOUCH_KEY_B | TOUCH_KEY_C | TOUCH_KEY_D; <span class="comment">// 选择 GPIO 端口</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;                                        <span class="comment">// 选择 GPIO 接口工作方式为上拉输入</span></span><br><span class="line">  GPIO_Init(TOUCH_KEYPORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双击长按控制核心板-led">双击/长按控制核心板 LED</h3>
<p>本实验项目沿用上面的源代码，未进行目录结构上的任何修改，仅在<code>main.c</code>文件当中添加了<code>#define KEYA_SPEED1 100</code>和<code>#define KEYA_SPEED2 10</code>两条用于区分长按与双击时间的宏定义语句，下面是触摸按键单击、双击、长按时产生的信号时序示意图：</p>
<p><img src="/Embedded/STM32F103/touch-key/sequence.png"></p>
<h4 id="main.c-14">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYA_SPEED1 100 <span class="comment">// 定义长按的时间长度(单位为 10ms)，即 100 * 10ms = 1秒，当按键按下的时间持续 1 秒钟以后就认为是长按</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYA_SPEED2 10  <span class="comment">// 定义双击的时间长度(单位为 20ms)，即 10 * 20ms = 200毫秒，即第一次按键放开之后，如果 200ms 以内还有按键按下，就认为是双击</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a = <span class="number">0</span>, b, c = <span class="number">0</span>;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化 LED</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化 按键</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断触摸按键 A 是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>);                                              <span class="comment">// 为了让程序兼容核心板上的按键 K1，这里调用了去抖函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断长短按键 */</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">        <span class="comment">/* 循环进行长按状态的判断，如果 c &lt; 100，这里 KEYA_SPEED1 为上面宏定义的值 100 */</span></span><br><span class="line">        <span class="keyword">while</span> ((!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &amp;&amp; c &lt; KEYA_SPEED1) &#123;</span><br><span class="line">          c++;</span><br><span class="line">          delay_ms(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 长按处理代码，如果 c &gt;= 100 */</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= KEYA_SPEED1) &#123;</span><br><span class="line">          GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>));          <span class="comment">// 点亮 LED1</span></span><br><span class="line">          <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 单击处理代码 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* 首先判断双击，如果 b &lt; 10，这里 KEYA_SPEED2 为上面宏定义的值 10 */</span></span><br><span class="line">          <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; KEYA_SPEED2; b++) &#123;</span><br><span class="line">            delay_ms(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">              a = <span class="number">1</span>;</span><br><span class="line">              GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>));      <span class="comment">// 点亮 LED2</span></span><br><span class="line">              <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 然后判断单击 */</span></span><br><span class="line">          <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>)); <span class="comment">// 将 LED1 和 LED2 全部熄灭</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">0</span>; c = <span class="number">0</span>;   <span class="comment">// 参数清零，确保下次判断时 2 个参数都恢复为初始值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动控制-led">滑动控制 LED</h3>
<p>需要进行滑动操作的 A、B、C、D
四个触摸按键间距必须足够的小，才会呈现出<code>A - AB - B - BC - C - CD - D</code>的滑动轨迹，而非仅仅被识别为
4 次点击操作。</p>
<p><img src="/Embedded/STM32F103/touch-key/sliding-sequence.png"></p>
<p>本实验项目同样基于上一步代码进行修改，引入了<code>#include "usart.h"</code>串口操作相关的头文件，便于在<code>main.c</code>当中将滑动操作的轨迹打印到
USART 串口上面。</p>
<h4 id="main.c-15">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYA_SPEED1 100 <span class="comment">// 定义长按的时间长度(单位为 10ms)，即 100 * 10ms = 1秒，当按键按下的时间持续 1 秒钟以后就认为是长按</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYA_SPEED2 10  <span class="comment">// 定义双击的时间长度(单位为 20ms)，即 10 * 20ms = 200毫秒，即第一次按键放开之后，如果 200ms 以内还有按键按下，就认为是双击</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 k = <span class="number">1000</span>;        <span class="comment">// 用于滑动计数的变量，即串口终端上看到的计数值</span></span><br><span class="line">  u8 a = <span class="number">0</span>, b, c = <span class="number">0</span>;</span><br><span class="line">  u8 s = <span class="number">0</span>;            <span class="comment">// 定义用于判断是否刚结束完滑动的标志位</span></span><br><span class="line"></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>); <span class="comment">// 初始化 串口</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化 LED</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化 按键</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 触摸按键 A 处理程序，先检测按键是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>); <span class="comment">// 按键消抖</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断长短键 */</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &amp;&amp; c &lt; KEYA_SPEED1) &#123;</span><br><span class="line">          c++;</span><br><span class="line">          delay_ms(<span class="number">10</span>); <span class="comment">// 长按计时</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 长按处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= KEYA_SPEED1) &#123;</span><br><span class="line">          <span class="comment">// 长按后执行的程序放到此处</span></span><br><span class="line">          GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED1</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;A键长按 \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)); <span class="comment">// 等待按键 A 放开</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 单击处理 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* 判断当 A 键按下之后，按键 B 是否被按下，如果被按下就说明当前为滑动操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;A键右滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚刚完成滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 判断是否为双击 */</span></span><br><span class="line">          <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; KEYA_SPEED2; b++) &#123;</span><br><span class="line">              delay_ms(<span class="number">20</span>);</span><br><span class="line">              <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A键双击 \r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断是否为单击 */</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">/* 判断是否刚执行完滑动操作，如果是则属于滑动的放开操作，本次不需要进行单击处理 */</span></span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* 如果不是则正常执行单击处理 */</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>)); <span class="comment">// 将 LED1 和 LED2 全部熄灭</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A键单击 \r\n&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">0</span>; c = <span class="number">0</span>; <span class="comment">// 参数清零，确保下次判断时 2 个参数都恢复为初始值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触摸按键 B 处理程序，先检测按键是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>); <span class="comment">// 按键消抖</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断长短键 */</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &amp;&amp; c &lt; KEYA_SPEED1) &#123;</span><br><span class="line">          c++;</span><br><span class="line">          delay_ms(<span class="number">10</span>); <span class="comment">// 长按计时</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 长按处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= KEYA_SPEED1) &#123;</span><br><span class="line">          <span class="comment">// 长按后执行的程序放到此处</span></span><br><span class="line">          GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED1</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;B键长按 \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)); <span class="comment">// 等待按键 B 放开</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 单击处理 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* 判断当 B 键按下之后，按键 C 是否被按下，如果被按下就说明当前为右滑操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;B键右滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚执行完滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 判断当 B 键按下之后，按键 A 是否被按下，如果被按下就说明当前为左滑操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;B键左滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚执行完滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 判断是否为双击 */</span></span><br><span class="line">          <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; KEYA_SPEED2; b++) &#123;</span><br><span class="line">              delay_ms(<span class="number">20</span>);</span><br><span class="line">              <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;B键双击 \r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断是否为单击 */</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">/* 判断是否刚执行完滑动操作，如果是则属于滑动的放开操作，本次不需要进行单击处理 */</span></span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* 如果不是则正常执行单击处理 */</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>)); <span class="comment">// 将 LED1 和 LED2 全部熄灭</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;B键单击 \r\n&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">0</span>; c = <span class="number">0</span>; <span class="comment">// 参数清零，确保下次判断时 2 个参数都恢复为初始值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触摸按键 C 处理程序，先检测按键是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>); <span class="comment">// 按键消抖</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断长短键 */</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &amp;&amp; c &lt; KEYA_SPEED1) &#123;</span><br><span class="line">          c++;</span><br><span class="line">          delay_ms(<span class="number">10</span>); <span class="comment">// 长按计时</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 长按处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= KEYA_SPEED1) &#123;</span><br><span class="line">          <span class="comment">// 长按后执行的程序放到此处</span></span><br><span class="line">          GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED1</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;C键长按 \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)); <span class="comment">// 等待按键 C 放开</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 单击处理 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* 判断当 C 键按下之后，按键 D 是否被按下，如果被按下就说明当前为右滑操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;C键右滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚执行完滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 判断当 C 键按下之后，按键 B 是否被按下，如果被按下就说明当前为左滑操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;C键左滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚执行完滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 判断是否为双击 */</span></span><br><span class="line">          <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; KEYA_SPEED2; b++) &#123;</span><br><span class="line">              delay_ms(<span class="number">20</span>);</span><br><span class="line">              <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;C键双击 \r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断是否为单击 */</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">/* 判断是否刚执行完滑动操作，如果是则属于滑动的放开操作，本次不需要进行单击处理 */</span></span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* 如果不是则正常执行单击处理 */</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>)); <span class="comment">// 将 LED1 和 LED2 全部熄灭</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;C键单击 \r\n&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">0</span>; c = <span class="number">0</span>; <span class="comment">// 参数清零，确保下次判断时 2 个参数都恢复为初始值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触摸按键 D 处理程序，先检测按键是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>); <span class="comment">// 按键消抖</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断长短键 */</span></span><br><span class="line">      <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &amp;&amp; c &lt; KEYA_SPEED1) &#123;</span><br><span class="line">          c++;</span><br><span class="line">          delay_ms(<span class="number">10</span>); <span class="comment">// 长按计时</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 长按处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= KEYA_SPEED1) &#123;</span><br><span class="line">          <span class="comment">// 长按后执行的程序放到此处</span></span><br><span class="line">          GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED1</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;D键长按 \r\n&quot;</span>);</span><br><span class="line">          <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)); <span class="comment">// 等待按键 D 放开</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 单击处理 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 判断当 D 键按下之后，按键 C 是否被按下，如果被按下就说明当前为左滑操作 */</span></span><br><span class="line">          <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">            k++; <span class="comment">// 用于显示的计数值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;D键左滑 %d \r\n&quot;</span>, k);</span><br><span class="line">            a = <span class="number">1</span>; s = <span class="number">1</span>; <span class="comment">// 变量 a 是单双击判断标志位，变量 s 是刚执行完滑动的标志位，赋值以后程序流程就不再进入双击与单击的判断</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 判断是否为双击 */</span></span><br><span class="line">          <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; KEYA_SPEED2; b++) &#123;</span><br><span class="line">              delay_ms(<span class="number">20</span>);</span><br><span class="line">              <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED2, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;D键双击 \r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断是否为单击 */</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">/* 判断是否刚执行完滑动操作，如果是则属于滑动的放开操作，本次不需要进行单击处理 */</span></span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* 如果不是则正常执行单击处理 */</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                GPIO_WriteBit(LEDPORT, LED1 | LED2, (BitAction)(<span class="number">0</span>)); <span class="comment">// 将 LED1 和 LED2 全部熄灭</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;D键单击 \r\n&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">0</span>; c = <span class="number">0</span>; <span class="comment">// 参数清零，确保下次判断时 2 个参数都恢复为初始值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tm1640-驱动共阴极数码管">TM1640 驱动共阴极数码管</h2>
<p>TM1640 由深圳天威电子推出的一款数码管专用驱动控制芯片，采用 SOP28
形式封装，并使用 5V 工作电压。</p>
<p><img src="/Embedded/STM32F103/digital-tube/tm1640.png"></p>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 8%">
<col style="width: 10%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>引脚名称</th>
<th style="text-align: center;">引脚编号</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DIN</td>
<td>数据输入</td>
<td style="text-align: center;">7</td>
<td>串行数据输入，输入数据在 SCLK 的低电平变化，在 SCLK
的高电平被传输</td>
</tr>
<tr class="even">
<td>SCLK</td>
<td>时钟输入</td>
<td style="text-align: center;">8</td>
<td>在上升沿输入数据</td>
</tr>
<tr class="odd">
<td>SEG1~SEG8</td>
<td>输出【段】</td>
<td style="text-align: center;">9~16</td>
<td>段输出，P 管开漏输出</td>
</tr>
<tr class="even">
<td>GRID1~GRID11 和 GRID12~GRID16</td>
<td>输出【位】</td>
<td style="text-align: center;">1~5 和 18~28</td>
<td>位输出，N 管开漏输出</td>
</tr>
<tr class="odd">
<td>VDD</td>
<td>逻辑电源</td>
<td style="text-align: center;">17</td>
<td>接电源正</td>
</tr>
<tr class="even">
<td>VSS</td>
<td>逻辑地</td>
<td style="text-align: center;">6</td>
<td>接系统地</td>
</tr>
</tbody>
</table>
<p><strong>STM32F103C8T6</strong>的通过两线式通信接口与<strong>TM1640</strong>进行连接，当时钟信号<strong>CLK</strong>为高电平时，数据信号<strong>DIN</strong>保持不变；仅当<strong>CLK</strong>为低电平时<strong>DIN</strong>的信号才会发生改变，数据传输时总是<strong>低位在前，高位在后</strong>。数据输入的开始条件为<strong>CLK</strong>为高时
<strong>DIN</strong>由高变低负跳变；结束条件是<strong>CLK</strong>为高时<strong>DIN</strong>由低向高正跳变，指令传输的时序图如下：</p>
<p><img src="/Embedded/STM32F103/digital-tube/sequence.png"></p>
<p>TM1640
的数据线<strong>DIN</strong>和时钟同步线<strong>SCLK</strong>引脚通过跳线帽<strong>P9</strong>连接至
STM32 的<strong>PA11</strong>和<strong>PA12</strong>引脚，其第 17 脚和 6
脚分别连接至 5V
电源与<strong>GND</strong>，并在回路上串接了<strong>C1</strong>和<strong>C2</strong>两枚滤波电容；<strong>GR1</strong>至<strong>GR8</strong>引脚则各自连接到共阴极数码管的位选端上，<strong>SEG1</strong>至<strong>SEG8</strong>引脚则连接至段选端。另外，电路中
8 枚独立 LED 的负极分别连接至 TM1640 的第 26
脚，正极则分别连接至<strong>SEG1</strong>至<strong>SEG8</strong>引脚。</p>
<p><img src="/Embedded/STM32F103/digital-tube/diagram.png"></p>
<h3 id="main.c-16">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TM1640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 c = <span class="number">0x01</span>;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  RTC_Config();        <span class="comment">// 初始化 RTC</span></span><br><span class="line">  TM1640_Init();       <span class="comment">// 初始化 TM1640</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RTC_Get() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 调用 TM1640 显示函数，用于显示天数，后面加 10 是为了点亮小数点 */</span></span><br><span class="line">      TM1640_display(<span class="number">0</span>, rday / <span class="number">10</span>);</span><br><span class="line">      TM1640_display(<span class="number">1</span>, rday % <span class="number">10</span> + <span class="number">10</span>);</span><br><span class="line">      <span class="comment">/* 调用 TM1640 显示函数，用于显示小时，后面加 10 是为了点亮小数点 */</span></span><br><span class="line">      TM1640_display(<span class="number">2</span>, rhour / <span class="number">10</span>);</span><br><span class="line">      TM1640_display(<span class="number">3</span>, rhour % <span class="number">10</span> + <span class="number">10</span>);</span><br><span class="line">      <span class="comment">/* 调用 TM1640 显示函数，用于显示分钟，后面加 10 是为了点亮小数点 */</span></span><br><span class="line">      TM1640_display(<span class="number">4</span>, rmin / <span class="number">10</span>);</span><br><span class="line">      TM1640_display(<span class="number">5</span>, rmin % <span class="number">10</span> + <span class="number">10</span>);</span><br><span class="line">      <span class="comment">/* 调用 TM1640 显示函数，用于显示秒数，后面加 10 是为了点亮小数点 */</span></span><br><span class="line">      TM1640_display(<span class="number">6</span>, rsec / <span class="number">10</span>);</span><br><span class="line">      TM1640_display(<span class="number">7</span>, rsec % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      TM1640_led(c); <span class="comment">// 高电平点亮与 TM1640 连接的 8 位独立 LED</span></span><br><span class="line"></span><br><span class="line">      c &lt;&lt;= <span class="number">1</span>;       <span class="comment">// 通过对局部变量 c 进行左移操作，实现出流水灯效果</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x00</span>)</span><br><span class="line">        c = <span class="number">0x01</span>;    <span class="comment">// 局部变量 c 左移操作结束之后，让 c 恢复默认值，从而达到反复显示流水灯的效果</span></span><br><span class="line">      delay_ms(<span class="number">125</span>); <span class="comment">// 通过延时函数来决定流水灯的速度</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tm1640.h">TM1640.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/TM1640/TM1640.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TM1640_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TM1640_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TM1640 所使用的 GPIO 端口 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640_GPIOPORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640_SCLK GPIO_Pin_11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640_DIN GPIO_Pin_12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640_LEDPORT 0xC8 <span class="comment">// 定义连接到 TM1640 的 8 个独立 LED 操作地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_Init</span><span class="params">(<span class="type">void</span>)</span>;                       <span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_led</span><span class="params">(u8 date)</span>;                     <span class="comment">// 8 个独立 LED 驱动函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_display</span><span class="params">(u8 address, u8 date)</span>;     <span class="comment">// 数码管显示函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_display_add</span><span class="params">(u8 address, u8 date)</span>; <span class="comment">// 数码管显示函数，自有自动累加 1 功能</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="tm1640.c">TM1640.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/TM1640/TM1640.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TM1640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL 1                                                     <span class="comment">// 如果数码管显示不稳定，可以增大这个数值，从而减慢通信速度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址模式的设置 */</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_ADD 0x40                                    // 地址自动加 1 模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640MEDO_ADD 0x44                                       <span class="comment">// 固定地址模式，推荐使用该模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示亮度，0x80 可以关闭显示，0x88、0x89、0x8a、0x8b、0x8c、0x8d、0x8e、0x8f 分别对应的脉冲宽度为 1/16、2/16、4/16、10/16、11/16、12/16、13/16、14/16 */</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x88                                // 最小亮度</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x89</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x8a</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x8b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640MEDO_DISPLAY 0x8c                                   <span class="comment">// 推荐亮度</span></span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x8d</span></span><br><span class="line"><span class="comment">// #define TM1640MEDO_DISPLAY 0x8f                                // 最大亮度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TM1640MEDO_DISPLAY_OFF 0x80                               <span class="comment">// 关闭显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通信时序，启动 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_start</span><span class="params">()</span> &#123;</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">1</span>));     <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">1</span>));    <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">  delay_us(DEL);</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">0</span>));     <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">  delay_us(DEL);</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">0</span>));    <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">  delay_us(DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通信时序，结束 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_stop</span><span class="params">()</span> &#123;</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">0</span>));     <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">1</span>));    <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">  delay_us(DEL);</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">1</span>));     <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">  delay_us(DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通信时序，写数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_write</span><span class="params">(u8 date)</span> &#123; <span class="comment">//</span></span><br><span class="line">  u8 i;</span><br><span class="line">  u8 aa;</span><br><span class="line">  aa = date;</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">0</span>));     <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">0</span>));    <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">0</span>));  <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">    delay_us(DEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">      GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">1</span>)); <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">      delay_us(DEL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">0</span>)); <span class="comment">// 引脚输出低电平 0</span></span><br><span class="line">      delay_us(DEL);</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">1</span>));  <span class="comment">// 引脚输出高电平 1</span></span><br><span class="line">    delay_us(DEL);</span><br><span class="line">    aa = aa &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">0</span>));     <span class="comment">// 引脚输出 0</span></span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">0</span>));    <span class="comment">// 引脚输出 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TM1640 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = TM1640_DIN | TM1640_SCLK;         <span class="comment">// 选择 GPIO 端口号</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                <span class="comment">// 设置为推挽输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;               <span class="comment">// 设置 GPIO 接口速度为 50MHz</span></span><br><span class="line">  GPIO_Init(TM1640_GPIOPORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将两个 GPIO 默认初始为高电平 1 */</span></span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(<span class="number">1</span>));</span><br><span class="line">  GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  TM1640_start();</span><br><span class="line">  TM1640_write(TM1640MEDO_ADD);                                   <span class="comment">// 设置固定地址还是自动加 1 模式</span></span><br><span class="line">  TM1640_stop();</span><br><span class="line">  TM1640_start();</span><br><span class="line">  TM1640_write(TM1640MEDO_DISPLAY);                               <span class="comment">// 设置显示亮度</span></span><br><span class="line">  TM1640_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 个独立 LED 控制函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_led</span><span class="params">(u8 date)</span> &#123;</span><br><span class="line">  TM1640_start();</span><br><span class="line">  TM1640_write(TM1640_LEDPORT);</span><br><span class="line">  TM1640_write(date);</span><br><span class="line">  TM1640_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 固定地址模式显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_display</span><span class="params">(u8 address, u8 date)</span> &#123;</span><br><span class="line">  <span class="comment">/* 数字 0 ~ 9 的显示段码表，每个数组元素分别对应 0 1 2 3 4 5 6 7 8 9 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 空 */</span></span><br><span class="line">  <span class="type">const</span> u8 buff[<span class="number">21</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0xbf</span>, <span class="number">0x86</span>, <span class="number">0xdb</span>, <span class="number">0xcf</span>, <span class="number">0xe6</span>, <span class="number">0xed</span>, <span class="number">0xfd</span>, <span class="number">0x87</span>, <span class="number">0xff</span>, <span class="number">0xef</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line">  TM1640_start();</span><br><span class="line">  TM1640_write(<span class="number">0xC0</span> + address);                                  <span class="comment">// 写入显示位置</span></span><br><span class="line">  TM1640_write(buff[date]);                                      <span class="comment">// 写入显示数据</span></span><br><span class="line">  TM1640_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址自动加 1 模式显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TM1640_display_add</span><span class="params">(u8 address, u8 date)</span> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  <span class="comment">/* 数字 0 ~ 9 的显示段码表，每个数组元素分别对应 0 1 2 3 4 5 6 7 8 9 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 空 */</span></span><br><span class="line">  <span class="type">const</span> u8 buff[<span class="number">21</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0xbf</span>, <span class="number">0x86</span>, <span class="number">0xdb</span>, <span class="number">0xcf</span>, <span class="number">0xe6</span>, <span class="number">0xed</span>, <span class="number">0xfd</span>, <span class="number">0x87</span>, <span class="number">0xff</span>, <span class="number">0xef</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line">  TM1640_start();</span><br><span class="line">  TM1640_write(<span class="number">0xC0</span> + address);                                  <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    TM1640_write(buff[date]);</span><br><span class="line">  &#125;</span><br><span class="line">  TM1640_stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ec11-旋转编码器">EC11 旋转编码器</h2>
<p>实验电路中所使用的 EC11
旋转编码器，旋转一圈产生的脉冲次数为<strong>20</strong>次（<em>即旋转
360° 需要经过 20
个位格</em>），且向下按压时可作为开关使用，最大工作电压为<code>5V</code>，最大工作电流为<code>10mA</code>，其内部等效原理图如下所示：</p>
<p><img src="/Embedded/STM32F103/rotary-encoder/sketch.png"></p>
<p>当按下旋钮时，开关<strong>K1</strong>闭合，导通第<strong>1</strong>和<strong>2</strong>引脚；当旋转旋钮时，开关<strong>K2</strong>和<strong>K3</strong>以一定的先后顺序导通，通过两者的导通顺序就可以判断旋转方向和旋转的隔断数，如下是旋钮分别向左和向右旋转时，开关<strong>K2</strong>和<strong>K3</strong>产生的时序差异比较图：</p>
<p><img src="/Embedded/STM32F103/rotary-encoder/sequence.png"></p>
<blockquote>
<p><strong>注意：</strong>由于旋转编码器内部采用的是机械式微动开关，旋钮旋转过一个隔断会产生一个低电平触发，此时会在该低电平触发的下降沿和上升沿产生约<code>2ms</code>左右的按键抖动。</p>
</blockquote>
<p><img src="/Embedded/STM32F103/rotary-encoder/diagram.png"></p>
<p>电路图当中，将 EC11
旋转编码器的第<strong>1</strong>和<strong>4</strong>引脚连接至<strong>GND</strong>，而第<strong>2</strong>、<strong>3</strong>、<strong>5</strong>脚通过跳线帽<strong>P8</strong>连接至
STM32F103
的<strong>PA6</strong>、<strong>PA7</strong>、<strong>PB2</strong>引脚，此时只需要将<strong>GPIO</strong>设置为上拉电阻输入方式，就可以在<strong>K1</strong>、<strong>K2</strong>、<strong>K3</strong>任何一个开关闭合导通时，向
GPIO 端口输入低电平，从而通过这 3 个 GPIO 读取到了旋转编码器内部 3
个微动开关的状态。</p>
<h3 id="main.c-17">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TM1640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">//主程序</span></span><br><span class="line">  u8 a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0x01</span>;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RTC_Config();        <span class="comment">// 初始化 RTC 实时时钟</span></span><br><span class="line">  ENCODER_Init();      <span class="comment">// 初始化 旋转编码器</span></span><br><span class="line">  TM1640_Init();       <span class="comment">// 初始化 TM1640</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数码管 8 位的显示内容，其中前 2 位显示变量 a 的十位和个位 */</span></span><br><span class="line">  TM1640_display(<span class="number">0</span>, a / <span class="number">10</span>);</span><br><span class="line">  TM1640_display(<span class="number">1</span>, a % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数码管其它位保持熄灭状态 */</span></span><br><span class="line">  TM1640_display(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">4</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">7</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    b = ENCODER_READ(); <span class="comment">// 读取旋转编码器的当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 b 等于 1，说明当前为向右旋转 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">      a++;</span><br><span class="line">      <span class="keyword">if</span> (a &gt; <span class="number">99</span>)</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 b 等于 2，说明当前为向左旋转 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">      a--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 b 等于 3，就表示旋钮按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">3</span>)</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果存在旋转操作，就调用数码管显示变量 a 的十位和个位 */</span></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">      TM1640_display(<span class="number">0</span>, a / <span class="number">10</span>);</span><br><span class="line">      TM1640_display(<span class="number">1</span>, a % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="encoder.h">encoder.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/ENCODER/encoder.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义旋钮旋转控制对应的 3 个 GPIO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_PORT_A GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_L GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_D GPIO_Pin_7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义旋钮按下导通对应的 1 个 GPIO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_PORT_B GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_R GPIO_Pin_2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ENCODER_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">ENCODER_READ</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="encoder.c">encoder.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/ENCODER/encoder.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encoder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 KUP;  <span class="comment">// 编码器旋钮卡死标志位，如果旋钮处于卡死状态则置 1，如果未发生卡死则清零</span></span><br><span class="line">u16 cou; <span class="comment">// 卡死状态的循环计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 旋转编码器初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ENCODER_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">// 定义GPIO的初始化枚举结构</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 PA 引脚上的 2 个 GPIO，并配置为上拉电阻输入方式 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = ENCODER_L | ENCODER_D;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_Init(ENCODER_PORT_A, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 PB 引脚上的 1 个 GPIO，并配置为上拉电阻输入方式 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = ENCODER_R;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_Init(ENCODER_PORT_B, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 旋转编码器状态读取函数，返回值为当前编码器的操作状态，如果为 1 表示右转，为 2 表示左转，为 3 表示按下 */</span></span><br><span class="line">u8 <span class="title function_">ENCODER_READ</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a; <span class="comment">// 存放按键的值</span></span><br><span class="line">  u8 kt;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断旋钮是否解除卡死 */</span></span><br><span class="line">  <span class="keyword">if</span> (GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L))</span><br><span class="line">    KUP = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断是否旋转旋钮，同时判断旋钮卡死标志位 */</span></span><br><span class="line">  <span class="keyword">if</span> (!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L) &amp;&amp; KUP == <span class="number">0</span>) &#123;</span><br><span class="line">    delay_us(<span class="number">100</span>);                                         <span class="comment">// 等待进入稳定状态</span></span><br><span class="line">    kt = GPIO_ReadInputDataBit(ENCODER_PORT_B, ENCODER_R); <span class="comment">// 读取 K3 开关的状态，并将其暂存至变量 kt</span></span><br><span class="line">    delay_ms(<span class="number">3</span>);                                           <span class="comment">// 消除微动开关机械抖动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新读取 K2 开关的状态，确定 K2 是否还依然处于低电平，如果是则表明状态有效 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 通过 K3 开关的状态判断当前是左转还是右转 */</span></span><br><span class="line">      <span class="keyword">if</span> (kt == <span class="number">0</span>) &#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 旋钮右转</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>; <span class="comment">// 旋钮左转</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cou = <span class="number">0</span>; <span class="comment">// 初始卡死判断计数器</span></span><br><span class="line">      <span class="comment">/* 循环判断 K2 对应的 GPIO 是否为低电平，如果旋钮发生卡死，则不会退出循环。与此同时，判断 cou 变量是否小于 60000，即旋钮隔断的时间是否小于 1.2 秒，一旦超出 1.2 秒之后则认为发生卡死并退出循环，从而避免由于旋钮卡死造成程序陷入死循环 */</span></span><br><span class="line">      <span class="keyword">while</span> (!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L) &amp;&amp; cou &lt; <span class="number">60000</span>) &#123;</span><br><span class="line">        cou++;        <span class="comment">// 等待放开旋钮，同时累加判断卡死</span></span><br><span class="line">        KUP = <span class="number">1</span>;      <span class="comment">// 标识当前旋钮处于卡死状态</span></span><br><span class="line">        delay_us(<span class="number">20</span>); <span class="comment">// 延时 20 × 60000 = 1.2秒</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断旋钮是否按下，同时判断旋钮卡死标志位 */</span></span><br><span class="line">  <span class="keyword">if</span> (!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_D) &amp;&amp; KUP == <span class="number">0</span>) &#123;</span><br><span class="line">    delay_ms(<span class="number">20</span>);             <span class="comment">// 机械式微动开头去抖</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次判断旋钮是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_D)) &#123;</span><br><span class="line">      a = <span class="number">3</span>;                  <span class="comment">// 旋钮按下时，变量 a 的值为 3</span></span><br><span class="line">      <span class="keyword">while</span> (ENCODER_D == <span class="number">0</span>); <span class="comment">// 如果需要等待旋钮松开，可以取消该条程序的注释</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a; <span class="comment">// 将 a 的值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>旋钮锁死是指旋钮停留在两个机械开关隔断之间的状态，卡死会造成
K2 和 K3 都处于低电平状态无法退出。</p>
</blockquote>
<h2 id="i²c-总线">I²C 总线</h2>
<h3 id="lm75a-温度传感器">LM75A 温度传感器</h3>
<p><strong>I²C</strong>总线属于两线制的通信连接方式，传输线路上需要使用<code>1kΩ ~ 10kΩ</code>范围阻值的上拉电阻，并且复用为
I²C 接口的 GPIO 引脚需要设置为<strong>复用开漏模式</strong>。由于 I²C
总线上，所有设备都连接到相同的<strong>数据线
SDA</strong>与<strong>时钟线
SCL</strong>，因此通过每个设备的唯一地址来加以区分，该地址由 7
位十六进制数组成，一条总线上最多可挂载 127 个设备。新版 I²C 规范增加了
10 位地址模式，可以容纳的设备数量达到了 1023 个。</p>
<p><strong>STM32F103C8T6</strong>拥有 2
组<strong>I²C</strong>总线接口，分别是由<strong>PB6</strong>和<strong>PB7</strong>组成的<strong>I²C1</strong>，由<strong>PB10</strong>和<strong>PB11</strong>组成的<strong>I²C2</strong>。其中，<strong>I²C1</strong>通过跳线帽<strong>P11</strong>串联<strong>R18</strong>和<strong>R19</strong>两枚<code>5.1kΩ</code>上拉电阻以后，连接至实验电路中的
OLED 液晶显示屏以及 LM75A 温度传感器。</p>
<p><img src="/Embedded/STM32F103/i2c/diagram-lm75a.png"></p>
<p><strong>LM75A</strong>是由恩智浦公司生产的一款温度传感器，一共拥有 8
个引脚，其中第 1 和 2 引脚分别连接至 I²C 总线的两条通信线路，第 3
脚是中断输出，第 4 和 8
脚分别是电源的<strong>VCC</strong>和<strong>GND</strong>，而第 5、6、7
引脚可以用来定义设备地址。</p>
<p><img src="/Embedded/STM32F103/i2c/lm75a.png"></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">引脚编号</th>
<th style="text-align: center;">引脚名称</th>
<th style="text-align: right;">功能说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>SDA</strong></td>
<td style="text-align: right;">串行数据输入输出。</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><strong>SCL</strong></td>
<td style="text-align: right;">串行时钟输入。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><strong>OS</strong></td>
<td style="text-align: right;">过热时中断输出。</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><strong>GND</strong></td>
<td style="text-align: right;">电源负极接地。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;"><strong>A2</strong></td>
<td style="text-align: right;">设备地址设置 2。</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;"><strong>A1</strong></td>
<td style="text-align: right;">设备地址设置 1。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;"><strong>A0</strong></td>
<td style="text-align: right;">设备地址设置 0。</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;"><strong>+Vs</strong></td>
<td style="text-align: right;">电源正极供电。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：实验程序中，会将 A0、A1、A2 这 3
位的值都置为<code>1</code>，由于前 4
位地址固定为<code>1001</code>，最低位读写位默认为 0，那么 LM75A
的设备地址应为：<code>1001 111 0 = 0x9E</code>。</p>
</blockquote>
<p>本实验以上一个项目作为模板修改完成，在<code>Basic</code>文件夹下加入<code>i2c.h</code>和<code>i2c.c</code>两个程序文件，然后在<code>Hardware</code>目录下添加了<code>lm75a.h</code>和<code>lm75a.c</code>两个源文件，最后将官方的<code>stm32f10x_i2c.c</code>库文件加入到<code>Lib</code>目录。</p>
<h4 id="main.c-18">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TM1640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lm75a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 buffer[<span class="number">3</span>];</span><br><span class="line">  u8 c = <span class="number">0x01</span>;</span><br><span class="line">  RCC_Configuration();    <span class="comment">// 初始化 系统时钟</span></span><br><span class="line">  I2C_Configuration();    <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  TM1640_Init();          <span class="comment">// 初始化 TM1640</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化显示内容 */</span></span><br><span class="line">  TM1640_display(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">4</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">  TM1640_display(<span class="number">7</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    LM75A_GetTemp(buffer); <span class="comment">// 将 LM75A 获取的温度数据读取到变量 buffer</span></span><br><span class="line"></span><br><span class="line">    TM1640_display(<span class="number">0</span>, buffer[<span class="number">1</span>] / <span class="number">10</span>);      <span class="comment">// 温度值整数部分十位</span></span><br><span class="line">    TM1640_display(<span class="number">1</span>, buffer[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">10</span>); <span class="comment">// 温度值整数部分个位</span></span><br><span class="line">    TM1640_display(<span class="number">2</span>, buffer[<span class="number">2</span>] / <span class="number">10</span>);      <span class="comment">// 温度值小数部分十位</span></span><br><span class="line">    TM1640_display(<span class="number">3</span>, buffer[<span class="number">2</span>] % <span class="number">10</span>);      <span class="comment">// 温度值小数部分个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 点亮与 TM1640 数码管相连的 8 枚独立 LED，并呈现流水灯效果 */</span></span><br><span class="line">    TM1640_led(c);</span><br><span class="line">    c &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x00</span>)</span><br><span class="line">      c = <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">150</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="i2c.h">i2c.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/i2c/i2c.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __I2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __I2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 I²C 总线需要使用的 GPIO 引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CPORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA GPIO_Pin_7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HostAddress 0xc0 <span class="comment">// STM32F103C8T6 作为 I²C 总线主设备的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BusSpeed 200000  <span class="comment">// 总线速度过高，可能会出现通信数据出错卡死的情况，建议不高于 400000</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Configuration</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SEND_BUFFER</span><span class="params">(u8 SlaveAddr, u8 WriteAddr, u8 *pBuffer, u16 NumByteToWrite)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SEND_BYTE</span><span class="params">(u8 SlaveAddr, u8 writeAddr, u8 pBuffer)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_READ_BUFFER</span><span class="params">(u8 SlaveAddr, u8 readAddr, u8 *pBuffer, u16 NumByteToRead)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_READ_BYTE</span><span class="params">(u8 SlaveAddr, u8 readAddr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="i2c.c">i2c.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/i2c/i2c.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I²C 初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">//</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE); <span class="comment">// 配置 GPIO 相关的时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); <span class="comment">// 启动 I2C 功能</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = I2C_SCL | I2C_SDA;     <span class="comment">// 选择 GPIO 端口</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;      <span class="comment">// 选择 GPIO 工作方式为复用开漏输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    <span class="comment">// 设置 GPIO 传输速度</span></span><br><span class="line">  GPIO_Init(I2CPORT, &amp;GPIO_InitStructure);             <span class="comment">// 将设置写入 GPIO 初始化程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I²C 配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">  I2C_GPIO_Init();                                                          <span class="comment">// 初始化 GPIO</span></span><br><span class="line">  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;                                <span class="comment">// 设置为 I²C 模式</span></span><br><span class="line">  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">  I2C_InitStructure.I2C_OwnAddress1 = HostAddress;                          <span class="comment">// 主设备地址</span></span><br><span class="line">  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;                               <span class="comment">// 允许应答</span></span><br><span class="line">  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; <span class="comment">// 设备为 7 位地址模式</span></span><br><span class="line">  I2C_InitStructure.I2C_ClockSpeed = BusSpeed;                              <span class="comment">// 设置 I²C 总线速度</span></span><br><span class="line">  I2C_Init(I2C1, &amp;I2C_InitStructure);</span><br><span class="line">  I2C_Cmd(I2C1, ENABLE);                                                    <span class="comment">// 开启 I²C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 I²C 总线发送多个字节数据，参数 SlaveAddr 是目标设备地址，参数 WriteAddr 表示向该设备哪个地址写入数据，参数 pBuffer 为待发送的数据，参数 NumByteToWrite 为写入数据的数量 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SEND_BUFFER</span><span class="params">(u8 SlaveAddr, u8 WriteAddr, u8 *pBuffer, u16 NumByteToWrite)</span> &#123;</span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE);                                           <span class="comment">// 产生起始位</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));               <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Transmitter);           <span class="comment">// 发送设备地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_SendData(I2C1, WriteAddr);                                             <span class="comment">// 发送需要写入数据的目标设备地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));          <span class="comment">// 等待完成</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环发送多个数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (NumByteToWrite--) &#123;</span><br><span class="line">    I2C_SendData(I2C1, *pBuffer);                                            <span class="comment">// 发送数据</span></span><br><span class="line">    pBuffer++;                                                               <span class="comment">// 待写入数据的指针地址自增 1</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));        <span class="comment">// 等待完成</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_GenerateSTOP(I2C1, ENABLE);                                            <span class="comment">//产生停止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 I²C 总线发送 1 个字节数据，参数 SlaveAddr 是目标设备地址，参数 WriteAddr 表示向该设备哪个地址写入数据，参数 pBuffer 为待发送的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SEND_BYTE</span><span class="params">(u8 SlaveAddr, u8 writeAddr, u8 pBuffer)</span> &#123;</span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE);                                           <span class="comment">// 发送开始信号</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));               <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Transmitter);           <span class="comment">// 发送目标设备地址，并设置为发送者模式</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_SendData(I2C1, writeAddr);                                             <span class="comment">// 该设备需要写入数据的地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));          <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_SendData(I2C1, pBuffer);                                               <span class="comment">// 发送待写入的内容</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));          <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_GenerateSTOP(I2C1, ENABLE);                                            <span class="comment">// 发送结束信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 I²C 总线读取多个字节的数据，参数 SlaveAddr 为从设备地址，参数 readAddr 为从设备上待读取的地址，参数 pBuffer 为读取数据所存放的指针，参数 NumByteToRead 为待读取的字节数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_READ_BUFFER</span><span class="params">(u8 SlaveAddr, u8 readAddr, u8 *pBuffer, u16 NumByteToRead)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));</span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE);                                            <span class="comment">// 发送开始信号</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));                <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Transmitter);            <span class="comment">// 写入器件地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));  <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Cmd(I2C1, ENABLE);</span><br><span class="line">  I2C_SendData(I2C1, readAddr);                                               <span class="comment">// 发送从设备上待读取的地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));           <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE); <span class="comment">//开启信号</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));                <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Receiver);               <span class="comment">// 发送从设备地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));     <span class="comment">// 等待完成</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环读取多个数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (NumByteToRead) &#123;</span><br><span class="line">    <span class="comment">/* 如果读取到的是最后 1 个数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (NumByteToRead == <span class="number">1</span>) &#123;</span><br><span class="line">      I2C_AcknowledgeConfig(I2C1, DISABLE);                                   <span class="comment">// 读取最后 1 个数据时关闭应答位</span></span><br><span class="line">      I2C_GenerateSTOP(I2C1, ENABLE);                                         <span class="comment">// 发送停止位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 正常读取数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)) &#123;</span><br><span class="line">      *pBuffer = I2C_ReceiveData(I2C1);                                       <span class="comment">// 将数据读取出到 pBuffer 指针</span></span><br><span class="line">      pBuffer++;                                                              <span class="comment">// 读取数据指针 pBuffer 自增 1</span></span><br><span class="line">      NumByteToRead--;                                                        <span class="comment">// 待读取字节数自减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_AcknowledgeConfig(I2C1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 I²C 总线读取 1 个字节数据，参数 SlaveAddr 为从设备地址，参数 readAddr 为从设备上待读取的地址 */</span></span><br><span class="line">u8 <span class="title function_">I2C_READ_BYTE</span><span class="params">(u8 SlaveAddr, u8 readAddr)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));                            <span class="comment">// 判断总线是否繁忙，空闲后开始执行后续代码</span></span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE);                                           <span class="comment">// 发起始信号</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));               <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Transmitter);           <span class="comment">// 发送从设备地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Cmd(I2C1, ENABLE);                                                     <span class="comment">// 开启 I²C1</span></span><br><span class="line">  I2C_SendData(I2C1, readAddr);                                              <span class="comment">// 发送从设备上待读取的地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));          <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_GenerateSTART(I2C1, ENABLE);                                           <span class="comment">// 允许 I²C 从设备产生开始信号，让从设备可以向单片机主设备发送数据</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));               <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_Send7bitAddress(I2C1, SlaveAddr, I2C_Direction_Receiver);              <span class="comment">// 发送从设备地址</span></span><br><span class="line">  <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));    <span class="comment">// 等待完成</span></span><br><span class="line">  I2C_AcknowledgeConfig(I2C1, DISABLE);                                      <span class="comment">// 读取最后 1 个数据时关闭应答位</span></span><br><span class="line">  I2C_GenerateSTOP(I2C1, ENABLE);                                            <span class="comment">// 发送停止位</span></span><br><span class="line">  a = I2C_ReceiveData(I2C1);                                                 <span class="comment">// 将接收到的数据保存至变量 a</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lm75a.h">lm75a.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/LM75A/lm75a.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LM75A_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LM75A_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LM75A_ADD 0x9E              <span class="comment">// LM75A温度传感器的 I²C 设备地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LM75A_GetTemp</span><span class="params">(u8 *Tempbuffer)</span>; <span class="comment">// 温度读取函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LM75A_POWERDOWN</span><span class="params">(<span class="type">void</span>)</span>;         <span class="comment">// 温度传感器进入掉电模式，常用于低功耗场合</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="lm75a.c">lm75a.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/LM75A/lm75a.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lm75a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 LM75A 温度值，取值范围在 -55℃ ~ 125℃ 之间，参数值 Tempbuffer 是温度值指针存放的位置，包含有 3 个字节的数据，第1个字节是温度正负号，第2个字节是温度整数值，第3个则是温度小数值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LM75A_GetTemp</span><span class="params">(u8 *Tempbuffer)</span> &#123;</span><br><span class="line">  u8 buf[<span class="number">2</span>];                                <span class="comment">// 用于保存从 LM75A 中读取的温度值</span></span><br><span class="line">  u8 t = <span class="number">0</span>, a = <span class="number">0</span>;</span><br><span class="line">  I2C_READ_BUFFER(LM75A_ADD, <span class="number">0x00</span>, buf, <span class="number">2</span>); <span class="comment">// 调用 I²C 总线驱动函数，读取 LM75A 设备地址上温度寄存器的 2 个字节数据到 buf 数组当中，， 读取温度</span></span><br><span class="line">  t = buf[<span class="number">0</span>];                               <span class="comment">// 读取温度整数部分</span></span><br><span class="line">  *Tempbuffer = <span class="number">0</span>;                          <span class="comment">// 将温度值设置为正数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果温度值的符号位为 1，表示温度为负值 */</span></span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">    *Tempbuffer = <span class="number">1</span>;                        <span class="comment">// 将温度值设置为负数</span></span><br><span class="line">    t = ~t;</span><br><span class="line">    t++;                                    <span class="comment">// 将温度数据的原码，取反后加 1 得到补码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x01</span>) &#123; a = a + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x02</span>) &#123; a = a + <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x04</span>) &#123; a = a + <span class="number">4</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x08</span>) &#123; a = a + <span class="number">8</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x10</span>) &#123; a = a + <span class="number">16</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x20</span>) &#123; a = a + <span class="number">32</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x40</span>) &#123; a = a + <span class="number">64</span>; &#125;</span><br><span class="line"></span><br><span class="line">  Tempbuffer++;                             <span class="comment">// 指针地址自增 1</span></span><br><span class="line">  *Tempbuffer = a;                          <span class="comment">// 然后写入温度数据</span></span><br><span class="line"></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  t = buf[<span class="number">1</span>];                               <span class="comment">// 处理温度值的小数部分</span></span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x20</span>) &#123; a = a + <span class="number">12</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x40</span>) &#123; a = a + <span class="number">25</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (t &amp; <span class="number">0x80</span>) &#123; a = a + <span class="number">50</span>; &#125;</span><br><span class="line"></span><br><span class="line">  Tempbuffer++;                            <span class="comment">// 指针地址自增 1</span></span><br><span class="line">  *Tempbuffer = a;                         <span class="comment">// 写入温度数据的小数部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要降低功耗时，可以让 LM75A 进入掉电模式，再次调用 LM75A_GetTemp() 就可恢复到正常模式 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LM75A_POWERDOWN</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  I2C_SEND_BYTE(LM75A_ADD, <span class="number">0x01</span>, <span class="number">1</span>);       <span class="comment">// 调用 I²C 总线驱动函数，将 LM75A 的配置寄存器值置为 1，开启掉电模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="oled-无字库液晶屏">OLED 无字库液晶屏</h3>
<p>12864
液晶是指<code>128 × 64</code>像素分辨率的显示屏幕，当前实验电路采用的是型号为
<strong>OLED0561</strong> 的 OLED 液晶显示屏，采用
<strong>SH1106</strong> 主控芯片，可以进行单色无灰度的显示，屏幕采用 I²C
总线与<strong>STM32F103C8T6</strong>微控制器进行通信。</p>
<p><img src="/Embedded/STM32F103/i2c/diagram-oled.png"></p>
<p>在<code>Hardware</code>目录下的<code>OLED0561</code>文件夹内新建<code>ASCII_8x16</code>（八乘十六的
ASCII
码字库）、<code>CHS_16x16.h</code>（十六乘十六的汉字编码）、<code>PIC1.h</code>（图片编码）以及
OLED
显示驱动程序<code>oled0561.h</code>和<code>oled0561.c</code>源文件。</p>
<blockquote>
<p><strong>注意：</strong>将<code>128 × 64</code>像素的屏幕划分为<code>16 × 8</code>个分辨率为<code>8 × 8</code>的区块，显示英文和数字时需要
2
个<code>8 × 8</code>区块组成的<code>8 × 16</code>分辨率区域，显示汉字则需要
4
个<code>8 × 8</code>区块组成的<code>16 × 16</code>分辨率区域。因此，整个屏幕每行可以显示
16 个英文和数字或者 8 个汉字，一共可以显示 4 行。</p>
</blockquote>
<h4 id="oled0561.h">oled0561.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/OLED0561/oled0561.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED0561_ADD 0x78 <span class="comment">// 定义 OLED 的固定 I²C 总线地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM 0x00          <span class="comment">// 定义固定的 OLED 指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAT 0x40          <span class="comment">// 定义固定的 OLED 数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED0561_Init</span><span class="params">(<span class="type">void</span>)</span>;                       <span class="comment">// 初始化 OLED</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_ON</span><span class="params">(<span class="type">void</span>)</span>;                     <span class="comment">// 打开 OLED 屏幕显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_OFF</span><span class="params">(<span class="type">void</span>)</span>;                    <span class="comment">// 关闭 OLED 屏幕显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_LIT</span><span class="params">(u8 x)</span>;                    <span class="comment">// 设置 OLED 屏幕亮度（0 ~ 255）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_CLEAR</span><span class="params">(<span class="type">void</span>)</span>;                  <span class="comment">// 清除屏幕当前显示内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_8x16</span><span class="params">(u8 x, u8 y, u16 w)</span>;      <span class="comment">// 显示单个 8 * 16 的英文或数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_8x16_BUFFER</span><span class="params">(u8 row, u8 *str)</span>; <span class="comment">// 显示 8 * 16 的英文或数字组成的字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_16x16</span><span class="params">(u8 x,u8 y,u16 w)</span>;       <span class="comment">// 显示 16 * 16 汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_PIC1</span><span class="params">(<span class="type">void</span>)</span>;                   <span class="comment">// 显示全屏图片</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="oled0561.c">oled0561.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/OLED0561/oled0561.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ASCII_8x16.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CHS_16x16.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PIC1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** OLED 屏幕初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED0561_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  OLED_DISPLAY_OFF();   <span class="comment">// 关闭 OLED 屏幕显示，避免上电瞬间屏幕显示乱码</span></span><br><span class="line">  OLED_DISPLAY_CLEAR(); <span class="comment">// 清除屏幕当前显示的内容</span></span><br><span class="line">  OLED_DISPLAY_ON();    <span class="comment">// 开启 OLED 屏幕显示，设定 OLED 初始状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 屏幕显示开启函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_ON</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 屏幕主控芯片 SH1106 的控制指令*/</span></span><br><span class="line">  u8 buf[<span class="number">28</span>] = &#123;</span><br><span class="line">      <span class="number">0xae</span>,       <span class="comment">// 0xae 关闭显示，</span></span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="comment">// 开始地址双字节</span></span><br><span class="line">      <span class="number">0xd5</span>, <span class="number">0x80</span>, <span class="comment">// 时钟频率</span></span><br><span class="line">      <span class="number">0xa8</span>, <span class="number">0x3f</span>, <span class="comment">// 复用率</span></span><br><span class="line">      <span class="number">0xd3</span>, <span class="number">0x00</span>, <span class="comment">// 显示偏移量</span></span><br><span class="line">      <span class="number">0XB0</span>,       <span class="comment">// 写入页位置</span></span><br><span class="line">      <span class="number">0x40</span>,       <span class="comment">// 显示开始线</span></span><br><span class="line">      <span class="number">0x8d</span>, <span class="number">0x14</span>, <span class="comment">// VCC 电源</span></span><br><span class="line">      <span class="number">0xa1</span>,       <span class="comment">// 设置段重映射</span></span><br><span class="line">      <span class="number">0xc8</span>,       <span class="comment">// COM 输出方式</span></span><br><span class="line">      <span class="number">0xda</span>, <span class="number">0x12</span>, <span class="comment">// COM 输出方式</span></span><br><span class="line">      <span class="number">0x81</span>, <span class="number">0xff</span>, <span class="comment">// 对比度</span></span><br><span class="line">      <span class="number">0xd9</span>, <span class="number">0xf1</span>, <span class="comment">// 充电周期</span></span><br><span class="line">      <span class="number">0xdb</span>, <span class="number">0x30</span>, <span class="comment">// VCC电压输出</span></span><br><span class="line">      <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="comment">// 水平寻址设置</span></span><br><span class="line">      <span class="number">0xa4</span>,       <span class="comment">// 0xa4 正常显示，0xa5 整体点亮</span></span><br><span class="line">      <span class="number">0xa6</span>,       <span class="comment">// 0xa6 正常显示，0xa7 反色显示</span></span><br><span class="line">      <span class="number">0xaf</span>        <span class="comment">// 0xaf 打开显示</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用 I²C 总线发送函数，第 1 个参数是 OLED 地址，第 2 个是操作指令，第 3 个是待发送的数据，第 4 个是发送数据长度 */</span></span><br><span class="line">  I2C_SAND_BUFFER(OLED0561_ADD, COM, buf, <span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 屏幕显示关闭函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_OFF</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 buf[<span class="number">3</span>] = &#123;</span><br><span class="line">      <span class="number">0xae</span>,       <span class="comment">// 0xae 关闭显示</span></span><br><span class="line">      <span class="number">0x8d</span>, <span class="number">0x10</span>, <span class="comment">// 关闭 OLED 屏幕的 VCC 电源</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  I2C_SAND_BUFFER(OLED0561_ADD, COM, buf, <span class="number">3</span>); <span class="comment">// 将 buf 通过 I²C 总线发送给 OLED 屏幕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 屏幕亮度设置函数，0 为最低，255 为最高 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_LIT</span><span class="params">(u8 x)</span> &#123;</span><br><span class="line">  I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0x81</span>); <span class="comment">// 选择亮度指令</span></span><br><span class="line">  I2C_SAND_BYTE(OLED0561_ADD, COM, x);    <span class="comment">// 设置亮度值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 屏幕显示清除函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_CLEAR</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 j, t;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环的起始页地址为 0xB0，本质是向屏幕所有显示区域写入 0 使其熄灭</span></span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">0xB0</span>; t &lt; <span class="number">0xB8</span>; t++) &#123;</span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, t);    <span class="comment">// 选择向哪个区块行写入数据</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0x10</span>); <span class="comment">// 写入数据起始列地址的高 4 位</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0x00</span>); <span class="comment">// 写入数据起始列地址的低 4 位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 整页内容填充，可以将 132 列修改为 128 列 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">132</span>; j++) &#123;</span><br><span class="line">      I2C_SAND_BYTE(OLED0561_ADD, DAT, <span class="number">0x00</span>); <span class="comment">// 向 132 列写入 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 向屏幕指定位置写入字符，参数 x 定义在哪页写入字符，参数 y 是具体的列坐标, 参数 w 是 ASCII 字符编码*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_8x16</span><span class="params">(u8 x, u8 y, u16 w)</span> &#123;</span><br><span class="line">  u8 j, t, c = <span class="number">0</span>;</span><br><span class="line">  y = y + <span class="number">2</span>; <span class="comment">// 加上偏移量，用于匹配主控芯片起始地址为 0x02 的屏幕</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 选择向哪个 8 * 8 区块写入数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++) &#123;</span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0xb0</span> + x);      <span class="comment">// 选择向哪个区块行写入数据，取值范围从 0xB0 到 0xB7</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, y / <span class="number">16</span> + <span class="number">0x10</span>); <span class="comment">// 写入数据起始列地址的高 4 位</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, y % <span class="number">16</span>);        <span class="comment">// 写入数据起始列地址的低 4 位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向 OLED 发送 ASCII 字符编码 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      I2C_SAND_BYTE(OLED0561_ADD, DAT, ASCII_8x16[(w * <span class="number">16</span>) + c - <span class="number">512</span>]);</span><br><span class="line">      c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x++; <span class="comment">// 页地址加 1 跳入下一行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 字符串显示函数，参数 row 向哪个区块行写入，参数 str 是待写入的内容 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_8x16_BUFFER</span><span class="params">(u8 row, u8 *str)</span> &#123;</span><br><span class="line">  u8 r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断字符数据是否发送结束 */</span></span><br><span class="line">  <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    OLED_DISPLAY_8x16(row, r * <span class="number">8</span>, *str++);</span><br><span class="line">    r++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 16*16 汉字显示函数，参数 x 是待写入的行地址，参数 y 是待写入的列地址，参数 w 是待显示汉字的编码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_16x16</span><span class="params">(u8 x, u8 y, u16 w)</span> &#123;</span><br><span class="line">  u8 j, t, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++) &#123;</span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0xb0</span> + x);      <span class="comment">// 选择向哪个区块行写入数据，取值范围从 0xB0 到 0xB7</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, y / <span class="number">16</span> + <span class="number">0x10</span>); <span class="comment">// 写入数据起始列地址的高 4 位</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, y % <span class="number">16</span>);        <span class="comment">// 写入数据起始列地址的低 4 位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向 OLED 发送汉字编码 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">      I2C_SAND_BYTE(OLED0561_ADD, DAT, GB_16[(w * <span class="number">32</span>) + c]);</span><br><span class="line">      c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x++; <span class="comment">// 页地址加 1 跳入下一行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0xAF</span>); <span class="comment">//开显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 全屏图片显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DISPLAY_PIC1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 m, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将数据发送至 8 个区块行 */</span></span><br><span class="line">  <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; <span class="number">8</span>; m++) &#123;</span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0xb0</span> + m); <span class="comment">// 选择向哪个区块行写入数据，取值范围从 0xB0 到 0xB7</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0x10</span>);     <span class="comment">// 写入数据起始列地址的高 4 位</span></span><br><span class="line">    I2C_SAND_BYTE(OLED0561_ADD, COM, <span class="number">0x02</span>);     <span class="comment">// 写入数据起始列地址的低 4 位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向 OLED 的每个区块行发送 128 列的图片编码数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">      I2C_SAND_BYTE(OLED0561_ADD, DAT, PIC1[i + m * <span class="number">128</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ascii_8x16.h">ASCII_8x16.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/OLED0561/ASCII_8x16.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASCII_8x16_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASCII_8x16_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ASCII 字模数据表 */</span></span><br><span class="line"><span class="type">const</span> u8 ASCII_8x16[] = &#123;</span><br><span class="line">  <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">  <span class="comment">/* ... ... ... ... ... */</span></span><br><span class="line">  <span class="number">0x80</span>,<span class="number">0xC0</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x60</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x07</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x07</span>,<span class="number">0x07</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="chs_16x16.h">CHS_16x16.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/OLED0561/CHS_16x16.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CHS_16x16_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CHS_16x16_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 汉字字模数据表 */</span></span><br><span class="line">uc8 GB_16[] = &#123;</span><br><span class="line">  <span class="number">0x10</span>,<span class="number">0x22</span>,<span class="number">0x64</span>,<span class="number">0x0C</span>,<span class="number">0x80</span>,<span class="number">0x08</span>,<span class="number">0x49</span>,<span class="number">0x4A</span>,</span><br><span class="line">  <span class="comment">/* ... ... ... ... ... */</span></span><br><span class="line">  <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="pic1.h">PIC1.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/OLED0561/PIC1.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PIC1_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PIC1_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 汉字字模数据表 */</span></span><br><span class="line">uc8 PIC1[] = &#123;</span><br><span class="line">  <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">  <span class="comment">/* ... ... ... ... ... */</span></span><br><span class="line">  <span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0x77</span>,<span class="number">0x74</span>,<span class="number">0x67</span>,<span class="number">0x67</span>,<span class="number">0x63</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="main.c-19">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lm75a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 buffer[<span class="number">3</span>];</span><br><span class="line">  delay_ms(<span class="number">100</span>);       <span class="comment">// 此处必须调用延时函数，等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 系统时钟初始化</span></span><br><span class="line"></span><br><span class="line">  I2C_Configuration();   <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  LM75A_GetTemp(buffer); <span class="comment">// 读取温度传感器 LM75A 的数据</span></span><br><span class="line">  OLED0561_Init();       <span class="comment">// 初始化 OLED 显示屏幕</span></span><br><span class="line">  OLED_DISPLAY_LIT(<span class="number">100</span>); <span class="comment">// 设置 OLED 屏幕亮度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OLED 全屏显示开机图片 */</span></span><br><span class="line">  OLED_DISPLAY_PIC1();   <span class="comment">// 显示 OLED 全屏图片</span></span><br><span class="line">  delay_ms(<span class="number">1000</span>);        <span class="comment">// 调用延时函数使图片显示停留 1 秒钟</span></span><br><span class="line">  OLED_DISPLAY_CLEAR();  <span class="comment">// 清空 OLED 屏幕显示</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OLED 显示数字和字母组成的温度值 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;  Hank&quot;</span>);  <span class="comment">// 显示字符串 Hank</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Temp:&quot;</span>); <span class="comment">// 显示字符串 Temp:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OLED 显示汉字 */</span></span><br><span class="line">  OLED_DISPLAY_16x16(<span class="number">2</span>, <span class="number">2</span> * <span class="number">16</span>, <span class="number">0</span>); <span class="comment">// 在第 2 个区块行的 2 * 16 列显示第 0 号汉字</span></span><br><span class="line">  OLED_DISPLAY_16x16(<span class="number">2</span>, <span class="number">3</span> * <span class="number">16</span>, <span class="number">1</span>); <span class="comment">// 在第 2 个区块行的 2 * 16 列显示第 1 号汉字</span></span><br><span class="line">  OLED_DISPLAY_16x16(<span class="number">2</span>, <span class="number">4</span> * <span class="number">16</span>, <span class="number">2</span>); <span class="comment">// 在第 2 个区块行的 2 * 16 列显示第 2 号汉字</span></span><br><span class="line">  OLED_DISPLAY_16x16(<span class="number">2</span>, <span class="number">5</span> * <span class="number">16</span>, <span class="number">3</span>); <span class="comment">// 在第 2 个区块行的 2 * 16 列显示第 3 号汉字</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    LM75A_GetTemp(buffer); <span class="comment">//读取LM75A的温度数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 buffer 缓冲区第 1 个元素等于 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>]) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">7</span> * <span class="number">8</span>, <span class="string">&#x27;-&#x27;</span>); <span class="comment">// 那么就显示负号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示温度值 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">8</span> * <span class="number">8</span>, buffer[<span class="number">1</span>] / <span class="number">10</span> + <span class="number">0x30</span>);  <span class="comment">// 整数部分十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">9</span> * <span class="number">8</span>, buffer[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">0x30</span>);  <span class="comment">// 整数部分个位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">10</span> * <span class="number">8</span>, <span class="string">&#x27;.&#x27;</span>);                   <span class="comment">// 显示小数点</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, buffer[<span class="number">2</span>] / <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 小数部分的个位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, buffer[<span class="number">2</span>] % <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 小数部分的十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>);                   <span class="comment">// 摄氏度符号</span></span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">200</span>); <span class="comment">// 调用延时函数，让显示内容停留一段时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="relay-继电器">Relay 继电器</h2>
<p>首先，将实验电路上继电器对应的<strong>P26</strong>跳线帽短接，然后将触摸按键对应的<strong>P10</strong>跳线帽短接，本实验使用触摸按键来进行继电器开关控制，并使用<strong>ULN2003A</strong>达林顿芯片来驱动继电器。</p>
<p><img src="/Embedded/STM32F103/relay-motor/diagram.png"></p>
<p>上面的电路图当中，继电器 1 和 2
分别连接至<strong>STM32F103C8T6</strong>的<strong>PA13</strong>和<strong>PA14</strong>引脚（上电时
JTAG 电路将这两个引脚默认为 JTAG 模式，本实验中需要将其手动设置为 GPIO
模式），然后 PA13 和 PA14
分别通过<strong>P26</strong>跳线帽连接至<strong>ULN2003</strong>达林顿管芯片的<strong>IN5</strong>和<strong>IN6</strong>引脚（由于其内部使用了非门电路，其左边输入与右边输出的状态相反），最后其<strong>OUT5/J1</strong>和<strong>OUT6/J2</strong>引脚分别用于控制原理图中的继电器<strong>U13</strong>和<strong>U12</strong>。</p>
<p>这样，当<strong>PA13</strong>和<strong>PA14</strong>输出高电平时，经过<strong>ULN2003</strong>反向之后，对应输出低电平，由于继电器另一端连接在<code>5V</code>高电平上，从而使继电器线圈吸合工作，导致<strong>OUT1A</strong>和<strong>OUT1C</strong>触点导通或者<strong>OUT2A</strong>和<strong>OUT2C</strong>触点导通；反之，如果<strong>PA13</strong>和<strong>PA14</strong>输出低电平，则<strong>OUT1A</strong>和<strong>OUT1B</strong>导通或者<strong>OUT2A</strong>和<strong>OUT2B</strong>导通。此外，实验电路还在继电器<strong>U13</strong>和<strong>U12</strong>上连接了<strong>LED9</strong>和<strong>LED10</strong>两枚
LED
指示灯，以及相应的<strong>R28</strong>和<strong>R29</strong>两只限流电阻。</p>
<h3 id="realy.h">realy.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/REALY/realy.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAYPORT GPIOA    <span class="comment">// 定义 GPIO 组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY1 GPIO_Pin_14 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY2 GPIO_Pin_13 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 继电器初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_1</span><span class="params">(u8 c)</span>;    <span class="comment">// 继电器 1 控制函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_2</span><span class="params">(u8 c)</span>;    <span class="comment">// 继电器 2 控制函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="realy.c">realy.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/REALY/realy.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 继电器初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); <span class="comment">// 使能 APB2 外设时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); <span class="comment">// 启动 AFIO 重映射功能时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = RELAY1 | RELAY2;       <span class="comment">// 选择 GPIO 端口</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;     <span class="comment">// 设置 GPIO 为推挽输出方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    <span class="comment">// 设置 GPIO 频率为 50MHz</span></span><br><span class="line">  GPIO_Init(RELAYPORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); <span class="comment">// 禁用 JTAG 模式</span></span><br><span class="line">  GPIO_ResetBits(RELAYPORT, RELAY1 | RELAY2);          <span class="comment">// 初始化继电器状态为低电平 0，使其处于关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 继电器 1 控制函数，参数 c 为 0 时继电器断开，为 1 时吸合 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_1</span><span class="params">(u8 c)</span> &#123;</span><br><span class="line">  GPIO_WriteBit(RELAYPORT, RELAY1, (BitAction)(c)); <span class="comment">// 写入 GPIO 状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 继电器 2 控制函数，参数 c 为 0 时继电器断开，为 1 时吸合 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RELAY_2</span><span class="params">(u8 c)</span> &#123;</span><br><span class="line">  GPIO_WriteBit(RELAYPORT, RELAY2, (BitAction)(c)); <span class="comment">// 写入 GPIO 状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-20">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 配置时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A))</span><br><span class="line">      RELAY_1(<span class="number">1</span>); <span class="comment">// 触摸按键 A 按下时，继电器 1 吸合</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B))</span><br><span class="line">      RELAY_1(<span class="number">0</span>); <span class="comment">// 触摸按键 B 按下时，继电器 1 放开</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C))</span><br><span class="line">      RELAY_2(<span class="number">1</span>); <span class="comment">// 触摸按键 C 按下时，继电器 2 吸合</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D))</span><br><span class="line">      RELAY_2(<span class="number">0</span>); <span class="comment">// 触摸按键 D 按下时，继电器 2 放开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uln2003-驱动步进电机">ULN2003 驱动步进电机</h2>
<p>短接实验电路上步进电机对应的<strong>P27</strong>跳线帽，以及触摸按键对应的<strong>P10</strong>跳线帽，本实验将会采用触摸按键对步进电机进行控制。步进电机是一种可以通过脉冲信号数量旋转特定角度的元器件，步进电机拥有蓝<code>A+</code>、粉<code>A-</code>、黄<code>B+</code>、橙<code>B-</code>、红<code>COM</code>五条连接线，向
COM
端输入高电平，其它端口输出相应的低电平，就可以让步进电机开始旋转（四拍模式下电机旋转
90 度，八拍模式下电机旋转 45
度），宣传完成之后需要及时断电，否则会造成某个线圈长时间通电烧毁。</p>
<p>当前实验电路采用的是五线四相步进电机（5 条接线，4
组线圈），通过<strong>STM32F103C8T6</strong>的<code>PB3</code>、<code>PB4</code>、<code>PB8</code>、<code>PB9</code>四个引脚进行控制，它们分别连接至<strong>ULN2003</strong>达林顿芯片输入端的<code>MO_1/IN1</code>、<code>MO_2/IN2</code>、<code>MO_3/IN3</code>、<code>MO_4/IN4</code>引脚，而输出端则连接至<strong>P20</strong>插座上步进电机的<code>蓝</code>、<code>粉</code>、<code>黄</code>、<code>橙</code>、<code>红</code>5
条导线，具体接线方式请参考前一小节继电器相关的电路图。</p>
<h3 id="按键控制步进电机">按键控制步进电机</h3>
<h4 id="step_motor.h">step_motor.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/STEP_MOTOR/step_motor.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STEP_MOTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STEP_MOTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_PORT GPIOB   <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_A GPIO_Pin_3 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_B GPIO_Pin_4 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_C GPIO_Pin_8 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_D GPIO_Pin_9 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 步进电机初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_OFF</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 步进电机关闭函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机驱动函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4S</span><span class="params">(u8 speed)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4R</span><span class="params">(u8 speed)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4L</span><span class="params">(u8 speed)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8R</span><span class="params">(u8 speed)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8L</span><span class="params">(u8 speed)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="step_motor.c">step_motor.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/STEP_MOTOR/step_motor.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;step_motor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); <span class="comment">// 使能 APB2 外设时钟</span></span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);                                     <span class="comment">// 启动 AFIO 重映射功能时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                                         <span class="comment">// 设置 GPIO 为推挽输出方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;                                        <span class="comment">// 设置 GPIO 频率为 50MHz</span></span><br><span class="line">  GPIO_Init(STEP_MOTOR_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); <span class="comment">// 禁用 JTAG 模式</span></span><br><span class="line">  STEP_MOTOR_OFF();                                    <span class="comment">// 初始化继电器为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机关闭函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_OFF</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// 将步进电机相关的 GPIO 全部置为低电平 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机制动函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4S</span><span class="params">(u8 speed)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_C);                               <span class="comment">// AC 设置为低电平</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_D);                                 <span class="comment">// BD 设置为高电平</span></span><br><span class="line">  delay_ms(speed);                                                                            <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// ABCD 设置为低电平</span></span><br><span class="line">  delay_ms(speed);                                                                            <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_D);                               <span class="comment">// BD 设置为低电平</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_C);                                 <span class="comment">// AC 设置为高电平</span></span><br><span class="line">  delay_ms(speed);                                                                            <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// ABCD 设置为低电平</span></span><br><span class="line">  delay_ms(speed);                                                                            <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF();                                                                           <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 4 拍方式顺时针转动函数，转动速度快，力度小*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4R</span><span class="params">(u8 speed)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);   <span class="comment">// A 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D); <span class="comment">// A D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);   <span class="comment">// B C 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B); <span class="comment">// A B 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);   <span class="comment">// C D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// B C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);   <span class="comment">// A D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF();                                             <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 4 拍方式逆时针转动函数，转动速度快，力度小*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_4L</span><span class="params">(u8 speed)</span> &#123;                                  <span class="comment">//电机逆时针，4拍，速度快，力小</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B); <span class="comment">// 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);   <span class="comment">// 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D); <span class="comment">// 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);   <span class="comment">// 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);   <span class="comment">// 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);   <span class="comment">// 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                              <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF();                                             <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 8 拍方式顺时针转动函数，转动速度慢，力度大，角度小 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8R</span><span class="params">(u8 speed)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// B C D设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A);                                 <span class="comment">// A 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);                <span class="comment">// C D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);                  <span class="comment">// A B 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// A C D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B);                                 <span class="comment">// B 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);                <span class="comment">// A D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);                  <span class="comment">// B C 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D); <span class="comment">// A B D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C);                                 <span class="comment">// C 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);                <span class="comment">// A B 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);                  <span class="comment">// C D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// A B C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_D);                                 <span class="comment">// D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);                <span class="comment">// B C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);                  <span class="comment">// A D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF();                                                            <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 8 拍方式逆时针转动函数，转动速度慢，力度大，角度小 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8L</span><span class="params">(u8 speed)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// A B C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_D);                                 <span class="comment">// D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);                <span class="comment">// A B 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);                  <span class="comment">// C D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D); <span class="comment">// A B D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C);                                 <span class="comment">// C 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);                <span class="comment">// A D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);                  <span class="comment">// B C 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// A C D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B);                                 <span class="comment">// B 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);                <span class="comment">// C D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);                  <span class="comment">// A B 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// B C D 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A);                                 <span class="comment">// A 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);                <span class="comment">// B C 设置为低电平 0</span></span><br><span class="line">  GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);                  <span class="comment">// A D 设置为高电平 1</span></span><br><span class="line">  delay_ms(speed);                                                             <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF();                                                            <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-21">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;step_motor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟设置</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  STEP_MOTOR_Init();   <span class="comment">// 初始化步进电机</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A))</span><br><span class="line">      STEP_MOTOR_4R(<span class="number">3</span>); <span class="comment">// 触摸按键 A 按下，步进电机 4 步右转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B))</span><br><span class="line">      STEP_MOTOR_4L(<span class="number">3</span>); <span class="comment">// 触摸按键 B 按下，步进电机 4 步左转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C))</span><br><span class="line">      STEP_MOTOR_8R(<span class="number">3</span>); <span class="comment">// 触摸按键 C 按下，步进电机 8 步右转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D))</span><br><span class="line">      STEP_MOTOR_8L(<span class="number">3</span>); <span class="comment">// 触摸按键 D 按下，步进电机 8 步左转</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      STEP_MOTOR_OFF(); <span class="comment">// 无按键按下时，步进电机断电，防止损坏线圈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步进电机步数控制">步进电机步数控制</h3>
<h4 id="step_motor.h-1">step_motor.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/STEP_MOTOR/step_motor.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STEP_MOTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STEP_MOTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 STEP;                 <span class="comment">// 单步计数全局变量，用于标识步进电机当前运行至哪一步</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_PORT GPIOB   <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_A GPIO_Pin_3 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_B GPIO_Pin_4 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_C GPIO_Pin_8 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEP_MOTOR_D GPIO_Pin_9 <span class="comment">// 步进电机控制相关的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 步进电机初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_OFF</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 步进电机关闭函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8A</span><span class="params">(u8 a, u16 speed)</span>;            <span class="comment">// 单步运行函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_NUM</span><span class="params">(u8 RL, u16 num, u8 speed)</span>;  <span class="comment">// 按步数运行函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_LOOP</span><span class="params">(u8 RL, u8 LOOP, u8 speed)</span>; <span class="comment">// 按圈数运行函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="step_motor.c-1">step_motor.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/STEP_MOTOR/step_motor.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;step_motor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 STEP;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); <span class="comment">// 使能 APB2 外设时钟</span></span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);                                     <span class="comment">// 启动 AFIO 重映射功能时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                                         <span class="comment">// 设置 GPIO 为推挽输出方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;                                        <span class="comment">// 设置 GPIO 频率为 50MHz</span></span><br><span class="line">  GPIO_Init(STEP_MOTOR_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); <span class="comment">// 禁用 JTAG 模式</span></span><br><span class="line">  STEP_MOTOR_OFF();                                    <span class="comment">// 初始化继电器为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 步进电机关闭函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_OFF</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// 将步进电机相关的 GPIO 全部置为低电平 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 单步 8 拍控制函数，参数 a 是电机步数(即转动至指定拍数位置)，参数 speed 是旋转速度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_8A</span><span class="params">(u8 a, u16 speed)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// B C D 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A);                                 <span class="comment">// A 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// C D 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B);   <span class="comment">// A B 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D); <span class="comment">// A C D 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B);                                 <span class="comment">// B 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D); <span class="comment">// A D 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C);   <span class="comment">// B C 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D); <span class="comment">// A B D 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C);                                 <span class="comment">// C 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B); <span class="comment">// A B 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_C | STEP_MOTOR_D);   <span class="comment">// C D 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// A B C 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_D);                                 <span class="comment">// D 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      GPIO_ResetBits(STEP_MOTOR_PORT, STEP_MOTOR_B | STEP_MOTOR_C); <span class="comment">// B C 设置为低电平</span></span><br><span class="line">      GPIO_SetBits(STEP_MOTOR_PORT, STEP_MOTOR_A | STEP_MOTOR_D);   <span class="comment">// A D 设置为高电平</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay_ms(speed);  <span class="comment">// 延时</span></span><br><span class="line">  STEP_MOTOR_OFF(); <span class="comment">// 步进电机断电，防止过热</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按步数运行函数，参数 RL 是旋转方向（为 1 时顺时针，为 0 时逆时针），参数 num 是转动的步数，参数 speed 是旋转速度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_NUM</span><span class="params">(u8 RL, u16 num, u8 speed)</span> &#123;</span><br><span class="line">  u16 i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="comment">/* 判断方向*/</span></span><br><span class="line">    <span class="keyword">if</span> (RL == <span class="number">1</span>) &#123;</span><br><span class="line">      STEP++;</span><br><span class="line">      <span class="keyword">if</span> (STEP &gt; <span class="number">7</span>)</span><br><span class="line">        STEP = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (STEP == <span class="number">0</span>)</span><br><span class="line">        STEP = <span class="number">8</span>;</span><br><span class="line">      STEP--;</span><br><span class="line">    &#125;</span><br><span class="line">    STEP_MOTOR_8A(STEP, speed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按圈数运行函数，参数 RL 是转动方向，参数 LOOP 是旋转圈数，参数 speed 是旋转速度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">STEP_MOTOR_LOOP</span><span class="params">(u8 RL, u8 LOOP, u8 speed)</span> &#123;</span><br><span class="line">  STEP_MOTOR_NUM(RL, LOOP * <span class="number">4076</span>, speed); <span class="comment">// 旋转 4076 拍可以让步进电机输出轴刚好旋转 1 圈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-22">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;step_motor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_Configuration(); <span class="comment">// 时钟设置</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  STEP_MOTOR_Init();   <span class="comment">// 初始化步进电机</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A))</span><br><span class="line">      STEP_MOTOR_LOOP(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 右转 1 圈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B))</span><br><span class="line">      STEP_MOTOR_LOOP(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 左转 1 圈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C))</span><br><span class="line">      STEP_MOTOR_NUM(<span class="number">0</span>, <span class="number">100</span>, <span class="number">3</span>); <span class="comment">// 右转 100 步</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D))</span><br><span class="line">      STEP_MOTOR_NUM(<span class="number">1</span>, <span class="number">100</span>, <span class="number">3</span>); <span class="comment">// 左转 100 步</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      STEP_MOTOR_OFF(); <span class="comment">// 无按键按下时，步进电机断电，防止损坏线圈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rs232-串行通信">RS232 串行通信</h2>
<p>短接实验电路上<strong>RS232</strong>对应的<code>P13</code>跳线帽，并且断开<strong>RS485</strong>对应的<code>P22</code>跳线帽，以及右上角网络标号
MY1680 对应的<strong>PB10</strong>和<strong>PB11</strong>跳线帽。</p>
<blockquote>
<p><strong>注意：</strong>将 RS232 的 DB9 接头最上面一排的第 2、3 针（即
RX 与 TX）用杜邦线短接在一起，可以方便的进行串口收发测试。</p>
</blockquote>
<p><img src="/Embedded/STM32F103/rs232-485-can/diagram-rs232.png"></p>
<p>上面的电路图当中，<strong>STM32F103C8T6</strong>的<strong>USART3</strong>引脚<code>RX/PB10</code>和<code>TX/PB11</code>，分别通过跳线座<strong>P13</strong>连接至<strong>SP3232</strong>电平转换芯片的<code>T1IN</code>和<code>R1OUT</code>引脚，然后经过<code>T1OUT</code>、<code>R1IN</code>连接至<strong>DB9</strong>插头的第
2 输入和第 3 输出针脚。此外，还将<strong>DB9</strong>插头的第 5
脚连接至<strong>GND</strong>。</p>
<h3 id="usart.h-1">usart.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/USART/usart.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART3 1  <span class="comment">// 使能 USART3</span></span></span><br></pre></td></tr></table></figure>
<h3 id="main.c-23">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line">  delay_ms(<span class="number">100</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;  Hank &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;  RS232 Test &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;TX:    RX:   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  USART3_Init(<span class="number">115200</span>); <span class="comment">// 初始化 USART3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 向 RS232 发送字符 A，并且显示到 OLED 屏幕*/</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      USART3_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS232 发送字符 B，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      USART3_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS232 发送字符 C，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      USART3_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS232 发送字符 D，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      USART3_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 采用查询方式（查询串口待处理标志位）接收数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART_GetFlagStatus(USART3, USART_FLAG_RXNE) != RESET) &#123;</span><br><span class="line">      a = USART_ReceiveData(USART3);   <span class="comment">// 读取接收到的数据</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, a); <span class="comment">// 显示到 OLED 上面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>RS232 串口与之前小节介绍的 USART
串行通信没有本质区别，唯一的差别在于硬件上将 TTL 电平转换为了 RS232
电平，而这样的转换并不影响之前编写的 USART 串行驱动程序的工作。</p>
</blockquote>
<h2 id="rs485-串行通信">RS485 串行通信</h2>
<p>RS485 通信依然是基于<strong>STM32F103C8T6</strong>的 USART
串行接口，其相比 RS232 可靠性更高传输距离更远（USART 最大传输距离 2
米，RS232 最大传输距离 20 米，RS485 最大传输距离达到 1000
米）。开始进一步学习之前，需要对实验电路当中的跳线进行设置，将实验电路上的<strong>RS232</strong>对应的<code>P13</code>跳线帽断开，然后将<strong>RS485</strong>对应的<code>P22</code>跳线帽短接，最后还需要断开右上角网络标号<strong>MY1680</strong>对应的<code>PB10</code>和<code>PB11</code>跳线帽。</p>
<blockquote>
<p><strong>注意：</strong> 由于 RS485
采用差分电平（<code>±2V ~ 6V</code>）通信机制，无法像 RS232
示例程序那样将 RX 和 TX 短接起来进行测试，因此必须借助于一个 USB 转
RS485 设备才能进行正确的完成通信实验。</p>
</blockquote>
<p><img src="/Embedded/STM32F103/rs232-485-can/diagram-rs485.png"></p>
<p>RS485
的<strong>TX</strong>、<strong>RX</strong>接口分别连接至<strong>STM32F103C8T6</strong>上面
USART3
所复用的<strong>PB11</strong>和<strong>PB10</strong>引脚，另外一个收发选择接口<strong>RE</strong>则连接至一个普通的<strong>PA8</strong>引脚（当<strong>RE</strong>输出高电平时，后续<strong>SP3485</strong>电平转换芯片处于发送状态，反之输出低电平就处于接收状态）。RS485
的<strong>TX</strong>、<strong>RX</strong>、<strong>RE</strong>经过<strong>P22</strong>跳线插座以后，分别连接到<strong>SP3485</strong>电平转换芯片的<strong>RO</strong>、<strong>DI</strong>以及<strong>RE</strong>和<strong>DE</strong>引脚，然后经由<strong>A</strong>、<strong>B</strong>引脚输出至标号为<strong>P23</strong>的接线端子。</p>
<blockquote>
<p><strong>注意：</strong> SP3485 电平转换芯片输出的 A 和 B
两条信号线之间连接了一枚<code>360Ω</code>的电阻<strong>R30</strong>，然后
A 和 B
各自连接了一枚<code>360Ω</code>的上拉电阻<strong>R31</strong>和下拉电阻<strong>R32</strong>，这些电阻的作用是为了保证通信的稳定性。</p>
</blockquote>
<h3 id="rs485.h">rs485.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/RS485/rs485.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RS485_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RS485_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RS485PORT GPIOA     <span class="comment">// 定义 GPIO 组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RS485_RE GPIO_Pin_8 <span class="comment">// 定义 GPIO 接口，用于切换 SP3485 的收发状态</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RS485_Init</span><span class="params">(<span class="type">void</span>)</span>;             <span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RS485_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span>; <span class="comment">// RS485 通信发送函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="rs485.c">rs485.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/RS485/rs485.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rs485.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** RS485 接口初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RS485_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = RS485_RE;           <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// 选择 GPIO 工作方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">// 设置 GPIO　工作频率为 50MHz</span></span><br><span class="line">  GPIO_Init(RS485PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_ResetBits(RS485PORT, RS485_RE); <span class="comment">// RE 引脚用于控制收/发状态，为 1 时发送，为 0 时接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** RS485 通信发送函数，参数 fmt 是待发送的字符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RS485_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[USART3_REC_LEN + <span class="number">1</span>]; <span class="comment">// 数据的长度</span></span><br><span class="line">  u8 i = <span class="number">0</span>;</span><br><span class="line">  va_list arg_ptr;</span><br><span class="line"></span><br><span class="line">  GPIO_SetBits(RS485PORT, RS485_RE); <span class="comment">// 设置为高电平，让 SP3485 切换至发送状态</span></span><br><span class="line"></span><br><span class="line">  va_start(arg_ptr, fmt);</span><br><span class="line">  vsnprintf(buffer, USART3_REC_LEN + <span class="number">1</span>, fmt, arg_ptr);</span><br><span class="line">  <span class="keyword">while</span> ((i &lt; USART3_REC_LEN) &amp;&amp; (i &lt; <span class="built_in">strlen</span>(buffer))) &#123;</span><br><span class="line">    USART_SendData(USART3, (u8)buffer[i++]);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(arg_ptr);</span><br><span class="line"></span><br><span class="line">  GPIO_ResetBits(RS485PORT, RS485_RE); <span class="comment">// 设置为低电平，让 SP3485 切换至接收状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-24">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rs485.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a;</span><br><span class="line">  delay_ms(<span class="number">100</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;  Hank &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;  RS485 Test &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;TX:    RX:   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 RS485 接口，必须遵循如下先后顺序 */</span></span><br><span class="line">  USART3_Init(<span class="number">115200</span>); <span class="comment">// 必须先调用 USART3 初始化函数</span></span><br><span class="line">  RS485_Init();        <span class="comment">// 然后再调用 RS485 初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 向 RS485 发送字符 A，并且显示到 OLED 屏幕*/</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      RS485_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS485 发送字符 B，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      RS485_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS485 发送字符 C，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      RS485_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 RS485 发送字符 D，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      RS485_printf(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 依然采用查询方式接收数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART_GetFlagStatus(USART3, USART_FLAG_RXNE) != RESET) &#123;</span><br><span class="line">      a = USART_ReceiveData(USART3);   <span class="comment">// 读取接收到的数据</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, a); <span class="comment">// 显示到 OLED 上面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="can-总线通信">CAN 总线通信</h2>
<p>由于实验电路当中，数码管占用了 CAN 总线实验需要的 GPIO
引脚，所以需要短接实验电路上 CAN
总线对应的<strong>P24</strong>跳线帽，并且断开数码管对应的<strong>P9</strong>跳线帽。</p>
<p><img src="/Embedded/STM32F103/rs232-485-can/diagram-can.png"></p>
<p>上面电路图当中的<strong>TJA1050</strong>是 NXP 推出的 CAN
协议控制器与物理总线之间的接口转换芯片，采用了<code>5V</code>电压驱动。</p>
<p><img src="/Embedded/STM32F103/rs232-485-can/tja1050.png"></p>
<p>CAN
总线的<code>CAN_TX</code>和<code>CAN_RX</code>分别连接至<strong>STM32F103C8T6</strong>的<code>PA12</code>和<code>PA11</code>引脚，然后经过
P24 跳线插座连接至 CAN 总线收发器 TJA1050
芯片的<code>TXD</code>和<code>RXD</code>引脚，然后经由<code>CANH</code>和<code>CANL</code>引脚输出，两条输出线之前还并联了一枚<code>120Ω</code>的<strong>R33</strong>电阻用于稳定总线工作，最后连接至<strong>P25</strong>接线端子。</p>
<h3 id="协议分析">协议分析</h3>
<p>CAN（控制器区域网络，Controller Area
Network）是一种标准化的串行通信协议，该协议经过 ISO
标准化以后分为<strong>ISO11898</strong>高速通信标准（<code>125Kbps ~ 1Mbps</code>，有效距离
40
米）和<strong>ISO11519-2</strong>低速通信标准（<code>10Kbps ~ 125Kbps</code>，有效距离
1 千米）。如果 CAN 总线上只挂载了两个设备，那么可以简单的将其视为 USART
串口来使用。而如果挂载了多个设备，则需要使用到 CAN
总线协议的邮箱、识别符、过滤器等高级特性。</p>
<p><img src="/Embedded/STM32F103/rs232-485-can/iso-11898-11519-2.png"></p>
<p>CAN 的优点在于，总线空闲时所有单元都可以发送数据，当 2
个以上的总线设备同时发送数据时，根据<strong>标识符</strong>来判断相应优先级，此时会对各条消息
ID
的每个位逐个进行仲裁，优先级最高的单元可以继续数据发送，较低的单元则立刻停止发送并进入接收工作状态。</p>
<p><img src="/Embedded/STM32F103/rs232-485-can/iso-11898-11519-2-physics.png"></p>
<blockquote>
<p><strong>注意：</strong>CAN
总线上的设备都必须基于相同的波特率进行通信。</p>
</blockquote>
<p><strong>CAN</strong>总线发送部分包含有如下的 5 个概念：</p>
<ul>
<li><strong>报文</strong>：CAN
设备发送出去的完整数据信息，一条数据帧或者遥控帧的报文格式如下所示：<code>起始位 | 标识符 | 控制位 | 数据内容 | CRC校验位 | ACK位 | 结束位</code>；</li>
<li><strong>发送邮箱</strong>：用于报文发送的调度器，<strong>STM32F103C8T6</strong>拥有
3
个发送邮箱，待发送数据会放入优先级最高的空邮箱，已放入数据的邮箱将会处于正在或等待发送的状态；</li>
<li><strong>帧种类</strong>：不同用途的报文种类，分为<strong>数据帧</strong>（用于发送单元向接收单元传递数据）、<strong>遥控帧</strong>（用于接收单元向具有相同标识的发送单元请求数据）、错误帧（用于检测到错误时向其它单元通知错误）、过载帧（用于接收单元通知其它尚未做好接收准备的单元）、帧间帧（用于分离数据/遥控帧与前面的其它帧）;</li>
<li><strong>标识符</strong>：属于 CAN 报文的一部分，用于 CAN
总线设备判断数据是否发给自身，标识符不符的报文会被过滤器移除；</li>
<li><strong>帧格式</strong>：报文当中包含的内容，<strong>数据帧</strong>和<strong>遥控帧</strong>都具有<strong>标准</strong>（11
个位标识符）和<strong>扩展</strong>（29 个位标识符）两种格式；</li>
</ul>
<p>进行数据接收时，与<strong>过滤器</strong>（<em>用来过滤掉与标识符不匹配的报文</em>）匹配的报文会被放入<strong>FIFO
邮箱</strong>（<em>先入先出</em>），<strong>STM32F103C8T6</strong>拥有 2
个 FIFO 接收邮箱，每个 FIFO 拥有 3
层深度。当<strong>过滤器</strong>处于<strong>列表模式</strong>时，必须标识符每个位都完全相同才视为匹配；处于<strong>屏蔽位模式</strong>时，屏蔽组为<code>1</code>的对应标识符位必须匹配，为<code>0</code>的对应标识符位无效。过滤器的优先级基于以下规则来判定：</p>
<ol type="1">
<li>位宽为<strong>32</strong>位的过滤器，优先级高于位宽为<strong>16</strong>位的过滤器；</li>
<li>位宽相同的过滤器，标识符<strong>列表模式</strong>的优先级高于<strong>屏蔽位模式</strong>；</li>
<li>位宽与模式都相同的过滤器，优先级由<strong>过滤器号</strong>决定，号码越小优先级越高。</li>
</ol>
<blockquote>
<p><strong>注意：</strong>进行接下来的 CAN 总线收发实验之前，需要先向
<strong>Lib</strong>
文件夹添加<code>stm32f10x_can.c</code>标准外设库文件。</p>
</blockquote>
<h3 id="can.h">can.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CAN/can.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CAN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CAN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_INT_ENABLE 0 <span class="comment">// 是否开启 CAN 总线接收中断模式（1 开启，0 关闭）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置波特率 = PCLK1 ÷ ((1+8+7)*9)) = 36MHz ÷ 16 ÷ 9 = 250Kbits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tsjw CAN_SJW_1tq <span class="comment">// 取值范围 1 ~ 4</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tbs1 CAN_BS1_8tq <span class="comment">// 取值范围 1 ~ 16</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tbs2 CAN_BS2_7tq <span class="comment">// 取值范围 1 ~ 8</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> brp 9 <span class="comment">// 设定了 1 个时间单位的长度为 9</span></span></span><br><span class="line"></span><br><span class="line">u <span class="number">8</span> CAN1_Configuration(<span class="type">void</span>);     <span class="comment">// CAN 总线初始化函数</span></span><br><span class="line">u8 <span class="title function_">CAN_Send_Msg</span><span class="params">(u8 *msg, u8 len)</span>; <span class="comment">// CAN 总线数据发送函数</span></span><br><span class="line">u8 <span class="title function_">CAN_Receive_Msg</span><span class="params">(u8 *buf)</span>;      <span class="comment">// CAN 总线数据接收函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="can.c">can.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CAN/can.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;can.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** CAN 总线初始化函数，返回 0 表示成功，其它表示失败 */</span></span><br><span class="line">u8 <span class="title function_">CAN1_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  CAN_InitTypeDef CAN_InitStructure;</span><br><span class="line">  CAN_FilterInitTypeDef CAN_FilterInitStructure;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CAN_INT_ENABLE</span></span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* 设置时钟 */</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); <span class="comment">// 使能 GPIOA 分组时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);  <span class="comment">// 使能 CAN1 总线时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 GPIO */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">// 复用推挽输出模式</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">// 上拉输入模式</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 CAN 总线功能 */</span></span><br><span class="line">  CAN_InitStructure.CAN_TTCM = DISABLE;         <span class="comment">// 关闭时间触发通信模式</span></span><br><span class="line">  CAN_InitStructure.CAN_ABOM = DISABLE;         <span class="comment">// 关闭软件自动离线管理</span></span><br><span class="line">  CAN_InitStructure.CAN_AWUM = DISABLE;         <span class="comment">// 关闭睡眠模式通过软件唤醒</span></span><br><span class="line">  CAN_InitStructure.CAN_NART = ENABLE;          <span class="comment">// 开启禁止报文自动传送</span></span><br><span class="line">  CAN_InitStructure.CAN_RFLM = DISABLE;         <span class="comment">// 关闭报文锁定</span></span><br><span class="line">  CAN_InitStructure.CAN_TXFP = DISABLE;         <span class="comment">// 优先级由报文标识符确定</span></span><br><span class="line">  CAN_InitStructure.CAN_Mode = CAN_Mode_Normal; <span class="comment">// CAN_Mode_Normal 普通模式，CAN_Mode_LoopBack 回环模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 CAN 总线波特率 */</span></span><br><span class="line">  CAN_InitStructure.CAN_SJW = tsjw;</span><br><span class="line">  CAN_InitStructure.CAN_BS1 = tbs1;</span><br><span class="line">  CAN_InitStructure.CAN_BS2 = tbs2;</span><br><span class="line">  CAN_InitStructure.CAN_Prescaler = brp;</span><br><span class="line">  CAN_Init(CAN1, &amp;CAN_InitStructure); <span class="comment">// 初始化 CAN1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 CAN 总线过滤器 */</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterNumber = <span class="number">0</span>;                    <span class="comment">// 设置过滤器 0</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;  <span class="comment">// 设置为屏蔽位模式</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit; <span class="comment">// 设置为 32bit 宽度</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterIdHigh = <span class="number">0x0000</span>;               <span class="comment">// 设置 32 位的 ID 值</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterIdLow = <span class="number">0x0000</span>;</span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterMaskIdHigh = <span class="number">0x0000</span>; <span class="comment">// 设置 32 位屏蔽值</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterMaskIdLow = <span class="number">0x0000</span>;</span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0; <span class="comment">// 将过滤器 0 关联至 FIFO0 邮箱</span></span><br><span class="line">  CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;               <span class="comment">// 激活过滤器 0</span></span><br><span class="line">  CAN_FilterInit(&amp;CAN_FilterInitStructure);                            <span class="comment">// 使用上述设置初始化过滤器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CAN_INT_ENABLE</span></span><br><span class="line">  <span class="comment">/* CAN 总线中断接收设置 */</span></span><br><span class="line">  CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE); <span class="comment">// 允许 FIFO0 邮箱产生中断</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>; <span class="comment">// 设置中断主优先级为 1</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;        <span class="comment">// 设置中断次优先级为 0</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CAN 数据发送函数，参数 msg 是待发送数据(最大 8 字节)，参数 len 是待发送的数据长度(最大值 8)，返回值为 0 表示发送成功，其它值表示失败*/</span></span><br><span class="line">u8 <span class="title function_">CAN_Send_Msg</span><span class="params">(u8 *msg, u8 len)</span> &#123;</span><br><span class="line">  u8 mbox;</span><br><span class="line">  u16 i = <span class="number">0</span>;</span><br><span class="line">  CanTxMsg TxMessage;</span><br><span class="line">  TxMessage.StdId = <span class="number">0x12</span>;          <span class="comment">// 设置标准格式下，标识符的值</span></span><br><span class="line">  TxMessage.ExtId = <span class="number">0x00</span>;          <span class="comment">// 设置扩展格式下，标识符的值</span></span><br><span class="line">  TxMessage.IDE = CAN_Id_Standard; <span class="comment">// 设置为标准帧格式</span></span><br><span class="line">  TxMessage.RTR = CAN_RTR_Data;    <span class="comment">// 设置为数据帧</span></span><br><span class="line">  TxMessage.DLC = len;             <span class="comment">// 待发送的数据长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    TxMessage.Data[i] = msg[i]; <span class="comment">// 将参数 msg 数组内的元素，逐个发送至 CAN 总线控制器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mbox = CAN_Transmit(CAN1, &amp;TxMessage); <span class="comment">// 将 TxMessage 数据写入至 CAN 总线 1，返回值 mbox 表示数据被放入了哪个邮箱</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 等待数据发送至邮箱，成功返回 0，失败返回 1 */</span></span><br><span class="line">  <span class="keyword">while</span> ((CAN_TransmitStatus(CAN1, mbox) == CAN_TxStatus_Failed) &amp;&amp; (i &lt; <span class="number">0XFFF</span>)) &#123;</span><br><span class="line">    i++; <span class="comment">// 等待发送结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0XFFF</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 超出预定时间，数据发送失败，返回 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 采用查询模方式接收 CAN 总线数据，参数 buf 是接收数据缓冲区，返回 0 表示当前没有数据接收，其它值则表示接收数据的长度 */</span></span><br><span class="line">u8 <span class="title function_">CAN_Receive_Msg</span><span class="params">(u8 *buf)</span> &#123;</span><br><span class="line">  u32 i;</span><br><span class="line">  CanRxMsg RxMessage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断 FIFO0 是否有数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (CAN_MessagePending(CAN1, CAN_FIFO0) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">// 未接收到数据返回 0</span></span><br><span class="line">    CAN_Receive(CAN1, CAN_FIFO0, &amp;RxMessage); <span class="comment">// 读取 FIFO0 数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">      buf[i] = RxMessage.Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxMessage.DLC; <span class="comment">// 返回数据长度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CAN 中断接收程序，需要将 can.h 的 CAN_INT_ENABLE 置为 1 才会使能中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USB_LP_CAN1_RX0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  CanRxMsg RxMessage;</span><br><span class="line">  vu8 CAN_ReceiveBuff[<span class="number">8</span>]; <span class="comment">// CAN 数据接收数组</span></span><br><span class="line">  vu8 i = <span class="number">0</span>;</span><br><span class="line">  vu8 u8_RxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清空相关的寄存器 */</span></span><br><span class="line">  CAN_ReceiveBuff[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  RxMessage.StdId = <span class="number">0x00</span>;</span><br><span class="line">  RxMessage.ExtId = <span class="number">0x00</span>;</span><br><span class="line">  RxMessage.IDE = <span class="number">0</span>;</span><br><span class="line">  RxMessage.RTR = <span class="number">0</span>;</span><br><span class="line">  RxMessage.DLC = <span class="number">0</span>;</span><br><span class="line">  RxMessage.FMI = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    RxMessage.Data[i] = <span class="number">0x00</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CAN_Receive(CAN1, CAN_FIFO0, &amp;RxMessage); <span class="comment">// 读取 FIFO0 邮箱数据</span></span><br><span class="line">  u8_RxLen = RxMessage.DLC;                 <span class="comment">// 获取数据的数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断标识符是否一致 */</span></span><br><span class="line">  <span class="keyword">if</span> (RxMessage.StdId == <span class="number">0x12</span>) &#123;</span><br><span class="line">    CAN_ReceiveBuff[<span class="number">0</span>] = RxMessage.DLC; <span class="comment">// 将接收到的数据存放至 CAN 数据接收数组的第 0 位</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; u8_RxLen; i++) &#123;</span><br><span class="line">      CAN_ReceiveBuff[i] = RxMessage.Data[i]; <span class="comment">// 将 8 位数据存放至 CAN 数据接收数组的其它位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-25">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;can.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 x;</span><br><span class="line">  u8 buff[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">100</span>);        <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration();  <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();     <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();         <span class="comment">// 初始化继电器</span></span><br><span class="line">  CAN1_Configuration(); <span class="comment">// 初始化 CAN 总线</span></span><br><span class="line">  I2C_Configuration();  <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();      <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank      &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;   CAN Test  &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;TX:    RX:   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 向 CAN 发送字符 A，并且显示到 OLED 屏幕*/</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      buff[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">      CAN_Send_Msg(buff, <span class="number">1</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 CAN 发送字符 B，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      buff[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">      CAN_Send_Msg(buff, <span class="number">1</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 CAN 发送字符 C，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      buff[<span class="number">0</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">      CAN_Send_Msg(buff, <span class="number">1</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向 CAN 发送字符 D，并且显示到 OLED 屏幕 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      buff[<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">      CAN_Send_Msg(buff, <span class="number">1</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询方式接收数据，判断 CAN 总线接收数据的长度，非 0 时表示接受到了数据 */</span></span><br><span class="line">    x = CAN_Receive_Msg(buff);</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, buff[<span class="number">0</span>]); <span class="comment">// 在 OLED 上显示接收的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="adc-模数转换">ADC 模数转换</h2>
<p>ADC
是<strong>STM32F103C8T6</strong>用于采集模拟值的片上外设，<strong>STM32F103C8T6</strong>拥有
2 个 12 位分辨率（读出数据的位长度）的 ADC 模数转换器，它们共用 16
个外部通道（即 ADC
输入引脚<code>ADC12_IN0 ~ ADC12_IN9</code>），并且都可使用 DMA
进行操作。此外，还有<code>VDDA</code>和<code>VSSA</code>引脚用于提供 ADC
功能的电源输入，为它们提供稳定的电源输入可以确保采集的精度与稳定性。</p>
<h3 id="光敏电阻">光敏电阻</h3>
<p>首先，短接 ADC
对应的<strong>P8</strong>跳线座，让光敏电阻与<strong>STM32F103C8T6</strong>正常连接，然后将<code>stm32f10x_dma</code>和<code>stm32f10x_adc</code>两个标准外设库文件添加到项目当中。</p>
<p><img src="/Embedded/STM32F103/adc/diagram-photoresistance.png"></p>
<p>电路图最左侧的<strong>RG1</strong>就是光敏电阻（光线越强阻值越小，光线越弱阻值越大），将它的一个引脚接地，另一个引脚通过<code>10K</code>上拉电阻连接至<code>3.3V</code>电源上，然后通过<code>1K</code>限流电阻经由<strong>P8</strong>跳线插座连接至<strong>STM32F103C8T6</strong>的<code>PA4</code>和<code>PA5</code>引脚。这样，光敏电阻阻值的变化，就会使得
ADC
采集对应的<code>PA4</code>和<code>PA5</code>引脚的输入电压发生变化。</p>
<h4 id="adc.h">adc.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/adc/adc.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC1_DR_Address ((uint32_t)0x4001244C) <span class="comment">// ADC1 外设地址，由 ADC1 外设起始地址加上偏移量获得</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADCPORT GPIOA      <span class="comment">// 设置 GPIO 引脚分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_CH4 GPIO_Pin_4 <span class="comment">// 定义 ADC 为电压电位器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_CH5 GPIO_Pin_5 <span class="comment">// 定义 ADC 为光敏电阻</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_CH6 GPIO_Pin_6 <span class="comment">// 定义 ADC 为摇杆 X 轴</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_CH7 GPIO_Pin_7 <span class="comment">// 定义 ADC 为摇杆 Y 轴</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Configuration</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMA_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="adc.c">adc.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/adc/adc.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">vu16 ADC_DMA_IN5; <span class="comment">// 用于存放 ADC 最终转换的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 使用 DMA 传输的初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMA_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  DMA_InitTypeDef DMA_InitStructure;                                          <span class="comment">// 定义 DMA 初始化结构体</span></span><br><span class="line">  DMA_DeInit(DMA1_Channel1);                                                  <span class="comment">// 复位 DMA 通道 1</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;                 <span class="comment">// 设置 DMA 通道外设基地址，即 DMA 从哪里读取数据</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_DMA_IN5;                   <span class="comment">// 设置 DMA 通道 ADC 数据存储器地址，即 DMA 将读取的数据放置到什么位置</span></span><br><span class="line">  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                          <span class="comment">// 指定外设源地址</span></span><br><span class="line">  DMA_InitStructure.DMA_BufferSize = <span class="number">1</span>;                                       <span class="comment">// 设置 DMA 缓冲区大小，根据 ADC 采集通道数决定，当前仅有光敏电阻 1 个数据量，所以这里选择 1</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;            <span class="comment">// 设置当前外设寄存器地址为不变化</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;                    <span class="comment">// 当前 DMA 存储器地址是否自增 1，由于当前只采集 1 个数据，所以选择 Disable</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; <span class="comment">// 设置 DMA 需要读取的数据宽度为 16 位</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;         <span class="comment">// 设置 DMA 存放地址的数据宽度为 16 位</span></span><br><span class="line">  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;                             <span class="comment">// 设置 DMA 通道操作模式为环形缓冲模式</span></span><br><span class="line">  DMA_InitStructure.DMA_Priority = DMA_Priority_High;                         <span class="comment">// 设置 DMA 通道优先级为高</span></span><br><span class="line">  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;                                <span class="comment">// 禁止 DMA 通道为存储器到存储器的传输</span></span><br><span class="line">  DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);                                <span class="comment">// 初始化 DMA 通道 1</span></span><br><span class="line">  DMA_Cmd(DMA1_Channel1, ENABLE);                                             <span class="comment">// 使能 DMA 通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 相关的 GPIO 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;                                                                <span class="comment">// 定义 GPIO 初始化结构体</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE); <span class="comment">// 使能 GPIO 相关时钟</span></span><br><span class="line">  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);                                                  <span class="comment">// 使能 DMA 相关时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);                                                <span class="comment">// 使能 ADC1 相关时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = ADC_CH5;                                                              <span class="comment">// 选择 PA5 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;                                                       <span class="comment">// 设置为模拟输入模式</span></span><br><span class="line">  GPIO_Init(ADCPORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ADC_InitTypeDef ADC_InitStructure; <span class="comment">// 定义 ADC 初始化结构体</span></span><br><span class="line">  ADC_GPIO_Init();                   <span class="comment">// 调用 ADC 相关的 GPIO 初始化函数</span></span><br><span class="line">  ADC_DMA_Init();                    <span class="comment">// 调用 ADC 相关的 DMA 初始化函数</span></span><br><span class="line"></span><br><span class="line">  ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                  <span class="comment">// 设置 ADC1 和 ADC2 独立工作模式</span></span><br><span class="line">  ADC_InitStructure.ADC_ScanConvMode = ENABLE;                        <span class="comment">// 使能 ADC 扫描</span></span><br><span class="line">  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;                  <span class="comment">// 设置 ADC 转换运行在连续模式，即循环进行采集</span></span><br><span class="line">  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; <span class="comment">// 有软件控制转换</span></span><br><span class="line">  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;              <span class="comment">// 设置数据排列为右对齐</span></span><br><span class="line">  ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;                             <span class="comment">// 设置当前使用的 ADC 通道数目</span></span><br><span class="line">  ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_5, <span class="number">1</span>, ADC_SampleTime_28Cycles5); <span class="comment">// 设置 ADC1 的通道 ADC_Channel_5，转换顺序为 1，采样时间为 ADC_SampleTime_28Cycles5</span></span><br><span class="line">  ADC_DMACmd(ADC1, ENABLE);                                                   <span class="comment">// 开启 ADC 的 DMA 功能</span></span><br><span class="line">  ADC_Cmd(ADC1, ENABLE);                                                      <span class="comment">// 使能 ADC1 开始工作</span></span><br><span class="line"></span><br><span class="line">  ADC_ResetCalibration(ADC1);                  <span class="comment">// 重置 ADC1 校准</span></span><br><span class="line">  <span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1)); <span class="comment">// 等待 ADC1 校准重置完成</span></span><br><span class="line">  ADC_StartCalibration(ADC1);                  <span class="comment">// 开始ADC1校准</span></span><br><span class="line">  <span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1));      <span class="comment">// 等待 ADC1 校准完成</span></span><br><span class="line"></span><br><span class="line">  ADC_SoftwareStartConvCmd(ADC1, ENABLE); <span class="comment">// 使能 ADC1 软件转换，开始执行 ADC 模拟量采集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-26">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> vu16 ADC_DMA_IN5; <span class="comment">// 声明外部变量，用于存放 ADC 采集的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  ADC_Configuration(); <span class="comment">// 初始化 ADC 设置</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank      &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;   ADC Test  &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; ADC_IN5:    &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将光敏电阻的 ADC 数据显示到 OLED */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">10</span> * <span class="number">8</span>, ADC_DMA_IN5 / <span class="number">1000</span> + <span class="number">0x30</span>);       <span class="comment">// 显示 ADC 采集的数据的千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, ADC_DMA_IN5 % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>); <span class="comment">// 显示 ADC 采集的数据的百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, ADC_DMA_IN5 % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);   <span class="comment">// 显示 ADC 采集的数据的十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, ADC_DMA_IN5 % <span class="number">10</span> + <span class="number">0x30</span>);         <span class="comment">// 显示 ADC 采集的数据的个位</span></span><br><span class="line">    delay_ms(<span class="number">500</span>);                                                 <span class="comment">// 每间隔 500ms 刷新一次 OLED 屏幕数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="电位器光敏电阻-2-通道-adc-采集">电位器&amp;光敏电阻 2 通道 ADC
采集</h3>
<p>上面的光敏电阻实验只演示了 1
个通道的示例，这里再来完成一个电位器、光敏电阻的 2 通道 ADC
采集。代码执行时，OLED
屏幕会同时显示<strong>ADC_IN4</strong>（电位器电压）和<strong>ADCIN5</strong>（光敏电阻电压）两组数据。</p>
<h4 id="adc.h-1">adc.h</h4>
<p><code>adc.h</code>没有进行任何改动，继续沿用上一个实验当中的头文件代码。</p>
<h4 id="adc.c-1">adc.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/adc/adc.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">vu16 ADC_DMA_IN[<span class="number">2</span>]; <span class="comment">// 用于存放 ADC 转换数据的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 使用 DMA 传输的初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMA_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  DMA_InitTypeDef DMA_InitStructure;                                          <span class="comment">// 定义 DMA 初始化结构体</span></span><br><span class="line">  DMA_DeInit(DMA1_Channel1);                                                  <span class="comment">// 复位 DMA 通道 1</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;                 <span class="comment">// 设置 DMA 通道外设基地址，即 DMA 从哪里读取数据</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_DMA_IN;                    <span class="comment">// 设置 DMA 通道 ADC 数据存储器地址，即 DMA 将读取的数据放置到什么位置</span></span><br><span class="line">  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                          <span class="comment">// 指定外设源地址</span></span><br><span class="line">  DMA_InitStructure.DMA_BufferSize = <span class="number">2</span>;                                       <span class="comment">// 设置 DMA 缓冲区大小，当前采用了光敏电阻和电位器 2 个数据量，所以这里修改为 2</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;            <span class="comment">// 设置当前外设寄存器地址为不变化</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                     <span class="comment">// 当前 DMA 存储器地址是否自增 1，由于当前只采集 1 个数据，所以选择 Disable</span></span><br><span class="line">  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; <span class="comment">// 设置 DMA 需要读取的数据宽度为 16 位</span></span><br><span class="line">  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;         <span class="comment">// 设置 DMA 存放地址的数据宽度为 16 位</span></span><br><span class="line">  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;                             <span class="comment">// 设置 DMA 通道操作模式为环形缓冲模式</span></span><br><span class="line">  DMA_InitStructure.DMA_Priority = DMA_Priority_High;                         <span class="comment">// 设置 DMA 通道优先级为高</span></span><br><span class="line">  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;                                <span class="comment">// 禁止 DMA 通道为存储器到存储器的传输</span></span><br><span class="line">  DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);                                <span class="comment">// 初始化 DMA 通道 1</span></span><br><span class="line">  DMA_Cmd(DMA1_Channel1, ENABLE);                                             <span class="comment">// 使能 DMA 通道 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 相关的 GPIO 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;                                                                <span class="comment">// 定义 GPIO 初始化结构体</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE); <span class="comment">// 使能 GPIO 相关时钟</span></span><br><span class="line">  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);                                                  <span class="comment">// 使能 DMA 相关时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);                                                <span class="comment">// 使能 ADC1 相关时钟</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = ADC_CH4 | ADC_CH5;                                                    <span class="comment">// 同时选择 PA4 和 PA5 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;                                                       <span class="comment">// 设置为模拟输入模式</span></span><br><span class="line">  GPIO_Init(ADCPORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ADC_InitTypeDef ADC_InitStructure; <span class="comment">// 定义 ADC 初始化结构体</span></span><br><span class="line">  ADC_GPIO_Init();                   <span class="comment">// 调用 ADC 相关的 GPIO 初始化函数</span></span><br><span class="line">  ADC_DMA_Init();                    <span class="comment">// 调用 ADC 相关的 DMA 初始化函数</span></span><br><span class="line"></span><br><span class="line">  ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                  <span class="comment">// 设置 ADC1 和 ADC2 独立工作模式</span></span><br><span class="line">  ADC_InitStructure.ADC_ScanConvMode = ENABLE;                        <span class="comment">// 使能 ADC 扫描</span></span><br><span class="line">  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;                  <span class="comment">// 设置 ADC 转换运行在连续模式，即循环进行采集</span></span><br><span class="line">  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; <span class="comment">// 有软件控制转换</span></span><br><span class="line">  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;              <span class="comment">// 设置数据排列为右对齐</span></span><br><span class="line">  ADC_InitStructure.ADC_NbrOfChannel = <span class="number">2</span>;                             <span class="comment">// 设置当前使用的 ADC 通道数目</span></span><br><span class="line">  ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_4, <span class="number">1</span>, ADC_SampleTime_28Cycles5); <span class="comment">// 设置 ADC1 的通道 ADC_Channel_4，转换顺序为 1 先转换，采样时间为 ADC_SampleTime_28Cycles5</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_5, <span class="number">2</span>, ADC_SampleTime_28Cycles5); <span class="comment">// 设置 ADC1 的通道 ADC_Channel_5，转换顺序为 2 后转换，采样时间为 ADC_SampleTime_28Cycles5</span></span><br><span class="line">  ADC_DMACmd(ADC1, ENABLE);                                                   <span class="comment">// 开启 ADC 的 DMA 功能</span></span><br><span class="line">  ADC_Cmd(ADC1, ENABLE);                                                      <span class="comment">// 使能 ADC1 开始工作</span></span><br><span class="line"></span><br><span class="line">  ADC_ResetCalibration(ADC1);                   <span class="comment">// 重置 ADC1 校准</span></span><br><span class="line">  <span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1));  <span class="comment">// 等待 ADC1 校准重置完成</span></span><br><span class="line">  ADC_StartCalibration(ADC1);                   <span class="comment">// 开始ADC1校准</span></span><br><span class="line">  <span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1));       <span class="comment">// 等待 ADC1 校准完成</span></span><br><span class="line"></span><br><span class="line">  ADC_SoftwareStartConvCmd(ADC1, ENABLE); <span class="comment">// 使能 ADC1 软件转换，开始执行 ADC 模拟量采集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-27">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> vu16 ADC_DMA_IN[<span class="number">2</span>]; <span class="comment">// 声明外部变量数组，用于存放 ADC 将要采集的 2 个数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  ADC_Configuration(); <span class="comment">// 初始化 ADC 设置</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank      &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;   ADC Test  &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot; ADC_IN4:    &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; ADC_IN5:    &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将电位器的 ADC 数据显示到 OLED */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">10</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] / <span class="number">1000</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">11</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">12</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">13</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将光敏电阻的 ADC 数据显示到 OLED */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">10</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] / <span class="number">1000</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">500</span>); <span class="comment">// 每间隔 500ms 刷新一次 OLED 屏幕数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟量摇杆">模拟量摇杆</h3>
<p>模拟量摇杆的机械结构由 2 个电位器和 1
个微动开关组成，进入本实验之前，需要将实验电路当中模拟量遥感对应的<strong>P17</strong>跳线座短接，同时断开旋转编码器对应的<strong>P18</strong>跳线，避免两者共用一组
GPIO 引脚。</p>
<p><img src="/Embedded/STM32F103/adc/diagram-rocker.png"></p>
<p>模拟量摇杆的 X 轴电位器<strong>JS_X</strong>、Y
轴电位器<strong>JS_Y</strong>、微动开头<strong>JS_D</strong>分别经由<strong>P17</strong>跳线插座连接至<strong>STM32F103C8T6</strong>的<code>PA6</code>、<code>PA7</code>、<code>PB2</code>引脚。将下面程序下载到实验电路运行以后，OLED
屏幕显示的<strong>ADC_IN7</strong>是摇杆上下调整的模拟量值，<strong>ADC_IN6</strong>则是摇杆左右调整的模拟量值。如果分别向左上、右上、左下、右下摆动摇杆，则会使<strong>ADC_IN6</strong>和<strong>ADC_IN7</strong>两组值同时发生变化。如果直接按下摇杆，将会在
OLED 屏幕的左上角显示<code>H</code>字母，放开则会直接消失。</p>
<h4 id="joystick.h">JoyStick.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/JoyStick/JoyStick.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JoyStickPORT GPIOB      <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JoyStick_KEY GPIO_Pin_2 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">JoyStick_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="joystick.c">JoyStick.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/JoyStick/JoyStick.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;JoyStick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 模拟量摇杆的微动开关初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">JoyStick_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//  定义 GPIO 初始化枚举结构</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = JoyStick_KEY;   <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">// 设置 GPIO 为上拉电阻输入模式</span></span><br><span class="line">  GPIO_Init(JoyStickPORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="adc.c-2">adc.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 相关的 GPIO 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = ADC_CH6 | ADC_CH7; <span class="comment">// 同时选择 PA6 和 PA7 引脚</span></span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Configuration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_6, <span class="number">1</span>, ADC_SampleTime_28Cycles5); <span class="comment">// 设置 ADC1 的通道 ADC_Channel_6，转换顺序为 1 先转换，采样时间为 ADC_SampleTime_28Cycles5</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_7, <span class="number">2</span>, ADC_SampleTime_28Cycles5); <span class="comment">// 设置 ADC1 的通道 ADC_Channel_7，转换顺序为 2 后转换，采样时间为 ADC_SampleTime_28Cycles5</span></span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-28">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;JoyStick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> vu16 ADC_DMA_IN[<span class="number">2</span>]; <span class="comment">// 声明外部变量数组，用于存放 ADC 将要采集的 2 个数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  ADC_Configuration(); <span class="comment">// 初始化 ADC 设置</span></span><br><span class="line">  JoyStick_Init();     <span class="comment">// 初始化模拟量摇杆的微动开关</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank      &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;   ADC Test  &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot; ADC_IN6:    &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; ADC_IN7:    &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将电位器的 ADC 数据显示到 OLED */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">10</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] / <span class="number">1000</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">11</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">12</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">13</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">0</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将光敏电阻的 ADC 数据显示到 OLED */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">10</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] / <span class="number">1000</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, ADC_DMA_IN[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模拟量摇杆微动开关按下处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_ReadInputDataBit(JoyStickPORT, JoyStick_KEY) == <span class="number">0</span>) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>); <span class="comment">// 如果按键按下，显示字母 H</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27; &#x27;</span>); <span class="comment">// 如果按键放开，显示空格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">500</span>); <span class="comment">// 每间隔 500ms 刷新一次 OLED 屏幕数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="my1650-音频解码芯片">MY1650 音频解码芯片</h2>
<p><strong>MY1690-16S</strong>是深圳市迈优科技有限公司自主研发的一款串口控制的插卡音频播放芯片，可以进行
MP3 和 WAV 双格式解码，最大支持 32G 的 TF 存储卡，也可以外接 U 盘或者
USB 数据线连接至电脑，以更换 SD
卡音频文件。进行本实验之前，需要先短接实验电路右上角的 <strong>TF
CARD</strong>、<strong>MY1680</strong>、<strong>USB</strong>
相关的跳线座，然后再分别断接旋转编码器、模拟量摇杆对应的<strong>P18</strong>和<strong>P17</strong>跳线座。</p>
<p><img src="/Embedded/STM32F103/my1690-tf-usb/diagram-my1690.png"></p>
<p><strong>STM32F103C8T6</strong>的 USART3
外设对应的<code>PB10</code>和<code>PB11</code>经由上面原理图中的<code>TFMUSIC_RX</code>和<code>TFMUSIC_TX</code>分别连接至<strong>P14</strong>跳线插座的<code>RX</code>和<code>TX</code>，最后连接到<strong>MY1690-16S</strong>音频播放芯片的
<code>RX</code> 和 <code>TX</code>
引脚。此外，网络标号为<strong>J8</strong>的 SD
卡座的<code>DO</code>、<code>CLK</code>、<code>DI</code>引脚分别经由<strong>P16</strong>跳线座连接至<strong>MY1690-16S</strong>的<code>MY_DAT</code>、<code>MY_CMD</code>、<code>MY_CLK</code>引脚。最后，<strong>MY1690</strong>的<code>ADKEY</code>引脚经过<strong>P16</strong>跳线座以后，最终连接至<strong>LM4871</strong>音频功率放大芯片的电源控制引脚<code>SHUTDOWN</code>。</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 42%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">管脚号</th>
<th>管脚名称</th>
<th>功能描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td><strong>SD_DAT</strong></td>
<td>接 SD 卡</td>
<td>-</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td><strong>SD_CMD</strong></td>
<td>接 SD 卡</td>
<td>-</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td><strong>SD_CLK</strong></td>
<td>接 SD 卡</td>
<td>-</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td><strong>ADKEY</strong></td>
<td>电阻分压功能选择脚</td>
<td>通过不同阻值分压实现多种功能</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td><strong>DM</strong></td>
<td>USB 信号线</td>
<td>U 盘或者 USB 连接电脑更换 TF 卡文件</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td><strong>DP</strong></td>
<td>USB 信号线</td>
<td>U 盘或者 USB 连接电脑更换 TF 卡文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">7</td>
<td><strong>VPN</strong></td>
<td>内部电源偏置电压</td>
<td><code>1uF</code> 电容接地</td>
</tr>
<tr class="even">
<td style="text-align: left;">8</td>
<td><strong>VSS</strong></td>
<td>模拟信号地</td>
<td>模拟地，连接大功率功放时与数字地分开</td>
</tr>
<tr class="odd">
<td style="text-align: left;">9</td>
<td><strong>DACL</strong></td>
<td>右声道音频信号输出</td>
<td>连接耳机或者功放</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td><strong>DACR</strong></td>
<td>左声道音频信号输出</td>
<td>连接耳机或者功放</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td><strong>3V3</strong></td>
<td>内部 LDO 3.3V 输出</td>
<td>可以为 TF 卡，驱动电流<code>100mA</code>以内</td>
</tr>
<tr class="even">
<td style="text-align: left;">12</td>
<td><strong>DC5V</strong></td>
<td>芯片电源正极输入</td>
<td>电源范围<code>3.4V ~ 5.5V</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">13</td>
<td><strong>GND</strong></td>
<td>系统接地</td>
<td>-</td>
</tr>
<tr class="even">
<td style="text-align: left;">14</td>
<td><strong>TX</strong></td>
<td>UART 异步串口数据输出</td>
<td><code>3.3V</code>的 TTL 信号</td>
</tr>
<tr class="odd">
<td style="text-align: left;">15</td>
<td><strong>RX</strong></td>
<td>UART 异步串口数据输入</td>
<td><code>3.3V</code>的 TTL 信号</td>
</tr>
<tr class="even">
<td style="text-align: left;">16</td>
<td><strong>BUSY</strong></td>
<td>播放时输出高电平，暂停或停止时为低电平</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>如前所述，<strong>MY1690-16S</strong>的<code>MY_DAT</code>、<code>MY_CMD</code>、<code>MY_CLK</code>是连接到
TF
卡上的，可连接控制按键盘的<code>ADKEY</code>引脚通过<code>22KΩ</code>电阻直接连接到<code>3.3V</code>电源，另外<code>DM</code>和<code>DP</code>引脚用于连接开发板上的
Micro USB 接口（如果连接了 USB 接口但是没有插入 TF 卡，MY1690 会将 TF
卡的 U
盘功能切换为声卡功能）。<strong>MY1690-16S</strong>的<code>VPN</code>引脚则连接至<code>1uF</code>电容，<code>VSS</code>引脚直接接地，<code>DACL</code>和<code>DACR</code>是左右声道音频输出，当前实验电路只有一个单声道扬声器，所以各经过<code>1uF</code>电容后将双声道合并为单声道经由功放芯片<strong>LM4871</strong>音频放大后接入扬声器；<code>BUSY</code>引脚连接到一枚外部
LED，芯片工作时自动点亮。</p>
<p><strong>MY1690-16S</strong>采用 <code>3.3V</code> 的 UART
异步串行接口连接，通讯数据格式为<code>1 位起始位</code>、<code>8 位数据位</code>、<code>无奇偶校验位</code>、<code>1 位停止位</code>；此外，其传输的数据必须遵循如下协议格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始码(0x7E) | 长度(参考手册) | 操作码(参考手册) | 参数(参考手册) | 校验码(参考手册) | 结束码(0xEF)</span><br></pre></td></tr></table></figure>
<h3 id="音乐播放">音乐播放</h3>
<h4 id="usart.h-2">usart.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART3 1 <span class="comment">// 使能 USART3</span></span></span><br></pre></td></tr></table></figure>
<h4 id="usart.c-6">usart.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** USART3 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_Init</span><span class="params">(u32 BaudRate)</span> &#123;</span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); <span class="comment">// 使能 USART 接收中断</span></span><br><span class="line">  <span class="comment">/* ... 省略雷同代码 ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** USART3 中断服务程序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 Res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断接收中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123;</span><br><span class="line">    Res = USART_ReceiveData(USART3); <span class="comment">// 读取 USART3 接收到的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断数据是否为 STOP，省略读取 S */</span></span><br><span class="line">    <span class="keyword">if</span> (Res == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">      USART3_RX_STA = <span class="number">1</span>; <span class="comment">// 标志位置为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 判断数据是否为 OK，省略读取 K */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Res == <span class="string">&#x27;K&#x27;</span>) &#123;</span><br><span class="line">      USART3_RX_STA = <span class="number">2</span>; <span class="comment">// 标志位置为 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="my1690.h">MY1690.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/MY1690/MY1690.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY1690_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY1690_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_Init</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// MY1690 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PLAY</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 播放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PREV</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 上一曲</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_NEXT</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 下一曲</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PAUSE</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 暂停</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_VUP</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// 音量加 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_VDOWN</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 音量减 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_STOP</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MY1690 指令输入函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD1</span><span class="params">(u8 a)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD2</span><span class="params">(u8 a, u8 b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD3</span><span class="params">(u8 a, u16 b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="my1690.c">MY1690.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/MY1690/MY1690.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MY1690.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** MY1690 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_Init(<span class="number">9600</span>); <span class="comment">// 初始化 USART 为 9600 波特率</span></span><br><span class="line">  MY1690_STOP();     <span class="comment">// 发送一条停止播放指令，从而激活 MY1690</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 播放 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PLAY</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x11\x12\xef&quot;</span>); <span class="comment">// 符号 \x 后面是十六进制数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 暂停 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PAUSE</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x12\x11\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 上一曲 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_PREV</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x14\x17\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 下一曲 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_NEXT</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x13\x10\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 音量加 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_VUP</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x15\x16\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 音量减 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_VDOWN</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x16\x15\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 停止函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_STOP</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  USART3_printf(<span class="string">&quot;\x7e\x03\x1E\x1D\xef&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 无参数指令的发送函数，参数 a 是操作码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD1</span><span class="params">(u8 a)</span> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  i = <span class="number">3</span> ^ a; <span class="comment">// 生成校验码</span></span><br><span class="line"></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x7e</span>);  <span class="comment">// 发送起始码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x03</span>);  <span class="comment">// 发送数据长度</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, a);     <span class="comment">// 发送操作码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, i);     <span class="comment">// 发送校验码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0xef</span>);  <span class="comment">// 发送结束码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有参数指令的发送函数，参数 a 是操作码 b 是 8 位参数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD2</span><span class="params">(u8 a, u8 b)</span> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  i = <span class="number">4</span> ^ a; <span class="comment">// 生成校验码</span></span><br><span class="line">  i = i ^ b; <span class="comment">// 生成校验码</span></span><br><span class="line"></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x7e</span>);  <span class="comment">// 发送起始码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x04</span>);  <span class="comment">// 发送数据长度</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, a);     <span class="comment">// 发送操作码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, b);     <span class="comment">// 发送 8 位参数</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, i);     <span class="comment">// 发送校验码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0xef</span>);  <span class="comment">// 发送结束码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有参数指令的发送函数，参数 a 是操作码 b 是 16 位参数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MY1690_CMD3</span><span class="params">(u8 a, u16 b)</span> &#123;</span><br><span class="line">  u8 i, c, d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 16 位参数分解为 2 个 8 位参数 */</span></span><br><span class="line">  c = b / <span class="number">0x100</span>;</span><br><span class="line">  d = b % <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">5</span> ^ a; <span class="comment">// 获取校验码</span></span><br><span class="line">  i = i ^ c; <span class="comment">// 获取校验码</span></span><br><span class="line">  i = i ^ d; <span class="comment">// 获取校验码</span></span><br><span class="line"></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x7e</span>);   <span class="comment">// 发送起始码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0x05</span>);   <span class="comment">// 发送数据长度</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, a);      <span class="comment">// 发送操作码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, c);      <span class="comment">// 发送 16 位参数高 8 位</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, d);      <span class="comment">// 发送 16 位参数低 8 位</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, i);      <span class="comment">// 发送校验码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">  USART_SendData(USART3, <span class="number">0xef</span>);   <span class="comment">// 发送结束码</span></span><br><span class="line">  <span class="keyword">while</span> (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET); <span class="comment">// 检查发送中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-29">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my1690.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 b;</span><br><span class="line">  u8 MP3 = <span class="number">0</span>; <span class="comment">// 初始化 MY1690 为暂停状态</span></span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  ENCODER_Init();      <span class="comment">// 初始化旋转编码器</span></span><br><span class="line">  MY1690_Init();       <span class="comment">// 初始化 MY1690 以及 USART</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">3</span>, <span class="string">&quot; MP3 Play Test  &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断 4 个触摸按键是否按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D) == <span class="number">0</span>) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>); <span class="comment">// 去抖延时，便于程序移植到机械按键</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* A 键按下，播放上一曲 */</span></span><br><span class="line">      <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span>) &#123;</span><br><span class="line">        MY1690_PREV();</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PREV --    &quot;</span>);</span><br><span class="line">        delay_ms(<span class="number">500</span>);</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PLAY --    &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* B 键按下，播放下一曲 */</span></span><br><span class="line">      <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B) == <span class="number">0</span>) &#123;</span><br><span class="line">        MY1690_NEXT();</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- NEXT --    &quot;</span>);</span><br><span class="line">        delay_ms(<span class="number">500</span>);</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PLAY --    &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* C 键按下，设置音量为最大 */</span></span><br><span class="line">      <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C) == <span class="number">0</span>) &#123;</span><br><span class="line">        MY1690_CMD2(<span class="number">0x31</span>, <span class="number">30</span>);</span><br><span class="line">        delay_ms(<span class="number">500</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* C 键按下，播放第 0004 曲目 */</span></span><br><span class="line">      <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D) == <span class="number">0</span>) &#123;</span><br><span class="line">        MY1690_CMD3(<span class="number">0x41</span>, <span class="number">0x04</span>);</span><br><span class="line">        delay_ms(<span class="number">500</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 等待触摸按键放开 */</span></span><br><span class="line">      <span class="keyword">while</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取旋转编码器状态值，并进行判断分析 */</span></span><br><span class="line">    b = ENCODER_READ();</span><br><span class="line">    <span class="comment">/* 右转增大音量 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">      MY1690_VUP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 左转降低音量 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>) &#123;</span><br><span class="line">      MY1690_VDOWN();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 按下旋转编码器，执行播放或暂停操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果当前处于播放状态 */</span></span><br><span class="line">      <span class="keyword">if</span> (MP3 == <span class="number">0</span>) &#123;</span><br><span class="line">        MP3 = <span class="number">1</span>;</span><br><span class="line">        MY1690_PLAY();</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PLAY --    &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果当前处于暂停状态 */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (MP3 == <span class="number">1</span>) &#123;</span><br><span class="line">        MP3 = <span class="number">0</span>;</span><br><span class="line">        MY1690_PAUSE();</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PAUSE --   &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      delay_ms(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MY1690 串行接口接收到指令的处理，标志位 1 表示收到 STOP 指令，标志位 2 表示收到 OK 指令 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART3_RX_STA == <span class="number">1</span>) &#123;</span><br><span class="line">      MP3 = <span class="number">0</span>;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- STOP --    &quot;</span>);</span><br><span class="line">      USART3_RX_STA = <span class="number">0</span>; <span class="comment">// 标志位清 0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (USART3_RX_STA == <span class="number">2</span>) &#123;</span><br><span class="line">      USART3_RX_STA = <span class="number">0</span>; <span class="comment">// 标志位清 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时钟语音播报">时钟语音播报</h3>
<p>TF
卡语音播报文件当中，<code>0001 ~ 0011</code>是阿拉伯数字<code>0 ~ 10</code>的发音，<code>0012</code>是<code>现在是北京时间</code>的发音，<code>0013</code>是<code>点</code>的发音，<code>0014</code>是<code>分</code>的发音，<code>0015</code>是<code>秒</code>的发音。</p>
<h4 id="main.c-30">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my1690.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>); <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line"></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RTC_Config();        <span class="comment">// 初始化实时时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  ENCODER_Init();      <span class="comment">// 初始化旋转编码器</span></span><br><span class="line">  MY1690_Init();       <span class="comment">// 初始化 MY1690 以及 USART</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot; MP3 Time Read  &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 读取实时时钟 RTC 的数据*/</span></span><br><span class="line">    <span class="keyword">if</span> (RTC_Get() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* OLED 显示小时 */</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">3</span>, rhour / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">4</span>, rhour % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">5</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      <span class="comment">/* OLED 显示分钟 */</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">6</span>, rmin / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">7</span>, rmin % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">8</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      <span class="comment">/* OLED 显示秒钟 */</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">9</span>, rsec / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">8</span> * <span class="number">10</span>, rsec % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      delay_ms(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 4 个触摸按键是否有被按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D) == <span class="number">0</span>) &#123;</span><br><span class="line">      delay_ms(<span class="number">20</span>);</span><br><span class="line">      <span class="comment">/* 如果 A 键被按下，就采用 MY1690 的组合播放功能，一次性播放多条指令 */</span></span><br><span class="line">      <span class="keyword">if</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span>) &#123;</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- PLAY --    &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 播放小时值十位和个位对应的语音编号 */</span></span><br><span class="line">        MY1690_CMD3(<span class="number">0x41</span>, <span class="number">12</span>); <span class="comment">// 播放曲目 12，&quot;现在是北京时间&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果小时值十位等于 0 时 */</span></span><br><span class="line">        <span class="keyword">if</span> (rhour / <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 不发音</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 当小时值的十位等于 1 时 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rhour / <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);             <span class="comment">// 播放曲目 11，&quot;十&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 当小时值十位除了为 0 或者 1 之外，进行正常播报 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rhour / <span class="number">10</span> + <span class="number">1</span>); <span class="comment">// 播放小时值十位对应的语音编号</span></span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);             <span class="comment">// 播放曲目 11，&quot;十&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 当整个小时值等于 0 或者 仅个位不等于 0 时 */</span></span><br><span class="line">        <span class="keyword">if</span> (rhour % <span class="number">10</span> != <span class="number">0</span> || rhour == <span class="number">0</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rhour % <span class="number">10</span> + <span class="number">1</span>); <span class="comment">// 播放小时值个位对应的语音编号</span></span><br><span class="line">        &#125;</span><br><span class="line">        MY1690_CMD3(<span class="number">0x41</span>, <span class="number">13</span>);               <span class="comment">// 播放曲目 11，&quot;点&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 播放分钟值十位和个位对应的语音编号，判断方式与小时相同 */</span></span><br><span class="line">        <span class="keyword">if</span> (rmin / <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rmin / <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rmin / <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rmin / <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rmin % <span class="number">10</span> != <span class="number">0</span> || rmin == <span class="number">0</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rmin % <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MY1690_CMD3(<span class="number">0x41</span>, <span class="number">14</span>); <span class="comment">// 播放曲目 11，&quot;点&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 播放秒数值十位和个位对应的语音编号，判断方式与小时相同 */</span></span><br><span class="line">        <span class="keyword">if</span> (rsec / <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rsec / <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rsec / <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rsec / <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, <span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rsec % <span class="number">10</span> != <span class="number">0</span> || rsec == <span class="number">0</span>) &#123;</span><br><span class="line">          MY1690_CMD3(<span class="number">0x41</span>, rsec % <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MY1690_CMD3(<span class="number">0x41</span>, <span class="number">15</span>); <span class="comment">// 播放曲目 11，&quot;点&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 等待按键松开 */</span></span><br><span class="line">      <span class="keyword">while</span> (GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C) == <span class="number">0</span> || GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART3 接收处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (USART3_RX_STA == <span class="number">1</span>) &#123; <span class="comment">// 标志位为 1 就表示收到 STOP</span></span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  -- STOP --    &quot;</span>);</span><br><span class="line">      USART3_RX_STA = <span class="number">0</span>; <span class="comment">// 将串口数据标志位清 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ch376-文件管理控制芯片">CH376 文件管理控制芯片</h2>
<p>CH376T
是江苏沁恒股份有限公司生产的一款文件管理控制芯片，主要用于单片机系统读写
U 盘或者 SD 卡，并且可以通过 SPI 和 UART
两种总线方式与<strong>STM32F103C8T6</strong>进行通信，当前实验电路选择的是
SPI 总线连接方式。设置好右上角的跳线坐，短接实验电路右上角的 <strong>TF
CARD</strong>、<strong>MY1680</strong>、<strong>USB</strong>
跳线座，并且将<code>stm32f10x_spi</code>标准外设库添加至当前工程，后续将着手完成一个用于检测
U 盘插入状态以及进行文件系统读取的实验程序。</p>
<p><img src="/Embedded/STM32F103/spi/block.png"></p>
<p><strong>STM32F103C8T6</strong>拥有 2 个 SPI
接口（<strong>SPI1</strong>的<code>PA4/SPI1_NSS</code>、<code>PA5/SPI1_SCK</code>、<code>PA6/SPI1_MISO</code>、<code>PA7/SPI1_MOSI</code>引脚，<strong>SPI2</strong>的<code>PB12/SPI2_NSS</code>、<code>PB13/SPI2_SCK</code>、<code>PB14/SPI2_MISO</code>、<code>PB15/SPI2_MOSI</code>引脚），每个接口拥有
<code>MISO</code>（主机接收，从机发送）、<code>MOSI</code>（主机发送，从机接收）、<code>SCK</code>（同步时钟）、<code>NSS</code>（设备选择）
四条信号线，并且所有的主从设备都需要进行共地连接。由于 SPI
总线上的设备没有地址的概念，所以需要通过<code>NSS</code>信号线的电平状态来选中需要通信的设备（低电平使能，高电平失能）。<strong>STM32F103C8T6</strong>只拥有
1 条<code>NSS</code>信号线，如果需要连接更多的设备，就需要使用到普通的
GPIO 引脚来模拟相关的功能。</p>
<p><img src="/Embedded/STM32F103/spi/diagram.png"></p>
<p>实验电路中，电路图里的<code>SPI_CS</code>、<code>SPI_CLK</code>、<code>SPI_DI</code>、<code>SPI_DO</code>分别代表<strong>SPI2</strong>的<code>PB12/SPI2_NSS</code>、<code>PB13/SPI2_SCK</code>、<code>PB14/SPI2_MISO</code>、<code>PB15/SPI2_MOSI</code>引脚，经过<strong>P16</strong>和<strong>PA15</strong>跳线座以后，连接到
CH376T
芯片的<code>SCS</code>、<code>SCK</code>、<code>SDI</code>、<code>SDO</code>引脚。
CH376T 芯片的<code>INT</code>引脚连接 到 TF 卡实验电路的的 TF
插入状态标志引脚<code>Cd</code>，<code>SPI</code>引脚接入到低电平选择使用
SPI
通信，<code>SD_DI</code>、<code>SD_CK</code>、<code>SD_DO</code>、<code>SD_CS</code>连接至
TF
卡电路，<code>V3</code>是<code>3.3V</code>电源引脚，<code>UD+</code>和<code>UD-</code>则是连接到
USB
插槽的两条数据线，最后<code>XO</code>和<code>XI</code>用于连接一枚外部的<code>12MHz</code>晶振以及起振电容<code>C20</code>。</p>
<h3 id="u-盘插拔状态">U 盘插拔状态</h3>
<h4 id="spi.h">spi.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/spi/spi.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI2PORT GPIOB <span class="comment">// 定义 GPIO 组</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 SPI 通信相关的 GPIO 引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI2_MOSI GPIO_Pin_15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI2_MISO GPIO_Pin_14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI2_SCK GPIO_Pin_13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI2_NSS GPIO_Pin_12</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI2_Init</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// SPI2 总线初始化函数</span></span><br><span class="line">u8 <span class="title function_">SPI2_SendByte</span><span class="params">(u8 Byte)</span>; <span class="comment">// SPI2 总线数据发送函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="spi.c">spi.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/spi/spi.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** SPI2 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI2_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  SPI_InitTypeDef SPI_InitStructure;                   <span class="comment">// 声明 SPI 结构体</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;                 <span class="comment">// 声明 GPIO 结构体</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE); <span class="comment">// 使能 SPI2 总线时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置 MISO 引脚为浮空输入模式 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = SPI2_MISO;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">  GPIO_Init(SPI2PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置 SCK 和 MOSI 引脚为 50MHz 的推挽输出模式 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = SPI2_MOSI | SPI2_SCK;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">  GPIO_Init(SPI2PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置 NSS 引脚为 50MHz 的推挽输出模式 */</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = SPI2_NSS;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_Init(SPI2PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;   <span class="comment">// 设置 SPI 总线为双线全双工模式</span></span><br><span class="line">  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                        <span class="comment">// 设置为 SPI 主机模式，即由 SCK 主动产生时钟</span></span><br><span class="line">  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                    <span class="comment">// 设置 SPI 数据大小为 8 位帧结构</span></span><br><span class="line">  SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;                          <span class="comment">// 设置空闲状态时，SCK 的状态为保持高电平</span></span><br><span class="line">  SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;                         <span class="comment">// 设置时钟相位，为 1 表示在 SCK 奇数沿采样，为 2 表示在偶数沿采样</span></span><br><span class="line">  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                            <span class="comment">// 设置 NSS 为软件控制，即 SPI 通信时自动将 NSS 拉低，通信完成后自动拉高</span></span><br><span class="line">  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; <span class="comment">// 设置时钟预分频值为 256</span></span><br><span class="line">  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;                   <span class="comment">// 设置 SPI 总线时序为 MSB 高位在前</span></span><br><span class="line">  SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;                             <span class="comment">// 设置为不使用 CRC 较验</span></span><br><span class="line">  SPI_Init(SPI2, &amp;SPI_InitStructure);                                  <span class="comment">// 初始化 SPI2 配置</span></span><br><span class="line">  SPI_Cmd(SPI2, ENABLE);                                               <span class="comment">// 使能 SPI2 总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** SPI2 总线数据收发函数，参数 Byte 表示待发送的参数，返回值是总线接收到的数据 */</span></span><br><span class="line">u8 <span class="title function_">SPI2_SendByte</span><span class="params">(u8 Byte)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);  <span class="comment">// 循环判断 SPI2 发送寄存器是否为空</span></span><br><span class="line">  SPI_I2S_SendData(SPI2, Byte);                                    <span class="comment">// 通过 SPI2 总线发送数据</span></span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET); <span class="comment">// 循环判断 SPI2 接收寄存器是否为空</span></span><br><span class="line">  <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI2);                                <span class="comment">// 将 SPI2 总线接收到的数据返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ch376inc.h">ch376inc.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CH376/ch376inc.h 由官方提供的 CH376 芯片控制命令，具体功能可以参考 CH376 官方数据手册 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... 省略冗余代码 ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD01_GET_IC_VER 0x01 <span class="comment">// 获取 CH376 芯片及固件版本</span></span></span><br><span class="line"><span class="comment">/* ... 省略冗余代码 ... */</span></span><br></pre></td></tr></table></figure>
<h4 id="ch376.h">ch376.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CH376/ch376.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CH376_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CH376_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ch376inc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH376_INTPORT GPIOA   <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH376_INT GPIO_Pin_15 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明 ch376.c 当中定义的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CH376_PORT_INIT</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">xEndCH376Cmd</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">xWriteCH376Cmd</span><span class="params">(u8 mCmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">xWriteCH376Data</span><span class="params">(u8 mData)</span>;</span><br><span class="line">u8 <span class="title function_">xReadCH376Data</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">Query376Interrupt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">mInitCH376Host</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="ch376.c">ch376.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CH376/ch376.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CH376.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** CH376 相关的 GPIO 引脚初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CH376_PORT_INIT</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">// 设置为上拉输入模式</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 GPIO 引脚初始状态 */</span></span><br><span class="line">  GPIO_SetBits(CH376_INTPORT, CH376_INT); <span class="comment">// 设置中断输入引脚为高电平</span></span><br><span class="line">  GPIO_SetBits(SPI2PORT, SPI2_NSS);       <span class="comment">// 设置 NSS 片选为高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 结束 CH376 命令发送 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xEndCH376Cmd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_SetBits(SPI2PORT, SPI2_NSS); <span class="comment">// 直接设置 NSS 为高电平，使 SPI 片选无效，从而结束 CH376 命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 SPI 总线发送数据，参数 d 是待发送数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Spi376OutByte</span><span class="params">(u8 d)</span> &#123;</span><br><span class="line">  SPI2_SendByte(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 SPI 总线接收 1 个字节的数据，返回值就是接收到的数据 */</span></span><br><span class="line">u8 <span class="title function_">Spi376InByte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET); <span class="comment">// 循环判断接收寄存器是否收到数据</span></span><br><span class="line">  <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 向 CH376 写入命令，参数 mCmd 是待发送的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xWriteCH376Cmd</span><span class="params">(u8 mCmd)</span> &#123;</span><br><span class="line">  GPIO_SetBits(SPI2PORT, SPI2_NSS);   <span class="comment">// 禁止 SPI 片选，防止之前未调用 xEndCH376Cmd() 结束命令发送</span></span><br><span class="line">  delay_us(<span class="number">20</span>);                       <span class="comment">// 延时确保正确写入</span></span><br><span class="line">  GPIO_ResetBits(SPI2PORT, SPI2_NSS); <span class="comment">// 重新开启 SPI 片选</span></span><br><span class="line">  Spi376OutByte(mCmd);                <span class="comment">// 发送命令码</span></span><br><span class="line">  delay_us(<span class="number">1700</span>);                     <span class="comment">// 延时确保正确写入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 向 CH376 芯片写入数据，参数 mData 是待发送的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xWriteCH376Data</span><span class="params">(u8 mData)</span> &#123;</span><br><span class="line">  Spi376OutByte(mData); <span class="comment">// 调用 CH376 的 SPI 总线数据发送函数</span></span><br><span class="line">  delay_us(<span class="number">800</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从 CH376 芯片读取数据 */</span></span><br><span class="line">u8 <span class="title function_">xReadCH376Data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  delay_us(<span class="number">10</span>);</span><br><span class="line">  i = SPI2_SendByte(<span class="number">0xFF</span>); <span class="comment">// 调用 SPI2 的数据发送函数</span></span><br><span class="line">  <span class="keyword">return</span> (i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 查询 CH376 中断状态，返回 0 表示没有中断，1 表示有中断 */</span></span><br><span class="line">u8 <span class="title function_">Query376Interrupt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  i = GPIO_ReadInputDataBit(CH376_INTPORT, CH376_INT); <span class="comment">// 从 GPIO 端口读取中断状态并返回</span></span><br><span class="line">  <span class="keyword">return</span> (i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CH376 芯片初始化函数 */</span></span><br><span class="line">u8 <span class="title function_">mInitCH376Host</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 res;</span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">600</span>);     <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  CH376_PORT_INIT(); <span class="comment">// 调用 CH376 相关的 GPIO 引脚初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 测试 STM32F103C8T6 与 CH376 之间通讯接口的工作状态 */</span></span><br><span class="line">  xWriteCH376Cmd(CMD11_CHECK_EXIST); <span class="comment">// 发送测试命令</span></span><br><span class="line">  xWriteCH376Data(<span class="number">0x55</span>);             <span class="comment">// 发送数据</span></span><br><span class="line">  res = xReadCH376Data();            <span class="comment">// 接收响应</span></span><br><span class="line">  xEndCH376Cmd();                    <span class="comment">// 结束与 CH376 的通信</span></span><br><span class="line">  <span class="comment">/* 如果接收到的数据不是 0x55 的按位取反值 0xAA */</span></span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">0xAA</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (ERR_USB_UNKNOWN); <span class="comment">// 返回通信异常命令，后续代码将不会被执行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 测试成功则开始设置 USB 的工作模式 */</span></span><br><span class="line">  xWriteCH376Cmd(CMD11_SET_USB_MODE); <span class="comment">// 设置 USB 工作模式</span></span><br><span class="line">  xWriteCH376Data(<span class="number">0x06</span>);              <span class="comment">// 切换为主机模式</span></span><br><span class="line">  delay_us(<span class="number">20</span>);                       <span class="comment">// 保证设置正确结束</span></span><br><span class="line">  res = xReadCH376Data();             <span class="comment">// 读取 CH376 返回数据</span></span><br><span class="line">  xEndCH376Cmd();                     <span class="comment">// 结束总线通信</span></span><br><span class="line">  <span class="comment">/* 判断 CH376 命令执行状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (res == CMD_RET_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> (USB_INT_SUCCESS); <span class="comment">// 操作成功返回 SUCCESS</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (ERR_USB_UNKNOWN); <span class="comment">// 操作失败返回 UNKNOWN</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-31">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ch376.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 s;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;  U Disk Test   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 CH376 文件管理控制芯片 */</span></span><br><span class="line">  SPI2_Init(); <span class="comment">// 首先初始化 SPI 总线</span></span><br><span class="line">  <span class="keyword">if</span> (mInitCH376Host() == USB_INT_SUCCESS) &#123;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;   CH376 OK!    &quot;</span>); <span class="comment">// 如果初始化成功就向 OLED 屏幕显示字符串</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    s = CH376DiskConnect(); <span class="comment">// 读取 U 盘状态</span></span><br><span class="line">    <span class="keyword">if</span> (s == USB_INT_SUCCESS) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; U Disk Ready!  &quot;</span>); <span class="comment">// U 盘插入，显示字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;                &quot;</span>); <span class="comment">// U 盘拔出，显示空白</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件系统读写">文件系统读写</h3>
<h4 id="filesys.h">filesys.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CH376/filesys.h，由沁恒公司官方提供 http://www.wch.cn/search?t=all&amp;q=ch376 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="filesys.c">filesys.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/CH376/filesys.c，由沁恒公司官方提供 http://www.wch.cn/search?t=all&amp;q=ch376 */</span></span><br></pre></td></tr></table></figure>
<h4 id="main.c-32">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ch376.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">u8 buf[<span class="number">128</span>]; <span class="comment">// 数据缓冲区，用于存放临时数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 s i;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  TOUCH_KEY_Init();    <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;  U Disk Test   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 CH376 文件管理控制芯片 */</span></span><br><span class="line">  SPI2_Init(); <span class="comment">// 首先初始化 SPI 总线</span></span><br><span class="line">  <span class="keyword">if</span> (mInitCH376Host() == USB_INT_SUCCESS) &#123;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;   CH376 OK!    &quot;</span>); <span class="comment">// 如果初始化成功就向 OLED 屏幕显示字符串</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 循环等待 U 盘插入 */</span></span><br><span class="line">    <span class="keyword">while</span> (CH376DiskConnect() != USB_INT_SUCCESS) &#123;</span><br><span class="line">      delay_ms(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; U DISK Ready!  &quot;</span>); <span class="comment">// U 盘插入后，向 OLED 显示字符串</span></span><br><span class="line">    delay_ms(<span class="number">200</span>);                                   <span class="comment">// 延时确保操作正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环 100 次，初始化 U 盘 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      delay_ms(<span class="number">50</span>);</span><br><span class="line">      s = CH376DiskMount(); <span class="comment">// 初始化磁盘并且测试磁盘是否就绪，即建立与 U 盘的连接，并且等待 U 盘进入工作状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断 U 盘状态 */</span></span><br><span class="line">      <span class="keyword">if</span> (s == USB_INT_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 如果 U 盘准备就绪，跳出 for 循环</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == ERR_DISK_DISCON) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 如果 U 盘未准备就绪，只是跳出 for 循环，并未进一步处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 针对某些型号 U 盘总是返回未准备好的处理 */</span></span><br><span class="line">      <span class="keyword">if</span> (CH376GetDiskStatus() &gt;= DEF_DISK_MOUNTED &amp;&amp; i &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; U Disk Init!   &quot;</span>); <span class="comment">// 显示 U 盘初始化完成提示信息</span></span><br><span class="line">    delay_ms(<span class="number">200</span>);                                   <span class="comment">// 延时确保指令操作正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件操作相关的代码 */</span></span><br><span class="line">    s = CH376FileCreatePath(<span class="string">&quot;/Hank.txt&quot;</span>);                              <span class="comment">// 创建文件</span></span><br><span class="line">    delay_ms(<span class="number">200</span>);                                                     <span class="comment">// 延时确保指令操作正确</span></span><br><span class="line">    s = <span class="built_in">sprintf</span>((<span class="type">char</span> *)buf, <span class="string">&quot;Bit by bit：https://uinika.github.io/&quot;</span>); <span class="comment">// 将字符放置到缓冲区数组 buf，并返回数组长度</span></span><br><span class="line">    s = CH376ByteWrite(buf, s, <span class="literal">NULL</span>);                                  <span class="comment">// 将数据写入 Hank.txt 文件</span></span><br><span class="line">    delay_ms(<span class="number">200</span>);                                                     <span class="comment">// 延时确保指令操作正确</span></span><br><span class="line">    s = CH376FileClose(TRUE);                                          <span class="comment">// 关闭文件保存数据</span></span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; U DISK SUCCESS &quot;</span>);                   <span class="comment">// 显示 U 盘操作完成提示信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环判断 U 盘是否拔出 */</span></span><br><span class="line">    <span class="keyword">while</span> (CH376DiskConnect() == USB_INT_SUCCESS) &#123;</span><br><span class="line">      delay_ms(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;                &quot;</span>); <span class="comment">// 不显示任何提示信息</span></span><br><span class="line">    delay_ms(<span class="number">200</span>);                                   <span class="comment">// 延时确保指令操作正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵键盘">4 × 4 矩阵键盘</h2>
<p>将 4 × 4
矩阵键盘连接到<strong>STM32F103C8T6</strong>的<code>PA0 ~ PA7</code>共 4
个 GPIO 引脚，同时断开 ADC
输入相关的<strong>P8</strong>跳线座、模拟量摇杆对应的<strong>P17</strong>跳线座、触摸按键对应的<strong>P10</strong>跳线座、旋转编码器对应的<strong>P18</strong>跳线座。</p>
<p><img src="/Embedded/STM32F103/key-board/diagram.png"></p>
<p>上面的电路图里的红色与蓝色接线，作用类似于地图的经线与纬线，只需要获取按键触发的经纬线，就可以知道当前哪个按键被按下。例如，如果按下【A】键，此时将<code>PA0 ~ PA3</code>设置为上拉电阻输入模式并置为高电平<code>1</code>，再将<code>PA4 ~ PA7</code>设置为推挽输出模式并置为低电平<code>0</code>，此时按下【A】键让
PA2 与 PA6 导通，此时 PA2 被 PA6 下拉为低电平，即 PA2
对应的【8】【9】【A】【B】当中有按键被按下。</p>
<p>接下来，交换两组 GPIO
的工作模式，即让<code>PA0 ~ PA3</code>设置为推挽输出模式并置为低电平<code>0</code>，然后<code>PA4 ~ PA7</code>设置为上拉电阻输入模式并置为高电平<code>1</code>，此时按下【A】键会让
PA2 把 PA6 下拉为低电平，由此可知按下【A】键会导致 PA2 和 PA6
分别被下拉为低电平<code>0</code>，根据矩阵键盘的经纬线原则，就可以定位当前被按下的是【A】键。这种方式的缺点在于，同一时间只允许
1
枚按键被按下，如果发生多个按键同时按下的情况，就不能正确的判断按键位置。</p>
<blockquote>
<p><strong>注意：</strong>矩阵键盘直接连接到微控制器会占用大量 GPIO
引脚，因此也可以采用专用的矩阵键盘驱动芯片<strong>CH456</strong>（可同时驱动
16 位数码管以及 8×8
矩阵按键）、<strong>MAX7300</strong>自动扫描矩阵键盘状态。</p>
</blockquote>
<h3 id="keypad44.h">KEYPAD4×4.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/KEYPAD4×4/KEYPAD4×4.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEYPAD4x4_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEYPAD4x4_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPAD4x4PORT GPIOA <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵键盘连接的 GPIO 引脚 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2 GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3 GPIO_Pin_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4 GPIO_Pin_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYa GPIO_Pin_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYb GPIO_Pin_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYc GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYd GPIO_Pin_7</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_Init</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 初始化矩阵键盘，正向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_Init2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 初始化矩阵键盘，反向</span></span><br><span class="line">u8 <span class="title function_">KEYPAD4x4_Read</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 读取被按下按键的键值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="keypad44.c">KEYPAD4×4.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/KEYPAD4×4/KEYPAD4×4.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KEYPAD4x4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化矩阵键盘，正向 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = KEYa | KEYb | KEYc | KEYd; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;            <span class="comment">// 设置为上拉电阻输入模式</span></span><br><span class="line">  GPIO_Init(KEYPAD4x4PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = KEY1 | KEY2 | KEY3 | KEY4; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;         <span class="comment">// 设置为推挽输出方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(KEYPAD4x4PORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化矩阵键盘，反向 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_Init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = KEY1 | KEY2 | KEY3 | KEY4; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;            <span class="comment">// 设置为上拉电阻输入模式</span></span><br><span class="line">  GPIO_Init(KEYPAD4x4PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = KEYa | KEYb | KEYc | KEYd; <span class="comment">// 选择 GPIO 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;         <span class="comment">// 设置为推挽输出方式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(KEYPAD4x4PORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 矩阵键盘读取函数，返回值为当前被按下按键的键值 */</span></span><br><span class="line">u8 <span class="title function_">KEYPAD4x4_Read</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 a = <span class="number">0</span>, b = <span class="number">0</span>;  <span class="comment">// 定义变量</span></span><br><span class="line">  KEYPAD4x4_Init(); <span class="comment">// 调用按键初始化函数</span></span><br><span class="line"></span><br><span class="line">  GPIO_ResetBits(KEYPAD4x4PORT, KEY1 | KEY2 | KEY3 | KEY4); <span class="comment">// 设置 1234 为低电平</span></span><br><span class="line">  GPIO_SetBits(KEYPAD4x4PORT, KEYa | KEYb | KEYc | KEYd);   <span class="comment">// 设置 ABCD 为高电平</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测按键是否被按下 */</span></span><br><span class="line">  <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYa) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYb) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYc) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYd)) &#123;</span><br><span class="line">    delay_ms(<span class="number">20</span>); <span class="comment">// 按键去抖，延时 20 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续检测按键是否被按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYa) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYb) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYc) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEYd)) &#123;</span><br><span class="line">      a = GPIO_ReadInputData(KEYPAD4x4PORT) &amp; <span class="number">0xff</span>; <span class="comment">// 获取 PA0 ~ PA7 这 8 个 GPIO 引脚的状态，并放入变量 a</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KEYPAD4x4_Init2();                                        <span class="comment">// 调用按键初始化函数，反转</span></span><br><span class="line">    GPIO_SetBits(KEYPAD4x4PORT, KEY1 | KEY2 | KEY3 | KEY4);   <span class="comment">// 设置 1234 为高电平</span></span><br><span class="line">    GPIO_ResetBits(KEYPAD4x4PORT, KEYa | KEYb | KEYc | KEYd); <span class="comment">// 设置 ABCD 为低电平</span></span><br><span class="line">    b = GPIO_ReadInputData(KEYPAD4x4PORT) &amp; <span class="number">0xff</span>;             <span class="comment">// 再次获取 8 个 GPIO 引脚状态，并放入变量 b</span></span><br><span class="line">    a = a | b;                                                <span class="comment">// 对 2 次获取的按键状态进行或运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对键值进行判断 */</span></span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xee</span>: b = <span class="number">16</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xed</span>: b = <span class="number">15</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xeb</span>: b = <span class="number">14</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xe7</span>: b = <span class="number">13</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xde</span>: b = <span class="number">12</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xdd</span>: b = <span class="number">11</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xdb</span>: b = <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xd7</span>: b = <span class="number">9</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xbe</span>: b = <span class="number">8</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xbd</span>: b = <span class="number">7</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xbb</span>: b = <span class="number">6</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0xb7</span>: b = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x7e</span>: b = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x7d</span>: b = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x7b</span>: b = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x77</span>: b = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: b = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// 键值错误，多发生于多个按键同时按下时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待按键放开 */</span></span><br><span class="line">    <span class="keyword">while</span> (!GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEY1) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEY2) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEY3) || !GPIO_ReadInputDataBit(KEYPAD4x4PORT, KEY4));</span><br><span class="line">    delay_ms(<span class="number">20</span>); <span class="comment">// 延时去抖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (b); <span class="comment">// 返回 b 作为按键编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-33">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KEYPAD4x4.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 s;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">3</span>, <span class="string">&quot; Keyboard Test: &quot;</span>);</span><br><span class="line"></span><br><span class="line">  KEYPAD4x4_Init(); <span class="comment">// 初始化阵列键盘</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    s = KEYPAD4x4_Read(); <span class="comment">// 调用按键值读取函数，获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按键值不为 0 说明有按键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; Key NO.        &quot;</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">8</span> * <span class="number">8</span>, s / <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 显示按键编号的十位</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">9</span> * <span class="number">8</span>, s % <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 显示按键编号的个位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exti-与-nvic">EXTI 与 NVIC</h2>
<p>中断是指一个突然发生的事件打断了当前 MCU
的执行流程，微控制器转而去处理该中断事件，完成之后再重新返回到之前的执行流程。<strong>STM32F103C8T6</strong>允许多种类型的中断源，包括<strong>外部
GPIO</strong>、<strong>ADC</strong>、<strong>USART</strong>、<strong>I²C</strong>、<strong>RTC</strong>、<strong>USB</strong>、<strong>PVD</strong>等。本小节将要进行分析的
EXTI 外部中断支持将所有 GPIO
设置为中断源，可由<code>上升沿</code>、<code>下降沿</code>、<code>高低电平</code>3
种方式进行触发，并且可以选择<strong>中断方式</strong>（触发后进入专门的中断处理函数，需要
MCU 介入）或者<strong>事件方式</strong>（触发后自动运行相应功能，毋须
MCU 介入）触发。</p>
<p>下面的表格，整理了<strong>STM32F103C8T6</strong>与 EXTI
外部中断相关的所有 GPIO 引脚、中断标志位、中断处理函数：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">GPIO 引脚</th>
<th style="text-align: center;">中断标志位</th>
<th style="text-align: center;">中断处理函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>PA0 ~ PG0</code></td>
<td style="text-align: center;"><strong>EXTI0</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>0</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA1 ~ PG1</code></td>
<td style="text-align: center;"><strong>EXTI1</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>1</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA2 ~ PG2</code></td>
<td style="text-align: center;"><strong>EXTI2</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>2</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA3 ~ PG3</code></td>
<td style="text-align: center;"><strong>EXTI3</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>3</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA4 ~ PG4</code></td>
<td style="text-align: center;"><strong>EXTI4</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>4</strong><code>_IRQHandler()</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">GPIO 引脚</th>
<th style="text-align: center;">中断标志位</th>
<th style="text-align: center;">中断处理函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>PA5 ~ PG5</code></td>
<td style="text-align: center;"><strong>EXTI5</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>9_5</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA6 ~ PG6</code></td>
<td style="text-align: center;"><strong>EXTI6</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>9_5</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA7 ~ PG7</code></td>
<td style="text-align: center;"><strong>EXTI7</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>9_5</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA8 ~ PG8</code></td>
<td style="text-align: center;"><strong>EXTI8</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>9_5</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA9 ~ PG9</code></td>
<td style="text-align: center;"><strong>EXTI9</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>9_5</strong><code>_IRQHandler()</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">GPIO 引脚</th>
<th style="text-align: center;">中断标志位</th>
<th style="text-align: center;">中断处理函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>PA10 ~ PG10</code></td>
<td style="text-align: center;"><strong>EXTI10</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA11 ~ PG11</code></td>
<td style="text-align: center;"><strong>EXTI11</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA12 ~ PG12</code></td>
<td style="text-align: center;"><strong>EXTI12</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA13 ~ PG13</code></td>
<td style="text-align: center;"><strong>EXTI13</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>PA14 ~ PG14</code></td>
<td style="text-align: center;"><strong>EXTI14</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PA15 ~ PG15</code></td>
<td style="text-align: center;"><strong>EXTI15</strong></td>
<td style="text-align: center;"><code>EXTI</code><strong>15_10</strong><code>_IRQHandler()</code></td>
</tr>
</tbody>
</table>
<p>NVIC
嵌套中断向量控制器，这里的<strong>嵌套</strong>是指中断的嵌套，<strong>中断向量</strong>是指中断处理函数的入口地址，即
NVIC 本质上就是 Cortex M3
当中，用于对中断处理函数进行相应设置的硬件单元。NVIC
当中涉及两个比较重要的概念：</p>
<ul>
<li><strong>抢占式优先级</strong>（主优先级）：中断嵌套时，主优先级高的中断可以嵌套在主优先级低的中断当中，相同主优先级的中断不能进行嵌套。</li>
<li><strong>响应式优先级</strong>（子优先级）：如果同时发生相同主优先级的中断，<strong>STM32F103C8T6</strong>会首先处理子优先级较高的中断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数字越小，优先级越高 */</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;      <span class="comment">// 设置 NVIC 抢占优先级为 2</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;             <span class="comment">// 设置 NVIC 子优先级为 2</span></span><br></pre></td></tr></table></figure>
<p>抢占和响应优先级数值的设定范围，由<code>sys.h</code>当中定义的 NVIC
分组号<code>NVIC_PriorityGroup_x</code>来进行配置，不同的分组决定了抢占和响应优先级的数量，如果超过分组最大的优先级设定范围，代码可能会在执行过程中发生不可预知的错误，本实验相关的
NVIC 分组号由下面代码进行设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 嵌套中断向量控制器 NVIC 配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Configuration</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	<span class="comment">// 设置 NVIC 中断分组号为 2，即 4 个抢占优先级与 4 个响应优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，将前一小节主函数扫描矩阵键盘实验的代码，修改为通过下降沿进行触发的中断来判断，具体代码如下所示：</p>
<h3 id="nvic.h">NVIC.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NVIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NVIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 INT_MARK;            <span class="comment">// 中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_INT_INIT</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 阵列键盘中断初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="nvic.c">NVIC.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 INT_MARK; <span class="comment">// 中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阵列键盘中断初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEYPAD4x4_INT_INIT</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStruct; <span class="comment">// 向量中断控制器 NVIC 结构体变量</span></span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStruct; <span class="comment">// 外部中断 EXTI 结构体变量</span></span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); <span class="comment">// 开启 GPIOA 时钟，该代码原本位于 KEYPAD4×4.c，由于不能对同一时钟反复配置，所以挪动到这里</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);  <span class="comment">// 使能 AFIO 重映射功能时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 1 个中断 */</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource4); <span class="comment">// 映射 GPIO 引脚至 EXTI，参数 GPIO_PinSource4 是需要连接到的中断通道</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Line = EXTI_Line4;                     <span class="comment">// 设置外部中断线</span></span><br><span class="line">  EXTI_InitStruct.EXTI_LineCmd = ENABLE;                      <span class="comment">// 使能外部中断</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class="comment">// 设置为中断模式</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;        <span class="comment">// 设置为下降沿触发中断</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStruct);                                <span class="comment">// 初始化外部中断 EXTI 设置</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannel = EXTI4_IRQn;               <span class="comment">// 设置 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;                <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;      <span class="comment">// 设置 NVIC 的抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;             <span class="comment">// 设置 NVIC 的子优先级为 2</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStruct);                                <span class="comment">// 初始化向量中断控制器 NVIC 设置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 2 个中断 */</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource5); <span class="comment">// 映射 GPIO 引脚至 EXTI，参数 GPIO_PinSource5 是需要连接到的中断通道</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Line = EXTI_Line5;                     <span class="comment">// 设置外部中断线</span></span><br><span class="line">  EXTI_InitStruct.EXTI_LineCmd = ENABLE;                      <span class="comment">// 使能外部中断</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class="comment">// 设置为中断模式</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;        <span class="comment">// 设置为下降沿触发中断</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStruct);                                <span class="comment">// 初始化外部中断 EXTI 设置</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn;             <span class="comment">// 设置 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;                <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;      <span class="comment">// 设置 NVIC 的抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;             <span class="comment">// 设置 NVIC 的子优先级为 2</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStruct);                                <span class="comment">// 初始化向量中断控制器 NVIC 设置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 3 个中断 */</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource6); <span class="comment">// 映射 GPIO 引脚至 EXTI，参数 GPIO_PinSource6 是需要连接到的中断通道</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Line = EXTI_Line6;                     <span class="comment">// 设置外部中断线</span></span><br><span class="line">  EXTI_InitStruct.EXTI_LineCmd = ENABLE;                      <span class="comment">// 使能外部中断</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class="comment">// 设置为中断模式</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;        <span class="comment">// 设置为下降沿触发中断</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStruct);                                <span class="comment">// 初始化外部中断 EXTI 设置</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn;             <span class="comment">// 设置 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;                <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;      <span class="comment">// 设置 NVIC 的抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;             <span class="comment">// 设置 NVIC 的子优先级为 2</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStruct);                                <span class="comment">// 初始化向量中断控制器 NVIC 设置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 4 个中断 */</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource7); <span class="comment">// 映射 GPIO 引脚至 EXTI，参数 GPIO_PinSource7 是需要连接到的中断通道</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Line = EXTI_Line7;                     <span class="comment">// 设置外部中断线</span></span><br><span class="line">  EXTI_InitStruct.EXTI_LineCmd = ENABLE;                      <span class="comment">// 使能外部中断</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class="comment">// 设置为中断模式</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;        <span class="comment">// 设置为下降沿触发中断</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStruct);                                <span class="comment">// 初始化外部中断 EXTI 设置</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn;             <span class="comment">// 设置 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;                <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;      <span class="comment">// 设置 NVIC 的抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;             <span class="comment">// 设置 NVIC 的子优先级为 2</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStruct);                                <span class="comment">// 初始化向量中断控制器 NVIC 设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外部中断 4 中断处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断 EXTI_Line4 中断线是否发生中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line4) != RESET) &#123;</span><br><span class="line">    INT_MARK = <span class="number">1</span>;                       <span class="comment">// 标志位置 1，表示产生了按键中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line4); <span class="comment">// 清除中断线内的标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外部中断 5 6 7 中断处理函数，由于多路中断复用该处理函数，因此进入函数后需要判断当前中断属于哪条中断线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI9_5_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断 EXTI_Line5 中断线是否发生中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line5) != RESET) &#123;</span><br><span class="line">    INT_MARK = <span class="number">2</span>;                       <span class="comment">// 标志位置 1，表示产生了按键中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line5); <span class="comment">// 清除中断线内的标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 判断 EXTI_Line6 中断线是否发生中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line6) != RESET) &#123;</span><br><span class="line">    INT_MARK = <span class="number">3</span>;                       <span class="comment">// 标志位置 1，表示产生了按键中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line6); <span class="comment">// 清除中断线内的标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 判断 EXTI_Line7 中断线是否发生中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line7) != RESET) &#123;</span><br><span class="line">    INT_MARK = <span class="number">4</span>;                       <span class="comment">// 标志位置 1，表示产生了按键中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line7); <span class="comment">// 清除中断线内的标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-34">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KEYPAD4x4.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 s;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">3</span>, <span class="string">&quot; Keyboard Test: &quot;</span>);</span><br><span class="line"></span><br><span class="line">  INT_MARK = <span class="number">0</span>;         <span class="comment">// 标志位，用于标识当前是否发生中断，默认为 0</span></span><br><span class="line">  NVIC_Configuration(); <span class="comment">// 设置中断优先级</span></span><br><span class="line">  KEYPAD4x4_Init();     <span class="comment">// 初始化阵列键盘</span></span><br><span class="line">  KEYPAD4x4_INT_INIT(); <span class="comment">// 初始化阵列键盘中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断上面声明的中断标志位，如果非 0 则表示有按键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (INT_MARK) &#123;</span><br><span class="line">      INT_MARK = <span class="number">0</span>;         <span class="comment">// 中断标志位变量清 0</span></span><br><span class="line">      s = KEYPAD4x4_Read(); <span class="comment">// 调用按键值读取函数，获取按键值</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 按键值不为 0 说明有按键按下 */</span></span><br><span class="line">      <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot; Key NO.        &quot;</span>);</span><br><span class="line">        OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">8</span> * <span class="number">8</span>, s / <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 显示按键编号的十位</span></span><br><span class="line">        OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">9</span> * <span class="number">8</span>, s % <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">// 显示按键编号的个位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sg90-舵机">SG90 舵机</h2>
<p>SG90
舵机工作电压为<code>5V</code>，最大工作电流为<code>2A</code>，可旋转角度为<code>180°</code>。由于需要使用到触摸按键来进行舵机控制，因此实验开始之前，需要先短接触摸按键相关的<strong>P10</strong>跳线座。</p>
<p><img src="/Embedded/STM32F103/pwm/steering.png"></p>
<p>上面接线图当中，标号为<strong>PWM</strong>的橙色线用于传输脉冲宽度调制信号，标号为<strong>VCC</strong>的红色线和标号为<strong>GND</strong>的棕色线分别用于表示电源正负极。<strong>STM32F103C8T6</strong>对于舵机的控制主要依靠
PWM 信号线来传输<strong>连续</strong>的波形。</p>
<p><img src="/Embedded/STM32F103/pwm/waveform.png"></p>
<p>上面的信号波形示意图当中，如果高电平持续时间长度介于<code>0.5ms ~ 2.5ms</code>之间，则会让舵盘的转角介于<code>0° ~ 180°</code>范围以内。</p>
<h3 id="sg90.h">SG90.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/SG90/SG90.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SG90_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SG90_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PORT GPIOA      <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_OUT GPIO_Pin_15 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SG90_Init</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// SG90 舵机初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SG90_angle</span><span class="params">(u8 a)</span>;     <span class="comment">// 舵机旋转角度控制函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sg90.c">SG90.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/SG90/SG90.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SG90.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** SG90 舵机初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SG90_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = SE_OUT;             <span class="comment">// 设置为 PA15 引脚</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// 设置为推挽输出工作模式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">// GPIO 引脚输出频率为 50MHz</span></span><br><span class="line">  GPIO_Init(SE_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">  GPIO_WriteBit(SE_PORT, SE_OUT, (BitAction)(<span class="number">0</span>)); <span class="comment">// 初始化 GPIO 引脚为低电平 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 舵机旋转角度控制函数，参数 a 是角度 0° ~ 180° */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SG90_angle</span><span class="params">(u8 a)</span> &#123;</span><br><span class="line">  u8 b = <span class="number">100</span>;                                     <span class="comment">// 角度偏移量校正</span></span><br><span class="line">  GPIO_WriteBit(SE_PORT, SE_OUT, (BitAction)(<span class="number">1</span>)); <span class="comment">// PA15 引脚输出高电平 1</span></span><br><span class="line">  delay_us(<span class="number">500</span> + a * <span class="number">10</span> + b);                     <span class="comment">// 高电平状态延时时间</span></span><br><span class="line">  GPIO_WriteBit(SE_PORT, SE_OUT, (BitAction)(<span class="number">0</span>)); <span class="comment">// PA15 引脚输出低电平 0</span></span><br><span class="line">  delay_us(<span class="number">19500</span> - a * <span class="number">10</span> - b);                   <span class="comment">// 低电平状态延时时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-35">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SG90.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">3</span>, <span class="string">&quot;   SG90 Test    &quot;</span>);</span><br><span class="line"></span><br><span class="line">  TOUCH_KEY_Init(); <span class="comment">// 初始化触摸按键</span></span><br><span class="line">  SG90_Init();      <span class="comment">// 初始化 SG90 舵机</span></span><br><span class="line">  SG90_angle(<span class="number">0</span>);    <span class="comment">// 设置舵机初始角度为最小值 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果 A 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 0       &quot;</span>);</span><br><span class="line">      SG90_angle(<span class="number">0</span>); <span class="comment">// 设置舵机角度为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 B 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 45      &quot;</span>);</span><br><span class="line">      SG90_angle(<span class="number">45</span>); <span class="comment">// 设置舵机角度为 45</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 C 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 90      &quot;</span>);</span><br><span class="line">      SG90_angle(<span class="number">90</span>); <span class="comment">// 设置舵机角度为 90</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 D 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 180     &quot;</span>);</span><br><span class="line">      SG90_angle(<span class="number">180</span>); <span class="comment">// 设置舵机角度为 180</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pwm-脉冲宽度调制">PWM 脉冲宽度调制</h2>
<p>脉冲宽度调制（PWM，<strong>P</strong>ulse <strong>W</strong>idth
<strong>M</strong>odulation）有时也被称为<strong>占空比</strong>，可以通过<strong>STM32F103C8T6</strong>的定时器功能（包括
1 个高级定时器<code>TIM1</code>和 3
个普通定时器<code>TIM2</code>、<code>TIM3</code>、<code>TIM4</code>）来产生
PWM。具体而言，就是借助定时器的<code>TIMx_ARR</code>寄存器溢出值产生 PWM
周期，然后由<code>TIMx_CCRx</code>寄存器产生高低电平的占空比。</p>
<p><img src="/Embedded/STM32F103/pwm/pwm.png"></p>
<p>本实验沿用前一小节通过延时函数驱动舵机的程序与跳线设置，此外为了连接定时器相关的
GPIO
输出，需要使用杜邦线将<strong>PB0</strong>和<strong>PA15</strong>短接。本实验将会通过触摸按键产生
PWM 信号来控制舵机，由于 PWM
是使用定时器生成的，所以无论用户是否按下触摸按键 PWM
都会一直处于工作状态，此时由于输入电平长度有一定误差，因而按下触摸按键时舵机会产生抖动。另外，在舵机工作的同时，实验电路中核心板附近连接到
PB0 引脚的 LED
指示灯会持续点亮，由于本实验会将<strong>PB0</strong>与<strong>PA15</strong>短接，因此
LED 也会体现出当前 PWM 生成的信号状态。</p>
<h3 id="pwm.h">pwm.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/pwm/pwm.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_PWM_Init</span><span class="params">(u16 arr, u16 psc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="pwm.c">pwm.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/pwm/pwm.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 定时器 3 的 PWM 初始化函数，参数 arr 是计数重载值，参数 psc 是预分频系数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_PWM_Init</span><span class="params">(u16 arr, u16 psc)</span> &#123;</span><br><span class="line">  <span class="comment">/* PWM 相关的 3 种结构体 */</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStrue;</span><br><span class="line">  TIM_OCInitTypeDef TIM_OCInitStrue;</span><br><span class="line">  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStrue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* PWM 相关的时钟设置 */</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  <span class="comment">// 使能 TIM3 时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); <span class="comment">// 使能 GPIOB 时钟，因为 LED 连接在 PB0 引脚</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);  <span class="comment">// 使能 AFIO 时钟，因为定时器 3 的通道 3 复用 BP5 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO 设置 */</span></span><br><span class="line">  GPIO_InitStrue.GPIO_Pin = GPIO_Pin_0;         <span class="comment">// 选择 GPIO0 引脚</span></span><br><span class="line">  GPIO_InitStrue.GPIO_Mode = GPIO_Mode_AF_PP;   <span class="comment">// 复用推挽输出模式</span></span><br><span class="line">  GPIO_InitStrue.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">// 输出频率 50MHz</span></span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStrue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有进行 GPIO 引脚重映射时，TIM3 的 4 个通道 CH1、CH2、CH3、CH4 分别对应 PA6、PA7、PB0、PB1 引脚</span></span><br><span class="line">  <span class="comment">// GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); // 开启部分重映射时，TIM3 的 4 个通道分别被映射至 PB4、PB5、PB0、PB1</span></span><br><span class="line"></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_Period = arr;                     <span class="comment">// 自动重装载值为 arr</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_Prescaler = psc;                  <span class="comment">// 预分频系数为 psc</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">// 工作模式为向上累加计数</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">// 时钟分频因子，用于内部计数器滤波，仅影响电路的稳定性</span></span><br><span class="line">  TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStrue);             <span class="comment">// 初始化 定时器3 TIM3 设置</span></span><br><span class="line"></span><br><span class="line">  TIM_OCInitStrue.TIM_OCMode = TIM_OCMode_PWM1;             <span class="comment">// 设置为 TIM 脉冲宽度调试模式 1，即当前计数值小于 CCR 时输出高电平 1，否则输出 0</span></span><br><span class="line">  TIM_OCInitStrue.TIM_OCPolarity = TIM_OCPolarity_High;     <span class="comment">// 设置极性，即有效电平为高电平 1，无效电平为低电平 0</span></span><br><span class="line">  TIM_OCInitStrue.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">// 定时器状态输出使能，即将定时器的状态通过 GPIO 引脚输出</span></span><br><span class="line">  TIM_OC3Init(TIM3, &amp;TIM_OCInitStrue);                      <span class="comment">// 初始化定时器 3 的通道 3</span></span><br><span class="line">  TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);         <span class="comment">// 使能预装载寄存器</span></span><br><span class="line">  TIM_Cmd(TIM3, ENABLE);                                    <span class="comment">// 使能定时器 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-36">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;touch_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">3</span>, <span class="string">&quot;   SG90 Test2   &quot;</span>);</span><br><span class="line">  TOUCH_KEY_Init(); <span class="comment">// 初始化触摸按键</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 计算公式为溢出时间 Tout 秒 = (arr+1)(psc+1)/Tclk，即 (59999+1)*(23+1)/72000000 = 0.02s = 20ms</span></span><br><span class="line"><span class="comment">   * 公式中 Tclk 为通用定时器时钟，如果 APB1 没有分频，则为 72MHz 系统时钟</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TIM3_PWM_Init(<span class="number">59999</span>, <span class="number">23</span>); <span class="comment">// 通过定时器 3 实现 PWM 输出，参数 59999 是定时器溢出值 ARR，参数 23 是时钟分频系数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果 D 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_A)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 0       &quot;</span>);</span><br><span class="line">      <span class="comment">/* 如果整个 PWM 周期为 20ms，而已知定时 20ms 需要 60000 次计数，那么定时 0.5 毫秒需要的计数次数 = 0.5 * 60000/20 = 1500 */</span></span><br><span class="line">      TIM_SetCompare3(TIM3, <span class="number">1500</span>); <span class="comment">// 设置定时器 3 的 CCR2值调节占空比，1500 表示 0°</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 D 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_B)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 45      &quot;</span>);</span><br><span class="line">      TIM_SetCompare3(TIM3, <span class="number">3000</span>); <span class="comment">// 设置定时器 3 的 CCR2值调节占空比，3000 表示 45°</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 D 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_C)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 90     &quot;</span>);</span><br><span class="line">      TIM_SetCompare3(TIM3, <span class="number">4500</span>); <span class="comment">// 设置定时器 3 的 CCR2值调节占空比，4500 表示 90°</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果 D 键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(TOUCH_KEYPORT, TOUCH_KEY_D)) &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Angle 180     &quot;</span>);</span><br><span class="line">      TIM_SetCompare3(TIM3, <span class="number">7500</span>); <span class="comment">// 设置定时器 3 的 CCR2值调节占空比，7500 表示 180°</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dht11-温湿度传感器">DHT11 温湿度传感器</h2>
<p>DHT11
是一款由广州奥松电子出品的温湿度传感器，其供电电压介于<code>3V ~ 5.5V</code>之间，温度采集范围为<code>0°C ~ 50°C</code>，湿度采集范围为<code>20% ~ 90%</code>，一共拥有
4 个引脚（第 1 脚连接至<code>5V</code>电源，第 2
脚连接到微控制器的<strong>PA15</strong>引脚，第 3 脚悬空，第 4
脚连接至电源负极
GND），采用单总线通信方式与<strong>STM32F103C8T6</strong>进行连接。</p>
<p><img src="/Embedded/STM32F103/dht11/diagram.png"></p>
<p>DHT11
采用简化的串行单总线通信方式，即所有的数据交换与控制都只通过一条数据线完成。单总线结构通常需要外接一枚<code>4.7kΩ</code>上拉电阻，在总线闲置时将其钳制为高电平状态。<strong>STM32F103C8T6</strong>与<strong>DHT11</strong>通信时，每次会传送
40 位数据（8
个字节），并且遵循高位先出的顺序，具体数据格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 位湿度整数部分 | 8 位湿度小数部分 | 8 位温度整数部分 | 8 位温度小数部分 | 8 位校验位</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 8 位校验位的值等于前面 4 部分累加结果的最后 8
位。进行数据采集时，必须间隔 1 秒以上进行，以确保获得正确的结果。</p>
</blockquote>
<h3 id="dht11.h">dht11.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/DHT11/dht11.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11PORT GPIOA      <span class="comment">// 定义 GPIO 分组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_IO GPIO_Pin_15 <span class="comment">// 定义 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于封装 dht11.c 内部处理流程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_IO_OUT</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_IO_IN</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_RST</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">Dht11_Check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">Dht11_ReadBit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">Dht11_ReadByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提供给 main 函数进行调用 */</span></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_ReadData</span><span class="params">(u8 *h)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="dht11.c">dht11.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/DHT11/dht11.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将单总线连接的 GPIO 引脚设置为推挽输出模式，用于单总线发送数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_IO_OUT</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = DHT11_IO;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">// 设置推挽输出工作模式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(DHT11PORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将单总线连接的 GPIO 引脚设置为上拉电阻输入模式，用于单总线接收数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_IO_IN</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = DHT11_IO;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">// 设置上拉电阻输入模式</span></span><br><span class="line">  GPIO_Init(DHT11PORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 发送起始信号给 DHT11 传感器，该信号由 18ms 低电平和 20us~40us 高电平组成 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_RST</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  DHT11_IO_OUT();</span><br><span class="line">  GPIO_ResetBits(DHT11PORT, DHT11_IO); <span class="comment">// 置为低电平 0</span></span><br><span class="line">  delay_ms(<span class="number">20</span>);                        <span class="comment">// 延时 18ms</span></span><br><span class="line">  GPIO_SetBits(DHT11PORT, DHT11_IO);   <span class="comment">// 置为高电平 1</span></span><br><span class="line">  delay_us(<span class="number">30</span>);                        <span class="comment">// 延时 20us~40us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 等待 DHT11 响应状态，返回 0 表示接收成功，返回 1 表示未检测到设备 */</span></span><br><span class="line">u8 <span class="title function_">Dht11_Check</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 retry = <span class="number">0</span>;</span><br><span class="line">  DHT11_IO_IN(); <span class="comment">// 将单总线连接的 GPIO 引脚设置为上拉电阻输入模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果检测到 GPIO 引脚接收到低电平就跳出循环，变量 retry 用于避免陷入死循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (GPIO_ReadInputDataBit(DHT11PORT, DHT11_IO) &amp;&amp; retry &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    retry++;</span><br><span class="line">    delay_us(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果等待超过 100ms 依然未检测到低电平，就返回未检测到设备的状态码 1 */</span></span><br><span class="line">  <span class="keyword">if</span> (retry &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retry = <span class="number">0</span>; <span class="comment">// 清零以便用于下次循环</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果检测到 GPIO 引脚接收到高电平则跳出循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (!GPIO_ReadInputDataBit(DHT11PORT, DHT11_IO) &amp;&amp; retry &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    retry++;</span><br><span class="line">    delay_us(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (retry &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回接收成功状态码 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从 DHT11 读取 1 个位的数据，返回值是读取到的二进制数据 0 或 1 */</span></span><br><span class="line">u8 <span class="title function_">Dht11_ReadBit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 retry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测到 GPIO 引脚接收到低电平就跳出循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (GPIO_ReadInputDataBit(DHT11PORT, DHT11_IO) &amp;&amp; retry &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    retry++;</span><br><span class="line">    delay_us(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  retry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测到 GPIO 引脚接收到高电平则跳出循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (!GPIO_ReadInputDataBit(DHT11PORT, DHT11_IO) &amp;&amp; retry &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    retry++;</span><br><span class="line">    delay_us(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断通信时序对应的电平状态 */</span></span><br><span class="line">  delay_us(<span class="number">40</span>); <span class="comment">// 延时 40us 以后，开始判断 GPIO 电平状态</span></span><br><span class="line">  <span class="keyword">if</span> (GPIO_ReadInputDataBit(DHT11PORT, DHT11_IO)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从 DHT11 读取 1 个字节数据，返回值是读取到的字节数据 */</span></span><br><span class="line">u8 <span class="title function_">Dht11_ReadByte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 i, dat;</span><br><span class="line">  dat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将位读取函数循环调用 8 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    dat |= Dht11_ReadBit();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** DHT11 初始化函数，返回 0 表示成功，返回 1 表示设备错误 */</span></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); <span class="comment">// 使能 APB2 外设时钟</span></span><br><span class="line">  DHT11_RST();          <span class="comment">// 让 DHT11 连接的 GPIO 引脚复位，从而发出起始信号</span></span><br><span class="line">  <span class="keyword">return</span> Dht11_Check(); <span class="comment">// 返回 DHT11 响应状态函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 读取 DHT11 温湿度数据，参数 h 用于存放读取到的温湿度数据的整数部分 */</span></span><br><span class="line">u8 <span class="title function_">DHT11_ReadData</span><span class="params">(u8 *h)</span> &#123;</span><br><span class="line">  u8 buf[<span class="number">5</span>]; <span class="comment">// 缓存由 DHT11 读取的 40 位数据，即 8 个字节</span></span><br><span class="line">  u8 i;</span><br><span class="line">  DHT11_RST(); <span class="comment">// 复位 DHT11 对应的 GPIO 引脚，发送起始信号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断 DHT11 响应状态 */</span></span><br><span class="line">  <span class="keyword">if</span> (Dht11_Check() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 循环 5 次读取 5 个字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      buf[i] = Dht11_ReadByte(); <span class="comment">// 将读取到的字节数据存放至缓存变量 buf</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对数据校验位进行校验 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf[<span class="number">0</span>] + buf[<span class="number">1</span>] + buf[<span class="number">2</span>] + buf[<span class="number">3</span>]) == buf[<span class="number">4</span>]) &#123;</span><br><span class="line">      *h = buf[<span class="number">0</span>]; <span class="comment">// 将读取到的第 1 个数据，即湿度值的整数部分存放至指针 h</span></span><br><span class="line">      h++;         <span class="comment">// 指针地址增加 1</span></span><br><span class="line">      *h = buf[<span class="number">2</span>]; <span class="comment">// 将读取到的第 3 个数据，即温度值的整数部分存放至指针 h</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 读取失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 读取成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-37">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8 b[<span class="number">2</span>];             <span class="comment">// 保存由 DHT11 读取的温湿度值</span></span><br><span class="line">  delay_ms(<span class="number">1000</span>);      <span class="comment">// 等待 DHT11 上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Hank         &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;   DHT11 Test   &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用 DHT11 初始化函数，返回 0 表示成功，返回 1 说明失败 */</span></span><br><span class="line">  <span class="keyword">if</span> (DHT11_Init() == <span class="number">0</span>) &#123;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;Humidity:   %   &quot;</span>);</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;Temperature:   C&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  Init Error!   &quot;</span>); <span class="comment">// 初始化失败时显示错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay_ms(<span class="number">1000</span>); <span class="comment">// 初始化 DHT11 之后延时不低于 1 秒</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将读取到的十进制温湿度数据保存至数组变量 a，同时返回 0 表示成功，返回 1 表示失败  */</span></span><br><span class="line">    <span class="keyword">if</span> (DHT11_ReadData(b) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 显示湿度值的十位与个位 */</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">9</span> * <span class="number">8</span>, b[<span class="number">0</span>] / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">10</span> * <span class="number">8</span>, b[<span class="number">0</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      <span class="comment">/* 显示温度值的十位与个位 */</span></span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, b[<span class="number">1</span>] / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">      OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, b[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;  Read Error!   &quot;</span>); <span class="comment">// 读取错误时显示提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">1000</span>); <span class="comment">// 确保数据刷新周期不低于 1 秒钟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mpu6050-加速度陀螺仪">MPU6050 加速度陀螺仪</h2>
<p>MPU-6050
整合了三轴加速度和三轴陀螺仪传感器，有效降低了封装尺寸以及两者配合工作时的误差。本小节实验程序将会在
OLED
屏幕左侧的<code>X Y Z</code>字符后面分别显示三轴加速度（位移）传感值，右侧的<code>X Y Z</code>字符后面则用于显示三轴陀螺仪（方向）传感值。</p>
<p><img src="/Embedded/STM32F103/mpu6050/diagram.png"></p>
<p>将<strong>MPU6050</strong>模块的<code>VCC</code>和<code>GND</code>引脚分别连接至实验电路的<code>5V</code>和<code>GND</code>进行供电，然后再将
I²C
通信相关的<code>SCL</code>和<code>SDA</code>分别连接至<strong>STM32F103C8T6</strong>的<code>PB6</code>和<code>PB7</code>引脚，这样就完成了实验电路的全部连接工作，下面的表格对模块的各引脚进行了详细的功能说明：</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 26%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">MPU6050 模块引脚</th>
<th style="text-align: center;">STM32F103C8T6 引脚</th>
<th>功能定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>VCC</strong></td>
<td style="text-align: center;"><code>5V</code></td>
<td>电源正极</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>GND</strong></td>
<td style="text-align: center;"><code>GND</code></td>
<td>电源负极</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>SCL</strong></td>
<td style="text-align: center;"><code>PB6</code></td>
<td>从模式 I²C 时钟线</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>SDA</strong></td>
<td style="text-align: center;"><code>PB7</code></td>
<td>从模式 I²C 数据线</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>XCL</strong></td>
<td style="text-align: center;"><code>悬空</code></td>
<td>主模式 I²C 时钟线</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>XDA</strong></td>
<td style="text-align: center;"><code>悬空</code></td>
<td>主模式 I²C 数据线</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>AD0</strong></td>
<td style="text-align: center;"><code>悬空</code></td>
<td>设备地址，悬空时为低电平</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>INT</strong></td>
<td style="text-align: center;"><code>悬空</code></td>
<td>中断输出，即向微控制器发送中断信号</td>
</tr>
</tbody>
</table>
<p>MPU6050
的设备地址为<code>0xD0</code>，而官方数据手册上给出的地址是<code>0x68</code>，由于
I²C 的地址为 7 位，使用 8
位字节的方式进行表达时，会出现两种状况：在低位补<code>0</code>结果为<code>1101 0000</code>，在高位补<code>0</code>结果为<code>0110 1000</code>，本实验电路使用<strong>STM32F103C8T6</strong>的
I²C 外设时，采用的是<code>0xD0</code>地址。</p>
<h3 id="mpu6050.h">MPU6050.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/MPU6050/MPU6050.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADD 0xD0 <span class="comment">// MPU6050 设备地址，如果模块的 AD0 引脚处于悬空或低电平状态时，该地址为 0xD0，否则为 0xD2</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MPU6050 寄存器地址映射 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_SMPLRT_DIV 0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_CONFIG 0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_CONFIG 0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_CONFIG 0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_PWR_MGMT_1 0x6B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MPU6050 的 X、Y、Z 原始数据所在的寄存器地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_XOUT_H 0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_XOUT_L 0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_YOUT_H 0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_YOUT_L 0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_ZOUT_H 0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_ACCEL_ZOUT_L 0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_TEMP_OUT_H 0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_TEMP_OUT_L 0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_XOUT_H 0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_XOUT_L 0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_YOUT_H 0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_YOUT_L 0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_ZOUT_H 0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_RA_GYRO_ZOUT_L 0x48</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// MPU6050 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_READ</span><span class="params">(u16 *n)</span>; <span class="comment">// MPU6050 原始数据读取函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="mpu6050.c">MPU6050.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Hardware/MPU6050/MPU6050.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** MPU6050 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_PWR_MGMT_1, <span class="number">0x80</span>);   <span class="comment">// 调用 I²C 总线发送函数，让 MPU6050 进入复位并解除休眠</span></span><br><span class="line">  delay_ms(<span class="number">1000</span>);                                            <span class="comment">// 等待设备命令执行就绪</span></span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_PWR_MGMT_1, <span class="number">0x00</span>);   <span class="comment">// 调用 I²C 总线发送函数，让 MPU6050 进入正常工作状态</span></span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_SMPLRT_DIV, <span class="number">0x07</span>);   <span class="comment">// 调用 I²C 总线发送函数，设置陀螺仪采样率</span></span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_CONFIG, <span class="number">0x06</span>);       <span class="comment">// 调用 I²C 总线发送函数，修改设置寄存器</span></span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_ACCEL_CONFIG, <span class="number">0x00</span>); <span class="comment">// 调用 I²C 总线发送函数，配置加速度传感器的取值范围</span></span><br><span class="line">  I2C_SAND_BYTE(MPU6050_ADD, MPU6050_RA_GYRO_CONFIG, <span class="number">0x18</span>);  <span class="comment">// 调用 I²C 总线发送函数，设置 MPU6050 的测量范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 读取 MPU6050 的 X、Y、Z 三轴原始数据，参数 n 用于存放读取到的原始数据，其中 n[0] = AX、n[1] = AY、n[2] = AZ、n[3] = GX、n[4] = GY、n[5] = GZ */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_READ</span><span class="params">(u16 *n)</span> &#123;</span><br><span class="line">  u8 i;     <span class="comment">// for 循环索引</span></span><br><span class="line">  u8 t[<span class="number">14</span>]; <span class="comment">// 存放原始数据的临时变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 I²C 连续读取函数，从 MPU6050_RA_ACCEL_XOUT_H 地址读取 14 个字节的数据，并将其存放至临时变量 t 当中 */</span></span><br><span class="line">  I2C_READ_BUFFER(MPU6050_ADD, MPU6050_RA_ACCEL_XOUT_H, t, <span class="number">14</span>);</span><br><span class="line">  <span class="comment">/* 存放加速度数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    n[i] = ((t[<span class="number">2</span> * i] &lt;&lt; <span class="number">8</span>) + t[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 存放陀螺仪数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    n[i - <span class="number">1</span>] = ((t[<span class="number">2</span> * i] &lt;&lt; <span class="number">8</span>) + t[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-38">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u16 t[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;  MPU6050 Test  &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">2</span>, <span class="string">&quot;X:       X:     &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;Y:       Y:     &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">6</span>, <span class="string">&quot;Z:       Z:     &quot;</span>);</span><br><span class="line"></span><br><span class="line">  MPU6050_Init(); <span class="comment">// 初始化 MPU6050 模块</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    MPU6050_READ(t); <span class="comment">// 读取 MPU6050 的数据到上面声明的数组变量 t，其中第 0 ~ 2 位存放加速度值，第 3 ~ 5 位存放陀螺仪值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 0 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">2</span> * <span class="number">8</span>, t[<span class="number">0</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">3</span> * <span class="number">8</span>, t[<span class="number">0</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">4</span> * <span class="number">8</span>, t[<span class="number">0</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">5</span> * <span class="number">8</span>, t[<span class="number">0</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">6</span> * <span class="number">8</span>, t[<span class="number">0</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 3 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">11</span> * <span class="number">8</span>, t[<span class="number">3</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">12</span> * <span class="number">8</span>, t[<span class="number">3</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">13</span> * <span class="number">8</span>, t[<span class="number">3</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">14</span> * <span class="number">8</span>, t[<span class="number">3</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">2</span>, <span class="number">15</span> * <span class="number">8</span>, t[<span class="number">3</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 1 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">2</span> * <span class="number">8</span>, t[<span class="number">1</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">3</span> * <span class="number">8</span>, t[<span class="number">1</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">4</span> * <span class="number">8</span>, t[<span class="number">1</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">5</span> * <span class="number">8</span>, t[<span class="number">1</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">6</span> * <span class="number">8</span>, t[<span class="number">1</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 4 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">11</span> * <span class="number">8</span>, t[<span class="number">4</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">12</span> * <span class="number">8</span>, t[<span class="number">4</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">13</span> * <span class="number">8</span>, t[<span class="number">4</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">14</span> * <span class="number">8</span>, t[<span class="number">4</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">4</span>, <span class="number">15</span> * <span class="number">8</span>, t[<span class="number">4</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 2 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">2</span> * <span class="number">8</span>, t[<span class="number">2</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">3</span> * <span class="number">8</span>, t[<span class="number">2</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">4</span> * <span class="number">8</span>, t[<span class="number">2</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">5</span> * <span class="number">8</span>, t[<span class="number">2</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">6</span> * <span class="number">8</span>, t[<span class="number">2</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示 t 数组第 5 个元素的数据到 OLED 屏幕 */</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">11</span> * <span class="number">8</span>, t[<span class="number">5</span>] / <span class="number">10000</span> + <span class="number">0x30</span>);        <span class="comment">// 万位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">12</span> * <span class="number">8</span>, t[<span class="number">5</span>] % <span class="number">10000</span> / <span class="number">1000</span> + <span class="number">0x30</span>); <span class="comment">// 千位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">13</span> * <span class="number">8</span>, t[<span class="number">5</span>] % <span class="number">1000</span> / <span class="number">100</span> + <span class="number">0x30</span>);   <span class="comment">// 百位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">14</span> * <span class="number">8</span>, t[<span class="number">5</span>] % <span class="number">100</span> / <span class="number">10</span> + <span class="number">0x30</span>);     <span class="comment">// 十位</span></span><br><span class="line">    OLED_DISPLAY_8x16(<span class="number">6</span>, <span class="number">15</span> * <span class="number">8</span>, t[<span class="number">5</span>] % <span class="number">10</span> + <span class="number">0x30</span>);           <span class="comment">// 个位</span></span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">200</span>); <span class="comment">// 修改该延时值，可以调整 MPU6050 的数据刷新频率</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="low-power-modes-低功耗模式">Low-power Modes 低功耗模式</h2>
<p>微控制器的功率是各种片上外设与模块的功率总和，低功耗模式则是通过关闭部分芯片内部的功能，以达到降低功耗节约电能的目的。<strong>STM32F103C8T6</strong>拥有<strong>睡眠(Sleep)</strong>、<strong>停机(Stop)</strong>、<strong>待机(Standby)</strong>三种低功耗模式模式，并且支持通过<code>Vʙᴀᴛ</code>引脚为实时时钟以及备用寄存器供电。</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 36%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>低功耗模式</strong></th>
<th style="text-align: right;">关闭功能</th>
<th style="text-align: right;">唤醒方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>睡眠模式</strong></td>
<td style="text-align: right;">ARM 内核</td>
<td style="text-align: right;">所有内、外部功能的中断事件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>停机模式</strong></td>
<td style="text-align: right;">ARM 内核以及内部所有功能、PLL
分频器、HSE</td>
<td style="text-align: right;">外部中断输入引脚 EXTI、电源电压监控中断
PVD、RTC 时钟、USB 唤醒信号</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>待机模式</strong></td>
<td style="text-align: right;">ARM 内核以及内部所有功能、PLL
分频器、HSE、SDRAM</td>
<td style="text-align: right;">NRST 引脚外部复位、独立看门狗 IWDG
复位、专用唤醒引脚 WKUP、RTC 时钟</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>参考：</strong>STM32F103C8T6
正常模式下工作电流约<code>10mA</code>，进入睡眠模式后为<code>2mA</code>，进入停机模式之后仅<code>20uA</code>，而进入待机模式则只有<code>2uA</code>，这些数据根据程序和集成电路工艺的不同而略有差异，但是能对低功耗下各模式的能耗状况有一个直观的认识。</p>
</blockquote>
<p>当 ARM Cortex M3
内核空闲的时候，可以进入<strong>睡眠模式</strong>。由于仅仅只关闭了内核，节能效果有限，因此极少在祼机系统当中使用，但是常用于嵌入式操作系统当中。而进入<strong>停机模式</strong>以后，SRAM
里的内容不会消失，程序也不会自动复位，在唤醒以后可以恢复之前的工作状态，其节能效果与待机模式相近，在电池供电的场景下具备一定优势。但是，进入<strong>待机模式</strong>以后，SRAM
的数据将会掉电丢失，唤醒后程序会自动复位，由于<strong>待机</strong>和<strong>停机</strong>两种模式下消耗的电流差别仅以<code>uA</code>为单位，因此更多场景会采用<strong>停机模式</strong>，而仅在与之前工作状态无关，且运行并不频繁的场景下考虑采用<strong>待机模式</strong>。</p>
<h3 id="sleep-睡眠模式">Sleep 睡眠模式</h3>
<p>将下面的程序编译下载运行，实验电路上电<strong>STM32F103C8T6</strong>默认进入睡眠模式，但是按下核心板电路上的<strong>KEY1</strong>按键，可以通过产生中断唤醒微控制器。当按键弹起后经过<code>0.5</code>秒左右时间，微控制器又会重新进入睡眠模式。</p>
<h4 id="nvic.h-1">NVIC.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NVIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NVIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 INT_MARK;      <span class="comment">// 中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_INT_INIT</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 按键中断初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="nvic.c-1">NVIC.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 INT_MARK; <span class="comment">// 中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按键中断初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_INT_INIT</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);       <span class="comment">// 使能 GPIO 相关时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);        <span class="comment">// 使能 AFIO 重映射功能时钟</span></span><br><span class="line">  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); <span class="comment">// 映射 GPIO 引脚至 EXTI</span></span><br><span class="line"></span><br><span class="line">  EXTI_InitStruct.EXTI_Line = EXTI_Line0;                <span class="comment">// 设置外部中断线</span></span><br><span class="line">  EXTI_InitStruct.EXTI_LineCmd = ENABLE;                 <span class="comment">// 使能外部中断</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;       <span class="comment">// 设置为中断模式</span></span><br><span class="line">  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;   <span class="comment">// 设置为下降沿触发中断</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStruct);                           <span class="comment">// 初始化外部中断 EXTI 设置</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn;          <span class="comment">// 设置 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;           <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>; <span class="comment">// 设置 NVIC 的抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;        <span class="comment">// 设置 NVIC 的子优先级为 2</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStruct);                           <span class="comment">// 初始化向量中断控制器 NVIC 设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外部中断 0 的中断处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断 EXTI_Line0 中断线是否发生中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) != RESET) &#123;</span><br><span class="line">    INT_MARK = <span class="number">1</span>;                       <span class="comment">// 标志位置 1，表示产生了按键中断</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line0); <span class="comment">// 清除中断线内的标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-39">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Sleep Test   &quot;</span>); <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  INT_MARK = <span class="number">0</span>;         <span class="comment">// 中断标志位初始化为 0</span></span><br><span class="line">  NVIC_Configuration(); <span class="comment">// 设置中断优先级</span></span><br><span class="line">  KEY_INT_INIT();       <span class="comment">// 调用按键中断初始化函数，将 KEY1 按键对应的 PA0 设置为按键中断输入</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 睡眠模式设置 */</span></span><br><span class="line">  NVIC_SystemLPConfig(NVIC_LP_SEVONPEND, DISABLE);   <span class="comment">// DISABLE 表示只有使能的中断或事件才能唤醒 ARM 内核，ENABLE 表示任何中断与事件都可以唤醒 ARM 内核</span></span><br><span class="line">  NVIC_SystemLPConfig(NVIC_LP_SLEEPDEEP, DISABLE);   <span class="comment">// DISABLE 表示设置低功耗模式为睡眠模式，ENABLE 表示进入低功耗时为深度睡眠模式。</span></span><br><span class="line">  NVIC_SystemLPConfig(NVIC_LP_SLEEPONEXIT, DISABLE); <span class="comment">// DISABLE 表示唤醒进入线程模式以后不再进入睡眠模式，ENABLE 表示唤醒执行完相应中断处理以后直接进入睡眠模式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED</span></span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  MCU Sleep!    &quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __WFI() 与 __WFE() 函数均声明并定义在内核相关的 core_cm3.h 和 core_cm3.c 文件 */</span></span><br><span class="line">    __WFI(); <span class="comment">// 执行到此处以后进入睡眠模式，并且等待中断唤醒，后续代码将不会再执行</span></span><br><span class="line">    <span class="comment">// __WFE(); // 进入睡眠模式，等待事件唤醒</span></span><br><span class="line"></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// 熄灭 LED</span></span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  MCU Wake Up!  &quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stop-停机模式">Stop 停机模式</h3>
<p>将下面的程序编译下载运行，实验电路上电<strong>STM32F103C8T6</strong>默认进入停机模式，按下核心板电路上的<strong>KEY1</strong>按键，可以通过产生中断唤醒微控制器。当按键弹起<code>0.5</code>秒以后，微控制器又会重新进入停机模式。</p>
<h4 id="nvic.h-2">NVIC.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.h，代码与睡眠模式实验相同 */</span></span><br></pre></td></tr></table></figure>
<h4 id="nvic.c-2">NVIC.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/nvic/NVIC.c，代码与睡眠模式实验相同 */</span></span><br></pre></td></tr></table></figure>
<h4 id="main.c-40">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   Stop  Test   &quot;</span>); <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  INT_MARK = <span class="number">0</span>;         <span class="comment">// 中断标志位初始化为 0</span></span><br><span class="line">  NVIC_Configuration(); <span class="comment">// 设置中断优先级</span></span><br><span class="line">  KEY_INT_INIT();       <span class="comment">// 调用按键中断初始化函数，将 KEY1 按键对应的 PA0 设置为按键中断输入</span></span><br><span class="line"></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); <span class="comment">// 使能电源 PWR 相关时钟，因为停机模式是电源 PWR 功能的组成部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED</span></span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  MCU  Stop!    &quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数 PWR_Regulator_ON 指电源不进入低功耗模式，参数 PWR_Regulator_LowPower 让电源进入低功耗模式</span></span><br><span class="line"><span class="comment">     * 参数 PWR_STOPEntry_WFI 表示采用中断方式唤醒，参数 PWR_STOPEntry_WFE 表示采用事件方式唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI); <span class="comment">// 调用标准库函数进入停机模式，并采用中断方式唤醒，后续代码将不会再执行</span></span><br><span class="line"></span><br><span class="line">    RCC_Configuration(); <span class="comment">// 初始化系统时钟，由于停机模式唤醒后会默认采用 HSI 内部高速时钟，因此需要重新进行初始化</span></span><br><span class="line"></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// 熄灭 LED</span></span><br><span class="line">    OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  MCU Wake Up!  &quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="standby-待机模式">Standby 待机模式</h3>
<p>本实验需要断开触摸按键对应<strong>PA10</strong>跳线座的<strong>PA0</strong>跳线，下面程序下载上电以后，<strong>STM32F103C8T6</strong>默认进入待机模式，只能通过实验电路上的【复位
K1】和【唤醒
K2】两个按键进行唤醒。例如：<strong>K2</strong>按键一端连接到<code>3.3V</code>电源，另外一端连接至<code>WKUP/PA0</code>引脚，按键按下时该引脚会输入一个高电平上升沿信号，从而唤醒微控制器。</p>
<p><img src="/Embedded/STM32F103/low-power-mode/diagram.png"></p>
<h4 id="main.c-41">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot; Standby Test   &quot;</span>); <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); <span class="comment">// 使能电源 PWR 相关时钟，由于待机和停机模式都需要使用到 PWR 时钟</span></span><br><span class="line">  PWR_WakeUpPinCmd(ENABLE);                           <span class="comment">// 调用标准库函数，开启 WKUP 功能唤醒引脚，待机时 WKUP/PA0 引脚为模拟输入，该引脚如果接收到上升沿信号，就会使微控制器重新唤醒</span></span><br><span class="line"></span><br><span class="line">  GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">0</span>)); <span class="comment">// 熄灭 LED</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;  MCU Reset!    &quot;</span>);</span><br><span class="line">  delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span>)); <span class="comment">// 点亮 LED</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;   Standby!     &quot;</span>);</span><br><span class="line">  delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  PWR_EnterSTANDBYMode(); <span class="comment">// 进入待机模式，程序不会再向下执行，唤醒后由于 SRAM 保存的内容消失，代码会复位并重新执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wdg-看门狗定时器">WDG 看门狗定时器</h2>
<p>看门狗（WDG，Watch
Dog）是<strong>STM32F103C8T6</strong>的一个片上外设单元，原理上是一个定时计数器，当其开始递减计数以后，每间隔一段时间微控制器就会发出一条复位指令，从而使其重新开始递减计数；如果运行期间看门狗未进行正确的复位，则递减计数至<code>0</code>以后，看门狗就会强制复位系统或进行其它指定处理。</p>
<h3 id="iwdg-独立看门狗">IWDG 独立看门狗</h3>
<p>独立看门狗（IWDG，Independent Watchdog）基于一个 12
位的递减计数器和一个 8
位的预分频器，并由内部独立于主时钟的<code>40kHz</code>的 RC
振荡器提供时钟源，可以运行于停机与待机模式之下。<strong>独立看门狗可以在计数到<code>0</code>之前随时进行喂狗操作，主要用于监控程序是否正常运行</strong>。</p>
<p><img src="/Embedded/STM32F103/watch-dog/independent.png"></p>
<blockquote>
<p><strong>注意：</strong>编写实验工程时，必须向项目当中加入<code>stm32f10x_iwdg.h</code>和<code>stm32f10x_iwdg.c</code>标准函数库文件。</p>
</blockquote>
<h4 id="iwdg.h">iwdg.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/iwdg/iwdg.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 看门狗定时时间（单位：ms）= (预分频值 * 重装载值) / 40</span></span><br><span class="line"><span class="comment"> * 本实验将预分频值 pre 设置为 64，重装载值设置为 625，由上面公式可知独立看门狗的定时时间约为 1 秒钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pre IWDG_Prescaler_64 <span class="comment">// 分频器取值范围，可选 4、8、16、32、64、128、256</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rlr 625               <span class="comment">// 重装载值取值范围，0 ~ 0xFFF（将 0xFFF 换算为十进制数等于 4095）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 独立看门狗初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Feed</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 独立看门喂狗函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="iwdg.c">iwdg.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/iwdg/iwdg.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 独立看门狗初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); <span class="comment">// 使能寄存器 IWDG_PR 和 IWDG_RLR 的写操作，允许独立看门狗写数据</span></span><br><span class="line">  IWDG_SetPrescaler(pre);                       <span class="comment">// 设置独立看门狗计数器的预分频值 64</span></span><br><span class="line">  IWDG_SetReload(rlr);                          <span class="comment">// 设置独立看门狗计数器的重装载值 625</span></span><br><span class="line">  IWDG_ReloadCounter();                         <span class="comment">// 将重装载值写入计数器</span></span><br><span class="line">  IWDG_Enable();                                <span class="comment">// 使能独立看门狗，让计数器开始进行递减计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 独立看门喂狗函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Feed</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  IWDG_ReloadCounter(); <span class="comment">// 将重装载值 625 重新写入计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-42">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iwdg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   IWDG Test    &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;    Reset!      &quot;</span>);</span><br><span class="line">  delay_ms(<span class="number">800</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line"></span><br><span class="line">  IWDG_Init(); <span class="comment">// 初始化独立看门狗，设置在 1 秒内进行喂狗操作，同时计数器开始递减计数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    IWDG_Feed(); <span class="comment">// 调用标准外设库函数，执行喂狗操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 KEY1 按键被按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;</span><br><span class="line">      delay_s(<span class="number">2</span>); <span class="comment">// 延时 2 秒使程序流程不能执行喂狗操作，进而导致程序复位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wwdg-窗口看门狗">WWDG 窗口看门狗</h3>
<p>窗口看门狗（WWDG，Window Watchdog）内置一个 7
位递减计数器，并且由主时钟进行驱动，具备早期预警中断功能。<strong>窗口看门狗必须在指定的时间范围内进行喂狗操作，主要作用是监控单片机运行时效是否精确</strong>。</p>
<p><img src="/Embedded/STM32F103/watch-dog/window.png"></p>
<blockquote>
<p><strong>注意：</strong>编写实验工程时，必须向项目当中加入<code>stm32f10x_wwdg.h</code>和<code>stm32f10x_wwdg.c</code>标准函数库文件。</p>
</blockquote>
<h4 id="wwdg.h">wwdg.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/wwdg/wwdg.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 上窗口超时时间（单位：us）= 4096 * 预分频值 * (计数器重装载 - 上窗口边界值) / APB1时钟频率（单位：MHz）</span></span><br><span class="line"><span class="comment"> * 下窗口超时时间（单位：us）= 4096 * 预分频值 * (计数器重装载 - 0x40) / APB1时钟频率（单位：MHz）</span></span><br><span class="line"><span class="comment"> * 本实验计数器重装载值为 0x7f，上窗口边界值为 0x50，预分频值为 8，得到上窗口时间 = 48ms，下窗口时间 = 64ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WWDG_CNT 0x7F          <span class="comment">// 计数器重装载值，取值范围 0x40 ~ 0x7F</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wr 0x50                <span class="comment">// 用户设置的上窗口边界值，取值范围 0x40 ~ 0x7F</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fprer WWDG_Prescaler_8 <span class="comment">// 预分频值，取值范围 1、2、4、8</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Init</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// 窗口看门狗初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_NVIC_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 窗口看门狗中断服务初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Feed</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// 窗口看门喂狗函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="wwdg.c">wwdg.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/wwdg/wwdg.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 窗口看门狗初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); <span class="comment">// 使能窗口看门狗对应的时钟</span></span><br><span class="line">  WWDG_SetPrescaler(fprer);                            <span class="comment">// 设置窗口看门狗计数器的预分频值 8</span></span><br><span class="line">  WWDG_SetWindowValue(wr);                             <span class="comment">// 设置上窗口边界值 0x50</span></span><br><span class="line">  WWDG_Enable(WWDG_CNT);                               <span class="comment">// 使能窗口看门狗，并且设置重装载值 0x7F</span></span><br><span class="line">  WWDG_ClearFlag();                                    <span class="comment">// 清除提前唤醒中断标志位</span></span><br><span class="line">  WWDG_NVIC_Init();                                    <span class="comment">// 初始化窗口看门狗对应的 NVIC</span></span><br><span class="line">  WWDG_EnableIT();                                     <span class="comment">// 使能窗口看门狗中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 窗口看门狗中断服务初始化函数，被 WWDG_Init() 所调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_NVIC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;           <span class="comment">// 设置窗口看门狗中断请求通道</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>; <span class="comment">// 设置抢占优先级为 2</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;        <span class="comment">// 设置子优先级为 3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;           <span class="comment">// 使能中断请求通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);                           <span class="comment">// 初始化 NVIC 中断向量控制器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 窗口看门喂狗函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Feed</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  WWDG_SetCounter(WWDG_CNT); <span class="comment">// 调用标准外设库提供的喂狗操作函数，参数为计数器重装载值 0x7F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 窗口看门狗中断服务函数，窗口期没有执行喂狗操作时，计数值递减至 0x40 时就会触发该中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  WWDG_ClearFlag(); <span class="comment">// 清除提前唤醒中断标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 按需加入系统复位之前需要执行的任务 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main.c-43">main.c</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示文字信息到 OLED 屏幕 */</span></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   WWDG Test    &quot;</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;    Reset!      &quot;</span>);</span><br><span class="line">  delay_ms(<span class="number">800</span>);</span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">4</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line"></span><br><span class="line">  WWDG_Init(); <span class="comment">// 初始化窗口看门狗，设置喂狗操作的间隔时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    delay_ms(<span class="number">54</span>); <span class="comment">// 避开窗口时间之前的位置，即计数初始值 ~ 上窗口边界</span></span><br><span class="line">    WWDG_Feed();  <span class="comment">// 调用标准外设库函数，进行喂狗操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 KEY1 按键按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (!GPIO_ReadInputDataBit(KEYPORT, KEY1)) &#123;</span><br><span class="line">      delay_s(<span class="number">2</span>); <span class="comment">// 延时 2 秒使程序流程不能执行喂狗操作，进而导致程序复位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tim234-标准定时器">TIM2/3/4 标准定时器</h2>
<p><strong>STM32F103C8T6</strong>内置了<strong>TIM2</strong>、<strong>TIM3</strong>、<strong>TIM4</strong>三个可同步运行的标准定时器，每个定时器都有一个
16 位自动加载递加/递减计数器、一个 16 位预分频器、4
个独立的通道，其中每个通道都可用于输入捕获、输出比较、PWM
和单脉冲模式输出。</p>
<p><img src="/Embedded/STM32F103/timer/diagram.png"></p>
<p>本小节将会基于<strong>TIM3</strong>标准定时器 3
实现了一个让<strong>LED1</strong>间隔<code>1</code>秒进行闪烁的实验，进行实验之前需要先往项目中加入定时器相关的<code>stm32f10x_tim.h</code>和<code>stm32f10x_tim.c</code>标准函数库源文件。</p>
<h3 id="tim.h">tim.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/tim/tim.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_Init</span><span class="params">(u16 arr, u16 psc)</span>; <span class="comment">// 定时器 3 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_NVIC_Init</span><span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 定时器 3 嵌套中断向量 NVIC 初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="tim.c">tim.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Basic/tim/tim.c  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定时器 3 初始化函数，参数 arr 是计数重装载值，参数 psc 是预分频系数</span></span><br><span class="line"><span class="comment"> * 定时时间 = ((重装载值 + 1) * (预分频系数 + 1)) / 时钟频率</span></span><br><span class="line"><span class="comment"> * 例如：重装载值 = 9999，预分频系数 = 7199，则可以定时 1 秒钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_Init</span><span class="params">(u16 arr, u16 psc)</span> &#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStrue;</span><br><span class="line"></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">// 使能 TIM3 相关时钟</span></span><br><span class="line">  TIM3_NVIC_Init();                                    <span class="comment">// 调用 TIM3 嵌套中断向量 NVIC 初始化函数</span></span><br><span class="line"></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_Period = arr;                     <span class="comment">// 设置计数重装载值 arr</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_Prescaler = psc;                  <span class="comment">// 设置预分频系数 psc</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">// 计数器向上计数溢出</span></span><br><span class="line">  TIM_TimeBaseInitStrue.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">// 定时器分频因子，通常设为 TIM_CKD_DIV1</span></span><br><span class="line">  TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStrue);             <span class="comment">// 初始化 TIM3 设置</span></span><br><span class="line">  TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);                  <span class="comment">// 使能 TIM3 中断</span></span><br><span class="line">  TIM_Cmd(TIM3, ENABLE);                                      <span class="comment">// 使能 TIM3，此时定时器开始工作，每间隔 1 秒产生一次定时器中断，然后跳转至相应的中断服务函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 定时器 3 嵌套中断向量 NVIC 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_NVIC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;             <span class="comment">// 定义 TIM3 中断请求通道</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x3</span>; <span class="comment">// 设置主优先级</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x3</span>;        <span class="comment">// 设置子优先级</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             <span class="comment">// 使能 NVIC 中断请求通道</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 定时器 3 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断当前是否为 TIM3 定时器中断 */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) &#123;</span><br><span class="line">    TIM_ClearITPendingBit(TIM3, TIM_IT_Update); <span class="comment">// 如果是则清空中断标志位</span></span><br><span class="line">    <span class="comment">/* 用户自定义处理代码 */</span></span><br><span class="line">    GPIO_WriteBit(LEDPORT, LED1, (BitAction)(<span class="number">1</span> - GPIO_ReadOutputDataBit(LEDPORT, LED1))); <span class="comment">// 对 LED1 电平状态取反，实现间隔 1 秒闪烁效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main.c-44">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   TIM3 Test    &quot;</span>); <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  TIM3_Init(<span class="number">9999</span>, <span class="number">7199</span>); <span class="comment">// 定时器初始化函数，通过设置参数 9999 与 7199 可以产生 1 秒的定时时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 放置用户程序，例如将 LED1 的闪烁代码放置在 TIM3 中断服务函数里 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="crc-循环冗余校验">CRC 循环冗余校验</h2>
<p><strong>STM32F103C8T6</strong>内置的循环冗余校验（CRC，<strong>C</strong>yclic
<strong>R</strong>edundancy
<strong>C</strong>heck）计算单元基于固定的多项式，可以得到任意 32 位的
CRC
计算结果，该结果可以应用于通信与数据存储的校验。在进行实验之前需要向工程当中加入
CRC
校验相关的<code>stm32f10x_crc.h</code>和<code>stm32f10x_crc.c</code>标准函数库文件。</p>
<p><img src="/Embedded/STM32F103/crc-id/crc.png"></p>
<h3 id="main.c-45">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* CRC 校验相关数据 */</span></span><br><span class="line">  u32 a, b;</span><br><span class="line">  u8 c;</span><br><span class="line">  u32 y[<span class="number">3</span>] = &#123;<span class="number">0x87654321</span>, <span class="number">0x98765432</span>, <span class="number">0x09876543</span>&#125;;</span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;   CRC  Test    &quot;</span>);  <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line">  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_CRC, ENABLE); <span class="comment">// 使能 CRC 相关时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 采用单独数据的方式进行 CRC 计算，最后变量 a 存放的是 3 个独立数据的 CRC 计算结果，32 位 */</span></span><br><span class="line">    CRC_ResetDR();           <span class="comment">// 使用 CRC 计算之前需要先进行复位</span></span><br><span class="line">    CRC_CalcCRC(<span class="number">0x12345678</span>); <span class="comment">// 使用标准外设库函数向 CRC 寄存器写入数据，参数就是待写入 CRC 的 32 位数据，最后返回 32 位 CRC 计算结果</span></span><br><span class="line">    CRC_CalcCRC(<span class="number">0x23456789</span>);</span><br><span class="line">    a = CRC_CalcCRC(<span class="number">0x34567890</span>); <span class="comment">// 将返回的 32 位 CRC 计算结果赋给变量 a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 采用数组的方式进行 CRC 计算，最后变量 b 存放的是数组 y 的 3 个元素 CRC 计算结果，32 位 */</span></span><br><span class="line">    CRC_ResetDR();              <span class="comment">// 使用 CRC 计算之前再次进行复位</span></span><br><span class="line">    b = CRC_CalcBlockCRC(y, <span class="number">3</span>); <span class="comment">// 使用标准外设库向 CRC 寄存器写入数组数据，参数 y 是待写入 CRC 的数组，参数 3 是数组长度，最后将返回的 32 位 CRC 计算结果赋给变量 b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 采用数组的方式进行 CRC 计算 读取和写入临时数据寄存器，最终变量 c 存放的是之前写入 CRC_IDR 寄存器的数据 0x5a，8位 */</span></span><br><span class="line">    CRC_SetIDRegister(<span class="number">0x5a</span>); <span class="comment">// 使用标准外设库向 CRC 独立寄存器 CRC_IDR 写入 8 位数据</span></span><br><span class="line">    c = CRC_GetIDRegister(); <span class="comment">// 使用标准外设库从 CRC 独立寄存器 CRC_IDR 读取数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="芯片-id-编码">芯片 ID 编码</h2>
<p><strong>STM32F103C8T6</strong>拥有 96 位芯片 ID
编码，分别固定存放于如下 12 个地址，其中每个地址存放 8
位编码。因此，读取读取该 ID
编码的时候，可以采用<code>8 位方式读取 12 个数据</code>、<code>16 位方式读取 6 个数据</code>、<code>32 位方式读取 3 个数据</code>三种方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 低位 ⇐===-- 芯片 ID 编码存放地址 --===⇒ 高位 */</span></span><br><span class="line"><span class="number">0x1FFFF7E8</span> | <span class="number">0x1FFFF7E9</span> | <span class="number">0x1FFFF7EA</span> | <span class="number">0x1FFFF7EB</span> | <span class="number">0x1FFFF7EC</span> | <span class="number">0x1FFFF7ED</span> | <span class="number">0x1FFFF7EE</span> | <span class="number">0x1FFFF7EF</span> | <span class="number">0x1FFFF7F0</span> | <span class="number">0x1FFFF7F1</span> | <span class="number">0x1FFFF7F2</span> | <span class="number">0x1FFFF7F3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>小端数据</strong>存放是指数据整合时，将<strong>低位地址</strong>数据放入内存的<strong>低位地址</strong>部分；<strong>大端数据</strong>存放方式正好反其道而行之，即将将<strong>低位地址</strong>数据放入内存的<strong>高位地址</strong>部分。ARM
架构微控制器为小端存放方式，而 8051 架构单片机为大端存放方式。</p>
</blockquote>
<h3 id="main.c-46">main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** User/main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled0561.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;relay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u32 ID[<span class="number">3</span>]; <span class="comment">// 声明拥有 3 个 32 位元素数据的数组</span></span><br><span class="line"></span><br><span class="line">  delay_ms(<span class="number">500</span>);       <span class="comment">// 等待相关元器件上电并且工作正常</span></span><br><span class="line">  RCC_Configuration(); <span class="comment">// 初始化系统时钟</span></span><br><span class="line">  RELAY_Init();        <span class="comment">// 初始化继电器</span></span><br><span class="line">  LED_Init();          <span class="comment">// 初始化核心板 LED</span></span><br><span class="line">  KEY_Init();          <span class="comment">// 初始化核心板按键</span></span><br><span class="line">  USART1_Init(<span class="number">115200</span>); <span class="comment">// 初始化 USART 串行接口，参数是波特率</span></span><br><span class="line">  I2C_Configuration(); <span class="comment">// 初始化 I²C 总线</span></span><br><span class="line">  OLED0561_Init();     <span class="comment">// 初始化 OLED</span></span><br><span class="line"></span><br><span class="line">  OLED_DISPLAY_8x16_BUFFER(<span class="number">0</span>, <span class="string">&quot;  STM32 ChipID  &quot;</span>); <span class="comment">// 显示文字信息到 OLED 屏幕</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 采用 32 位方式读取芯片 ID 编码 */</span></span><br><span class="line">  ID[<span class="number">0</span>] = *(__IO u32 *)(<span class="number">0X1FFFF7E8</span>); <span class="comment">// 读取前面 4 个字节</span></span><br><span class="line">  ID[<span class="number">1</span>] = *(__IO u32 *)(<span class="number">0X1FFFF7EC</span>); <span class="comment">// 读取中间 4 个字节</span></span><br><span class="line">  ID[<span class="number">2</span>] = *(__IO u32 *)(<span class="number">0X1FFFF7F0</span>); <span class="comment">// 读取后面 4 个字节</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;STM32F103C8T6 ChipID: %08X %08X %8X \r\n&quot;</span>, ID[<span class="number">0</span>], ID[<span class="number">1</span>], ID[<span class="number">2</span>]); <span class="comment">// 将 ID 编码打印至 USART 输出，格式字符串中的 08 表示数据不足 8 位时，则以 8 位格式补 0 进行显示</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查从微控制器内读取到的 ID 是否与给定的编码匹配 */</span></span><br><span class="line">  <span class="keyword">if</span> (ID[<span class="number">0</span>] == <span class="number">0x0669FF52</span> &amp;&amp; ID[<span class="number">1</span>] == <span class="number">0x52517178</span> &amp;&amp; ID[<span class="number">2</span>] == <span class="number">0x67255837</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ChipID match! \r\n&quot;</span>); <span class="comment">// 匹配</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chipID error! \r\n&quot;</span>); <span class="comment">// 不匹配</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>意法半导体 UINIO-MCU-STM32F103 标准库典型实例</p><p><a href="http://www.uinio.com/Embedded/STM32F103/">http://www.uinio.com/Embedded/STM32F103/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2015-03-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-07-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Zen/Data-Structure/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">常用数据结构 &amp; 算法分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Web/Http/"><span class="level-item">HTTP 协议深入解析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#片上资源概览"><span class="level-left"><span class="level-item">1</span><span class="level-item">片上资源概览</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#时钟系统"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">时钟系统</span></span></a></li><li><a class="level is-mobile" href="#gpio"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">GPIO</span></span></a></li><li><a class="level is-mobile" href="#定时器"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">定时器</span></span></a></li><li><a class="level is-mobile" href="#通信接口"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">通信接口</span></span></a></li><li><a class="level is-mobile" href="#dma"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">DMA</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stm32f103-最小系统"><span class="level-left"><span class="level-item">2</span><span class="level-item">STM32F103 最小系统</span></span></a></li><li><a class="level is-mobile" href="#keil-mdk-arm-设置"><span class="level-left"><span class="level-item">3</span><span class="level-item">Keil MDK-ARM 设置</span></span></a></li><li><a class="level is-mobile" href="#led-发光二极管"><span class="level-left"><span class="level-item">4</span><span class="level-item">LED 发光二极管</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#led-闪烁"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">LED 闪烁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#led.h"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">led.h</span></span></a></li><li><a class="level is-mobile" href="#led.c"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">led.c</span></span></a></li><li><a class="level is-mobile" href="#delay.h"><span class="level-left"><span class="level-item">4.1.4</span><span class="level-item">delay.h</span></span></a></li><li><a class="level is-mobile" href="#delay.c"><span class="level-left"><span class="level-item">4.1.5</span><span class="level-item">delay.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#led-呼吸灯"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">LED 呼吸灯</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-1"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#led-按键"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">LED 按键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-2"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#key.h"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">key.h</span></span></a></li><li><a class="level is-mobile" href="#key.c"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">key.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#flash-闪存"><span class="level-left"><span class="level-item">5</span><span class="level-item">Flash 闪存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-3"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#flash.h"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">flash.h</span></span></a></li><li><a class="level is-mobile" href="#flash.c"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">flash.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#buzzer-无源蜂鸣器"><span class="level-left"><span class="level-item">6</span><span class="level-item">Buzzer 无源蜂鸣器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按键控制蜂鸣器"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">按键控制蜂鸣器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-4"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#buzzer.h"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">buzzer.h</span></span></a></li><li><a class="level is-mobile" href="#buzzer.c"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">buzzer.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#播放-midi"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">播放 MIDI</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-5"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#buzzer.h-1"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">buzzer.h</span></span></a></li><li><a class="level is-mobile" href="#buzzer.c-1"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">buzzer.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#usart-串行通信"><span class="level-left"><span class="level-item">7</span><span class="level-item">USART 串行通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#usart-发送"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">USART 发送</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-6"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#usart.h"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">usart.h</span></span></a></li><li><a class="level is-mobile" href="#usart.c"><span class="level-left"><span class="level-item">7.1.3</span><span class="level-item">usart.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#usart-接收"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">USART 接收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#查询方式"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">查询方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-7"><span class="level-left"><span class="level-item">7.2.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#usart.c-1"><span class="level-left"><span class="level-item">7.2.1.2</span><span class="level-item">usart.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#中断方式"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">中断方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#usart.c-2"><span class="level-left"><span class="level-item">7.2.2.1</span><span class="level-item">usart.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#usart-控制-led"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">USART 控制 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-8"><span class="level-left"><span class="level-item">7.3.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#usart.c-3"><span class="level-left"><span class="level-item">7.3.2</span><span class="level-item">usart.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#终端-usart-控制-led"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">终端 USART 控制 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-9"><span class="level-left"><span class="level-item">7.4.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#usart.c-4"><span class="level-left"><span class="level-item">7.4.2</span><span class="level-item">usart.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#rtc-实时时钟"><span class="level-left"><span class="level-item">8</span><span class="level-item">RTC 实时时钟</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#led-间隔-1-秒分-闪烁"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">LED 间隔 1 秒/分 闪烁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-10"><span class="level-left"><span class="level-item">8.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#rtc.h"><span class="level-left"><span class="level-item">8.1.2</span><span class="level-item">rtc.h</span></span></a></li><li><a class="level is-mobile" href="#rtc.c"><span class="level-left"><span class="level-item">8.1.3</span><span class="level-item">rtc.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#终端日历程序"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">终端日历程序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-11"><span class="level-left"><span class="level-item">8.2.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#usart.c-5"><span class="level-left"><span class="level-item">8.2.2</span><span class="level-item">usart.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#rcc-复位与时钟控制器"><span class="level-left"><span class="level-item">9</span><span class="level-item">RCC 复位与时钟控制器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#rtc.c-1"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">rtc.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-12"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#sys.c"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">sys.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ttp223-触摸按键"><span class="level-left"><span class="level-item">10</span><span class="level-item">TTP223 触摸按键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单击控制核心板-led"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">单击控制核心板 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-13"><span class="level-left"><span class="level-item">10.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#touch_key.h"><span class="level-left"><span class="level-item">10.1.2</span><span class="level-item">touch_key.h</span></span></a></li><li><a class="level is-mobile" href="#touch_key.c"><span class="level-left"><span class="level-item">10.1.3</span><span class="level-item">touch_key.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#双击长按控制核心板-led"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">双击/长按控制核心板 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-14"><span class="level-left"><span class="level-item">10.2.1</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#滑动控制-led"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">滑动控制 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-15"><span class="level-left"><span class="level-item">10.3.1</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#tm1640-驱动共阴极数码管"><span class="level-left"><span class="level-item">11</span><span class="level-item">TM1640 驱动共阴极数码管</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-16"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#tm1640.h"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">TM1640.h</span></span></a></li><li><a class="level is-mobile" href="#tm1640.c"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">TM1640.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ec11-旋转编码器"><span class="level-left"><span class="level-item">12</span><span class="level-item">EC11 旋转编码器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-17"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#encoder.h"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">encoder.h</span></span></a></li><li><a class="level is-mobile" href="#encoder.c"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">encoder.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#i²c-总线"><span class="level-left"><span class="level-item">13</span><span class="level-item">I²C 总线</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#lm75a-温度传感器"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">LM75A 温度传感器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-18"><span class="level-left"><span class="level-item">13.1.1</span><span class="level-item">main.c</span></span></a></li><li><a class="level is-mobile" href="#i2c.h"><span class="level-left"><span class="level-item">13.1.2</span><span class="level-item">i2c.h</span></span></a></li><li><a class="level is-mobile" href="#i2c.c"><span class="level-left"><span class="level-item">13.1.3</span><span class="level-item">i2c.c</span></span></a></li><li><a class="level is-mobile" href="#lm75a.h"><span class="level-left"><span class="level-item">13.1.4</span><span class="level-item">lm75a.h</span></span></a></li><li><a class="level is-mobile" href="#lm75a.c"><span class="level-left"><span class="level-item">13.1.5</span><span class="level-item">lm75a.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#oled-无字库液晶屏"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">OLED 无字库液晶屏</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#oled0561.h"><span class="level-left"><span class="level-item">13.2.1</span><span class="level-item">oled0561.h</span></span></a></li><li><a class="level is-mobile" href="#oled0561.c"><span class="level-left"><span class="level-item">13.2.2</span><span class="level-item">oled0561.c</span></span></a></li><li><a class="level is-mobile" href="#ascii_8x16.h"><span class="level-left"><span class="level-item">13.2.3</span><span class="level-item">ASCII_8x16.h</span></span></a></li><li><a class="level is-mobile" href="#chs_16x16.h"><span class="level-left"><span class="level-item">13.2.4</span><span class="level-item">CHS_16x16.h</span></span></a></li><li><a class="level is-mobile" href="#pic1.h"><span class="level-left"><span class="level-item">13.2.5</span><span class="level-item">PIC1.h</span></span></a></li><li><a class="level is-mobile" href="#main.c-19"><span class="level-left"><span class="level-item">13.2.6</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#relay-继电器"><span class="level-left"><span class="level-item">14</span><span class="level-item">Relay 继电器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#realy.h"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">realy.h</span></span></a></li><li><a class="level is-mobile" href="#realy.c"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">realy.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-20"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#uln2003-驱动步进电机"><span class="level-left"><span class="level-item">15</span><span class="level-item">ULN2003 驱动步进电机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按键控制步进电机"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">按键控制步进电机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#step_motor.h"><span class="level-left"><span class="level-item">15.1.1</span><span class="level-item">step_motor.h</span></span></a></li><li><a class="level is-mobile" href="#step_motor.c"><span class="level-left"><span class="level-item">15.1.2</span><span class="level-item">step_motor.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-21"><span class="level-left"><span class="level-item">15.1.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#步进电机步数控制"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">步进电机步数控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#step_motor.h-1"><span class="level-left"><span class="level-item">15.2.1</span><span class="level-item">step_motor.h</span></span></a></li><li><a class="level is-mobile" href="#step_motor.c-1"><span class="level-left"><span class="level-item">15.2.2</span><span class="level-item">step_motor.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-22"><span class="level-left"><span class="level-item">15.2.3</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#rs232-串行通信"><span class="level-left"><span class="level-item">16</span><span class="level-item">RS232 串行通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#usart.h-1"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">usart.h</span></span></a></li><li><a class="level is-mobile" href="#main.c-23"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#rs485-串行通信"><span class="level-left"><span class="level-item">17</span><span class="level-item">RS485 串行通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#rs485.h"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">rs485.h</span></span></a></li><li><a class="level is-mobile" href="#rs485.c"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">rs485.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-24"><span class="level-left"><span class="level-item">17.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#can-总线通信"><span class="level-left"><span class="level-item">18</span><span class="level-item">CAN 总线通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#协议分析"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">协议分析</span></span></a></li><li><a class="level is-mobile" href="#can.h"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">can.h</span></span></a></li><li><a class="level is-mobile" href="#can.c"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">can.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-25"><span class="level-left"><span class="level-item">18.4</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#adc-模数转换"><span class="level-left"><span class="level-item">19</span><span class="level-item">ADC 模数转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#光敏电阻"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">光敏电阻</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#adc.h"><span class="level-left"><span class="level-item">19.1.1</span><span class="level-item">adc.h</span></span></a></li><li><a class="level is-mobile" href="#adc.c"><span class="level-left"><span class="level-item">19.1.2</span><span class="level-item">adc.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-26"><span class="level-left"><span class="level-item">19.1.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#电位器光敏电阻-2-通道-adc-采集"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">电位器&amp;光敏电阻 2 通道 ADC
采集</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#adc.h-1"><span class="level-left"><span class="level-item">19.2.1</span><span class="level-item">adc.h</span></span></a></li><li><a class="level is-mobile" href="#adc.c-1"><span class="level-left"><span class="level-item">19.2.2</span><span class="level-item">adc.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-27"><span class="level-left"><span class="level-item">19.2.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#模拟量摇杆"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">模拟量摇杆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#joystick.h"><span class="level-left"><span class="level-item">19.3.1</span><span class="level-item">JoyStick.h</span></span></a></li><li><a class="level is-mobile" href="#joystick.c"><span class="level-left"><span class="level-item">19.3.2</span><span class="level-item">JoyStick.c</span></span></a></li><li><a class="level is-mobile" href="#adc.c-2"><span class="level-left"><span class="level-item">19.3.3</span><span class="level-item">adc.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-28"><span class="level-left"><span class="level-item">19.3.4</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#my1650-音频解码芯片"><span class="level-left"><span class="level-item">20</span><span class="level-item">MY1650 音频解码芯片</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#音乐播放"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">音乐播放</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#usart.h-2"><span class="level-left"><span class="level-item">20.1.1</span><span class="level-item">usart.h</span></span></a></li><li><a class="level is-mobile" href="#usart.c-6"><span class="level-left"><span class="level-item">20.1.2</span><span class="level-item">usart.c</span></span></a></li><li><a class="level is-mobile" href="#my1690.h"><span class="level-left"><span class="level-item">20.1.3</span><span class="level-item">MY1690.h</span></span></a></li><li><a class="level is-mobile" href="#my1690.c"><span class="level-left"><span class="level-item">20.1.4</span><span class="level-item">MY1690.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-29"><span class="level-left"><span class="level-item">20.1.5</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#时钟语音播报"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">时钟语音播报</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-30"><span class="level-left"><span class="level-item">20.2.1</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#ch376-文件管理控制芯片"><span class="level-left"><span class="level-item">21</span><span class="level-item">CH376 文件管理控制芯片</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#u-盘插拔状态"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">U 盘插拔状态</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#spi.h"><span class="level-left"><span class="level-item">21.1.1</span><span class="level-item">spi.h</span></span></a></li><li><a class="level is-mobile" href="#spi.c"><span class="level-left"><span class="level-item">21.1.2</span><span class="level-item">spi.c</span></span></a></li><li><a class="level is-mobile" href="#ch376inc.h"><span class="level-left"><span class="level-item">21.1.3</span><span class="level-item">ch376inc.h</span></span></a></li><li><a class="level is-mobile" href="#ch376.h"><span class="level-left"><span class="level-item">21.1.4</span><span class="level-item">ch376.h</span></span></a></li><li><a class="level is-mobile" href="#ch376.c"><span class="level-left"><span class="level-item">21.1.5</span><span class="level-item">ch376.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-31"><span class="level-left"><span class="level-item">21.1.6</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件系统读写"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">文件系统读写</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#filesys.h"><span class="level-left"><span class="level-item">21.2.1</span><span class="level-item">filesys.h</span></span></a></li><li><a class="level is-mobile" href="#filesys.c"><span class="level-left"><span class="level-item">21.2.2</span><span class="level-item">filesys.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-32"><span class="level-left"><span class="level-item">21.2.3</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#矩阵键盘"><span class="level-left"><span class="level-item">22</span><span class="level-item">4 × 4 矩阵键盘</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#keypad44.h"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">KEYPAD4×4.h</span></span></a></li><li><a class="level is-mobile" href="#keypad44.c"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">KEYPAD4×4.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-33"><span class="level-left"><span class="level-item">22.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#exti-与-nvic"><span class="level-left"><span class="level-item">23</span><span class="level-item">EXTI 与 NVIC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#nvic.h"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">NVIC.h</span></span></a></li><li><a class="level is-mobile" href="#nvic.c"><span class="level-left"><span class="level-item">23.2</span><span class="level-item">NVIC.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-34"><span class="level-left"><span class="level-item">23.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#sg90-舵机"><span class="level-left"><span class="level-item">24</span><span class="level-item">SG90 舵机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sg90.h"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">SG90.h</span></span></a></li><li><a class="level is-mobile" href="#sg90.c"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">SG90.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-35"><span class="level-left"><span class="level-item">24.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#pwm-脉冲宽度调制"><span class="level-left"><span class="level-item">25</span><span class="level-item">PWM 脉冲宽度调制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#pwm.h"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">pwm.h</span></span></a></li><li><a class="level is-mobile" href="#pwm.c"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">pwm.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-36"><span class="level-left"><span class="level-item">25.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#dht11-温湿度传感器"><span class="level-left"><span class="level-item">26</span><span class="level-item">DHT11 温湿度传感器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dht11.h"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">dht11.h</span></span></a></li><li><a class="level is-mobile" href="#dht11.c"><span class="level-left"><span class="level-item">26.2</span><span class="level-item">dht11.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-37"><span class="level-left"><span class="level-item">26.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mpu6050-加速度陀螺仪"><span class="level-left"><span class="level-item">27</span><span class="level-item">MPU6050 加速度陀螺仪</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mpu6050.h"><span class="level-left"><span class="level-item">27.1</span><span class="level-item">MPU6050.h</span></span></a></li><li><a class="level is-mobile" href="#mpu6050.c"><span class="level-left"><span class="level-item">27.2</span><span class="level-item">MPU6050.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-38"><span class="level-left"><span class="level-item">27.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#low-power-modes-低功耗模式"><span class="level-left"><span class="level-item">28</span><span class="level-item">Low-power Modes 低功耗模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sleep-睡眠模式"><span class="level-left"><span class="level-item">28.1</span><span class="level-item">Sleep 睡眠模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#nvic.h-1"><span class="level-left"><span class="level-item">28.1.1</span><span class="level-item">NVIC.h</span></span></a></li><li><a class="level is-mobile" href="#nvic.c-1"><span class="level-left"><span class="level-item">28.1.2</span><span class="level-item">NVIC.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-39"><span class="level-left"><span class="level-item">28.1.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stop-停机模式"><span class="level-left"><span class="level-item">28.2</span><span class="level-item">Stop 停机模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#nvic.h-2"><span class="level-left"><span class="level-item">28.2.1</span><span class="level-item">NVIC.h</span></span></a></li><li><a class="level is-mobile" href="#nvic.c-2"><span class="level-left"><span class="level-item">28.2.2</span><span class="level-item">NVIC.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-40"><span class="level-left"><span class="level-item">28.2.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#standby-待机模式"><span class="level-left"><span class="level-item">28.3</span><span class="level-item">Standby 待机模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-41"><span class="level-left"><span class="level-item">28.3.1</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#wdg-看门狗定时器"><span class="level-left"><span class="level-item">29</span><span class="level-item">WDG 看门狗定时器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#iwdg-独立看门狗"><span class="level-left"><span class="level-item">29.1</span><span class="level-item">IWDG 独立看门狗</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#iwdg.h"><span class="level-left"><span class="level-item">29.1.1</span><span class="level-item">iwdg.h</span></span></a></li><li><a class="level is-mobile" href="#iwdg.c"><span class="level-left"><span class="level-item">29.1.2</span><span class="level-item">iwdg.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-42"><span class="level-left"><span class="level-item">29.1.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#wwdg-窗口看门狗"><span class="level-left"><span class="level-item">29.2</span><span class="level-item">WWDG 窗口看门狗</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#wwdg.h"><span class="level-left"><span class="level-item">29.2.1</span><span class="level-item">wwdg.h</span></span></a></li><li><a class="level is-mobile" href="#wwdg.c"><span class="level-left"><span class="level-item">29.2.2</span><span class="level-item">wwdg.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-43"><span class="level-left"><span class="level-item">29.2.3</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#tim234-标准定时器"><span class="level-left"><span class="level-item">30</span><span class="level-item">TIM2/3/4 标准定时器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#tim.h"><span class="level-left"><span class="level-item">30.1</span><span class="level-item">tim.h</span></span></a></li><li><a class="level is-mobile" href="#tim.c"><span class="level-left"><span class="level-item">30.2</span><span class="level-item">tim.c</span></span></a></li><li><a class="level is-mobile" href="#main.c-44"><span class="level-left"><span class="level-item">30.3</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#crc-循环冗余校验"><span class="level-left"><span class="level-item">31</span><span class="level-item">CRC 循环冗余校验</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-45"><span class="level-left"><span class="level-item">31.1</span><span class="level-item">main.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#芯片-id-编码"><span class="level-left"><span class="level-item">32</span><span class="level-item">芯片 ID 编码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#main.c-46"><span class="level-left"><span class="level-item">32.1</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Design/"><span class="level-start"><span class="level-item">Design</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Electronics/"><span class="level-start"><span class="level-item">Electronics</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Embedded/"><span class="level-start"><span class="level-item">Embedded</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/English/"><span class="level-start"><span class="level-item">English</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Thinking/"><span class="level-start"><span class="level-item">Thinking</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Zen/"><span class="level-start"><span class="level-item">Zen</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%B5%E5%AD%90%E7%A1%AC%E4%BB%B6/"><span class="level-start"><span class="level-item">电子硬件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Battery/"><img src="/Electronics/Battery/logo.png" alt="关于锂离子电池选型里的一些重要细节"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-08-28T16:00:00.000Z">2024-08-29</time></p><p class="title"><a href="/Electronics/Battery/">关于锂离子电池选型里的一些重要细节</a></p><p class="categories"><a href="/categories/%E7%94%B5%E5%AD%90%E7%A1%AC%E4%BB%B6/">电子硬件</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/LTspice/"><img src="/Electronics/LTspice/logo.png" alt="如何使用新版本的 LTspice 进行模拟电路仿真"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-05-21T16:00:00.000Z">2024-05-22</time></p><p class="title"><a href="/Electronics/LTspice/">如何使用新版本的 LTspice 进行模拟电路仿真</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/SI9000/"><img src="/Electronics/SI9000/logo.png" alt="基于 Polar Si9000e 计算传输线特征阻抗的全攻略"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-04-04T16:00:00.000Z">2024-04-05</time></p><p class="title"><a href="/Electronics/SI9000/">基于 Polar Si9000e 计算传输线特征阻抗的全攻略</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Component/"><img src="/Electronics/Component/logo.png" alt="硬件电路设计当中 の 常用分立元器件选型"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-30T16:00:00.000Z">2024-03-31</time></p><p class="title"><a href="/Electronics/Component/">硬件电路设计当中 の 常用分立元器件选型</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Project/UINIO-MCU-GD32/"><img src="/Project/UINIO-MCU-GD32/logo.png" alt="兆易创新 UINIO-MCU-GD32F350 固件库开发指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-17T16:00:00.000Z">2024-03-18</time></p><p class="title"><a href="/Project/UINIO-MCU-GD32/">兆易创新 UINIO-MCU-GD32F350 固件库开发指南</a></p><p class="categories"><a href="/categories/Project/">Project</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Analog-Circuit/"><span class="tag">Analog Circuit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Calculus/"><span class="tag">Calculus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Circuit-Analysis/"><span class="tag">Circuit Analysis</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Circuit-Theory/"><span class="tag">Circuit Theory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Command/"><span class="tag">Command</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Component/"><span class="tag">Component</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Config/"><span class="tag">Config</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Convention/"><span class="tag">Convention</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Digital-Circuit/"><span class="tag">Digital Circuit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Economy/"><span class="tag">Economy</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Elementary/"><span class="tag">Elementary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Encrypt/"><span class="tag">Encrypt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Grammar/"><span class="tag">Grammar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Industry/"><span class="tag">Industry</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Instrument/"><span class="tag">Instrument</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Life/"><span class="tag">Life</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mobile/"><span class="tag">Mobile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/New-Concept-English/"><span class="tag">New Concept English</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protocol/"><span class="tag">Protocol</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RFID/"><span class="tag">RFID</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Server/"><span class="tag">Server</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Simulation/"><span class="tag">Simulation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zen/"><span class="tag">Zen</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%B1%A0/"><span class="tag">电池</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2024 <span>UinIO.com</span> by Hank</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>