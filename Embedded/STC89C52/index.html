<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>宏晶 STC89C52RC 微控制器实践小书 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="伴随 NB-IOT、LoRa、5G 等无线物联网通信技术的快速成熟，已经诞生近四十余年的 8051 系列微处理，在功耗、性能、开发难易程度方面，已然全面落后于 ARM Cortex-M3 等主流嵌入式微控制器方案。但是由于其技术架构较为经典，寄存器配置相对简洁，在一些低成本场景中依然有所沿用。笔者当前使用的开发板基于宏晶STC89C52RC嵌入式微控制器方案，虽然购置于六年以前，但是依然集成"><meta property="og:type" content="blog"><meta property="og:title" content="宏晶 STC89C52RC 微控制器实践小书"><meta property="og:url" content="http://www.uinio.com/Embedded/STC89C52/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="伴随 NB-IOT、LoRa、5G 等无线物联网通信技术的快速成熟，已经诞生近四十余年的 8051 系列微处理，在功耗、性能、开发难易程度方面，已然全面落后于 ARM Cortex-M3 等主流嵌入式微控制器方案。但是由于其技术架构较为经典，寄存器配置相对简洁，在一些低成本场景中依然有所沿用。笔者当前使用的开发板基于宏晶STC89C52RC嵌入式微控制器方案，虽然购置于六年以前，但是依然集成"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2013-06-18T16:00:00.000Z"><meta property="article:modified_time" content="2014-12-20T16:00:00.000Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Embedded/STC89C52/"},"headline":"宏晶 STC89C52RC 微控制器实践小书","image":["http://www.uinio.com/Embedded/STC89C52/logo.png"],"datePublished":"2013-06-18T16:00:00.000Z","dateModified":"2014-12-20T16:00:00.000Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"伴随 NB-IOT、LoRa、5G\r 等无线物联网通信技术的快速成熟，已经诞生近四十余年的 8051\r 系列微处理，在功耗、性能、开发难易程度方面，已然全面落后于 ARM Cortex-M3\r 等主流嵌入式微控制器方案。但是由于其技术架构较为经典，寄存器配置相对简洁，在一些低成本场景中依然有所沿用。笔者当前使用的开发板基于宏晶STC89C52RC嵌入式微控制器方案，虽然购置于六年以前，但是依然集成"}</script><link rel="canonical" href="http://www.uinio.com/Embedded/STC89C52/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2013-06-18T16:00:00.000Z" title="2013/6/19 00:00:00">2013-06-19</time>发表</span><span class="level-item"><time dateTime="2014-12-20T16:00:00.000Z" title="2014/12/21 00:00:00">2014-12-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/">嵌入式固件</a></span><span class="level-item">9 小时读完 (大约84459个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">宏晶 STC89C52RC 微控制器实践小书</h1><div class="content"><p>伴随 NB-IOT、LoRa、5G
等无线物联网通信技术的快速成熟，已经诞生近四十余年的 8051
系列微处理，在功耗、性能、开发难易程度方面，已然全面落后于 ARM Cortex-M3
等主流嵌入式微控制器方案。但是由于其技术架构较为经典，寄存器配置相对简洁，在一些低成本场景中依然有所沿用。笔者当前使用的开发板基于宏晶<strong>STC89C52RC</strong>嵌入式微控制器方案，虽然购置于六年以前，但是依然集成有各类常用的
UART、I²C、SPI 总线模块。</p>
<p><img src="/Embedded/STC89C52/logo.png"></p>
<p>笔者日常开发工作当中，经常需要使用到此类嵌入式总线通信协议，因此参考了官方文档以及相关技术资料，逐步将本文涉及的各类模块驱动移植至当前开发板，便于用作与其它嵌入式设备联调测试之用。近几年，意法半导体的<strong>STM32F103C8T6</strong>量产价格不断下探，已经逐步接近宏晶的<strong>STC8051</strong>系列产品，可以预见后者将会逐渐面临市场淘汰，作为一款极为经典的
8 位微控制器，用作测试和实验目的依然是不错的选择。</p>
<span id="more"></span>
<h1 id="stc89c52rc-简介">STC89C52RC 简介</h1>
<p><strong>STC89C52RC</strong>工作电压在<code>5.5V ~ 3.4V</code>之间，属于<code>5V</code>单片机（工作电压范围在<code>2.7V ~ 3.6V</code>的称为<code>3.3V</code>单片机）。<strong>STC89C52RC</strong>提供给开发者使用的片上存储空间主要划分为以下三类：</p>
<p><strong>SFR</strong>（<em>特殊功能寄存器，Special Function
Register</em>）：特殊功能寄存器，用于配置单片机内部的各种功能。
<strong>RAM</strong>（<em>随机存取存储器，Random Access
Memory</em>）：数据存储空间，用于存储程序运行过程中产生和需要的数据，读写速度较快断电后丢失。
<strong>Flash</strong>（<em>闪存，Flash
Memory</em>）：程序存储空间，用于存储单片机需要运行的程序，可重复擦写且断电后不丢失。</p>
<p><strong>STC89C52RC</strong>单片机最小系统由<strong>电源</strong>、<strong>晶振</strong>、<strong>复位</strong>电路三个要素构成，参考如下电路图所示：</p>
<p><img src="/Embedded/STC89C52/Base/minimum.png"></p>
<blockquote>
<p>电路图当中，连线上放置的字符称为网络标号，相同名称的网络标号表示此处相互连接。</p>
</blockquote>
<h2 id="电源">电源</h2>
<p>目前主流单片机的电源主要分为<code>5V</code>和<code>3.3V</code>两个标准，<strong>STC89C52RC</strong>属于<code>5V</code>单片机，当前电路使用计算机
USB
接口输出的<code>5V</code>直流进行供电，供电电路分别连接至单片机的<code>40脚</code>（<strong>VCC</strong>，接<code>+5V</code>代表电源正极）与<code>20脚</code>（<strong>GND</strong>，接地代表电源负极）。</p>
<h2 id="晶振">晶振</h2>
<p>晶振的全称叫做晶体振荡器，作用是为单片机系统提供基准时钟信号，<strong>STC89C52RC</strong>内部所有工作都以该信号作为基准步调。<strong>STC89C52RC</strong>的<code>18脚</code>和<code>19脚</code>是外接晶振引脚，这里使用了频率为<code>11.0592MHz</code>的晶振（每秒振荡<code>11059200</code>次），并且外加两个<code>20pF</code>电容协助晶振起振以及维持振荡信号稳定。晶振通常可分为无源晶振和有源晶振两种类型，<strong>有源晶振</strong>是一套利用石英晶体压电效应起振的完整谐振振荡器，供电后即可产生高精度的振荡频率。<strong>无源晶振</strong>需要芯片内置的振荡电路协同工作才能产生振荡信号，两侧通常还需放置两枚<code>10pF~40pF</code>电容（<em>通常选取典型值<code>20pF</code></em>）。</p>
<p><img src="/Embedded/STC89C52/Base/crystal-oscillator.png"></p>
<p>上图是<a target="_blank" rel="noopener" href="http://www.yxc.hk/">深圳扬兴科技</a>生产的<strong>YXC</strong>品牌晶振，最左侧的是一个无源晶振，拥有
<code>VCC</code>、<code>GND</code>、<code>信号输出</code>、<code>悬空/使能</code>
4
个引脚，使用时只需要将<code>信号输出</code>引脚连接到单片机的晶振信号输入引脚<code>XTAL1</code>即可。右侧的三个都是无源晶振，通常拥有
2
个不区分正负极性的引脚，使用时分别连接到单片机的<code>XTAL1</code>和<code>XTAL2</code>两个晶振信号引脚上面。</p>
<p><img src="/Embedded/STC89C52/Base/crystal-oscillator-method.png"></p>
<blockquote>
<p>注意：无源晶振有时也存在 3
个引脚的情况，其中间引脚连接晶振外壳后接入<code>GND</code>。</p>
</blockquote>
<h2 id="复位电路">复位电路</h2>
<p>左侧复位电路连接至单片机的<code>9脚</code>，即<strong>RST</strong>（Reset）复位引脚。单片机复位通常可分为上电复位（每次上电都从一固定的相同的状态开始工作）、手动复位（通过复位按键让程序重新初始化运行）、程序自动复位（程序失去响应时看门狗自动重启并复位单片机）三种情况。</p>
<p><img src="/Embedded/STC89C52/Base/reset.png"></p>
<p>当上面这个复位电路处于稳定工作状态时，电容<strong>C11</strong>起到了隔离<code>5V</code>直流的作用，由于左侧复位按键处于弹起状态，下半部分电路接地后电压为<code>0V</code>，<strong>STC89C52RC</strong>单片机属于<strong>高电平复位，低电平正常工作</strong>，因而此时单片机就处于正常工作状态。接下来的内容，重点讨论一下<strong>上电复位</strong>和<strong>手动复位</strong>。</p>
<p><strong>上电复位</strong>发生在上电一瞬间：电容<strong>C11</strong>上方电路电压为<code>5V</code>下方电路电压为<code>0V</code>，伴随电容逐步开始充电，所有电压都加在电阻<strong>R31</strong>上面，此时<strong>RST</strong>端口位置的电压为<code>5V</code>。伴随电容充电量逐步增多，电流将会越来越小，此时由于<strong>RST</strong>端口上的电压等于电流乘以<strong>R31</strong>的阻值，所以电压将会越来越小，直至电容完全充满之后，<strong>RST</strong>端口与<strong>GND</strong>电位相同，两端电压差为<code>0V</code>所以不再产生电流。换而言之，单片机上电之后，<strong>RST</strong>引脚会先保持一小段时间（<em>不少于<code>2</code>个机器周期时间</em>）高电平然后变为低电平，也就是经历了一个完整的上电复位过程。</p>
<blockquote>
<p>每种单片机的复位电压各不相同，<strong>STC89C52RC</strong>通常按照<code>0.7 × VCC</code>
作为复位电压值，而复位时间的计算过程较为复杂，这里只需要记住一个结论：<code>t = 1.2 × R × C</code>，其中<strong>R</strong>是<code>4700</code>欧，<strong>C</strong>是<code>0.0000001</code>法，那么<code>t</code>的值是为<code>0.000564</code>秒，即<code>564us</code>左右，远大于
2 个机器周期约<code>2us</code>的时间。</p>
</blockquote>
<p><strong>按键手动复位</strong>需要经历 2
个过程：微动开关按下之前，<strong>RST</strong>电压为<code>0V</code>，开关按下之后电路导通，电容会在瞬间放电，<strong>RST</strong>电压值变化为<code>4700 × VCC/(4700 + 18)</code>，此时处于高电平复位状态。开关松开之后经历的过程与上电复位类似，即首先电容充电，然后电流逐渐减小直至<strong>RST</strong>端电压变为<code>0V</code>。按下微动开关的时间通常都会维持几百毫秒，完全满足复位的时间要求。</p>
<blockquote>
<p>按下微动开关的一瞬间，电容<strong>C11</strong>两端的<code>5V</code>电压会瞬间遭受较大电流的冲击，并引起局部范围内的电磁干扰。因此，为了抑制大电流引发的干扰，电路图当中串联了一个<code>18Ω</code>欧电阻<strong>R60</strong>进行限流。</p>
</blockquote>
<h1 id="配置-keil-uvision-5">配置 Keil uVision 5</h1>
<p>在进行接下来的工作之前，需要对<strong>Keil
uVision</strong>进行一些初始化配置。首先，右键选中【Options for
Target】打开目标设置，然后打开【Target】选项卡设置当前使用的<strong>Xtal</strong>晶振频率为板载的<code>11.0592MHz</code>。</p>
<p><img src="/Embedded/STC89C52/Base/target.png"></p>
<p>然后，勾选【Output】选项卡当中的<code>Create HEX File</code>生成可供
ISP 工具烧写的十六进制文件。</p>
<p><img src="/Embedded/STC89C52/Base/output.png"></p>
<p>最后，确保【debug】选项卡下的<code>Use Simulator</code>处于默认的选中状态。</p>
<p><img src="/Embedded/STC89C52/Base/debug.png"></p>
<h1 id="发光二极管-led">发光二极管 LED</h1>
<h2 id="电源开关指示-led">电源/开关指示 LED</h2>
<p>开发板使用的是是普通贴片发光二极管，正向导通电压在<code>1.8V ~ 2.2V</code>之间，工作电流在<code>1mA ~ 20mA</code>
之间，导通电流越大 LED 亮度越高，如果超过限定电流则有可能烧坏元件。</p>
<p><img src="/Embedded/STC89C52/LED/usb.png"></p>
<p>开发板上的<strong>USB
接口电路</strong>可同时用于供电、程序下载、串口通信，USB
插座<strong>USB-B</strong>一共拥 6
个引脚，其中<code>2脚</code>与<code>3脚</code>是数据通信引脚，<code>1脚</code>和<code>4脚</code>是电源引脚，<code>5脚</code>和<code>6脚</code>通过
USB
外壳连接到<strong>GND</strong>上。注意<code>1脚</code>的<strong>VCC</strong>和<code>4脚</code>的<strong>GND</strong>，其中<code>1脚</code>通过<strong>F1
自恢复保险丝</strong>连接至右侧电路，正常工作时保险丝可以视为导线，但当后级电路发生短路故障时，保险丝会自动切断电路，故障恢复以后再重新恢复导通。</p>
<p>电路图右侧的两条支路，第一条在<strong>VCC</strong>与<strong>GND</strong>之间连接了一个<code>470uF</code>的<strong>C16</strong>电容，由于电容是隔离直流的，所以这条支路上没有电流通过，此处电容起到的仅是缓冲电源电流避免上电瞬间电流过大的作用。第二条支路串联了一颗用作电源指示灯的发光二极管<strong>LED1</strong>以及一枚电阻<strong>R34</strong>，注意发光二极管与普通二极管一样使用时需要区分正负极。由于<strong>VCC</strong>电压是<code>5V</code>，发光二极管自身压降约<code>2V</code>，那么<strong>R34</strong>电阻承受的电压为<code>5V - 2V = 3V</code>；现在已知
LED
正常点亮的电流范围是<code>1~20mA</code>，那根据欧姆定律<code>电阻R = 电压U / 电流I</code>，电阻<strong>R34</strong>取值的下限为<code>3V / 0.02A = 150Ω</code>，上限在<code>3V / 0.001A = 3000Ω</code>；由于这枚电阻能够限制整条通路上的电流大小，因此通常被称作<strong>限流电阻</strong>。</p>
<p><img src="/Embedded/STC89C52/LED/switch.png"></p>
<p>同样的原理，在上面电路后级的<strong>电源开关电路</strong>当中，还有一颗标号为<strong>LED10</strong>的发光二极管用作开关指示灯。注意上面电路图中的开关是两路的，并联的两路开关可以有效确保后级电路供电的稳定性。开关<strong>Power</strong>后级还并接了一个<code>100uF</code>的<strong>C19</strong>电容以及一个<code>0.1uF</code>的<strong>C10</strong>电容，电容<strong>C19</strong>主要用于稳定后级电路电流电压，避免某个元件突然工作时造成的瞬时电流电压的下降；而容值较小的<code>0.1uF</code>电容<strong>C10</strong>，主要用于滤除高频信号干扰，该电容的取值是结合干扰频率、电容参数得到的一个经验值，数字电路设计时，电源位置的<strong>高频去耦电容</strong>可以直接选取<code>0.1uF</code>容值。</p>
<blockquote>
<p>注意：电路中大功率元件附近都可以放置一个较大容值的电容，从而起到稳定电流电压的作用。此外，所有<strong>IC</strong>元件的<strong>VCC</strong>与<strong>GND</strong>之间，都会放置一个<code>0.1uF</code>的高频去耦电容，特别是在
PCB Layout
的时候，该电容在位置上要尽可能靠近<strong>IC</strong>元件。</p>
</blockquote>
<h2 id="数字电路中三极管的应用">数字电路中三极管的应用</h2>
<p>三极管拥有<strong>饱和</strong>、<strong>截止</strong>、<strong>放大</strong>
3
种工作状态，其中<strong>放大状态</strong>主要用于模拟电路，用法较为复杂。数字电路主要使用到三极管的开关特性，即<strong>饱和状态</strong>与<strong>截止状态</strong>。电路图中箭头朝内的是<strong>PNP</strong>三极管，箭头朝外的是<strong>NPN</strong>三极管。三极管拥有<strong>基极</strong>(<strong>B</strong>ase)、<strong>发射极</strong>（<strong>E</strong>mitter）、<strong>集电极</strong>(<strong>C</strong>ollector)三个引脚，下图横向左侧的是<strong>基极</strong>，元件图中间的箭头一头连接基极另外一头连接的是<strong>发射极</strong>，最顶部的那个引脚是<strong>集电极</strong>。</p>
<p><img src="/Embedded/STC89C52/LED/transistor.png"></p>
<p>三极管使用的关键在于<code>基极B</code>和<code>发射极E</code>之间的电压情况，对于
PNP
型三极管，<code>发射极E</code>端电压高于<code>基极B</code>端电压<code>0.7V</code>以上，<code>发射极E</code>与<code>集电极C</code>之间就可以导通，即控制端在<code>基极B</code>和<code>发射极E</code>之间，被控制端在<code>发射极E</code>和<code>集电极C</code>之间。同样的道理，对于
NPN
型三极管，<code>基极B</code>端比<code>发射极E</code>端高<code>0.7V</code>以上，就可以导通<code>发射极E</code>与<code>集电极C</code>。</p>
<p><img src="/Embedded/STC89C52/LED/transistor-demo.png"></p>
<p>首先来介绍一下三极管的<strong>电压导通</strong>用法：上面的样例电路图当中，通过单片机引脚与三极管的配合来控制一个
LED
亮灭。三极管<strong>Q16</strong>的基极通过<code>10KΩ</code>电阻<strong>R47</strong>连接至单片机
IO
引脚，<code>发射极E</code>连接至<code>5V</code>电源，<code>集电极C</code>串接了一枚发光二极管<strong>LED2</strong>以及一颗<code>1KΩ</code>的限流电阻<strong>R41</strong>，并最终连接到电源负极<strong>GND</strong>。如果单片机
IO
接口输出高电平<code>1</code>，三极管<strong>Q16</strong>的<code>基极B</code>和<code>发射极E</code>都是<code>5V</code>，此时不会产生任何压降，<code>发射极E</code>和<code>集电极C</code>之间不会导通，发光二极管<strong>LED2</strong>也就无法点亮。当单片机
IO
接口输出低电平<code>0</code>，由于此时<code>发射极E</code>依然是<code>5V</code>，<code>集电极B</code>与<code>发射极E</code>之间产生压差，<code>发射极E</code>与<code>集电极C</code>被导通。</p>
<p>三极管<code>集电极B</code>与<code>发射极E</code>之间，其自身会产生<code>0.7V</code>左右压降，此时电阻<strong>R47</strong>上承受的电压为<code>5V - 0.7V = 4.3V</code>。三极管<code>发射极E</code>与<code>集电极C</code>之间，其自带的<code>0.2V</code>压降可以忽略不计，而后面的发光二极管<strong>LED2</strong>自身带有<code>2V</code>压降，此时限流电阻<strong>R41</strong>上的压降应为<code>5V - 2V = 3V</code>，根据欧姆定理可以推算出该条支路的电流约为<code>3V/1000Ω = 0.003A = 3mA</code>，可以满足<strong>LED2</strong>的工作电流并且正常点亮。</p>
<p>然后再介绍一下三极管的<strong>电流控制</strong>用法：三极管有<strong>截止</strong>、<strong>放大</strong>、<strong>饱和</strong>三种状态，其中截止是指<code>集电极B</code>与<code>发射极E</code>之间不导通，这里暂不作讨论；而要让三极管处于饱和状态必须要满足一个条件：<code>集电极B</code>的电流必须大于<code>发射极E</code>与<code>集电极C</code>之间的电流值除以三极管放大倍数<code>β</code>，常用三极管放大倍数约为<code>100</code>，接下来计算一下<strong>R47</strong>的阻值。</p>
<p><code>发射极E</code>与<code>集电极C</code>之间的电流为<code>3mA</code>，那么<code>基极B</code>的电流最小就是<code>3mA / 100 = 30uA</code>。由于基极电阻承受的电压为<code>4.3V</code>，那么基极电阻最大取值应为<code>4.3V / 30uA ≈ 143kΩ</code>，电阻取值只需要比这个值更小即可，但是也不能太小，否则电流通过电流过大会烧坏单片机或三极管。<strong>STC89C52RC</strong>的
IO
引脚的理论最大输入电流在<code>25mA</code>左右，但是实际推荐最好不要超过<code>6mA</code>，那么基极的<strong>R47</strong>电阻取值必须大于<code>4.3V / 6mA ≈ 717Ω</code>，即<strong>R47</strong>的阻值应该介于<code>717Ω</code>与<code>14.3kΩ</code>之间，上面电路图中实际选取的阻值为<code>10KΩ</code>。</p>
<p>综上所述，数字电路当中，三极管开关特性主要在于控制应用和驱动应用两个方面：</p>
<ul>
<li><strong>控制应用</strong>：通过单片机控制三极管<code>基极B</code>，从而间接控制<code>发射极E</code>与<code>集电极C</code>的导通状态，并进一步控制更高工作电压的外围元器件。</li>
<li><strong>驱动应用</strong>：单片机 IO
接口的电流输出能力通常在微安<code>uA</code>级别，而利用三极管的电流放大作用，可以增强单片机
IO 接口的电流输出能力至毫安<code>mA</code>级别。</li>
</ul>
<h2 id="hc245-双向缓冲器">74HC245 双向缓冲器</h2>
<p>虽然通过单片机 IO 接口<strong>低电平</strong>可以直接点亮少量的
LED，但是当八个 LED
发光二极管同时并联的时候，总的驱动电流将会达到<code>8mA ~ 160mA</code>区间，而<strong>STC89C52RC</strong>的输入电流不建议超过<code>6mA</code>。如果这里通过限流电阻来解决问题，又有可能导致后级电路上连接的数码管供电不足，因此这种降低电流的方法并不可取。面对这种情况，我们可以考虑选用诸如<strong>74HC245</strong>（可以稳定工作于<code>70mA</code>左右电流）这样的驱动
IC 来作为单片机的电流缓冲器。</p>
<p><img src="/Embedded/STC89C52/LED/74HC245.png"></p>
<p>网络标号为<code>19</code>的<strong>OE</strong>是输出使能引脚，该引脚在电路图当中上标有上划线，表示低电平有效。而网络标号为<code>1</code>的<strong>DIR</strong>是方向引脚，当其为高电平<code>1</code>时，右侧标号<strong>B</strong>的引脚等于左侧标号<strong>A</strong>引脚上的电压；当其为低电平<code>0</code>时，左侧标号<strong>A</strong>的引脚等于右侧标号<strong>B</strong>引脚上的电压；</p>
<h2 id="hc138-三八译码器">74HC138 三八译码器</h2>
<p><strong>74HC138</strong>可以将 3 种输入状态转换为 8
种输出状态，该逻辑芯片左侧的<strong>E1</strong>、<strong>E2</strong>、<strong>E3</strong>是使能引脚，<strong>A0</strong>、<strong>A1</strong>、<strong>A2</strong>是输入引脚，<strong>Y0</strong>至<strong>Y7</strong>是输出引脚。当<strong>E1</strong>、<strong>E2</strong>、<strong>E3</strong>引脚的电平状态分别为<code>0</code>、<code>0</code>、<code>1</code>的时候，就可以通过<strong>A0</strong>、<strong>A1</strong>、<strong>A2</strong>的输入状态来控制<strong>Y0</strong>至<strong>Y7</strong>的电平输出状态。</p>
<p><img src="/Embedded/STC89C52/LED/74HC138.png"></p>
<blockquote>
<p>注意观察上图的真值表，任意的输出引脚都只有一位是低电平<code>0</code>，而其它的七位都是高电平<code>1</code>。</p>
</blockquote>
<h2 id="led-闪烁实验">LED 闪烁实验</h2>
<p>下面电路图当中，<strong>LED2</strong>至<strong>LED9</strong>八个 LED
发光二极管的总开关是三极管<strong>Q16</strong>的基极<strong>LEDS6</strong>，即<strong>74HC138</strong>三八译码器的<strong>Y6</strong>引脚，该引脚输出低电平<code>0</code>就可以导通<strong>Q16</strong>三极管的集电极和发射极，由此可以推导出<strong>74HC138</strong>的<strong>A2</strong>、<strong>A1</strong>、<strong>A0</strong>的输入状态应该为<code>110</code>。</p>
<p><img src="/Embedded/STC89C52/LED/diagram.png"></p>
<p>另外，<strong>74HC138</strong>三八译码器的<strong>E1</strong>和<strong>E2</strong>并联至单片机的<strong>P1.4</strong>引脚<strong>ENLED</strong>，而<strong>E3</strong>引脚则通过<strong>ADDR3</strong>连接到了单片机的<strong>P1.3</strong>引脚，因此当<code>P1.4 = ENLED = 0; P1.3 = ADDR3 = 1;</code>的时候，就可以使能<strong>74HC138</strong>。然后根据前面的分析，<code>P1^2 = ADDR2 = 1; P1^1 = ADDR1 = 1; P1^0 = ADDR0 = 0;</code>就能够保证三极管<strong>Q16</strong>顺利导通<code>5V</code>的电源。思路整理完毕，接下来开始编写让发光二极管<strong>LED2</strong>反复闪烁的程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P0 ^ <span class="number">0</span>; <span class="comment">// 通过 DB0 点亮 LED2</span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>; ADDR3 = <span class="number">1</span>;            <span class="comment">// 使能 74HC138 译码器</span></span><br><span class="line">  ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; <span class="comment">// 导通三极管 Q16 的集电极与发射极</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    LED = <span class="number">0</span>;                     <span class="comment">// 点亮 LED</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++); <span class="comment">// for 循环延时</span></span><br><span class="line">    LED = <span class="number">1</span>;                     <span class="comment">// 熄灭 LED</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++); <span class="comment">// for 循环延时</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="软件延时">软件延时</h2>
<p><strong>延时</strong>是单片机开发工作当中的常见操作，例如上一小节内容在
LED 点亮和熄灭状态之间加入了延时操作，从而能够让 LED
呈现出闪烁效果，<strong>STC89C52RC+</strong>单片机开发当中主要存在四种延时方式：</p>
<p><img src="/Embedded/STC89C52/LED/delay-mode.png"></p>
<p>上图中的非精确延时，虽然无法精确控制程序执行的间隔时间，但是可以通过<strong>Keil
uVision</strong>提供的【Debug】模式，在延时函数以及后一条语句各设置一个断点，然后将两条语句的执行时间相减，即可得到一个较为接近的延时时间值。</p>
<p><img src="/Embedded/STC89C52/LED/delay-calculate.png"></p>
<p>这里通过<code>while()</code>循环方式来编写一个非精确的延时函数<code>delay()</code>，将前一小节编写的
LED 代码进行修改，使用延时函数替换掉之前的<code>for()</code>循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 延时函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>; ADDR3 = <span class="number">1</span>; <span class="comment">// 使能 74HC138</span></span><br><span class="line">  ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; <span class="comment">// 导通三极管 Q16 的集电极与发射极</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    LED = <span class="number">0</span>;      <span class="comment">// 点亮 LED</span></span><br><span class="line">    delay(<span class="number">25000</span>); <span class="comment">// 调用延时函数</span></span><br><span class="line">    LED = <span class="number">1</span>;      <span class="comment">// 熄灭 LED</span></span><br><span class="line">    delay(<span class="number">25000</span>); <span class="comment">// 调用延时函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码放入<strong>Keil
uVision</strong>进行调试，执行至第一个<code>delay()</code>断点语句的时间为<code>0.00038900</code>秒，到后一条断点语句<code>P0 = 0xFF</code>所消耗的时间为<code>1.00044500 - 0.00038900 = 1.000056</code>秒，也就是说
LED 亮灭状态的切换会在延时<code>1</code>秒后执行，即 LED
每间隔<code>1</code>秒反复闪烁。</p>
<h2 id="led-流水灯实验">LED 流水灯实验</h2>
<p>完成 LED 闪烁实验之后，现在来进行一个 LED 流水灯试验，即将八个 LED
依次循环进行点亮，从而呈现出流水的效果。实验当中，需要通过<strong>P0</strong>的全部
8 个 IO 管脚来控制 8 枚 LED 的亮灭，此时就需要借助 C
语言提供的按位左右移运算符<code>&lt;&lt;</code>、<code>&gt;&gt;</code>，以及按位取反运算符<code>~</code>来进行相应的控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;    <span class="comment">// 定义循环变量，用于软件延时</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 定义移位计数变量，用于移位控制</span></span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">1</span>;</span><br><span class="line">  ADDR1 = <span class="number">1</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P0 = ~(<span class="number">0x01</span> &lt;&lt; cnt);         <span class="comment">// P0 等于 1 左移 cnt 位，控制 8 个LED</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++); <span class="comment">// 软件延时</span></span><br><span class="line">    cnt++;                       <span class="comment">// 移位计数变量自增 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;                   <span class="comment">// 移位计数变量超过 7，则重新从 0 开始计数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，基于上面的代码，再来完成一个左移完接着右移，右移完再左移的往复式流水灯程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;         <span class="comment">//定义循环变量，用于软件延时</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dir = <span class="number">0</span>;      <span class="comment">//定义移位方向变量，用于控制移位的方向</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> shift = <span class="number">0x01</span>; <span class="comment">//定义循环移位变量，并赋初值为 0x01</span></span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">1</span>;</span><br><span class="line">  ADDR1 = <span class="number">1</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P0 = ~shift;                  <span class="comment">// 循环移位变量取反，通过 P0 控制 8 枚LED</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++);  <span class="comment">// 软件延时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 左移，当移位方向变量等于 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">      shift = shift &lt;&lt; <span class="number">1</span>;   <span class="comment">//循环移位变量左移 1 位</span></span><br><span class="line">      <span class="keyword">if</span> (shift == <span class="number">0x80</span>) &#123;</span><br><span class="line">        dir = <span class="number">1</span>;            <span class="comment">//左移到最左端后，改变移位方向</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 右移，当移位方向变量不等于 0 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      shift = shift &gt;&gt; <span class="number">1</span>;   <span class="comment">//循环移位变量右移 1 位</span></span><br><span class="line">      <span class="keyword">if</span> (shift == <span class="number">0x01</span>) &#123;</span><br><span class="line">        dir = <span class="number">0</span>;            <span class="comment">//右移到最右端后，改变移位方向</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="静态数码管-定时器">静态数码管 &amp; 定时器</h1>
<h2 id="定时器概念">定时器概念</h2>
<p>前面小节的内容当中，我们通过<strong>Keil
uVision</strong>的【Debug】模式得到一个非精确的延时时间。而日常项目开发当中，通常会使用更为精确的<strong>STC89C52RC</strong>单片机内置定时/计数器功能，通过配置单片机特殊功能寄存器，能够分别实现<strong>定时</strong>和<strong>计数</strong>的功能，相对而言<strong>定时器</strong>功能更加常用。标准
51
架构单片机内部拥有<strong>T0</strong>和<strong>T1</strong>两个定时器，这里的<strong>T</strong>就是单词<strong>Timer</strong>的缩写。除此之外，<strong>STC89C52RC</strong>还扩展了一个额外的定时器<strong>T2</strong>。在开始着手进一步相关的试验之前，需要了解如下基本概念：</p>
<p><strong>时钟周期</strong>：时序的<strong>最小</strong>时间单位，其值为<span class="math inline">\(\frac{1}{晶振时钟频率}\)</span>，当前晶振频率为<code>11.0592MHz</code>，即开发板的时钟周期为<code>1/11059200</code>秒。
<strong>机器周期</strong>：完成一个基本汇编操作的执行时间，<span class="math inline">\(1个机器周期 =
12个时钟周期\)</span>，那么开发板的机器周期就是<code>12/11059200</code>秒。
<strong>指令周期</strong>：时序的<strong>最大</strong>时间单位，指取出汇编指令并分析执行的时间，<span class="math inline">\(指令周期 =
机器周期\)</span>，换算成小数约等于<code>0.0000011</code>秒。</p>
<p><strong>STC89C52RC</strong>单片机内部拥有 4
个<strong>定时值存储寄存器</strong>（用于<strong>T0</strong>的<strong>TH0/TL0</strong>，以及用于<strong>T1</strong>的<strong>TH1/TL1</strong>），当定时器开始计数后，定时值寄存器的值每经过一个机器周期时间（<code>12 / 11059200 ≈ 0.000001秒</code>）就累加<code>1</code>，在这里<strong>机器周期可以理解为定时器的计数周期</strong>。
对于 16
位定时器工作模式，<code>16 bit = 2 Byte</code>能够保存的最大十进制数值为<code>65535</code>，再加<code>1</code>定时器就会发生<strong>溢出</strong>，此时定时值存储寄存器将会归<code>0</code>。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">符号</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">地址</th>
<th style="text-align: left;">复位值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>TL0</strong></td>
<td style="text-align: left;">定时器** T0 低**位</td>
<td style="text-align: left;">8AH</td>
<td style="text-align: left;">0000 0000B</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TH0</strong></td>
<td style="text-align: left;">定时器** T0 高**位</td>
<td style="text-align: left;">8BH</td>
<td style="text-align: left;">0000 0000B</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TL1</strong></td>
<td style="text-align: left;">定时器** T1 低**位</td>
<td style="text-align: left;">8CH</td>
<td style="text-align: left;">0000 0000B</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TH1</strong></td>
<td style="text-align: left;">定时器** T1 高**位</td>
<td style="text-align: left;">8DH</td>
<td style="text-align: left;">0000 0000B</td>
</tr>
</tbody>
</table>
<p>另一个与定时器工作相关的寄存器是<strong>定时器控制寄存器
TCON</strong>，该寄存器<strong>可以进行位寻址</strong>，下表当中的<code>IE0</code>、<code>IT0</code>、<code>IE1</code>、<code>IT1</code>位与外部中断功能相关，本小节只需重点了解<code>TF0</code>、<code>TR0</code>、<code>TF1</code>、<code>TR1</code>四个位。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">定时器控制寄存器</th>
<th style="text-align: left;">B7</th>
<th style="text-align: left;">B6</th>
<th style="text-align: left;">B5</th>
<th style="text-align: left;">B4</th>
<th style="text-align: left;">B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>TCON</strong></td>
<td style="text-align: left;">TF1</td>
<td style="text-align: left;">TR1</td>
<td style="text-align: left;">TF0</td>
<td style="text-align: left;">TR0</td>
<td style="text-align: left;">IE1</td>
<td>IT1</td>
<td>IE0</td>
<td>IT0</td>
</tr>
<tr>
<td style="text-align: left;"><strong>复位值</strong></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>TF1</strong>：定时器** T1
溢出标志位<strong>，当</strong>定时器
T1**发生溢出时由硬件置<code>1</code>，或者通过软件清零或者进入定时器中断时由硬件清零。</li>
<li><strong>TR1</strong>：定时器** T1
运行控制位**，通过软件置位/清零来启动/停止寄存器。</li>
<li><strong>TF0</strong>：定时器** T0
溢出标志位<strong>，当</strong>定时器
T0**发生溢出时由硬件置<code>1</code>，或者通过软件清零或者进入定时器中断时由硬件清零。</li>
<li><strong>TR0</strong>：定时器** T0
运行控制位**，通过软件置位/清零来启动/停止寄存器。</li>
</ul>
<p>当定时器运行控制位<code>TR1 = 1</code>的时候，定时器值每经过一个机器周期就自动累加<code>1</code>；当<code>TR1 = 0</code>的时候，定时器就会停止加<code>1</code>保持不变。当定时器设置为
16
位工作模式时，每经过一个机器周期<strong>TL1</strong>就自增<code>1</code>次，当定时值存储寄存器的低位<code>TL1</code>累加至<code>2⁸ = 255</code>次以后，再加<code>1</code>变为<code>0</code>。此时定时值存储寄存器高位<code>TH1</code>会累加<code>1</code>次，如此周而复始直至<code>TH1</code>和<code>TL1</code>累加至<code>255</code>次，这里<code>TL1</code>和<code>TH1</code>组成的十进制整数是<code>65535</code>。此时如果定时值再增加<code>1</code>次就会发生溢出，<code>TL1</code>和<code>TH1</code>同时自动清零<code>0</code>，与此同时定时器溢出标志位<code>TF1</code>被自动置<code>1</code>，标识定时器发生了溢出。</p>
<p>前面提到的定时器<code>T0</code>、<code>T1</code>的工作模式，则是由<strong>定时器模式寄存器
TMOD</strong>进行控制，需要注意该寄存器<strong>不可位寻址</strong>。</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">定时器工作模式寄存器</th>
<th style="text-align: left;">定时器 T1</th>
<th style="text-align: left;">定时器 T1</th>
<th style="text-align: left;">定时器 T1</th>
<th style="text-align: left;">定时器 T1</th>
<th style="text-align: left;">定时器 T0</th>
<th>定时器 T0</th>
<th>定时器 T0</th>
<th>定时器 T0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">序号</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TMOD</strong></td>
<td style="text-align: left;">GATE</td>
<td style="text-align: left;">C/T</td>
<td style="text-align: left;">M1</td>
<td style="text-align: left;">M0</td>
<td style="text-align: left;">GATE</td>
<td>C/T</td>
<td>M1</td>
<td>M0</td>
</tr>
<tr>
<td style="text-align: left;"><strong>复位值</strong></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>GATE</strong>：置<code>1</code>时为门控位，仅当<code>INTx</code>引脚为高电平且<code>TRx</code>控制位被置<code>1</code>时使能相应定时器开始计时。当该位被清<code>0</code>的时候，只需<code>TRx</code>位置<code>1</code>，相应的定时器就使能开始计时，并不受<code>INTx</code>引脚外部信号的干扰。该功能常用来测量外部信号脉冲宽度，本节内容暂不做介绍。</li>
<li><strong>C/T</strong>：<u>定时器/计数器功能选择位</u>，该位为<code>0</code>时作为定时器（<em>内部系统时钟</em>），该位为<code>1</code>时作为计数器（<em>外部脉冲计数</em>）。</li>
<li><strong>M1/M0</strong>：<u>工作模式选择位</u>，可以有如下选项：
<ul>
<li><strong>模式 0</strong>（<code>0</code> <code>0</code>）：<u>13
位定时器</u>，由<code>THn</code>的 8 位和<code>TLn</code>的 5 位组成一个
13 位定时器，用于兼容 8048 单片机的 13 位定时器。</li>
<li><strong>模式 1</strong>（<code>0</code> <code>1</code>）：<u>16
位定时器</u>，由<code>THn</code>和<code>TLn</code>组成一个 16
位定时器，计数范围位于<code>0 ~ 65535</code>，溢出后如果不对<code>THn</code>和<code>TLn</code>重新赋值，则从<code>0</code>开始计数。</li>
<li><strong>模式 2</strong>（<code>1</code> <code>0</code>）：<u>8
位自动重装模式</u>，<code>TLn</code>参予累加计数，计数范围位于<code>0 ~ 255</code>，发生溢出时会将<code>THn</code>的值自动重装至<code>TLn</code>，主要用于产生串口波特率。</li>
<li><strong>模式 3</strong>（<code>1</code> <code>1</code>）：<u>定时器
T1 无效</u>，即停止计数。<u>定时器 T0 双 8
位定时器</u>，<code>TL0</code>作为一个 8 位定时器由 T0
的控制位进行控制，<code>TH0</code>作为另一个 8 位定时器由 T1
的控制位进行控制。</li>
</ul></li>
</ul>
<blockquote>
<p><strong>注意</strong>：单片机的<strong>寄存器可位寻址</strong>表示程序能够直接对寄存器的每个位进行操作，而<strong>不可位寻址</strong>表示程序只能对寄存器整个字节进行操作。</p>
</blockquote>
<p>上面列表中的【模式
0】是出于兼容性而设计，日常开发基本不会使用到。【模式
3】的功能可以被【模式 2】取代，因此全文内容将会重点介绍【模式
1】与【模式 2】的使用。下面的流程图展示了定时器 T0 在【模式
1】下的配置过程，图中的<code>SYSclk</code>表示的是系统时钟频率：</p>
<p><img src="/Embedded/STC89C52/Tube/flow.png"></p>
<ol type="1">
<li><code>TR0</code>与其下方的<strong>或门电路</strong>进行<strong>与</strong>运算，因此如果要让定时器工作，<code>TR0</code>必须置<code>1</code>；与此同时，下方的<strong>或门</strong>也必须为<code>1</code>。</li>
<li>当<code>GATE</code>位等于<code>1</code>时，经过<strong>非门</strong>变成<code>0</code>。<strong>或门</strong>电路结果想要为<code>1</code>，则<code>INT0</code>必须为<code>1</code>定时器才会工作，如果<code>INT0</code>等于<code>0</code>则定时器不工作。</li>
<li>当<code>GATE</code>位等于<code>0</code>时，经过一个<strong>非门</strong>变为<code>1</code>，此时无论<code>INT0</code>引脚处于何种电平状态，经过<strong>或门</strong>电路以后都肯定为<code>1</code>，定时器就会正常工作。</li>
<li>当开关处于<code>C/T = 0</code>状态时候，一个机器周期就会累加一次，此时处于定时器功能。</li>
<li>当开关处于<code>C/T = 1</code>状态时候，T0
引脚接收到一个脉冲就会累加一次，此时处于计数器功能。</li>
</ol>
<blockquote>
<p><strong>STC89C52RC</strong>系列单片机的定时器有两种计数速率：一种是<strong>12T
模式</strong>，即每<code>12</code>个时钟周期累加<code>1</code>，兼容传统
8051 架构。另外一种是<strong>6T
模式</strong>，即每<code>6</code>个时钟周期累加<code>1</code>，速度是传统单片机的
2 倍；具体方式可以在 STC-ISP 编程器中进行设置。</p>
</blockquote>
<h2 id="定时器应用">定时器应用</h2>
<p><strong>STC89C52RC</strong>单片机的<strong>定时器/计数器 T0 与
T1</strong>的使用步骤大致可以总结如下：</p>
<ul>
<li>【第 1
步】：设置定时器工作模式寄存器<code>TMOD</code>，选择<strong>定时</strong>（计数脉冲由系统时钟输入）还是<strong>计数</strong>（计数脉冲从<code>T0/P3.4</code>引脚输入），以及选择定时值存储寄存器的工作模式。</li>
<li>【第 2
步】：设置定时值存储寄存器低位<code>TLn</code>与高位<code>THn</code>的初值。</li>
<li>【第 3
步】：设置定时器控制寄存器<code>TCON</code>，将其<code>TRn</code>位置<code>1</code>使定时器开始计数。</li>
<li>【第 4
步】：判断<code>TCON</code>里的<code>TFn</code>位，监听定时器溢出。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：上面列表中<code>TFn</code>、<code>TRn</code>、<code>TLn</code>、<code>THn</code>里<code>n</code>的取值可以是<code>0</code>（代表<strong>定时器
0</strong>）或<code>1</code>（代表<strong>定时器 1</strong>）。</p>
</blockquote>
<p>如前所述，已知当前单片机晶振电路的机器周期为<code>0.000001</code>秒，如果需要精确的定时<code>1ms</code>毫秒，那么就需要经历<span class="math inline">\(\frac{0.001}{0.000001}=1000\)</span>个机器周期。已知<strong>16
位模式</strong>定时器的溢出值为<code>2^&#123;16&#125; = 65536</code>，如果赋予<code>TLn</code>与<code>THn</code>一个初始值，使其经过<code>1000</code>个机器周期之后刚好达到<code>65536</code>溢出（通过检查<code>TFn</code>获得），这里只需要进行一个简单的减法运算即可得知该初始值为<span class="math inline">\(65536 - 1000 =
64536\)</span>，转换为十六进制数值就是<code>0xFC18</code>，那么<code>THn</code>的值为<code>0xFC</code>，<code>TLn</code>的值为<code>0x18</code>。这里将之前使用<code>while</code>非精确延时函数的例子，修改为使用片内定时/计数器的精确延时：</p>
<p>如前所述，当前电路使用的晶振是<code>11.0592MHz</code>，因此时钟周期等于<code>1 / 11059200</code>，机器周期等于<code>12/11059200</code>。如果定时<code>20ms</code>毫秒即<code>0.02s</code>秒，假设需要经过<code>X</code>个机器周期，那么根据<code>X × (12 / 11059200) = 0.02</code>从而得到<code>X = 18432</code>。由于
16
位定时器的溢出值是<code>65536</code>（<em><code>65535</code>需要加<code>1</code>才会溢出</em>），那么可以先为<code>TH0</code>与<code>TL0</code>赋一个初值，让其经过<code>18432</code>个机器周期后达到<code>65536</code>溢出，此时可以通过检测<code>TF0</code>的值来判断溢出状态。这个<code>TH0</code>与<code>TL0</code>的初值应为<code>65536 - 18432 = 47104 = 0xB800</code>，即<code>TH0 = 0xB8</code>、<code>TL0 = 0x00</code>，溢出<code>50</code>次就可以定时<code>1s</code>秒钟，接下来，编写一份关于定时器的代码，让
LED 点亮一秒然后熄灭一秒，不断进行闪烁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>;                      <span class="comment">// 溢出次数计数变量，用于记录定时器 T0 的溢出次数</span></span><br><span class="line">  ENLED = <span class="number">0</span>;                                  <span class="comment">// 使能网络标号为 U3 的 74HC138</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>; ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; <span class="comment">// 选择需要控制的 LED</span></span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>;            <span class="comment">// 设置 T0 为工作模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xB8</span>; TL0 = <span class="number">0x00</span>; <span class="comment">// 定时值存储寄存器赋初值 0xB800</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                <span class="comment">// 启动定时器 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断 T0 是否溢出*/</span></span><br><span class="line">    <span class="keyword">if</span> (TF0 == <span class="number">1</span>) &#123;</span><br><span class="line">      TF0 = <span class="number">0</span>;                <span class="comment">// T0 溢出后，清零中断标志</span></span><br><span class="line">      TH0 = <span class="number">0xB8</span>; TL0 = <span class="number">0x00</span>; <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">      cnt++;                  <span class="comment">// 计数值自加 1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断 T0 溢出是否达到50次 */</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;    <span class="comment">// 清零计数值</span></span><br><span class="line">        LED = ~LED; <span class="comment">// LED状态取反</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态数码管显示">静态数码管显示</h2>
<p>数码管是单片机开发当中的常用显示器件，每个数码管都拥有<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、<code>f</code>、<code>g</code>、<code>dp</code>八个
LED 段，下面是数码管的内部结构示意图：</p>
<p><img src="/Embedded/STC89C52/Tube/structure.png"></p>
<blockquote>
<p>由于并联电路电流之和等于总电流，数码管公共端的 2
个引脚可以起到分流的作用，从而降低单条支路所承受的电流。</p>
</blockquote>
<p>LED
数码管分为<strong>共阳</strong>和<strong>共阴</strong>两种，<strong>共阴数码管</strong>所有
LED 段的阴极连接在一起作为公共端，由阳极控制每个 LED
段的亮灭。<strong>共阳数码管</strong>所有 LED
段的阳极连接在一起作为公共端，由阴极控制每个 LED 段的亮灭。</p>
<p><img src="/Embedded/STC89C52/Tube/common-anode-cathode.png"></p>
<p>从下面电路图能够看出，电路当中使用了 6
个共阳数码管，每个数码管的公共端都连接至<code>5V</code>正极，其<strong>段选</strong>端（<em>控制某段
LED
亮灭状态的引脚</em>）同样由<strong>P0</strong>管脚经过<strong>74HC245</strong>进行驱动，并由网络标号为<strong>U3</strong>的<strong>74HC138</strong>使用三极管来进行控制。</p>
<p><img src="/Embedded/STC89C52/Tube/diagram.png"></p>
<p>LED
数码管通常用于显示数值和字母，下面的表格总结了共阴/共阳极数码管所能够显示字符的编码表：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 13%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">显示字符</th>
<th style="text-align: left;">无</th>
<th style="text-align: left;">0</th>
<th style="text-align: left;">1</th>
<th style="text-align: left;">2</th>
<th style="text-align: left;">3</th>
<th style="text-align: left;">4</th>
<th style="text-align: left;">5</th>
<th style="text-align: left;">6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th style="text-align: left;">A</th>
<th style="text-align: left;">B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">共<strong>阳</strong>极数码管</td>
<td style="text-align: left;"><code>0xFF</code></td>
<td style="text-align: left;"><code>0xC0</code></td>
<td style="text-align: left;"><code>0xF9</code></td>
<td style="text-align: left;"><code>0xA4</code></td>
<td style="text-align: left;"><code>0xB0</code></td>
<td style="text-align: left;"><code>0x99</code></td>
<td style="text-align: left;"><code>0x92</code></td>
<td style="text-align: left;"><code>0x82</code></td>
<td><code>0xF8</code></td>
<td><code>0x80</code></td>
<td><code>0x90</code></td>
<td style="text-align: left;"><code>0x88</code></td>
<td style="text-align: left;"><code>0x83</code></td>
<td><code>0xC6</code></td>
<td><code>0xA1</code></td>
<td><code>0x86</code></td>
<td><code>0x8E</code></td>
</tr>
<tr>
<td style="text-align: left;">共<strong>阴</strong>极数码管</td>
<td style="text-align: left;"><code>0x00</code></td>
<td style="text-align: left;"><code>0x3F</code></td>
<td style="text-align: left;"><code>0x06</code></td>
<td style="text-align: left;"><code>0x5B</code></td>
<td style="text-align: left;"><code>0x4F</code></td>
<td style="text-align: left;"><code>0x66</code></td>
<td style="text-align: left;"><code>0x6D</code></td>
<td style="text-align: left;"><code>0x7D</code></td>
<td><code>0x07</code></td>
<td><code>0x7F</code></td>
<td><code>0x6F</code></td>
<td style="text-align: left;"><code>0x77</code></td>
<td style="text-align: left;"><code>0x7C</code></td>
<td><code>0x39</code></td>
<td><code>0x5E</code></td>
<td><code>0x79</code></td>
<td><code>0x71</code></td>
</tr>
</tbody>
</table>
<p>前一小节内容当中有介绍过，<strong>74HC138</strong>同一时刻只能输出一个低电平，参照上面数码管电路图，也就是说同一时刻只会使能一个数码管，换而言之<strong>74HC138</strong>输出信号将会作为数码管的<strong>位选</strong>端（<em>选择多个数码管中具体哪个数码管被点亮</em>）。配合控制段选的单片机<strong>P0</strong>引脚，就能通过一个数码管显示上述编码表当中的字符，也就是一个数码管的<strong>静态显示</strong>。</p>
<p>正常声明的变量默认存放在单片机 RAM
（<em>数据存储空间</em>）当中，程序中可以随意进行修改。但是有些不需要在程序使用过程中进行修改的变量，可以使用
8051 C 语言提供的<code>code</code>关键字进行声明，使其存储至
Flash（<em>程序存储空间</em>）从而节省单片机相对有限的 RAM
存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 code 数组来存储数码管的编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 定时器 T0 的中断次数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sec = <span class="number">0</span>; <span class="comment">// 消耗的秒数</span></span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>;                                  <span class="comment">// 使能网络标号为 U3 的 74HC138</span></span><br><span class="line">  ADDR0 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR2 = <span class="number">0</span>; ADDR3 = <span class="number">1</span>; <span class="comment">// 位选，选中数码管 DS1</span></span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>; <span class="comment">// 设置 T0 为工作模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xB8</span>;  <span class="comment">// 为 T0 赋初值 0xB800</span></span><br><span class="line">  TL0 = <span class="number">0x00</span>;</span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">// 启动 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断 T0 是否溢出*/</span></span><br><span class="line">    <span class="keyword">if</span> (TF0 == <span class="number">1</span>) &#123;</span><br><span class="line">      TF0 = <span class="number">0</span>;                <span class="comment">// T0 溢出后，清零中断标志位</span></span><br><span class="line">      TH0 = <span class="number">0xB8</span>; TL0 = <span class="number">0x00</span>; <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">      cnt++;                  <span class="comment">// 计数值自加 1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断 T0 溢出是否达到 50 次 */</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;           <span class="comment">// 清零计数值</span></span><br><span class="line">        P0 = LedChar[sec]; <span class="comment">// 段选，传递当前秒数对应的编码</span></span><br><span class="line">        sec++;             <span class="comment">// 秒数记录自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当秒数超过15（0x0F）以后，重新从 0 开始计数 */</span></span><br><span class="line">        <span class="keyword">if</span> (sec &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">          sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态数码管-中断">动态数码管 &amp; 中断</h1>
<p>数码管的静态显示在同一时刻只能导通一位数码管，而数码管的动态显示，则是利用人眼的余晖效应（小于<code>10ms</code>）同时动态扫描刷新多个数码管。这里将利用
6
位数码管实现一个可以计时到<code>999999</code>的秒表功能。这里需要注意，对于多位数码管上每一位字符编码显示，可以通过除法运算<code>/</code>和取余运算<code>%</code>获取，例如要显示数字<code>123456</code>，个位数字<code>6</code>可以通过直接对<code>10</code>进行取余操作获得，十位数字<code>5</code>则需要先除以<code>10</code>然后再与<code>10</code>进行取余操作获取，以此类推就可以显示出全部数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动态数码管显示缓冲区*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span> <span class="comment">// 将初始值设置为 0xFF，确保启动时数码管处于熄灭状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;   <span class="comment">// 动态扫描索引</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// 定时器 T0 中断次数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sec = <span class="number">0</span>; <span class="comment">// 记录经过的秒数</span></span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>;              <span class="comment">// 使能网络标号为 U3 的 74HC138</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;              <span class="comment">// 因为需要动态修改ADDR 0、1、2的值，所以这里无须再初始化</span></span><br><span class="line">  TMOD = <span class="number">0x01</span>;            <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>; <span class="comment">// 设置定时值存储寄存器，定时 1ms</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                <span class="comment">// 启动 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断 T0 是否溢出*/</span></span><br><span class="line">    <span class="keyword">if</span> (TF0 == <span class="number">1</span>) &#123;</span><br><span class="line">      TF0 = <span class="number">0</span>; <span class="comment">// T0 溢出后，清零中断标志位</span></span><br><span class="line">      TH0 = <span class="number">0xFC</span>;</span><br><span class="line">      TL0 = <span class="number">0x67</span>; <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">      cnt++;      <span class="comment">// 中断次数计数值自增 1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断 T0 溢出是否达到 1000 次 */</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>; <span class="comment">// 清零计数值</span></span><br><span class="line">        sec++;   <span class="comment">// 秒数记录自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 sec 按照十进制由低至高，提取为数码管将要显示字符的编码 */</span></span><br><span class="line">        LedBuff[<span class="number">0</span>] = LedChar[sec % <span class="number">10</span>];</span><br><span class="line">        LedBuff[<span class="number">1</span>] = LedChar[sec / <span class="number">10</span> % <span class="number">10</span>];</span><br><span class="line">        LedBuff[<span class="number">2</span>] = LedChar[sec / <span class="number">100</span> % <span class="number">10</span>];</span><br><span class="line">        LedBuff[<span class="number">3</span>] = LedChar[sec / <span class="number">1000</span> % <span class="number">10</span>];</span><br><span class="line">        LedBuff[<span class="number">4</span>] = LedChar[sec / <span class="number">10000</span> % <span class="number">10</span>];</span><br><span class="line">        LedBuff[<span class="number">5</span>] = LedChar[sec / <span class="number">100000</span> % <span class="number">10</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 数码管动态扫描刷新 */</span></span><br><span class="line">      <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">0</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">3</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">4</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i = <span class="number">0</span>; P0 = LedBuff[<span class="number">5</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数码管显示残影与抖动">数码管显示残影与抖动</h2>
<p>上述实验程序运行之后，数码管不应该亮起的 LED
段微微发亮，这种现象称为<strong>残影</strong>，主要是由于 C
语言逐语句执行时，位选和段选时进行瞬间状态切换而造成。以上面数码管秒表试验的代码为例，当代码执行流程从<code>case 5</code>切换至<code>case 0</code>时，<code>case 5</code>位选信号为<code>ADDR2=1; ADDR1=0; ADDR0=1;</code>，假如此刻最高位数码管<code>case 5</code>对应的显示值是<code>0</code>。需要切换到的<code>case 0</code>数码管位选为<code>ADDR2=0; ADDR1=0; ADDR0=0;</code>，假如其对应的数码管显示值是<code>1</code>。</p>
<p>由于 C
语言程序逐句顺序执行，每条语句的执行都会占用一个短暂的时间，在将<code>ADDR0=1</code>修改成<code>ADDR0=0</code>的时候，出现了一个瞬时的中间状态<code>ADDR2=1; ADDR1=0; ADDR0=0;</code>，从而让<code>case 4</code>对应的数码管<strong>DS5</strong>瞬间显示为<code>0</code>。当完成正确的赋值<code>ADDR2=0; ADDR1=0; ADDR0=0;</code>之后，由于<strong>P0</strong>还保持着之前的值，又会瞬间使<code>case 0</code>对应的数码管<strong>DS1</strong>显示为<code>0</code>。直至将<code>case 0</code>后面的所有语句执行完成，整个数码管的刷新流程才正式结束。整个刷新过程当中发生了两次错误的赋值，虽然点亮时间极短，但是依然能够被肉眼察觉。而解决数码管动态显示的残影问题，只需要避开这两个瞬间的错误赋值即可。即在位选切换期间，避免一切数码管赋值，主要存在以下两种方式：</p>
<ul>
<li><strong>关闭段选</strong>：数码管刷新之前关闭所有段选，位选完成之后，再打开段选；即在<code>switch(i)</code>语句之前，添加<code>P0=0xFF;</code>语句强制关闭数码管所有
LED
段，待完成<code>ADDRn</code>的赋值以后，再对<strong>P0</strong>进行赋值。</li>
<li><strong>关闭位选</strong>：关闭数码管位选，赋值过程完成以后再重新打开；即在<code>switch(i)</code>语句之前添加<code>ENLED=1</code>，直至<code>case</code>子句里的<code>ADDRn</code>和<code>P0</code>完成赋值之后，再执行一个<code>ENLED=0</code>语句，最后完成<code>break</code>操作。</li>
</ul>
<p>除了残影问题之外，上面的数码管秒表程序还存在显示<strong>抖动</strong>的问题，即每秒数值变化的时候，不参予变化的数码管会发生一次抖动。造成这个现象的原因在于程序定时到<code>1s</code>秒时，会执行<strong>秒数加<code>1</code>并转换为数码管显示字符</strong>的操作。由于<code>unsigned long sec</code>是一个
32
位的整型数据，当在<code>switch()</code>语句进行除法运算时会消耗大量时间，导致每次定时到<code>1s</code>秒时程序都需要多运行一段时间，从而造成某些数码管点亮时间较长，并最终影响到视觉效果。</p>
<p>接下来的内容里，将会引入<strong>STC89C52RC</strong>单片机内置的中断机制，来解决上述的<strong>残影</strong>与<strong>抖动</strong>的问题。</p>
<h2 id="中断机制">中断机制</h2>
<p>标准 8051
架构单片机涉及中断的寄存器主要有：<strong>中断使能寄存器</strong>（可位寻址）、<strong>中断优先级寄存器</strong>（可位寻址），这里首先来了解前者的相关相信：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">中断允许寄存器</th>
<th style="text-align: left;">B7</th>
<th style="text-align: left;">B6</th>
<th style="text-align: left;">B5</th>
<th style="text-align: left;">B4</th>
<th style="text-align: left;">B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>IE</strong></td>
<td style="text-align: left;">EA</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">ET2</td>
<td style="text-align: left;">ES</td>
<td style="text-align: left;">ET1</td>
<td>EX1</td>
<td>ET0</td>
<td>EX0</td>
</tr>
<tr>
<td style="text-align: left;"><strong>复位值</strong></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<ol type="1">
<li><strong>EA</strong>：<u>总中断使能</u>，<code>EA=1</code>允许中断，<code>EA=0</code>屏蔽所有中断。</li>
<li><strong>ET2</strong>：<u>定时/计数器 T2
中断使能</u>，<code>ET2=1</code>允许中断，<code>ET2=0</code>禁止中断。</li>
<li><strong>ES</strong>：<u>串行口中断使能</u>，<code>ES=1</code>允许串口中断，<code>ES=0</code>禁止串口中断。</li>
<li><strong>ET1</strong>：<u>定时/计数器 T1
中断使能</u>，<code>ET1=1</code>允许中断，<code>ET1=0</code>禁止中断。</li>
<li><strong>EX1</strong>：<u>外部中断 1
使能</u>，<code>EX1=1</code>允许中断，<code>EX1=0</code>禁止中断。</li>
<li><strong>ET0</strong>：<u>定时/计数器 T0
中断使能</u>，<code>ET0=1</code>允许中断，<code>ET0=0</code>禁止中断。</li>
<li><strong>EX0</strong>：<u>外部中断 0
使能</u>，<code>EX0=1</code>允许中断，<code>EX0=0</code>禁止中断。</li>
</ol>
<p>上面的表格当中，<code>ET2</code>、<code>ES</code>、<code>ET1</code>、<code>EX1</code>、<code>ET0</code>、<code>EX0</code>这六个位分别控制着四种中断方式的使能，而<code>EA</code>则是作为所有中断的总使能开关，<strong>STC89C52RC</strong>使用任意中断方式之前，首先都需要通过<code>EA = 1</code>打开总中断使能，然后再开启相应的中断方式使能即可。</p>
<p>接下来，将会在之前的数码管秒表程序当中加入中断机制，以求完美处理掉<strong>残影</strong>与<strong>抖动</strong>问题。由于中断程序的加入，执行流程将会被分割为两部分：数码管显示字符转换相关的代码继续留在主循环，动态扫描和定时<code>1s</code>秒功能则移动至中断函数，请参考下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动态数码管显示缓冲区*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;    <span class="comment">// 动态扫描索引</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;   <span class="comment">// 定时器 T0 中断次数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag = <span class="number">0</span>; <span class="comment">// 定时 1 秒标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sec = <span class="number">0</span>; <span class="comment">// 消耗的秒数</span></span><br><span class="line"></span><br><span class="line">  ENLED = <span class="number">0</span>;              <span class="comment">// 使能网络标号为 U3 的 74HC138</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;              <span class="comment">// 因为需要动态修改ADDR 0、1、2的值，所以这里无须再初始化</span></span><br><span class="line">  TMOD = <span class="number">0x01</span>;            <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>; <span class="comment">// 设置定时值存储寄存器，定时 1ms</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;  <span class="comment">// 使能总中断</span></span><br><span class="line">  ET0 = <span class="number">1</span>; <span class="comment">// 使能 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>; <span class="comment">// 启动 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 判断 1 秒定时标志 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">      flag = <span class="number">0</span>; <span class="comment">// 定时 1 秒标志清零</span></span><br><span class="line">      sec++;    <span class="comment">// 秒计数自增 1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 将 sec 按照十进制由低至高，提取为数码管将要显示字符的编码 */</span></span><br><span class="line">      LedBuff[<span class="number">0</span>] = LedChar[sec % <span class="number">10</span>];</span><br><span class="line">      LedBuff[<span class="number">1</span>] = LedChar[sec / <span class="number">10</span> % <span class="number">10</span>];</span><br><span class="line">      LedBuff[<span class="number">2</span>] = LedChar[sec / <span class="number">100</span> % <span class="number">10</span>];</span><br><span class="line">      LedBuff[<span class="number">3</span>] = LedChar[sec / <span class="number">1000</span> % <span class="number">10</span>];</span><br><span class="line">      LedBuff[<span class="number">4</span>] = LedChar[sec / <span class="number">10000</span> % <span class="number">10</span>];</span><br><span class="line">      LedBuff[<span class="number">5</span>] = LedChar[sec / <span class="number">100000</span> % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>; <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">  cnt++;                  <span class="comment">// 中断次数计数值自增 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断 T0 溢出是否达到 1000 次 */</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;  <span class="comment">// 清零计数值</span></span><br><span class="line">    flag = <span class="number">1</span>; <span class="comment">// 定时 1 秒标志置 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0xFF</span>;  <span class="comment">// 消除残影</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数码管动态扫描刷新 */</span></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">0</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">3</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">4</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i = <span class="number">0</span>; P0 = LedBuff[<span class="number">5</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码当中，程序的执行流程被分割为主函数、中断服务函数两部分，中断服务函数必须使用
8051C
提供的<code>interrupt</code>关键字进行声明，紧接在后面的数字<code>1</code>表示的是中断查询顺序号，<strong>STC89C52RC</strong>常用的中断查询顺序以及<strong>中断向量</strong>（中断服务程序入口地址）如下表所示：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 35%">
<col style="width: 17%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 7%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">中断函数</th>
<th style="text-align: left;">中断名称</th>
<th style="text-align: left;">中断标志位</th>
<th style="text-align: left;">中断使能位</th>
<th style="text-align: left;">中断向量地址</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>void service() interrupt 0</code></td>
<td style="text-align: left;">外部中断 0</td>
<td style="text-align: left;"><code>IE0</code></td>
<td style="text-align: left;"><code>EX0</code></td>
<td style="text-align: left;"><code>0x0003</code></td>
<td>▲ 高</td>
</tr>
<tr>
<td style="text-align: left;"><code>void service() interrupt 1</code></td>
<td style="text-align: left;">定时器 T0 中断</td>
<td style="text-align: left;"><code>TF0</code></td>
<td style="text-align: left;"><code>ET0</code></td>
<td style="text-align: left;"><code>0x000B</code></td>
<td>-</td>
</tr>
<tr>
<td style="text-align: left;"><code>void service() interrupt 2</code></td>
<td style="text-align: left;">外部中断 1</td>
<td style="text-align: left;"><code>IE1</code></td>
<td style="text-align: left;"><code>EX1</code></td>
<td style="text-align: left;"><code>0x0013</code></td>
<td>-</td>
</tr>
<tr>
<td style="text-align: left;"><code>void service() interrupt 3</code></td>
<td style="text-align: left;">定时器 T1 中断</td>
<td style="text-align: left;"><code>TF1</code></td>
<td style="text-align: left;"><code>ET1</code></td>
<td style="text-align: left;"><code>0x001B</code></td>
<td>-</td>
</tr>
<tr>
<td style="text-align: left;"><code>void service() interrupt 4</code></td>
<td style="text-align: left;">UART 中断</td>
<td style="text-align: left;"><code>TI/RI</code></td>
<td style="text-align: left;"><code>ES</code></td>
<td style="text-align: left;"><code>0x0023</code></td>
<td>-</td>
</tr>
<tr>
<td style="text-align: left;"><code>void service() interrupt 5</code></td>
<td style="text-align: left;">定时器 T2 中断</td>
<td style="text-align: left;"><code>TF2/EXF2</code></td>
<td style="text-align: left;"><code>ET2</code></td>
<td style="text-align: left;"><code>0x002B</code></td>
<td>▼ 低</td>
</tr>
</tbody>
</table>
<p>仔细分析上面的表格，对于前面代码中使用到的定时器 T0
中断，可以先通过<code>ET0 = 1</code>使能该中断，然后当其对应的中断标志位<code>TF0</code>置<code>1</code>时就会触发
T0
中断，此时单片机将会根据中断向量地址执行该中断函数，这里的中断向量是基于<code>interrupt</code>关键字后的<strong>中断函数编号</strong>得出，具体计算方法是<code>中断函数号 × 8 + 3</code>。当中断条件满足之后，就会自动触发中断并调用相应的中断函数。</p>
<blockquote>
<p>前面动态数码管显示的示例代码当中，就是通过中断机制来确保数码管动态扫描的间隔时间固定为<code>1ms</code>毫秒，从而避免了由于程序代码逐行执行而导致的数码管显示抖动。</p>
</blockquote>
<h2 id="中断优先级与中断嵌套">中断优先级与中断嵌套</h2>
<p><strong>STC89C52RC</strong>单片机存在着<strong>默认优先级</strong>和<strong>抢占式优先级</strong>两种概念，这里先来介绍一下抢占式优先级。<strong>中断优先级寄存器
IP</strong>可以进行位寻址，其每一位都代表着其<strong>对应中断</strong>的抢占式优先级，其复位值都是<code>0</code>，置<code>1</code>后该位对应的优先级将高于其它位。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 2%">
<col style="width: 2%">
<col style="width: 16%">
<col style="width: 12%">
<col style="width: 16%">
<col style="width: 17%">
<col style="width: 16%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">B7</th>
<th style="text-align: left;">B6</th>
<th style="text-align: left;">B5</th>
<th style="text-align: left;">B4</th>
<th style="text-align: left;">B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">PT2</td>
<td style="text-align: left;">PS</td>
<td style="text-align: left;">PT1</td>
<td>PX1</td>
<td>PT0</td>
<td>PX0</td>
</tr>
<tr>
<td style="text-align: left;">保留</td>
<td style="text-align: left;">保留</td>
<td style="text-align: left;">定时器 T2 中断优先级控制位</td>
<td style="text-align: left;">串口中断优先级控制位</td>
<td style="text-align: left;">定时器 T1 中断优先级控制位</td>
<td>外部中断 T1 中断优先级控制位</td>
<td>定时器 T0 中断优先级控制位</td>
<td>外部中断 T0 中断优先级控制位</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<p>例如<code>PT0 = 1</code>的时候，如果定时器 T0
发生中断，代码执行流程将会立即转入定时器 T0
的中断服务程序。如果此时发生了其它优先级较低的中断，也必须等待当前高优先级中断服务程序执行完成，才会进入低优先级中断对应的服务程序。当流程进入低优先级中断对应服务程序的时候，如果又发生了更高优先级的中断，此时执行流程就会立刻转入高优先级中断服务函数执行，处理完成之后再返回刚才的低优先级中断，这一系列过程称为<strong>中断嵌套</strong>，也就是上面提到的抢占，即高优先级中断可以打断低优先级中断的执行，从而形成中断嵌套；反过来，低优先级中断并不会打断高优先级中断的执行；标准
8051 架构单片机最多可以实现两级中断嵌套。</p>
<p><strong>默认优先级</strong>就是单片机中断机制当中，各种中断源默认的优先级顺序（<em>中断查询顺序编号数值越小优先级越高</em>），标准
8051 架构单片机一共拥有 6
个默认优先级中断源，它们分别是：<strong>外部中断
0</strong>、<strong>外部中断 1</strong>、<strong>定时器 T0
中断</strong>、<strong>定时器 T1 中断</strong>、<em>定时器 T2
中断</em>、<em>UART
中断</em>，中断源默认优先级与抢占式优先级最大的不同点在于：即使低优先级中断执行过程中又发生了高优先级中断，高优先级中断也只能等待低优先级中断执行完后才会得到响应。默认优先级主要用于处理多个中断源同时发生的仲裁，例如代码中暂时通过<code>EA = 0</code>关闭了总中断，然后在此期间有多个中断源产生了中断，由于总中断处于关闭状态，这些中断迟迟得不到响应。然后当程序中<code>EA = 0</code>重新使能总中断时，这些中断源就会同时申请中断，此时单片机就会按照各个中断源默认的优先级顺序逐个进行处理。</p>
<h1 id="led-点阵">LED 点阵</h1>
<p>函数中的<strong>局部变量</strong>（未添加<code>static</code>关键字修饰）属于<strong>自动变量</strong>，自动分配存储空间，函数调用完成后自动释放，自动变量也可以通过<code>auto</code>关键字显式进行声明。函数外的全局变量都属于<strong>静态变量</strong>，但是使用<code>static</code>关键字声明的局部变量被称为<strong>静态局部变量</strong>，可以用来缓存函数上一次的执行结果。因此，可以尝试将前面动态数码管显示所使用的索引变量<code>i</code>、定时器中断次数<code>cnt</code>定义为静态局部变量。</p>
<p>点阵 LED 是一种可任意分割组装的显示技术，本质上是由多个 LED
发光二极管组成的矩阵，点亮原理较为简单。下面电路图当中，LED
点阵<strong>LD1</strong>顶部的<code>DB0 ~ DB7</code>通过<strong>74HC245</strong>连接到单片机<strong>P0</strong>引脚，以此作为
LED 点阵的阴极；左侧引脚经过八枚<strong>9012
二极管</strong>之后，由<code>LEDC0 ~ LEDCC7</code>端连接至网络标号为<strong>U4</strong>的<strong>74HC138</strong>三八译码器，并最终与单片机的<code>P1.0 ~ P1.3</code>引脚连接，以此作为
LED 点阵的阳极。</p>
<p><img src="/Embedded/STC89C52/Matrix/diagram.png"></p>
<p>当 LED 点阵第 9
脚设置为高电平<code>1</code>，第<code>13</code>脚设置为低电平<code>0</code>，就可以点亮顶部左侧的第
1 枚
LED。同理，通过对<strong>P0</strong>整体赋值，并将<strong>74HC138</strong>的<strong>Y1</strong>引脚拉至低电平<code>0</code>就可以点亮第
2 行的全部八枚 LED，具体可以参考下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ENLED = <span class="number">0</span>; <span class="comment">// 同时使能 U3 和 U4 两片 74HC138 三八译码器</span></span><br><span class="line">  ADDR3 = <span class="number">0</span>; <span class="comment">// 使能 U4 输出</span></span><br><span class="line">  ADDR2 = <span class="number">0</span>; <span class="comment">// 经过 Y1 导通三极管 Q11</span></span><br><span class="line">  ADDR1 = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0x00</span>; <span class="comment">// 将 P0 引脚全部置为低电平</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">// 让程序运行停止在该位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LED 点阵由 64 枚发光二极管组成，可以考虑将 LED 点阵理解为一个 8
位的数码管（每个数码管由 8 段 LED 组成）。之前已经进行过 6
位数码管同时显示的实验，接下来就将同样利用定时器中断和数码管动态显示的原理来将
LED
点阵全部点亮。注意：之前代码中的动态扫描索引<code>i</code>，已经被移至中断服务函数当中，并被<code>static</code>关键字声明为了一个静态局部变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ENLED = <span class="number">0</span>; <span class="comment">// 同时使能 U3 和 U4 两片 74HC138 三八译码器</span></span><br><span class="line">  ADDR3 = <span class="number">0</span>; <span class="comment">// 使能 U4 输出，由于要动态改变 ADDR0/1/2 的值，所以这里不再初始化</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                 <span class="comment">// 使能总中断</span></span><br><span class="line">  TMOD = <span class="number">0x01</span>;            <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>; <span class="comment">// 设置定时值存储寄存器，定时 1ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                <span class="comment">// 使能 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                <span class="comment">// 启动 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">// 程序停止在此处，等待定时器 T0 中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>; <span class="comment">// 声明为静态局部变量的动态扫描索引</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;     <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                  <span class="comment">// 消除残影</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数码管动态扫描刷新 */</span></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i = <span class="number">0</span>; P0 = <span class="number">0x00</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="独立按键">独立按键</h1>
<p>独立式和矩阵式是两种比较常用的按键电路形式，其中独立式按键的电路非常简单，每个微动按键分别与单片机的
IO 管脚进行连接。</p>
<p><img src="/Embedded/STC89C52/Button/independent.png"></p>
<p>上面的电路图当中，四枚按键分别连接至单片机 IO
口，当按键<strong>K1</strong>按下，<code>5V</code>电压经过电阻<strong>R1</strong>与<strong>按键
K1</strong>以后进入<strong>GND</strong>形成通路，该线路上所有电压都将施加到这个<strong>R1</strong>电阻，单片机<strong>KeyIn1</strong>引脚此时表现为低电平<code>0</code>。当按键<strong>K1</strong>松开之后，这条通路被断开，从而没有电流通过，此时<strong>KeyIn1</strong>和<code>5V</code>是相等电位，<strong>KeyIn1</strong>引脚呈现高电平<code>1</code>。综上所述，我们就可以通过单片机<strong>KeyIn1</strong>引脚的电平状态来判断按键是否按下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 74HC138 选中需要控制的 LED */</span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 控制引脚 */</span></span><br><span class="line">sbit LED6 = P0 ^ <span class="number">4</span>;</span><br><span class="line">sbit LED7 = P0 ^ <span class="number">5</span>;</span><br><span class="line">sbit LED8 = P0 ^ <span class="number">6</span>;</span><br><span class="line">sbit LED9 = P0 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 独立按键控制引脚 */</span></span><br><span class="line">sbit KEY1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 将矩阵按键首行的 K1～K4 作为独立按键处理 */</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line">  ADDR1 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">1</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  P2 = <span class="number">0xF7</span>; <span class="comment">// 1111 0111，设置 P2.3 引脚对应的 KeyOut1 为低电平 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将按键对应引脚上的电平状态传递给 LED，按键按下时电平状态为 0 对应 LED 被点亮 */</span></span><br><span class="line">    LED9 = KEY1;</span><br><span class="line">    LED8 = KEY2;</span><br><span class="line">    LED7 = KEY3;</span><br><span class="line">    LED6 = KEY4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码让<code>KeyOut1</code>输出低电平<code>0</code>，<code>KeyOut2 ~ 4</code>则保持高电平<code>1</code>，相当于将矩阵按键第
1 行的<strong>Key1 ~ Key4</strong>作为 4 个独立按键处理，然后将这 4
个按键的电平状态分别传递给<code>LED6 ~ LED9</code> 这 4 个
LED。当按键按下时，<code>KEYn</code>和<code>LEDn</code>的电平状态都为<code>0</code>，此时
LED 正常点亮。</p>
<p>通常情况下，按键并不需要检测一个固定的电平值，而是需要检测电平值的<strong>按下</strong>和<strong>弹起</strong>两种变化状态，即模拟自锁定开关的效果。因此，可以将每次扫描到的按键状态进行缓存，每次扫描按键状态时都与前一次的状态进行比较，如果状态不一致，就说明按键产生过动作。接下来，以按键<strong>K4</strong>为例编写如下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  bit backup = <span class="number">1</span>;        <span class="comment">// 位变量，保存前次扫描的按键值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 记录按键按下的次数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 74HC138 选中数码管DS1 */</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line">  ADDR1 = <span class="number">0</span>;</span><br><span class="line">  ADDR2 = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  P2 = <span class="number">0xF7</span>;         <span class="comment">// KeyOut1 输出低电平</span></span><br><span class="line">  P0 = LedChar[cnt]; <span class="comment">// 显示按键次数的初始值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 当前值与前次值不相等说明此时按键有动作 */</span></span><br><span class="line">    <span class="keyword">if</span> (KEY4 != backup) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果前次值为0，则说明当前是由0变1，即按键弹起 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup == <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++; <span class="comment">// 按键次数自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 由于参与显示的只有 1 位数码管，所以按键次数自增到 10 就清零并重新计数 */</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">          cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        P0 = LedChar[cnt]; <span class="comment">// 让数码管显示计数值</span></span><br><span class="line">      &#125;</span><br><span class="line">      backup = KEY4;       <span class="comment">// 更新缓存值为当前值，便于下次进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序当中，按一次按键，就会产生【按下】与【弹起】两个状态，这里选择的是在【弹起】时对数码管进行加<code>1</code>操作。程序实际运行时，会发现有些时候<strong>K4</strong>按键按下一次，但是数码管显示的数字却累加了不止
1 次，这主要由于按键抖动所引起的，接下来的小节将会重点探讨这个问题。</p>
<blockquote>
<p>上面代码所使用的<code>bit</code>关键字是 8051
架构特有的一种数据类型，仅占用 1
个位的存储空间，且只能保存<code>0</code>和<code>1</code>两个值，通常用来表达按键的按下/弹起、LED
的亮/灭、三极管的导通/关断等状态。</p>
</blockquote>
<h2 id="按键消抖">按键消抖</h2>
<p><strong>按键抖动</strong>是由微动开关的机械触点在闭合/断开时未能稳定接通所造成的，抖动发生的时间通常不会超过<code>10ms</code>。按键消抖的基本原理，是在检查出按键状态发生变化时，延迟一段时间，等待触点闭合/断开状态稳定之后再进行相应处理。</p>
<p><img src="/Embedded/STC89C52/Button/jitter.jpg"></p>
<p>按键消抖的处理方式大致可以分为硬件消抖和软件消抖两类，<strong>硬件消抖</strong>会在按键上并联一个电容，从而利用电容的充放电特性对抖动过程中产生的电压杂波进行平滑处理，进而实现消抖功能。</p>
<p><img src="/Embedded/STC89C52/Button/jitter-circuit.png"></p>
<p>例如上面的按键消抖电路当中，微动开关下方就并联了一只容值为<code>0.1uF</code>的电容。实际开发环境里，如果按键数量较多，这种方式会显著增加电路成本，因此较少被使用到。相对而言，<strong>软件消抖</strong>才是工程实践当中较多采纳的消抖方式，当程序检测到按键状态变化以后，先延时<code>10ms</code>等待抖动消失以后，再检测一次按键状态，如果与之前检测的状态相同，就确认按键已经稳定的闭合/断开，这里对前面独立按键<strong>K4</strong>的实验程序进行修改，加入防抖处理的相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时函数，延时约 10ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  bit keybuf = <span class="number">1</span>;        <span class="comment">// 按键值暂存，临时保存按键的扫描值</span></span><br><span class="line">  bit backup = <span class="number">1</span>;        <span class="comment">// 按键值备份，保存前一次按键扫描值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 按键计数，记录按键被按下的次数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 74HC138 选中数码管DS1 */</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">0</span>;</span><br><span class="line">  ADDR1 = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  P2 = <span class="number">0xF7</span>;         <span class="comment">// KeyOut1 端输出低电平</span></span><br><span class="line">  P0 = LedChar[cnt]; <span class="comment">// 显示按键次数的初始值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    keybuf = KEY4;   <span class="comment">// 保存当前的按键扫描值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前值与前次值不相等说明此时按键有动作 */</span></span><br><span class="line">    <span class="keyword">if</span> (keybuf != backup) &#123;</span><br><span class="line">      delay();       <span class="comment">// 消抖，调用延时函数，延时约 10ms</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断扫描值是否发生变化，即按键是否还在抖动 */</span></span><br><span class="line">      <span class="keyword">if</span> (keybuf == KEY4) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果前次值为0，说明当前按键弹起 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup == <span class="number">0</span>) &#123;</span><br><span class="line">          cnt++;             <span class="comment">// 按键次数自增 1</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 由于参与显示的仅 1 位数码管，所以按键次数自增到 10 就清零重新计数 */</span></span><br><span class="line">          <span class="keyword">if</span> (cnt &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          P0 = LedChar[cnt]; <span class="comment">// 让数码管显示计数值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backup = keybuf;     <span class="comment">// 更新缓存值为当前值，便于下次进行比较</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于延时函数<code>delay()</code>极有可能会造成<code>main()</code>函数执行流程的死锁，进而影响其它任务的调度，因此可以引入单片机的中断机制，每<code>2ms</code>进入一次定时中断，扫描一次按键状态后缓存下来，连续扫描
8 次以后，比较这 8
次的按键（共计<code>16ms</code>）状态是否一致，如果保持一致就可以确定按键已经处于稳定状态。</p>
<p><img src="/Embedded/STC89C52/Button/interrupt-anti-jitter.png"></p>
<p>上面示意图当中，左边是起始的<code>0</code>时间，每经过<code>2ms</code>左移一次，每移动一次，就判断当前连续的
8
次按键状态是否全为<code>0</code>或者全为<code>1</code>，如果全为<code>1</code>就表示按键弹起，全为<code>0</code>则表示按键按下，如果出现<code>0</code>与<code>1</code>交错的情况，就认为按键发生了抖动。这种方式可以有效避免延时消抖函数占用单片机执行时间，影响其它功能的执行，这里继续对上面<strong>K4</strong>独立按键的例子进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line">bit KeySta = <span class="number">1</span>;                  <span class="comment">// 当前按键的状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  bit backup = <span class="number">1</span>;                <span class="comment">// 按键值备份，保存前一次按键扫描值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>;         <span class="comment">// 按键计数，记录按键按下的次数</span></span><br><span class="line">  EA = <span class="number">1</span>;                        <span class="comment">// 使能总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 74HC138 选中数码管DS1 */</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">0</span>;</span><br><span class="line">  ADDR1 = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>;                   <span class="comment">// 设置 T0 为模式1</span></span><br><span class="line">  TH0 = <span class="number">0xF8</span>; TL0 = <span class="number">0xCD</span>;        <span class="comment">// 定时器 T0 赋初值 0xF8CD，表示定时 2ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                       <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                       <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  P2 = <span class="number">0xF7</span>;                     <span class="comment">// KeyOut1 端输出低电平</span></span><br><span class="line">  P0 = LedChar[cnt];             <span class="comment">// 显示按键次数的初始值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 当前值与前次值不相等说明此时按键有动作 */</span></span><br><span class="line">    <span class="keyword">if</span> (KeySta != backup) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果前次值为0，说明当前按键弹起 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup == <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;                   <span class="comment">// 按键次数自增 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 由于参与显示的仅 1 位数码管，所以按键次数自增到 10 就清零重新计数 */</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">          cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        P0 = LedChar[cnt];       <span class="comment">// 让数码管显示计数值</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      backup = KeySta;           <span class="comment">// 更新缓存值为当前值，便于下次进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于按键状态扫描与消抖 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf = <span class="number">0xFF</span>;   <span class="comment">// 扫描按键状态缓冲区，保存一段时间内的扫描值</span></span><br><span class="line">  TH0 = <span class="number">0xF8</span>; TL0 = <span class="number">0xCD</span>;               <span class="comment">// 定时器 T0 重新赋初值</span></span><br><span class="line">  keybuf = (keybuf &lt;&lt; <span class="number">1</span>) | KEY4;        <span class="comment">// 缓冲区左移一位，将当前扫描值移入最低位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续 8 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">  <span class="keyword">if</span> (keybuf == <span class="number">0x00</span>) &#123;</span><br><span class="line">    KeySta = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 连续 8 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keybuf == <span class="number">0xFF</span>) &#123;</span><br><span class="line">    KeySta = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其它情况说明按键状态尚未稳定，不需要更新 KeySta</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵键盘">矩阵键盘</h1>
<p>由于独立按键会占用大量的单片机 IO
资源，接下来将介绍更加常用的矩阵式按键设计。下面电路图当中，使用 8
个单片机 IO 管脚就可以控制由 16 个按键组成的矩阵按键（<em>共分为 4
组每组各 4
个独立按键</em>），通过矩阵按键的<strong>行线</strong>和<strong>列线</strong>就可以检测到当前按下的是哪个按键。</p>
<p><img src="/Embedded/STC89C52/Button/matrix.png"></p>
<p>前面小节当中介绍过，按键按下状态通常会保持<code>100ms</code>以上，如果在按键扫描中断服务函数当中，每次都让矩阵按键的一个<strong>KeyOut</strong>输出低电平<code>0</code>，其它三个引脚<strong>KeyOut2</strong>、<strong>KeyOut3</strong>、<strong>KeyOut4</strong>输出高电平<code>1</code>，然后判断所有<code>KeyIn</code>的状态，通过快速的中断不停循环进行判断，就可以最终确定当前按下的按键。</p>
<p>至于扫描间隔时间和消抖时间，由于目前拥有 4
路<strong>KeyOut</strong>输出，需要中断 4
次才能完成一次全部按键的扫描，继续采用<code>2ms</code>中断来判断 8
次扫描值的方式，消耗的时间（<code>2毫秒 × 4路 × 8次 = 64毫秒</code>）将会过长，无法正确实现消抖处理。因此，这里可以改用<code>1ms</code>中断并且判断
4
次的方式作为消抖时间（<code>1毫秒 × 4路 × 4次 = 16毫秒</code>）。接下来编写程序，循环扫描电路图当中的<strong>K1
~ K16</strong>共 16
个矩阵按键，并将当前按下按键的编号（<em>使用<code>0~F</code>表示，显示值等于按键编号减去<code>1</code></em>）显示在一位数码管上面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_IN_1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY_IN_2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY_IN_3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY_IN_4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_OUT_1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KEY_OUT_2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KEY_OUT_3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KEY_OUT_4 = P2 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的全部状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeySta[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">  <span class="comment">/* 键值备份，保存前一次的矩阵按键状态 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">  EA = <span class="number">1</span>; <span class="comment">//使能总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 74HC138 选中数码管DS1 */</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">0</span>;</span><br><span class="line">  ADDR1 = <span class="number">0</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>;                 <span class="comment">// 设置 T0 为模式1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;      <span class="comment">// 定时器 T0 赋初值 0xFC67，定时 1ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                     <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                     <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  P0 = LedChar[<span class="number">0</span>];             <span class="comment">// 数码管显示默认值 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 循环扫描 4*4 矩阵按键 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检测按键动作 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup[i][j] != KeySta[i][j]) &#123;</span><br><span class="line">          <span class="comment">/* 按键按下时需要执行的任务 */</span></span><br><span class="line">          <span class="keyword">if</span> (backup[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            P0 = LedChar[i * <span class="number">4</span> + j];   <span class="comment">// 将按键编号显示至数码管</span></span><br><span class="line">          &#125;</span><br><span class="line">          backup[i][j] = KeySta[i][j]; <span class="comment">// 更新前一次的备份值</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于按键状态扫描与消抖 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keyout = <span class="number">0</span>; <span class="comment">// 矩阵按键扫描输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 矩阵按键扫描缓冲区 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;          <span class="comment">// 定时器 T0 重新赋初值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将一行上 4 个按键的值移入缓冲区 */</span></span><br><span class="line">  keybuf[keyout][<span class="number">0</span>] = (keybuf[keyout][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_1;</span><br><span class="line">  keybuf[keyout][<span class="number">1</span>] = (keybuf[keyout][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_2;</span><br><span class="line">  keybuf[keyout][<span class="number">2</span>] = (keybuf[keyout][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_3;</span><br><span class="line">  keybuf[keyout][<span class="number">3</span>] = (keybuf[keyout][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 完成消抖之后更新按键的状态，因为每行 4 个按键，所以要循环 4 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行下一次扫描输出 */</span></span><br><span class="line">  keyout++;               <span class="comment">// 输出索引自增</span></span><br><span class="line">  keyout = keyout &amp; <span class="number">0x03</span>; <span class="comment">// 索引值自增到 4 以后归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据索引值释放当前输出引脚，并拉低下次的输出引脚 */</span></span><br><span class="line">  <span class="keyword">switch</span> (keyout) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: KEY_OUT_4 = <span class="number">1</span>; KEY_OUT_1 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: KEY_OUT_1 = <span class="number">1</span>; KEY_OUT_2 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: KEY_OUT_2 = <span class="number">1</span>; KEY_OUT_3 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: KEY_OUT_3 = <span class="number">1</span>; KEY_OUT_4 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中，中断函数中扫描<strong>KeyIn</strong>输入与切换<strong>KeyOut</strong>输出的顺序与前面顺序不同，代码中首先对所有<strong>KeyIn</strong>输入进行扫描与消抖处理，然后才切换到下一次<strong>KeyOut</strong>输出，即每次中断扫描的实质是上次输出所选择的那行按键。这是由于信号从输出到稳定需要一段时间，这里颠倒输入输出顺序就是为了让输出信号拥有足够时间（<em>一次定时器中断间隔</em>）保持稳定，从而确保程序代码的健壮性。</p>
<blockquote>
<p>注意：上面代码中的<code>keyout = keyout &amp; 0x03; // 索引值自增到 4 后归零</code>这条语句，其实质是确保<strong>keyout</strong>在<code>0 ~ 3</code>范围以内变化，加至<code>4</code>以后就自动归零。这里并未采用<code>if()</code>语句进行判断，而是另辟蹊径使用了与运算符<code>&amp;</code>来完成。由于数值<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>正好占据
2 个二进制位（bit），如果对 1 个字节（Byte）的高 6
位一直进行清零，那么该字节存储的值就自然呈现出一种满 4 归零的效果。</p>
</blockquote>
<h2 id="加法计算器试验">加法计算器试验</h2>
<p>完成前面数码管与键盘的学习之后，本节内容将着手实现一个简易的加法计算器：使用开发板上标有【<code>0 ~ 9</code>】的按键作为数字输入，这些数字会实时显示到数码管；然后采用标有向上箭头的按键作为【<code>+</code>】加号，按下以后可以再行输入一串被加数字；最后，按下回车键就可以得到加法计算的结果，并将其显示在数码管。本程序会将各个子功能划分为独立的函数，提高代码可读性的同时也便于程序的维护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_IN_1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY_IN_2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY_IN_3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY_IN_4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_OUT_1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KEY_OUT_2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KEY_OUT_3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KEY_OUT_4 = P2 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的全部状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeySta[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示缓冲区 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键编号和标准键盘键码的映射表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span>&#125;, <span class="comment">// 数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123;<span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span>&#125;, <span class="comment">// 数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123;<span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span>&#125;, <span class="comment">// 数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123;<span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span>&#125;  <span class="comment">// 数字键 0、ESC 键、回车键、向右键</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;          <span class="comment">// 按键驱动函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                  <span class="comment">// 总中断使能</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>;             <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;  <span class="comment">// 定时器 T0 赋初值 0xFC67，定时 1ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                 <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                 <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  LedBuff[<span class="number">0</span>] = LedChar[<span class="number">0</span>]; <span class="comment">// 上电以后数码管显示初始值 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();           <span class="comment">// 按键驱动函数调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管上显示一个无符号长整型数值，参数 num 表示要显示的数字 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> num)</span> &#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将长整型数值转换为 6 位十进制数组 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    buf[i] = num % <span class="number">10</span>;</span><br><span class="line">    num = num / <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 从最高位开始，如果遇到 0 就转换为空格，非 0 则退出循环 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">      LedBuff[i] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 剩下的低位原样转换为数码管要显示的字符 */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据键码执行相应操作，参数 keycode 是按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> result = <span class="number">0</span>;             <span class="comment">// 运算结果</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> addend = <span class="number">0</span>;             <span class="comment">// 输入的被加数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果输入的是 0 ~ 9 的数字 */</span></span><br><span class="line">  <span class="keyword">if</span> ((keycode &gt;= <span class="number">0x30</span>) &amp;&amp; (keycode &lt;= <span class="number">0x39</span>)) &#123;</span><br><span class="line">    addend = (addend * <span class="number">10</span>) + (keycode - <span class="number">0x30</span>); <span class="comment">// 整体十进制左移，新数字进入个位</span></span><br><span class="line">    ShowNumber(addend);                        <span class="comment">// 将运算结果显示到数码管</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向上键用作为加号，执行加法或者连加运算 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    result += addend;                          <span class="comment">// 进行加法运算</span></span><br><span class="line">    addend = <span class="number">0</span>;</span><br><span class="line">    ShowNumber(result);                        <span class="comment">// 将运算结果显示到数码管</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 按下回车键，然后执行加法运算 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x0D</span>) &#123;</span><br><span class="line">    result += addend;                          <span class="comment">// 进行加法运算</span></span><br><span class="line">    addend = <span class="number">0</span>;</span><br><span class="line">    ShowNumber(result);                        <span class="comment">// 将运算结果显示到数码管</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 按下 Esc 键，清零计算结果 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x1B</span>) &#123;</span><br><span class="line">    addend = <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    ShowNumber(addend);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 键值备份，保存前一次的矩阵按键状态 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环扫描 4*4 矩阵按键 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测按键动作 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup[i][j] != KeySta[i][j]) &#123;</span><br><span class="line">        <span class="comment">/* 按键按下时需要执行的任务 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">          KeyAction(KeyCodeMap[i][j]); <span class="comment">// 调用按键动作函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        backup[i][j] = KeySta[i][j];   <span class="comment">// 更新前一次备份的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用，推荐调用间隔1ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keyout = <span class="number">0</span>;     <span class="comment">// 矩阵按键扫描输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 矩阵按键扫描缓冲区 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将一行上 4 个按键的值移入缓冲区 */</span></span><br><span class="line">  keybuf[keyout][<span class="number">0</span>] = (keybuf[keyout][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_1;</span><br><span class="line">  keybuf[keyout][<span class="number">1</span>] = (keybuf[keyout][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_2;</span><br><span class="line">  keybuf[keyout][<span class="number">2</span>] = (keybuf[keyout][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_3;</span><br><span class="line">  keybuf[keyout][<span class="number">3</span>] = (keybuf[keyout][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 完成消抖之后更新按键的状态，因为每行 4 个按键，所以要循环 4 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行下一次扫描输出 */</span></span><br><span class="line">  keyout++;                           <span class="comment">// 输出索引自增</span></span><br><span class="line">  keyout = keyout &amp; <span class="number">0x03</span>;             <span class="comment">// 索引值自增到 4 以后归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据索引值释放当前输出引脚，并拉低下次的输出引脚 */</span></span><br><span class="line">  <span class="keyword">switch</span> (keyout) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: KEY_OUT_4 = <span class="number">1</span>; KEY_OUT_1 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: KEY_OUT_1 = <span class="number">1</span>; KEY_OUT_2 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: KEY_OUT_2 = <span class="number">1</span>; KEY_OUT_3 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: KEY_OUT_3 = <span class="number">1</span>; KEY_OUT_4 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，定时中断内调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;         <span class="comment">// 动态扫描索引</span></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                          <span class="comment">// 数码管显示消隐</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">0</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">3</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">4</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i = <span class="number">0</span>; P0 = LedBuff[<span class="number">5</span>]; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于按键状态扫描与消抖 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;             <span class="comment">// 定时器 T0 重新赋初值</span></span><br><span class="line">  LedScan();                          <span class="comment">// 调用数码管显示扫描函数</span></span><br><span class="line">  KeyScan();                          <span class="comment">// 调用按键扫描函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="步进电机">步进电机</h1>
<p>步进电机属于控制类电机，用来将脉冲信号转换成一个转动角度。当前使用的<code>28BYJ-48</code>是四相八拍的永磁式减速步进电机，这里的减速是指步进电机转子通过内置减速齿轮对外输出动力，<code>28BYJ-48</code>的减速比为<code>1 : 64</code>，也就是转子需要旋转<code>64</code>圈，外部的传动轴才会旋转<code>1</code>圈。</p>
<figure>
<img src="/Embedded/STC89C52/Motor/five-wire-four-phase.png" alt="type-matrix">
<figcaption aria-hidden="true">type-matrix</figcaption>
</figure>
<p>下面结构图当中，里圈由永磁体组成的 6
个齿（标注为<code>0～5</code>）称为<strong>转子</strong>，外圈缠有线圈绕组的
8
个齿并且保持不动的是<strong>定子</strong>，其正对的两个齿上的绕组相互串联，总是同时导通或关断，从而形成<strong>四相</strong>（标注为<code>A、B、C、D</code>）。通过循环导通<code>A、B、C、D</code>绕组实现转子的逆时针转动，每个四节拍转子将会转过一个定子齿的角度，八个四节拍转子就可以转动一圈，其中单个节拍使转子转过的角度<span class="math inline">\(\frac{360度}{8次\times4拍}=11.25度\)</span>称为<strong>步进角度</strong>，上述这种工作模式就是步进电机的<strong>单相绕组通电四节拍模式</strong>，简称<strong>单四拍模式</strong>。</p>
<p>如果在单四拍的两个节拍之间插入一个双绕组导通的中间节拍，则可以构成扭矩更大精度更高的<strong>八节拍模式</strong>，其步进角度为<span class="math inline">\(\frac{360度}{8次\times8拍}=5.625度\)</span>。如果舍弃八拍模式中单绕组通电的四拍，而只保留双绕组通电的四拍，就可以构成<strong>双绕组通电四节拍</strong>，其步进角度虽与单四拍模式相同，但由于两个绕组同时导通，扭矩相比单四拍模式更大。生产环境当中，<strong>八节拍模式</strong>能够最大限度发挥电机的扭矩和精度，是四相步进电机的最佳工作模式。</p>
<p><strong>五线四相步进电机</strong>一共拥有五条导线，其中<strong>红色</strong>导线是公共端连接至<code>5V</code>电源，<strong>橙</strong>、<strong>黄</strong>、<strong>粉</strong>、<strong>蓝</strong>色导线则分别对应<strong>A</strong>、<strong>B</strong>、<strong>C</strong>、<strong>D</strong>四相，其八拍模式绕组控制顺序表可以总结如下：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 46%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">导线颜色</th>
<th style="text-align: left;">1 拍</th>
<th style="text-align: left;">2 拍</th>
<th style="text-align: left;">3 拍</th>
<th style="text-align: left;">4 拍</th>
<th style="text-align: left;">5 拍</th>
<th style="text-align: left;">6 拍</th>
<th style="text-align: left;">7 拍</th>
<th style="text-align: left;">8 拍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>红</strong>（公共端，接<code>5V</code>电源）</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
<td style="text-align: left;">VCC</td>
</tr>
<tr>
<td style="text-align: left;"><strong>橙</strong>（<strong>A
相</strong>）</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">GND</td>
</tr>
<tr>
<td style="text-align: left;"><strong>黄</strong>（<strong>B
相</strong>）</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;"><strong>粉</strong>（<strong>C
相</strong>）</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;"><strong>蓝</strong>（<strong>D
相</strong>）</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
<td style="text-align: left;">GND</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：每个节拍的持续时间由步进电机的<strong>启动频率</strong>来决定，开发板使用的<strong>28BYJ-48</strong>启动频率为<code>≥550</code>，即单片机每秒输出大于<code>550</code>个步进脉冲就可以正常启动，换算成节拍持续时间就是<span class="math inline">\(\frac{1s}{550}=1.8ms\)</span>，也就是说每个节拍之后都需要延时这段时间才能保证步进电机正常工作。</p>
</blockquote>
<p>当前电路当中，步进电机控制模块与 LED
控制模块的<strong>74HC138</strong>译码器共同复用单片机的<code>P1.0 ~ P1.3</code>引脚，通过调整<strong>跳线帽</strong>位置可以切换<code>P1.0 ~ P1.3</code>去控制步进电机的四个绕组。</p>
<figure>
<img src="/Embedded/STC89C52/Motor/diagram.png" alt="type-matrix">
<figcaption aria-hidden="true">type-matrix</figcaption>
</figure>
<p>另外，由于单片机 IO 接口输出电流能力较弱，所以每相控制线上都添加了
9012
三极管提高驱动能力。结合上面的电路图和八拍模式绕组控制顺序表，如果要让<strong>A</strong>相绕组导通，则三极管<strong>Q2</strong>必须导通，此时<strong>A
相</strong>对应的橙色线相当于接地，单片机<strong>P1</strong>引脚低 4
位应输出<code>0b1110</code>（即<code>0xE</code>）；如要让<strong>A</strong>、<strong>B</strong>相同时导通，那么就需要三极管<strong>Q2</strong>、<strong>Q3</strong>导通，<strong>P1</strong>引脚低
4
位应输出<code>0b1100</code>（即<code>0xC</code>），依此类推就可以得出八拍模式下的单片机
IO 控制码数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123; <span class="number">0xE</span>, <span class="number">0xC</span>, <span class="number">0xD</span>, <span class="number">0x9</span>, <span class="number">0xB</span>, <span class="number">0x3</span>, <span class="number">0x7</span>, <span class="number">0x6</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，开始着手编写一个五线四相步进电机在八节拍工作模式下的测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 八拍模式下的单片机 IO 控制码 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0xE</span>, <span class="number">0xC</span>, <span class="number">0xD</span>, <span class="number">0x9</span>, <span class="number">0xB</span>, <span class="number">0x3</span>, <span class="number">0x7</span>, <span class="number">0x6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时函数，延时约2ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;             <span class="comment">// 临时变量</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>;       <span class="comment">// 节拍输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    tmp = P1;                    <span class="comment">// 缓存P1引脚当前状态</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xF0</span>;            <span class="comment">// 采用位运算 &amp; 清零低 4 位</span></span><br><span class="line">    tmp = tmp | BeatCode[index]; <span class="comment">// 采用位运算 | 将节拍代码写入低4位</span></span><br><span class="line">    P1 = tmp;                    <span class="comment">// 将低 4 位节拍代码与高 4 位原值发送给 P1</span></span><br><span class="line">    index++;                     <span class="comment">// 节拍输出索引自增 1</span></span><br><span class="line">    index = index &amp; <span class="number">0x07</span>;        <span class="comment">// 索引值自增到 8 以后归零</span></span><br><span class="line">    delay();                     <span class="comment">// 延时 2ms，即每 2ms 执行一拍</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>八拍模式下，步进电机转子转动一圈需要<code>64</code>个节拍，而其减速比为<code>1:64</code>，即转子转动<code>64</code>圈输出轴才会转动<code>1</code>圈，即步进电机输出轴转动一圈需要<code>64 × 64 = 4096</code>拍，其中每个节拍的步进角度为<code>360 ÷ 4096 ≈ 0.09</code>。步进电机的特点是可以精确控制转动幅度，因此可以让步进电机旋转多圈以后，检查其转轴是否停留在原来位置，从而确定其具体的转动精度。这里修改一下上面的程序，便于控制步进电机转动任意圈数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时函数，延时约2ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机转动控制函数，参数 angle 表示需要转动的角度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TurnMotor</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> angle)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;             <span class="comment">// 临时变量</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>;       <span class="comment">// 节拍输出索引</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> beats = <span class="number">0</span>;       <span class="comment">// 所需节拍总数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 八拍模式下的单片机 IO 控制码 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0xE</span>, <span class="number">0xC</span>, <span class="number">0xD</span>, <span class="number">0x9</span>, <span class="number">0xB</span>, <span class="number">0x3</span>, <span class="number">0x7</span>, <span class="number">0x6</span>&#125;;</span><br><span class="line"></span><br><span class="line">  beats = (angle * <span class="number">4096</span>) / <span class="number">360</span>;  <span class="comment">// 计算所需节拍总数，64×64=4096 拍对应一圈</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断 beats 不为 0 时执行循环，然后自减 1 */</span></span><br><span class="line">  <span class="keyword">while</span> (beats--) &#123;</span><br><span class="line">    tmp = P1;                    <span class="comment">// 缓存P1引脚当前状态</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xF0</span>;            <span class="comment">// 采用位运算 &amp; 清零低 4 位</span></span><br><span class="line">    tmp = tmp | BeatCode[index]; <span class="comment">// 采用位运算 | 将节拍代码写入低4位</span></span><br><span class="line">    P1 = tmp;                    <span class="comment">// 将低 4 位节拍代码与高 4 位原值发送给 P1</span></span><br><span class="line">    index++;                     <span class="comment">// 节拍输出索引自增 1</span></span><br><span class="line">    index = index &amp; <span class="number">0x07</span>;        <span class="comment">// 索引值自增到 8 以后归零</span></span><br><span class="line">    delay();                     <span class="comment">// 延时 2ms，即每 2ms 执行一拍</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  P1 = P1 | <span class="number">0x0F</span>;                <span class="comment">// 关闭步进电机所有相</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  TurnMotor(<span class="number">360</span> * <span class="number">25</span>); <span class="comment">// 转动 25 圈</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序执行完成之后，会发现输出轴最后停下的位置存在一定误差，经计算后实际减速比约为<code>1 : 63.684</code>，因此其转动一圈所需的节拍数应为<code>64 × 63.684 ≈ 4076</code>，如果将上面电机控制函数<code>TurnMotor()</code>里的<code>4096</code>修改为<code>4076</code>，就可以有效的校正这个误差。</p>
<blockquote>
<p>注意：造成误差的原因在于<strong>28BYJ-48</strong>最初是设计用于控制空调扇叶，转动范围通常不超过
180
度，厂商给出近似的整数减速比<code>1 : 64</code>，实质上相对于这类应用场景已经足够精确。</p>
</blockquote>
<p>精度问题讨论清楚以后，再将目光放回到电机控制程序。上述步进电机示例程序由于存在大段延时，从而阻塞单片机其它任务的执行，生产环境下通常会改用定时中断来进行节拍的刷新，进一步对上面的示例程序进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> beats = <span class="number">0</span>; <span class="comment">// 步进电机转动总节拍数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机启动函数，参数 angle 表示需要转动的角度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> angle)</span> &#123;</span><br><span class="line">  EA = <span class="number">0</span>;                        <span class="comment">// 节拍计算之前先关闭中断，避免打断计算过程发生错误</span></span><br><span class="line">  beats = (angle * <span class="number">4076</span>) / <span class="number">360</span>;  <span class="comment">// 校正误差，每 4076 拍转动一圈</span></span><br><span class="line">  EA = <span class="number">1</span>;                        <span class="comment">// 节拍计算完成以后再打开中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                        <span class="comment">// 总中断使能</span></span><br><span class="line">  TMOD = <span class="number">0x01</span>;                   <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xF8</span>;</span><br><span class="line">  TL0 = <span class="number">0xCD</span>;                    <span class="comment">// 定时器 T0 赋初值定时 2ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                       <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                       <span class="comment">// 启动定时器 T0</span></span><br><span class="line"></span><br><span class="line">  StartMotor(<span class="number">360</span> * <span class="number">2</span> + <span class="number">180</span>);     <span class="comment">// 控制电机转动 2.5 圈</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于驱动步进电机旋转 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;              <span class="comment">// 临时变量</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>; <span class="comment">// 节拍输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 八拍模式下的单片机 IO 控制码 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0xE</span>, <span class="number">0xC</span>, <span class="number">0xD</span>, <span class="number">0x9</span>, <span class="number">0xB</span>, <span class="number">0x3</span>, <span class="number">0x7</span>, <span class="number">0x6</span>&#125;;</span><br><span class="line">  TH0 = <span class="number">0xF8</span>; TL0 = <span class="number">0xCD</span>;         <span class="comment">// 定时器 T0 重新赋初值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果节拍数不为 0 就产生一个驱动节拍 */</span></span><br><span class="line">  <span class="keyword">if</span> (beats != <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = P1;                     <span class="comment">// 缓存P1引脚当前状态</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xF0</span>;             <span class="comment">// 采用位运算 &amp; 清零低 4 位</span></span><br><span class="line">    tmp = tmp | BeatCode[index];  <span class="comment">// 采用位运算 | 将节拍代码写入低4位</span></span><br><span class="line">    P1 = tmp;                     <span class="comment">// 将低 4 位节拍代码与高 4 位原值发送给 P1</span></span><br><span class="line">    index++;                      <span class="comment">// 节拍输出索引自增 1</span></span><br><span class="line">    index = index &amp; <span class="number">0x07</span>;         <span class="comment">// 索引值自增到 8 以后归零</span></span><br><span class="line">    beats--;                      <span class="comment">// 总节拍数自减 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果节拍数为 0 就关闭所有相 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    P1 = P1 | <span class="number">0x0F</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步进电机启动函数<code>StartMotor()</code>只负责计算总节拍数<code>beats</code>，然后在中断函数<code>InterruptTimer0()</code>当中检查该变量，如果不为<code>0</code>就执行节拍操作，同时对其执行自减<code>1</code>的操作，直至减到<code>0</code>为止。</p>
<blockquote>
<p>需要特别说明的是<code>StartMotor()</code>函数里对于总中断使能<code>EA</code>的两次操作，在计算<code>beats</code>之前首先关闭总中断使能，让单片机在计算过程中不响应中断事件，待计算完成之后再重新打开。即使这个过程中定时器发生了溢出，也只能等到<code>EA</code>重新置<code>1</code>使能之后，中断服务函数<code>InterruptTimer0()</code>才会开始响应。这样做的原因在于，<strong>STC89C52RC</strong>单片机操作数据都是按照
8 个位来进行，处理多个字节数据（变量<code>beats</code>就是占用 4
字节存储空间的<code>unsigned long</code>类型）的时候则需要分批执行，如果这个过程中恰好发生了中断，中断服务函数<code>InterruptTimer0()</code>将被自动调用，而该函数会对变量<code>beats</code>进行自减<code>1</code>操作，此时自减<code>1</code>的结果将不会是预期的值，最终就会造成错误的发生。如果这里的<code>beats</code>使用<code>char</code>或者<code>bit</code>数据类型，单片机一次就可以操作完成，即使不关闭总中断也不会发生错误。</p>
</blockquote>
<h2 id="按键控制步进电机实验">按键控制步进电机实验</h2>
<p>本节内容的最后，结合步进电机和按键程序来完成一个综合试验：【数字键】控制电机转动<code>1 ~ 9</code>圈，【上下键】改变电机转动的方向，【左右键】分别正反转
90 度，【Esc 键】停止转动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit KEY_IN_1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY_IN_2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY_IN_3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY_IN_4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_OUT_1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KEY_OUT_2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KEY_OUT_3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KEY_OUT_4 = P2 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键编号和标准键盘键码的映射表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span>&#125;,  <span class="comment">// 数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123;<span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span>&#125;,  <span class="comment">// 数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123;<span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span>&#125;,  <span class="comment">// 数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123;<span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span>&#125;   <span class="comment">// 数字键 0、ESC 键、回车键、向右键</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的全部状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeySta[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> beats = <span class="number">0</span>;    <span class="comment">// 所需的节拍总数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                 <span class="comment">// 总中断使能</span></span><br><span class="line">  TMOD = <span class="number">0x01</span>;            <span class="comment">// 设置 T0 为模式 1</span></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>; <span class="comment">// 定时器 T0 赋初值 0xFC67，定时 1ms</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                <span class="comment">// 启动定时器 T0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();          <span class="comment">// 按键驱动函数调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机启动函数，angle-需转过的角度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> angle)</span> &#123;</span><br><span class="line">  <span class="comment">// 在计算前关闭中断，完成后再打开，以避免中断打断计算过程而造成错误</span></span><br><span class="line">  EA = <span class="number">0</span>;</span><br><span class="line">  beats = (angle * <span class="number">4076</span>) / <span class="number">360</span>; <span class="comment">//实测为4076拍转动一圈</span></span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机停止函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopMotor</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">0</span>;</span><br><span class="line">  beats = <span class="number">0</span>;</span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据键码执行相应操作，参数 keycode 是按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="type">static</span> bit dirMotor = <span class="number">0</span>;    <span class="comment">//电机转动方向</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数字键，控制电机转动 1~9 圈 */</span></span><br><span class="line">  <span class="keyword">if</span> ((keycode &gt;= <span class="number">0x30</span>) &amp;&amp; (keycode &lt;= <span class="number">0x39</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirMotor == <span class="number">0</span>)</span><br><span class="line">      StartMotor(<span class="number">360</span> * (keycode - <span class="number">0x30</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      StartMotor(<span class="number">-360</span> * (keycode - <span class="number">0x30</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向上键，控制转动方向为正转 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    dirMotor = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向下键，控制转动方向为反转 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) &#123;</span><br><span class="line">    dirMotor = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向左键，正转90度 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x25</span>) &#123;</span><br><span class="line">    StartMotor(<span class="number">90</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向右键，反转90度 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x27</span>) &#123;</span><br><span class="line">    StartMotor(<span class="number">-90</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*  Esc键，停止转动 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x1B</span>) &#123;</span><br><span class="line">    StopMotor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作并执行相应任务，需要在主函数中循环调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 键值备份，保存前一次的矩阵按键状态 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环扫描 4*4 矩阵按键 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测按键动作 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup[i][j] != KeySta[i][j]) &#123;</span><br><span class="line">        <span class="comment">/* 按键按下时需要执行的任务 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">          KeyAction(KeyCodeMap[i][j]); <span class="comment">// 调用按键动作函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        backup[i][j] = KeySta[i][j];   <span class="comment">// 更新前一次备份的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需要在定时中断函数中调用，推荐调用间隔 1ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keyout = <span class="number">0</span>; <span class="comment">// 矩阵按键扫描输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 矩阵按键扫描缓冲区 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将一行上 4 个按键的值移入缓冲区 */</span></span><br><span class="line">  keybuf[keyout][<span class="number">0</span>] = (keybuf[keyout][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_1;</span><br><span class="line">  keybuf[keyout][<span class="number">1</span>] = (keybuf[keyout][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_2;</span><br><span class="line">  keybuf[keyout][<span class="number">2</span>] = (keybuf[keyout][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_3;</span><br><span class="line">  keybuf[keyout][<span class="number">3</span>] = (keybuf[keyout][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 完成消抖之后更新按键的状态，因为每行 4 个按键，所以要循环 4 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行下一次扫描输出 */</span></span><br><span class="line">  keyout++;               <span class="comment">// 输出索引自增</span></span><br><span class="line">  keyout = keyout &amp; <span class="number">0x03</span>; <span class="comment">// 索引值自增到 4 以后归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据索引值释放当前输出引脚，并拉低下次的输出引脚 */</span></span><br><span class="line">  <span class="keyword">switch</span> (keyout) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: KEY_OUT_4 = <span class="number">1</span>; KEY_OUT_1 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: KEY_OUT_1 = <span class="number">1</span>; KEY_OUT_2 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: KEY_OUT_2 = <span class="number">1</span>; KEY_OUT_3 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: KEY_OUT_3 = <span class="number">1</span>; KEY_OUT_4 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机转动控制函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TurnMotor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;              <span class="comment">// 临时变量</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>; <span class="comment">// 节拍输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 八拍模式下的单片机 IO 控制码 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0xE</span>, <span class="number">0xC</span>, <span class="number">0xD</span>, <span class="number">0x9</span>, <span class="number">0xB</span>, <span class="number">0x3</span>, <span class="number">0x7</span>, <span class="number">0x6</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果节拍数不为 0 就产生一个驱动节拍 */</span></span><br><span class="line">  <span class="keyword">if</span> (beats != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节拍数大于 0 时正转 */</span></span><br><span class="line">    <span class="keyword">if</span> (beats &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      index++;                   <span class="comment">// 正转时节拍输出索引递增</span></span><br><span class="line">      index = index &amp; <span class="number">0x07</span>;      <span class="comment">// 索引值自增到 8 以后归零</span></span><br><span class="line">      beats--;                   <span class="comment">// 正转时节拍计数递减</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 节拍数小于 0 时反转 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      index--;                   <span class="comment">// 反转时节拍输出索引递减</span></span><br><span class="line">      index = index &amp; <span class="number">0x07</span>;      <span class="comment">// 索引值自增到 -1 以后置为 7</span></span><br><span class="line">      beats++;                   <span class="comment">// 反转时节拍计数递增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = P1;                    <span class="comment">// 缓存P1引脚当前状态</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xF0</span>;            <span class="comment">// 采用位运算 &amp; 清零低 4 位</span></span><br><span class="line">    tmp = tmp | BeatCode[index]; <span class="comment">// 采用位运算 | 将节拍代码写入低4位</span></span><br><span class="line">    P1 = tmp;                    <span class="comment">// 将低 4 位节拍代码与高 4 位原值发送给 P1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果节拍数为 0 就关闭步进电机所有相 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    P1 = P1 | <span class="number">0x0F</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于按键扫描与电机转动控制 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> bit div = <span class="number">0</span>;       <span class="comment">// 定义一个静态的 bit 类型变量</span></span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFC</span>; TL0 = <span class="number">0x67</span>;   <span class="comment">// 定时器 T0 重新赋初值</span></span><br><span class="line"></span><br><span class="line">  KeyScan();                <span class="comment">// 调用按键扫描函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用变量 div 实现二分频，即 2ms 的定时，用于控制步进电机 */</span></span><br><span class="line">  div = ~div;</span><br><span class="line">  <span class="keyword">if</span> (div == <span class="number">1</span>) &#123;</span><br><span class="line">    TurnMotor();            <span class="comment">// 调用电机驱动函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，电机的正转和反转，并没有通过建立不同的函数来区分，而是通过将步进电机启动函数<code>void StartMotor(signed long angle)</code>中形式参数<code>angle</code>的数据类型从<code>unsigned long</code>调整为<code>signed long</code>来进行区分，即通过有符号数据类型固有的<strong>正负</strong>特性来区分<strong>正反</strong>转，正数表示正转<code>angle</code>度，负数表示反转<code>angle</code>度，这样处理起来简单明了。</p>
<p>另外，由于中断函数中需要处理<strong>按键扫描</strong>和<strong>电机驱动</strong>两件事情，为避免中断函数编写过于复杂，上面代码中将这两个功能分离为两个独立的函数。这里还有一个值得注意的问题，按键扫描采用的定时时间是<code>1ms</code>，而本实验之前代码中步进电机节拍的持续时间都是<code>2ms</code>。显然采用<code>1ms</code>的定时可以得到<code>2ms</code>的间隔，而采用<code>2ms</code>定时却不能得到准确的<code>1ms</code>间隔；因此上面代码中，定时器选择定时<code>1ms</code>，然后使用一个<code>bit</code>类型的变量做为标志，每<code>1ms</code>改变一次它的值，但只选择当其值为<code>1</code>时执行一次操作，这样就可以得到<code>2ms</code>间隔的效果；如果需要<code>3ms</code>、<code>4ms</code>...等更长的间隔，就可以考虑将<code>bit</code>更换为<code>char</code>或者<code>int</code>类型，然后再对其进行递增操作。</p>
<h1 id="蜂鸣器">蜂鸣器</h1>
<p>蜂鸣器常用于电子设备发出提示音，按照驱动方式可以分为<strong>有源</strong>和<strong>无源</strong>两种，这里的<strong>源</strong>并非指电源，而是指<strong>振荡源</strong>。有源蜂鸣器内部自带振荡源，通电使能以后就会发出震荡源对应的声响。无源蜂鸣器本身不带振荡源，需要向其施加<code>500Hz ~ 4.5KHz</code>之间的脉冲频率进行驱动才会发出声音。</p>
<p><img src="/Embedded/STC89C52/Buzzer/diagram.png"></p>
<p>上面电路图当中，依然采用了 9012
三极管来驱动蜂鸣器，并添加了一枚<code>100Ω</code>的<strong>R7</strong>电阻作为限流电阻。此外还使用了一枚型号为
4148
的二极管<strong>D4</strong>作为<strong>续流二极管</strong>。如果三极管导通蜂鸣器上电，电流就会经过蜂鸣器，电感的电流不能突变，导通时电流逐渐加大，可以正常工作。但是在关断时，<code>电源 - 三极管 - 蜂鸣器 - 接地</code>这条回路被截断，导致电流无法通过，储存的电流就经过这个续流二极管<strong>D4</strong>和蜂鸣器自身的回路消耗掉了，从而避免关断时由于电感的电流造成反向冲击，<strong>接续关断时的电流</strong>，这就是续流二极管称谓的由来。下面将通过编写程序，来完成一个<code>4 kHZ</code>以及<code>1 kHZ</code>频率下的无源蜂鸣器的发声实验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>;                               <span class="comment">// 蜂鸣器的单片机控制引脚</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;                           <span class="comment">// 定时器 T0 重载值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;                           <span class="comment">// 定时器 T0 重载值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器启动函数，参数 frequ 表示工作频率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenBuzz</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> frequ)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reload;                            <span class="comment">// 计算所需的定时器重载值</span></span><br><span class="line">  reload = <span class="number">65536</span> - (<span class="number">11059200</span> / <span class="number">12</span>) / (frequ * <span class="number">2</span>); <span class="comment">// 由给定的频率计算出定时器的重载值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 16 位的重载值分解为高、低两个字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(reload &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)reload;</span><br><span class="line"></span><br><span class="line">  TH0 = <span class="number">0xFF</span>;</span><br><span class="line">  TL0 = <span class="number">0xFE</span>;  <span class="comment">// 设置一个接近溢出的初始值，让定时器马上开始工作</span></span><br><span class="line">  ET0 = <span class="number">1</span>;     <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;     <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器停止函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopBuzz</span><span class="params">()</span> &#123;</span><br><span class="line">  ET0 = <span class="number">0</span>;     <span class="comment">// 禁用定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">0</span>;     <span class="comment">// 停止定时器 T0 运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  TMOD = <span class="number">0x01</span>; <span class="comment">// 配置T0工作在模式1，但先不启动</span></span><br><span class="line">  EA = <span class="number">1</span>;      <span class="comment">// 使能全局中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    OpenBuzz(<span class="number">4000</span>); <span class="comment">// 以 4KHz 频率驱动蜂鸣器</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    StopBuzz();     <span class="comment">// 停止蜂鸣器</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    OpenBuzz(<span class="number">1000</span>); <span class="comment">// 以 1KHz 频率驱动蜂鸣器</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    StopBuzz();     <span class="comment">// 停止蜂鸣器</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于控制蜂鸣器发声 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;   <span class="comment">// 重新加载重载值</span></span><br><span class="line">  BUZZ = ~BUZZ; <span class="comment">// 反转蜂鸣器控制电平状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高精度数字秒表">高精度数字秒表</h1>
<h2 id="定时器中断的精度补偿">定时器中断的精度补偿</h2>
<p>单片机从正常运行状态进入中断，通常需要耗费几个机器周期时间，去完成一些场景保存方面的工作；进入中断以后，重新为定时值存储寄存器<code>TH</code>、<code>TL</code>赋值，同样需要花费几个机器周期时间；此外，硬件问题也会影响到单片机系统的时钟精度，比如晶振的精度会随着温度的变化而发生【温漂】现象，这样就造成了一些不可避免的误差，需要进行相应的补偿。</p>
<ul>
<li><strong>使用【Debug】模式计算补偿值</strong>：进入<strong>Keil
uVision</strong>提供的【Debug】模式计算两次进入中断的时间间隔，观察与实际定时相差的机器周期时间，然后在定时器赋初值时补偿相应的机器周期时间。</li>
<li><strong>通过累计误差进行计算</strong>：让时钟运行一段相对比较长的时间，观察最终时间与实际时间的误差，然后计算进入定时器中断的次数，将误差的时间平均分配到每次定时器中断，从而完成误差的校正。</li>
</ul>
<blockquote>
<p>精确是一个相对的概念，因此只能在一定程度上提高精度，但是永远不能使误差为零。后续小节将要介绍的<strong>DS1302</strong>实时时钟芯片，其计时精度相对单片机内置的定时器更高。</p>
</blockquote>
<h2 id="不可位寻址寄存器的位操作">不可位寻址寄存器的位操作</h2>
<p>另外，对于诸如<code>TMOD</code>这样的不支持位寻址的寄存器，如果需要对指定的位进行赋值，而又不想影响其它位的状态，这种情况下可以考虑采用位运算<code>&amp;</code>和<code>|</code>来完成赋值。无论该位的初始值是<code>0</code>还是<code>1</code>，跟<code>0</code>进行与运算<code>&amp;</code>得到的结果都是<code>0</code>，跟<code>1</code>进行与运算<code>&amp;</code>得到的结果是初始值本身。与之相对应，无论该位的初始值是<code>0</code>还是<code>1</code>，跟<code>1</code>进行或运算<code>|</code>得到的结果都是<code>1</code>，跟<code>0</code>进行或运算<code>|</code>得到的结果是初始值本身。</p>
<p>例如现在要设置<code>TMOD</code>使<strong>定时器
T0</strong>工作在<strong>模式
1</strong>，而又不希望对同一寄存器上的<strong>定时器
T1</strong>配置造成干扰，那么可以通过<code>TMOD = TMOD &amp; 0xF0; TMOD = TMOD | 0x01;</code>语句达成目的。这段代码中，首先和<code>0xF0</code>进行与运算<code>&amp;</code>，高四位不变低四位被清零，得到的结果为<code>0bxxxx0000</code>。然后再同<code>0x01</code>进行或运算<code>|</code>，此时高七位不变最低一位变成<code>1</code>，得到的结果为<code>0bxxxx0001</code>，这样就达成了将低四位值修改为<code>0b0001</code>，而高四位保持原值不变<code>0bxxxx</code>的目的，即只对<strong>定时器
T0</strong>进行配置，而不会影响<strong>定时器 T1</strong>。</p>
<h2 id="改进数码管扫描函数">改进数码管扫描函数</h2>
<p>前面小节的内容当中，数码管的动态扫描函数采用了下面的<code>switch()</code>语句来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P0 = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">0</span>; i++; P0=LedBuff[<span class="number">0</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">1</span>; i++; P0=LedBuff[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">0</span>; i++; P0=LedBuff[<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">1</span>; i++; P0=LedBuff[<span class="number">3</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">0</span>; i++; P0=LedBuff[<span class="number">4</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">1</span>; i=<span class="number">0</span>; P0=LedBuff[<span class="number">5</span>]; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码里每个<code>case</code>分支的结构都是相同的，即首先来修改<code>ADDR2</code>、<code>ADDR1</code>、<code>ADDR0</code>这三个<strong>74HC138</strong>译码器的输入端，然后让索引变量<code>i</code>自增<code>1</code>，最后将缓冲区的数据写入<code>P0</code>。仔细分析代码可以发现，<code>case</code>后的选择条件常量与<code>ADDRx</code>以及<code>LedBuff</code>的下标相等，因此可以考虑直接将条件常量赋值给它们，而不必再使用冗长的<code>switch()</code>语句。而对于索引变量<code>i</code>，一共进行了五次自增和一次归零运算，因此可以使用自增运算符<code>++</code>以及<code>if</code>判断语句来实现。由于<code>ADDR2</code>、<code>ADDR1</code>、<code>ADDR0</code>端通过跳线帽与单片机的<code>P1.2</code>、<code>P1.1</code>、<code>P1.0</code>引脚相连，改进后的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P0 = <span class="number">0xFF</span>;</span><br><span class="line">P1 = (P1 &amp; <span class="number">0xF8</span>) | i;</span><br><span class="line">P0 = LedBuff[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写秒表实验程序">编写秒表实验程序</h2>
<p>接下来，结合上述的改进内容，综合应用定时器、数码管、中断、按键，完成一个实用的秒表程序，在计数保留到小数点后两位（<em>每<code>10ms</code>完成一次计数</em>）的同时，对定时器中断延时所造成的误差进行补偿。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示缓冲区 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的全部状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeySta[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">bit StopwatchRunning = <span class="number">0</span>;      <span class="comment">// 秒表运行标志</span></span><br><span class="line">bit StopwatchRefresh = <span class="number">1</span>;      <span class="comment">// 秒表刷新标志</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> DecimalPart = <span class="number">0</span>; <span class="comment">// 秒表小数部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> IntegerPart = <span class="number">0</span>;  <span class="comment">// 秒表整数部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;        <span class="comment">// 定时器 T0 重载值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;        <span class="comment">// 定时器 T0 重载值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StopwatchDisplay</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 总中断使能</span></span><br><span class="line">  ENLED = <span class="number">0</span>;</span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  P2 = <span class="number">0xFE</span>;       <span class="comment">// 选择第 4 行按键作为独立按键</span></span><br><span class="line">  ConfigTimer0(<span class="number">2</span>); <span class="comment">// 配置定时器 T0 去定时 2ms</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果秒表当前没有刷新，就调用秒表计数显示函数*/</span></span><br><span class="line">    <span class="keyword">if</span> (StopwatchRefresh) &#123;</span><br><span class="line">      StopwatchRefresh = <span class="number">0</span>;</span><br><span class="line">      StopwatchDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    KeyDriver();   <span class="comment">// 调用按键驱动函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示需要定时的时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">18</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;           <span class="comment">// 加载定时器 T0 重载值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表计数显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopwatchDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">4</span>]; <span class="comment">// 数据转换缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 小数部分转换到低 2 位 */</span></span><br><span class="line">  LedBuff[<span class="number">0</span>] = LedChar[DecimalPart % <span class="number">10</span>];</span><br><span class="line">  LedBuff[<span class="number">1</span>] = LedChar[DecimalPart / <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 整数部分转换到高 4 位 */</span></span><br><span class="line">  buf[<span class="number">0</span>] = IntegerPart % <span class="number">10</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = (IntegerPart / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">  buf[<span class="number">2</span>] = (IntegerPart / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">  buf[<span class="number">3</span>] = (IntegerPart / <span class="number">1000</span>) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将整数部分高位的 0 转换为空字符 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">      LedBuff[i + <span class="number">2</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将有效数字位转换为数码管要显示的字符 */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LedBuff[i + <span class="number">2</span>] = LedChar[buf[i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LedBuff[<span class="number">2</span>] &amp;= <span class="number">0x7F</span>; <span class="comment">// 点亮数码管的小数点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表启停函数，如果启动就停止，如果停止就启动 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopwatchAction</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StopwatchRunning)</span><br><span class="line">    StopwatchRunning = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    StopwatchRunning = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表复位函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopwatchReset</span><span class="params">()</span> &#123;</span><br><span class="line">  StopwatchRunning = <span class="number">0</span>; <span class="comment">// 停止秒表</span></span><br><span class="line">  DecimalPart = <span class="number">0</span>;      <span class="comment">// 清零计数值</span></span><br><span class="line">  IntegerPart = <span class="number">0</span>;</span><br><span class="line">  StopwatchRefresh = <span class="number">1</span>; <span class="comment">// 重置刷新标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，用于检测按键动作并调用相应的动作函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> backup[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环检测 4 个按键 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (backup[i] != KeySta[i]) &#123;</span><br><span class="line">      <span class="comment">/* 如果按键已经按下 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup[i] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Esc键复位秒表 */</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">          StopwatchReset();</span><br><span class="line">        <span class="comment">/* 回车键启停秒表 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">          StopwatchAction();</span><br><span class="line">      &#125;</span><br><span class="line">      backup[i] = KeySta[i]; <span class="comment">// 刷新前一次的备份值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//按键扫描缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将按键值移入缓冲区 */</span></span><br><span class="line">  keybuf[<span class="number">0</span>] = (keybuf[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY1;</span><br><span class="line">  keybuf[<span class="number">1</span>] = (keybuf[<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY2;</span><br><span class="line">  keybuf[<span class="number">2</span>] = (keybuf[<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY3;</span><br><span class="line">  keybuf[<span class="number">3</span>] = (keybuf[<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 按键消抖处理以后更新状态 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 连续 8 次扫描值都为 0 ，即 16ms 内都处于按下状态时，就认为按键已经稳定的按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (keybuf[i] == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 8 次扫描值都为 1 ，即 16ms 内都处于弹起状态时，就认为按键已经稳定的弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keybuf[i] == <span class="number">0xFF</span>) &#123;</span><br><span class="line">      KeySta[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，定时中断内调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>; <span class="comment">// 动态扫描索引</span></span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                  <span class="comment">// 关闭所有数码管段选进行消隐</span></span><br><span class="line">  P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">// 将位选索引值赋值给 P1 的低 3 位</span></span><br><span class="line">  P0 = LedBuff[i];            <span class="comment">// 将缓冲区指定索引位置的数据赋值给 P0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历整个缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表计数函数，每隔 10ms 调用一次，进行秒表计数累加 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopwatchCount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 处于运行状态时递增计数值 */</span></span><br><span class="line">  <span class="keyword">if</span> (StopwatchRunning) &#123;</span><br><span class="line">    DecimalPart++;              <span class="comment">// 小数部分自增 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 小数部分满 100 进位到整数部分 */</span></span><br><span class="line">    <span class="keyword">if</span> (DecimalPart &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">      DecimalPart = <span class="number">0</span>;</span><br><span class="line">      IntegerPart++;            <span class="comment">// 整数部分自增 1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 整数部分满 10000 进行归零 */</span></span><br><span class="line">      <span class="keyword">if</span> (IntegerPart &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">        IntegerPart = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StopwatchRefresh = <span class="number">1</span>;       <span class="comment">// 重置秒表计数刷新标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于执行数码管显示、按键扫描、秒表计数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr10ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL; <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">  LedScan();              <span class="comment">// 数码管扫描</span></span><br><span class="line">  KeyScan();              <span class="comment">// 按键扫描</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时10ms进行一次秒表计数 */</span></span><br><span class="line">  tmr10ms++;</span><br><span class="line">  <span class="keyword">if</span> (tmr10ms &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">    tmr10ms = <span class="number">0</span>;</span><br><span class="line">    StopwatchCount();     <span class="comment">// 调用秒表计数函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面代码中，将定时器相关的配置抽象为了一个可复用的函数，后面再遇到类似需要定时指定毫秒数的场景，就可以直接以毫秒数作为参数调用该函数即可。由于秒表需要的按键数量不多，所以代码中没有使用到矩阵按键，而是将矩阵按键第
4 行复用为了独立按键，尽量简化问题的处理。</p>
<h1 id="脉冲宽度调制-pwm">脉冲宽度调制 PWM</h1>
<p><strong>PWM</strong>是<strong>脉冲宽度调制</strong>（Pulse Width
Modulation）的英文缩写，意思是通过改变单片机输出脉冲的宽度来实现特定的功能，比如使用数字信号来控制模拟电路。</p>
<p><img src="/Embedded/STC89C52/waveform.png"></p>
<p>上图表达的是一个周期为<code>10ms</code>频率为<code>100Hz</code>的波形，但是每个周期内的高低电平脉冲宽度并不相同，这正是<strong>PWM</strong>的本质。这里要注意一个<strong>占空比</strong>的概念，所谓占空比就是指<strong>高电平时间</strong>占据<strong>整个周期</strong>的比例。例如上图第一部分波形的占空比为<code>4ms ÷ (4ms + 6ms) = 40%</code>，第二部分波形的占空比是<code>6ms ÷ (6ms + 4ms) = 60%</code>，第三部分波形的占空比是<code>8ms ÷ (8ms + 2ms) = 80%</code>。</p>
<p>第 3 小节点亮 LED 的程序当中，单片机输出低电平 LED
就会长亮，反之输出高电平 LED 就会熄灭。如果调整 LED
亮灭状态切换的间隔时间到肉眼无法分辨（大于<code>100Hz</code>）的程度，就可以基于
PWM 的原理完成对 LED 亮度的控制。接下来通过定时器 T0
改变<strong>P0.0</strong>引脚的输出，从而实现对 LED 的 PWM
控制。注意每个周期都需要重载两次定时器初值，从而控制高低电平的不同持续时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit PWMOUT = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高电平定时值高低字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> HighRH = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> HighRL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 低电平定时值高低字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LowRH = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LowRL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动 PWM，参数 fr 是频率，参数 dc 是占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigPWM</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fr, <span class="type">unsigned</span> <span class="type">char</span> dc)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> high, low;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">  tmp = (<span class="number">11059200</span> / <span class="number">12</span>) / fr; <span class="comment">// 计算一个机器周期所需要的计数值</span></span><br><span class="line"></span><br><span class="line">  high = (tmp * dc) / <span class="number">100</span>;    <span class="comment">// 计算高电平所需要的计数值</span></span><br><span class="line">  low = tmp - high;           <span class="comment">// 计算低电平所需要的计数值</span></span><br><span class="line">  high = <span class="number">65536</span> - high + <span class="number">12</span>;   <span class="comment">// 计算高电平的重载值并补偿中断延时</span></span><br><span class="line">  low = <span class="number">65536</span> - low + <span class="number">12</span>;     <span class="comment">// 计算低电平的重载值并补偿中断延时</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 高电平重载值拆分为高低字节 */</span></span><br><span class="line">  HighRH = (<span class="type">unsigned</span> <span class="type">char</span>)(high &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  HighRL = (<span class="type">unsigned</span> <span class="type">char</span>)high;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低电平重载值拆分为高低字节 */</span></span><br><span class="line">  LowRH = (<span class="type">unsigned</span> <span class="type">char</span>)(low &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  LowRL = (<span class="type">unsigned</span> <span class="type">char</span>)low;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;               <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;               <span class="comment">// 设置 T0 为工作模式 1</span></span><br><span class="line">  TH0 = HighRH; TL0 = HighRL; <span class="comment">// 赋予定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                    <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                    <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  PWMOUT = <span class="number">1</span>;                 <span class="comment">// 输出高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭PWM */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClosePWM</span><span class="params">()</span> &#123;</span><br><span class="line">  TR0 = <span class="number">0</span>;    <span class="comment">// 停止定时器</span></span><br><span class="line">  ET0 = <span class="number">0</span>;    <span class="comment">// 禁止中断</span></span><br><span class="line">  PWMOUT = <span class="number">1</span>; <span class="comment">// 输出高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;    <span class="comment">// 使能总中断</span></span><br><span class="line">  ENLED = <span class="number">0</span>; <span class="comment">// 使能 LED</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">1</span>;</span><br><span class="line">  ADDR1 = <span class="number">1</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ConfigPWM(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 频率100Hz，占空比10%</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    ClosePWM();</span><br><span class="line"></span><br><span class="line">    ConfigPWM(<span class="number">100</span>, <span class="number">40</span>); <span class="comment">// 频率100Hz，占空比40%</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    ClosePWM();</span><br><span class="line"></span><br><span class="line">    ConfigPWM(<span class="number">100</span>, <span class="number">90</span>); <span class="comment">// 频率100Hz，占空比90%</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    ClosePWM();         <span class="comment">// 关闭 PWM，即占空比100%</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于产生 PWM 输出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="comment">/* 当前输出为高电平时，赋予低电平定时值并输出低电平 */</span></span><br><span class="line">  <span class="keyword">if</span> (PWMOUT == <span class="number">1</span>) &#123;</span><br><span class="line">    TH0 = LowRH; TL0 = LowRL;</span><br><span class="line">    PWMOUT = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 当前输出为低电平时，赋予高电平定时值并输出高电平 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    TH0 = HighRH; TL0 = HighRL;</span><br><span class="line">    PWMOUT = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>STC89C52RC</strong>单片机内部没有集成 PWM
模块，所以上面代码采用定时器中断的方式来产生
PWM，现代单片机大部份已经集成了硬件 PWM
模块，因此仅仅需要计算周期计数值、占空比计数值，然后配置到相关特殊功能寄存器当中即可，这样既大幅度简化了程序，又消除了中断延时的影响，确保了
PWM 信号的输出品质。</p>
</blockquote>
<p>将上面程序编译并下载到单片机实验电路以后，会观察到 LED 被分为 4
个亮度等级。如果这样的亮度等级更加丰富并且发光连续起来，就可以产生一个
LED 亮度渐变的<strong>呼吸灯</strong>效果，接下来的代码里将会同时使用到
2 个定时器中断来进行如下实验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit PWMOUT = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> PeriodCnt = <span class="number">0</span>; <span class="comment">// PWM周期计数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高电平定时值高低字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> HighRH = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> HighRL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 低电平定时值高低字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LowRH = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LowRL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T1 的定时值高低字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T1RH = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T1RL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigPWM</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fr, <span class="type">unsigned</span> <span class="type">char</span> dc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;             <span class="comment">// 使能总中断</span></span><br><span class="line">  ENLED = <span class="number">0</span>;          <span class="comment">// 使能 LED</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  ADDR2 = <span class="number">1</span>;</span><br><span class="line">  ADDR1 = <span class="number">1</span>;</span><br><span class="line">  ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ConfigPWM(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 配置并启动PWM</span></span><br><span class="line">  ConfigTimer1(<span class="number">50</span>);   <span class="comment">// 调用定时器 T1 调整占空比</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T1，参数 ms 是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算需要的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  T1RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T1RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                     <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x10</span>;                     <span class="comment">// 配置定时器 T1 为工作模式 1</span></span><br><span class="line">  TH1 = T1RH; TL1 = T1RL;           <span class="comment">// 定时器 T1 重新赋初值</span></span><br><span class="line">  ET1 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T1 中断</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动PWM，参数 fr 表示频率，参数 dc 表示占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigPWM</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fr, <span class="type">unsigned</span> <span class="type">char</span> dc)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> high, low;</span><br><span class="line">  PeriodCnt = (<span class="number">11059200</span> / <span class="number">12</span>) / fr; <span class="comment">// 计算一个周期所需的计数值</span></span><br><span class="line"></span><br><span class="line">  high = (PeriodCnt * dc) / <span class="number">100</span>;    <span class="comment">// 计算高电平所需的计数值</span></span><br><span class="line">  low = PeriodCnt - high;           <span class="comment">// 计算低电平所需的计数值</span></span><br><span class="line">  high = <span class="number">65536</span> - high + <span class="number">12</span>;         <span class="comment">// 计算高电平的定时器重载值并补偿中断延时</span></span><br><span class="line">  low = <span class="number">65536</span> - low + <span class="number">12</span>;           <span class="comment">// 计算低电平的定时器重载值并补偿中断延时</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 高电平重载值拆分为高低字节 */</span></span><br><span class="line">  HighRH = (<span class="type">unsigned</span> <span class="type">char</span>)(high &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  HighRL = (<span class="type">unsigned</span> <span class="type">char</span>)high;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低电平重载值拆分为高低字节 */</span></span><br><span class="line">  LowRH = (<span class="type">unsigned</span> <span class="type">char</span>)(low &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  LowRL = (<span class="type">unsigned</span> <span class="type">char</span>)low;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = HighRH; TL0 = HighRL;       <span class="comment">// 赋予定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  PWMOUT = <span class="number">1</span>;                       <span class="comment">// 输出高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 占空比调整函数，频率不变只调整占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDutyCycle</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dc)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> high, low;</span><br><span class="line"></span><br><span class="line">  high = (PeriodCnt * dc) / <span class="number">100</span>; <span class="comment">// 计算高电平所需要的计数值</span></span><br><span class="line">  low = PeriodCnt - high;        <span class="comment">// 计算低电平所需要的计数值</span></span><br><span class="line">  high = <span class="number">65536</span> - high + <span class="number">12</span>;      <span class="comment">// 计算高电平的重载值并补偿中断延时</span></span><br><span class="line">  low = <span class="number">65536</span> - low + <span class="number">12</span>;        <span class="comment">// 计算低电平的重载值并补偿中断延时</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 高电平重载值拆分为高低字节 */</span></span><br><span class="line">  HighRH = (<span class="type">unsigned</span> <span class="type">char</span>)(high &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  HighRL = (<span class="type">unsigned</span> <span class="type">char</span>)high;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低电平重载值拆分为高低字节 */</span></span><br><span class="line">  LowRH = (<span class="type">unsigned</span> <span class="type">char</span>)(low &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  LowRL = (<span class="type">unsigned</span> <span class="type">char</span>)low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于产生PWM输出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="comment">/* 当前输出为高电平时，装载低电平值并输出低电平 */</span></span><br><span class="line">  <span class="keyword">if</span> (PWMOUT == <span class="number">1</span>) &#123;</span><br><span class="line">    TH0 = LowRH; TL0 = LowRL;</span><br><span class="line">    PWMOUT = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 当前输出为低电平时，装载高电平值并输出高电平 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    TH0 = HighRH; TL0 = HighRL;</span><br><span class="line">    PWMOUT = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T1 中断服务函数，动态定时调整占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer1</span><span class="params">()</span> interrupt 3 &#123;</span><br><span class="line">  <span class="type">static</span> bit dir = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 占空比调整表 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code table[<span class="number">13</span>] = &#123;<span class="number">5</span>,  <span class="number">18</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">51</span>, <span class="number">60</span>, <span class="number">68</span>, <span class="number">75</span>, <span class="number">81</span>, <span class="number">86</span>, <span class="number">90</span>, <span class="number">93</span>, <span class="number">95</span>&#125;;</span><br><span class="line"></span><br><span class="line">  TH1 = T1RH; TL1 = T1RL;        <span class="comment">// 定时器 T1 重新赋初值</span></span><br><span class="line"></span><br><span class="line">  AdjustDutyCycle(table[index]); <span class="comment">// 调整 PWM 占空比</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 逐步增加占空比 */</span></span><br><span class="line">  <span class="keyword">if</span> (dir == <span class="number">0</span>) &#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">      dir = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 逐步缩小占空比 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    index--;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      dir = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ram-与长短按键">RAM 与长短按键</h1>
<h2 id="数据存储空间-ram-的划分">数据存储空间 RAM 的划分</h2>
<p><strong>STC89C52RC</strong>的 512 字节 RAM
用来保存数据，程序中定义的变量都保存在 RAM 当中，标准 51 架构单片机的
RAM
是分块的，物理结构和使用方法上有一定区别。<strong>STC89C52RC</strong>将
RAM
存储空间划分为<strong>片内</strong>（<code>256Byte</code>）和<strong>片外</strong>（<code>256Byte</code>）两部分，标准
51 架构片内 RAM
地址从<code>0x00 ~ 0x7F</code>总共<code>128Byte</code>，而<strong>STC89C52RC</strong>将片内
RAM 从<code>0x00 ~ 0xFF</code>扩展为 256 个字节。而片外 RAM
则最大可以扩展至<code>0x0000 ~ 0xFFFF</code>共计<code>64KByte</code>。下面是
8051 C 语言当中的几个关键字，用于将声明的变量划分到不同的 RAM
数据存储区域：</p>
<ul>
<li><code>data</code>：<strong>片内
RAM</strong>是从<code>0x00~0x7F</code>；</li>
<li><code>idata</code>：<strong>片内
RAM</strong>是从<code>0x00~0xFF</code>；</li>
<li><code>pdata</code>：<strong>片外
RAM</strong>是从<code>0x00~0xFF</code>；</li>
<li><code>xdata</code>：<strong>片外
RAM</strong>是从<code>0x0000~0xFFFF</code>。</li>
</ul>
<p>从上面列表可以看出，片内的<code>data</code>是<code>idata</code>一部分，而片外的<code>pdata</code>是<code>xdata</code>一部分。在
8051 C 语言当中，声明的变量默认是<code>data</code>类型，RAM
的<code>data</code>区域在汇编语言中使用直接寻址进行访问，执行速度较快。如果显式定义为<code>idata</code>，不仅可以访问<code>data</code>区域，还可以访问<code>0x80H ~ 0xFF</code>范围的存储空间，此时汇编语言中使用的是通用寄存器间接寻址，速度相对<code>data</code>慢一些。由于<code>0x80H ~ 0xFF</code>区域通常用于中断与函数调用堆栈，大多数情况下，使用内部
RAM 时只用到<code>data</code>区域就可以了。</p>
<p>外部 RAM 当中，使用<code>pdata</code>可以将变量存储到外部 RAM
的<code>0x00 ~ 0xFF</code>地址范围，这块地址与<code>idata</code>一样都采用通用寄存器间接寻址，而如果定义为<code>xdata</code>，则可以访问全部<code>64KByte</code>存储空间，但这里需要额外使用
2
个字节的寄存器<code>DPTRH</code>和<code>DPTRL</code>来进行间接寻址，访问速度最慢。</p>
<blockquote>
<p>片内和片外的区分来自早期 51 架构单片机，现在的 51
芯片已经将两者都集成到了芯片内部。</p>
</blockquote>
<h2 id="长短按键试验">长短按键试验</h2>
<p>之前的按键相关实验当中，按下一次按键就可以执行加<code>1</code>或者减<code>1</code>操作，如果想连续执行同样动作，这样的操作就显得极为不便。如果能一直按住按键不松开，就能完成数值的持续增加或者减小，这样操作就显得更加便捷，这也就是本小节内容将要介绍的长短按键实验。其原理是当检测到按键产生按下的动作之后，立刻执行一次对应操作，同时在程序当中将按键按下的持续时间缓存起来，当这个时间超过<code>1s</code>秒以后（用于区分长/短按两个动作，短按持续时间通常会达到几百毫秒），每间隔<code>200ms</code>毫秒（如果想更快可以选择更短时间）就再自动执行一次该按键对应的操作。</p>
<p>基于上述原理完成这样的实验：单片机上电以后数码管显示数字<code>0</code>，按向上键数字加<code>1</code>，按向下键数字减<code>1</code>，长按向上键<code>1s</code>秒后数字持续增加，长按向下键<code>1s</code>秒后数字持续减小。数字设定完毕按下回车按键就会开始进行倒计时，倒计时归<code>0</code>以后，蜂鸣器会持续发声，并且
8 枚 LED 将会全部点亮。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_IN_1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY_IN_2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY_IN_3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY_IN_4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_OUT_1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KEY_OUT_2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KEY_OUT_3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KEY_OUT_4 = P2 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示缓冲区 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键编号和标准键盘键码的映射表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span>&#125;,  <span class="comment">// 数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123;<span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span>&#125;,  <span class="comment">// 数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123;<span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span>&#125;,  <span class="comment">// 数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123;<span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span>&#125;   <span class="comment">// 数字键 0、ESC 键、回车键、向右键</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的全部状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeySta[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键按下的持续时间，单位为毫秒 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pdata KeyDownTime[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">bit enBuzz = <span class="number">0</span>;                <span class="comment">// 蜂鸣器使能</span></span><br><span class="line">bit flag1s = <span class="number">0</span>;                <span class="comment">// 定时 1 秒标志位</span></span><br><span class="line">bit flagStart = <span class="number">0</span>;             <span class="comment">// 倒计时启动标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;        <span class="comment">// 定时器 T0 重载值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;        <span class="comment">// 定时器 T0 重载值低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> CountDown = <span class="number">0</span>;    <span class="comment">// 倒计时计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                      <span class="comment">// 使能总中断</span></span><br><span class="line">  ENLED = <span class="number">0</span>;                   <span class="comment">// 选中LED与数码管</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);             <span class="comment">// 定时器 T0 定时 1 毫秒</span></span><br><span class="line">  ShowNumber(<span class="number">0</span>);               <span class="comment">// 上电以后数码管默认显示 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();               <span class="comment">// 调用按键驱动函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果倒计时启动，并且经历 1 秒定时时间之后 */</span></span><br><span class="line">    <span class="keyword">if</span> (flagStart &amp;&amp; flag1s) &#123;</span><br><span class="line">      flag1s = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* 如果倒计时还未归 0 */</span></span><br><span class="line">      <span class="keyword">if</span> (CountDown &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CountDown--;</span><br><span class="line">        ShowNumber(CountDown); <span class="comment">// 数码管显示倒计时计数</span></span><br><span class="line">        <span class="comment">/* 如果倒计时已经归 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (CountDown == <span class="number">0</span>) &#123;</span><br><span class="line">          enBuzz = <span class="number">1</span>;          <span class="comment">// 蜂鸣器发声</span></span><br><span class="line">          LedBuff[<span class="number">6</span>] = <span class="number">0x00</span>;   <span class="comment">// 点亮 LED</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">28</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;           <span class="comment">// 加载定时器 T0 重载值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管上显示一个无符号长整型数值，参数 num 表示要显示的数字 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> num)</span> &#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将长整型数值转换为 6 位十进制数组 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    buf[i] = num % <span class="number">10</span>;</span><br><span class="line">    num = num / <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从最高位开始，如果遇到 0 就转换为空格，非 0 则退出循环 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">      LedBuff[i] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 剩下的低位原样转换为数码管要显示的字符 */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据键码执行相应操作，参数 keycode 是按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="comment">/* 向上键，倒计时设定值递增 */</span></span><br><span class="line">  <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    <span class="comment">/* 最大计时时间 9999 秒 */</span></span><br><span class="line">    <span class="keyword">if</span> (CountDown &lt; <span class="number">9999</span>) &#123;</span><br><span class="line">      CountDown++;</span><br><span class="line">      ShowNumber(CountDown);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向下键，倒计时设定值递减 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) &#123;</span><br><span class="line">    <span class="comment">//最小计时1秒</span></span><br><span class="line">    <span class="keyword">if</span> (CountDown &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      CountDown--;</span><br><span class="line">      ShowNumber(CountDown);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 回车键，启动倒计时 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x0D</span>) &#123;</span><br><span class="line">    flagStart = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Esc键，取消倒计时 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x1B</span>) &#123;</span><br><span class="line">    enBuzz = <span class="number">0</span>;        <span class="comment">// 关闭蜂鸣器</span></span><br><span class="line">    LedBuff[<span class="number">6</span>] = <span class="number">0xFF</span>; <span class="comment">// 关闭 LED</span></span><br><span class="line">    flagStart = <span class="number">0</span>;     <span class="comment">// 停止倒计时</span></span><br><span class="line">    CountDown = <span class="number">0</span>;     <span class="comment">// 数码管倒计时显示归零</span></span><br><span class="line">    ShowNumber(CountDown);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 缓存按键前一次的值 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> pdata backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 快速输入执行的时间阈值 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> pdata TimeThr[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;, &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;, &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;, &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环扫描 4*4 矩阵按键 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测按键动作 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup[i][j] != KeySta[i][j]) &#123;</span><br><span class="line">        <span class="comment">/* 当按键按下时 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">          KeyAction(KeyCodeMap[i][j]); <span class="comment">// 调用按键动作函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        backup[i][j] = KeySta[i][j];   <span class="comment">// 更新前一次备份的值</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测执行快速输入 */</span></span><br><span class="line">      <span class="keyword">if</span> (KeyDownTime[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 达到阈值时执行一次动作 */</span></span><br><span class="line">        <span class="keyword">if</span> (KeyDownTime[i][j] &gt;= TimeThr[i][j]) &#123;</span><br><span class="line">          KeyAction(KeyCodeMap[i][j]); <span class="comment">// 调用按键动作函数</span></span><br><span class="line">          TimeThr[i][j] += <span class="number">200</span>;        <span class="comment">// 时间阈值增加 200ms，便于下次执行</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 按键弹起时复位阈值时间 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TimeThr[i][j] = <span class="number">1000</span>;          <span class="comment">// 恢复 1s 初始阈值时间</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keyout = <span class="number">0</span>;  <span class="comment">// 矩阵按键扫描输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 矩阵按键扫描缓冲区 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将一行上 4 个按键的值移入缓冲区 */</span></span><br><span class="line">  keybuf[keyout][<span class="number">0</span>] = (keybuf[keyout][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_1;</span><br><span class="line">  keybuf[keyout][<span class="number">1</span>] = (keybuf[keyout][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_2;</span><br><span class="line">  keybuf[keyout][<span class="number">2</span>] = (keybuf[keyout][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_3;</span><br><span class="line">  keybuf[keyout][<span class="number">3</span>] = (keybuf[keyout][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 完成消抖之后更新按键的状态，因为每行 4 个按键，所以要循环 4 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">0</span>;</span><br><span class="line">      KeyDownTime[keyout][i] += <span class="number">4</span>; <span class="comment">// 累加按下持续时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">1</span>;</span><br><span class="line">      KeyDownTime[keyout][i] = <span class="number">0</span>;  <span class="comment">// 清零按下持续时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行下一次扫描输出 */</span></span><br><span class="line">  keyout++;                        <span class="comment">// 输出索引自增</span></span><br><span class="line">  keyout &amp;= <span class="number">0x03</span>;                  <span class="comment">// 索引值自增到 4 以后归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据索引值释放当前输出引脚，并拉低下次的输出引脚 */</span></span><br><span class="line">  <span class="keyword">switch</span> (keyout) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: KEY_OUT_4 = <span class="number">1</span>; KEY_OUT_1 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: KEY_OUT_1 = <span class="number">1</span>; KEY_OUT_2 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: KEY_OUT_2 = <span class="number">1</span>; KEY_OUT_3 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: KEY_OUT_3 = <span class="number">1</span>; KEY_OUT_4 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，定时中断内调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>; <span class="comment">// 动态扫描索引</span></span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                  <span class="comment">// 数码管显示消隐</span></span><br><span class="line">  P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">// 将位选索引值赋值给 P1 的低 3 位</span></span><br><span class="line">  P0 = LedBuff[i];            <span class="comment">// 将缓冲区指定索引位置的数据赋值给 P0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历整个缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">6</span>)</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于执行数码管显示、按键扫描、秒表计数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> tmr1s = <span class="number">0</span>; <span class="comment">// 1秒定时器</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;        <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enBuzz)</span><br><span class="line">    BUZZ = ~BUZZ;                <span class="comment">// 驱动蜂鸣器发声</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    BUZZ = <span class="number">1</span>;                    <span class="comment">// 关闭蜂鸣器</span></span><br><span class="line"></span><br><span class="line">  LedScan();                     <span class="comment">// LED扫描</span></span><br><span class="line">  KeyScan();                     <span class="comment">// 按键扫描</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 倒计时启动时处理1秒定时 */</span></span><br><span class="line">  <span class="keyword">if</span> (flagStart) &#123;</span><br><span class="line">    tmr1s++;</span><br><span class="line">    <span class="keyword">if</span> (tmr1s &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">      tmr1s = <span class="number">0</span>;</span><br><span class="line">      flag1s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 倒计时未启动时1秒定时器始终归零 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    tmr1s = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="串行通信-uart-与-rs232">串行通信 UART 与 RS232</h1>
<p><strong>UART</strong>串行通信（<strong>通用异步收发器</strong>，Universal
Asynchronous
Receiver/Transmitter）是微控制器设备之间的常用通信技术，<strong>STC89C52RC</strong>的<strong>P3.0/RxD</strong>（接收）和<strong>P3.1/TxD</strong>（发送）引脚可用作串行通信接口，具体接线方式请参见下面的示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5伏设备A       5伏设备B</span><br><span class="line">  TxD  ------&gt;  TxD</span><br><span class="line">  RxD  &lt;------  RxD</span><br><span class="line">  GND  -------  GND</span><br></pre></td></tr></table></figure>
<p><strong>TxD</strong>引脚和<strong>RxD</strong>引脚交叉进行连接，以此作为数据通道。而设备间的<strong>GND</strong>连接在一起，则是为了保持相同的电源基准；UART
通信过程当中，遵循<strong>从低位到高位</strong>的发送顺序（先发低位再发高位），即如果要发送<code>0b11100001</code>这个数据，则将会先发送一个高电平<code>1</code>，再发送一个低电平<code>0</code>，以此类推。而每个二进制数据位的传输速率称为波特率（Baud
rate），即 1
位二进制数据传输的持续时间等于<code>1 / 波特率</code>，单片机设备之间进行通信时双方的波特率必须保持一致。</p>
<p>UART 通信时一个字节为 8
位，没有通讯信号时线路保持高电平<code>1</code>，发送数据时则需要首先发送一个<code>0</code>表示<strong>起始位</strong>，然后再遵循由低位到高位的原则发送
8
位有效<strong>数据位</strong>，数据位发送完成以后会再发一位高电平<code>1</code>表示<strong>停止位</strong>，即总共发送了
10
个二进制位。而作为数据接收方，没有信号时一直保持高电平，一旦检测到一位低电平就会开始准备接收数据，8
位数据位接收完成之后，如果检测到停止位，就会继续准备接收下一位数据，具体可以参考下面的示意图：</p>
<p><img src="/Embedded/STC89C52/UART/frame.png"></p>
<h2 id="rs232-标准接口">RS232 标准接口</h2>
<p>计算机上常用的串行通信接口是<strong>RS-232</strong>，该接口主要有 9
个引脚的<strong>DB-9</strong>以及 25
个引脚的<strong>DB-25</strong>两种类型，计算机上普遍采用的是 9
针的<strong>DB-9</strong>规格， 当计算机通过 RS232
与单片机系统进行通信时，只需要关注其中的<strong>RXD</strong>、<strong>TXD</strong>、<strong>GND</strong>三个引脚即可，各针脚的功能具体定义如下：</p>
<ol type="1">
<li><strong>载波检测</strong> DCD；</li>
<li><strong>接收数据</strong> RXD；</li>
<li><strong>发送数据</strong> TXD；</li>
<li><strong>数据终端准备好</strong> DTR；</li>
<li><strong>信号地线</strong> GND；</li>
<li><strong>数据准备好</strong> DSR；</li>
<li><strong>请求发送</strong> RTS；</li>
<li><strong>清除发送</strong> CTS；</li>
<li><strong>振铃提示</strong> RI。</li>
</ol>
<p>由于 RS-232
标准采用了<strong>负逻辑</strong>（<code>-3V ~ -15V</code>电压代表<code>1</code>，<code>+3 ~ +15V</code>电压代表<code>0</code>，即低电平代表<code>1</code>高电平代表<code>0</code>），因此需要通过一块电平转换芯片<strong>MAX232</strong>与单片机设备进行连接。虽然
RS-232 与 UART
两者都采用了相同的串行通信协议，但使用的电平标准并不相同，而 MAX232
这块芯片可以将计算机输出的 RS-232
电平转换为<strong>STC89C52RC</strong>采用的<code>0V ~ 5.5V</code>标准
UART 电平，从而确保两者的正常通信。</p>
<p><img src="/Embedded/STC89C52/UART/RS232.png"></p>
<p>为了更加清晰的理解 UART
串行通信的原理，接下来将会利用<strong>STC89C52RC</strong>的<strong>P3.0/RxD</strong>和<strong>P3.1/TxD</strong>引脚来模拟串行通信的过程，即通过
STC ISP
提供的【串口调试助手】发送一个数值，单片机接收到该数值以后加上<code>1</code>再自动返回。注意波特率需要根据单片机程序的设定来选择，下面实验程序中一个数据位的电平持续时间为<code>1/9600</code>秒，因而此处波特率就选择了<code>9600</code>，具体设置见下面截图：</p>
<p><img src="/Embedded/STC89C52/UART/ISP.png"></p>
<blockquote>
<p>串口调试助手【发送/接收缓冲区】中的【文本模式】是将数据以 ASCII
编码进行显示，而【HEX 模式】则是将数据按照十六进制格式进行展示。</p>
</blockquote>
<p>接下来的实验代码当中，我们将使用<strong>定时器
T0</strong>的<strong>模式
2</strong>来配置波特率，这里的<code>TH0</code>和<code>TL0</code>不再分别代表高低
8
位，仅仅<code>TL0</code>进行计数，<code>TL0</code>发生溢出之后，对<code>TF0</code>置<code>1</code>的同时，还会将<code>TH0</code>当中的内容自动重装到<code>TL0</code>。这样就可以将所需的定时器初值提前存放于<code>TH0</code>，当<code>TL0</code>溢出以后，就自动将<code>TH0</code>中保存的初始值赋值给<code>TL0</code>，从而代码中无需再对<code>TL0</code>进行赋值。波特率设置完成以后就打开中断，等待串口调试助手下发数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit PIN_RXD = P3 ^ <span class="number">0</span>; <span class="comment">// 接收引脚</span></span><br><span class="line">sbit PIN_TXD = P3 ^ <span class="number">1</span>; <span class="comment">// 发送引脚</span></span><br><span class="line"></span><br><span class="line">bit RxdOrTxd = <span class="number">0</span>; <span class="comment">// 标识当前通信状态是接收 or 发送</span></span><br><span class="line">bit RxdEnd = <span class="number">0</span>;   <span class="comment">// 接收结束标志</span></span><br><span class="line">bit TxdEnd = <span class="number">0</span>;   <span class="comment">// 发送结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> RxdBuf = <span class="number">0</span>; <span class="comment">// 接收缓存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> TxdBuf = <span class="number">0</span>; <span class="comment">// 发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串行配置，参数 baud 表示波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                       <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x02</span>;                       <span class="comment">// 配置定时器 T0 为工作模式 2</span></span><br><span class="line">  TH0 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span>) / baud; <span class="comment">// 计算定时器 T0 的重载值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串行发送，参数 dat 表示等待发送的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTXD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  TxdBuf = dat; <span class="comment">// 将等待发送的数据保存至发送缓存</span></span><br><span class="line">  TL0 = TH0;    <span class="comment">// 设置定时器 T0 的初值为重载值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;      <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;      <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  PIN_TXD = <span class="number">0</span>;  <span class="comment">// 发送起始位</span></span><br><span class="line">  TxdEnd = <span class="number">0</span>;   <span class="comment">// 发送结束标志置 0</span></span><br><span class="line">  RxdOrTxd = <span class="number">1</span>; <span class="comment">// 设置当前通信状态为发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串行接收 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartRXD</span><span class="params">()</span> &#123;</span><br><span class="line">  TL0 = <span class="number">256</span> - ((<span class="number">256</span> - TH0) &gt;&gt; <span class="number">1</span>); <span class="comment">// 接收启动时的 T0 定时为半个波特率周期</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                        <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                        <span class="comment">// 启动定时器 T0</span></span><br><span class="line">  RxdEnd = <span class="number">0</span>;                     <span class="comment">// 接收结束标志置 0</span></span><br><span class="line">  RxdOrTxd = <span class="number">0</span>;                   <span class="comment">// 设置当前通信状态为接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                 <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>);       <span class="comment">// 设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (PIN_RXD);      <span class="comment">// 接收引脚等待串行通信起始位低电平的出现</span></span><br><span class="line">    StartRXD();           <span class="comment">// 开始接收</span></span><br><span class="line">    <span class="keyword">while</span> (!RxdEnd);      <span class="comment">// 等待接收完成</span></span><br><span class="line">    StartTXD(RxdBuf + <span class="number">1</span>); <span class="comment">// 将接收到的数据自增 1 以后发回</span></span><br><span class="line">    <span class="keyword">while</span> (!TxdEnd);      <span class="comment">// 等待发送完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于处理串行通信收发 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 位收发计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理发送 */</span></span><br><span class="line">  <span class="keyword">if</span> (RxdOrTxd) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从低位至高位依次发送 8 bit 数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">      PIN_TXD = TxdBuf &amp; <span class="number">0x01</span>;</span><br><span class="line">      TxdBuf &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 发送停止 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">9</span>) &#123;</span><br><span class="line">      PIN_TXD = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 发送结束 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;    <span class="comment">// 将位收发计数置 0</span></span><br><span class="line">      TR0 = <span class="number">0</span>;    <span class="comment">// 关闭定时器 T0</span></span><br><span class="line">      TxdEnd = <span class="number">1</span>; <span class="comment">// 发送结束标志置 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 处理接收 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 处理起始位 */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 起始位为 0 时，先将接收缓存置 0，然后让位收发计数自增 1 */</span></span><br><span class="line">      <span class="keyword">if</span> (!PIN_RXD) &#123;</span><br><span class="line">        RxdBuf = <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 起始位不为 0 时，关闭定时器 T0 中止接收 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        TR0 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理 8 位数据位 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">      RxdBuf &gt;&gt;= <span class="number">1</span>; <span class="comment">// 低位在前，所以让接收缓存右移 1 位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 接收引脚为高电平 1 时，将接收缓存的最高位置 1，而为 0 时则不进行任何处理 */</span></span><br><span class="line">      <span class="keyword">if</span> (PIN_RXD) &#123;</span><br><span class="line">        RxdBuf |= <span class="number">0x80</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 停止位处理 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cnt = <span class="number">0</span>; <span class="comment">// 位收发计数置 0</span></span><br><span class="line">      TR0 = <span class="number">0</span>; <span class="comment">// 关闭定时器 T0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 当停止位为 1 时才认为数据有效 */</span></span><br><span class="line">      <span class="keyword">if</span> (PIN_RXD) &#123;</span><br><span class="line">        RxdEnd = <span class="number">1</span>; <span class="comment">// 接收结束标志置 1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据串行通信<strong>低电平触发</strong>的原理，上面代码接收数据时，会首先使用<code>while (PIN_RXD)</code>进行低电平检测，未检测到就说明此时没有数据，而一旦检测到低电平就会调用接收函数<code>StartRXD()</code>。接收函数经历半个波特率周期以后（即信号较稳定的中间位置）会进行数据的读取。一旦读到起始低电平<code>0</code>，就将当前状态设置为接收并打开定时器中断。经过半个周期进入中断服务函数以后，会再次对起始位进行判断，以确认其处于低电平状态，而非一个干扰信号。然后每经过<code>1/9600</code>秒进入一次中断，将单片机引脚接收到的电平状态读取至<code>RxdBuf</code>变量。接收完毕之后，将<code>RxdBuf</code>变量的值加<code>1</code>以后再通过<code>TXD</code>引脚发回。同样需要先发送
1 位起始位，再发送 8 个数据位，最后再发送 1
位结束位。完成这一系列操作之后，代码重新循环至<code>while (PIN_RXD)</code>，开始准备下一轮信号的收发。</p>
<p>通信技术按照传输方向可分为单工通信、半双工通信、全双工通信 3
种类型：</p>
<ol type="1">
<li><strong>单工通信</strong>只允许一方向另外一方传送信息，而另一方不能回传信息；</li>
<li><strong>半双工通信</strong>的数据可以在双方之间相互传播，但是同一时刻只能由其中一方发给另外一方；</li>
<li><strong>全双工通信</strong>数据的发送与接收能够同步进行。</li>
</ol>
<p>上述代码通过单片机 IO
接口来模拟串口通信，由于程序需要不间断扫描单片机 IO
接口收到的数据，所以大量占用了单片机运行时间与资源。实际上，<strong>STC89C52RC</strong>单片机已经内置了一个
UART
硬件模块，能够自动接收数据并在接收完成以后通知单片机，开发人员只需配置相关的<strong>串行接口控制寄存器
SCON</strong>即可，该寄存器可以进行位寻址，其具体定义请见下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">串行控制寄存器</th>
<th style="text-align: left;">B7</th>
<th style="text-align: left;">B6</th>
<th style="text-align: left;">B5</th>
<th style="text-align: left;">B4</th>
<th style="text-align: left;">B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>SCON</strong></td>
<td style="text-align: left;">SM0</td>
<td style="text-align: left;">SM1</td>
<td style="text-align: left;">SM2</td>
<td style="text-align: left;">REN</td>
<td style="text-align: left;">TB8</td>
<td>RB8</td>
<td>TI</td>
<td>RI</td>
</tr>
<tr>
<td style="text-align: left;"><strong>复位值</strong></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>SM0/SM1</strong>：两位共同决定串口的通信模式 0~3，其中 1
位起始位、8 位数据位、1 位停止位的模式 1
最为常用，即<code>SM0 = 0; SM1 = 1;</code>；</li>
<li><strong>SM2</strong>：<u>多机通信控制位</u>（极少使用），模式 1
时直接置<code>0</code>；</li>
<li><strong>REN</strong>：<u>串行接收控制位</u>，置<code>1</code>时允许启用<strong>RxD</strong>进行串行接收，置<code>0</code>时则禁止接收；</li>
<li><strong>TB8</strong>： 工作模式 2 或者 3 当中，要发送的第 9
位数据。</li>
<li><strong>RB8</strong>： 工作模式 2 或者 3 当中，接收到的第 9
位数据。</li>
<li><strong>TI</strong>： <u>发送中断请求标志位</u>，工作模式 0
时，串行数据第 8
位<strong>发送</strong>结束时由硬件置<code>1</code>并请求中断，中断响应完成后必须代码手动置<code>0</code>复位；其它工作方式会在接收到停止位中间位置时由硬件自动置<code>1</code>，然后必须通过程序手动置<code>0</code>复位；</li>
<li><strong>RI</strong>： <u>接收中断请求标志位</u>，工作模式 0
时，串行数据第 8
位<strong>接收</strong>结束时由硬件置<code>1</code>并请求中断，中断响应完成后必须代码手动置<code>0</code>复位；其它工作方式会在接收到停止位中间位置时由硬件自动置<code>1</code>，然后必须通过程序手动置<code>0</code>复位。</li>
</ul>
<p>前面使用单片机 IO 接口模拟串口通信的程序当中，波特率是通过定时器 T0
中断来实现的；实际上，<strong>STC89C52RC</strong>内置的 UART
模块已经提供了一个波特率发生器（只能由定时器 T1 和 T2
产生），用于控制数据的收发速率。由于定时器 T2
需要配置额外的寄存器，这里默认使用定时器 T1
作为波特率发生器，而处于工作方式 1 的波特率发生器必须采用定时器 T1
的模式 2 自动重装模式，那么定时值存储寄存器的初始值的计算公式应为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TH1 = TL1 = <span class="number">256</span> - (晶振频率 ÷ <span class="number">12</span> ÷ <span class="number">2</span> ÷ <span class="number">16</span> ÷ 波特率)</span><br></pre></td></tr></table></figure>
<p>值得注意的是，<strong>电源管理寄存器
PCON</strong>的最高位可以将波特率提升一倍，即当<code>PCON |= 0x80</code>的时候，定时值存储寄存器的计算公式应修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TH1 = TL1 = <span class="number">256</span> - (晶振频率 ÷ <span class="number">12</span> ÷ <span class="number">16</span> ÷ 波特率)</span><br></pre></td></tr></table></figure>
<p>上面公式当中的<code>256</code>是 8
位定时器的溢出值，也就是<code>TL1</code>的溢出值；晶振频率为当前电路中使用的<code>11059200</code>；<code>12</code>是指一
个机器周期等于 12 个时钟周期；而数值<code>16</code>是指将一位信号采集 16
次，如果其中的第 7、8、9
次其中两次为高电平<code>1</code>，那么就认为该位处于高电平状态<code>1</code>，如果两次是低电平就认定该位是低电平状态<code>0</code>，这样即便受到意外干扰读错一次数据，也依然能够保证程序的正确性。</p>
<blockquote>
<p>电路中的晶振之所以选用<code>11.0592 MHz</code>，就是由于该值可以在上面的公式中被除尽。</p>
</blockquote>
<p><strong>STC89C52RC</strong>单片机的 UART
串口通信电路，在发送和接收两端分别都采用了 2
个同名称同地址（<code>0x99</code>）的<strong>SBUF
寄存器</strong>，一个用于发送缓冲，另一个用于接收缓冲，从而实现全双工的
UART 通信。但是程序代码当中不会区分收发，而仅仅只需要对 SBUF
寄存器进行操作，单片机会自动选择当前应使用<strong>接收
SBUF</strong>还是<strong>发送 SBUF</strong>。</p>
<h2 id="uart-串口行通信实验">UART 串口行通信实验</h2>
<p>编写一个串行通信相关的程序通常需要经历如下 4 个基本步骤：</p>
<p>1、配置串口为工作模式 1，即<strong>1 位起始位、8 位数据位、1
位停止位</strong>。 2、配置定时器 T1 为工作模式
2，即<strong>自动重装模式</strong>。 3、根据波特率计算定时值存储寄存器
TH1 和 TL1 的值，如有需要可使用电源管理寄存器 PCON 加倍波特率。
4、打开定时器控制寄存器 TR1，使定时器 T1 开始工作。</p>
<blockquote>
<p>注意：当使用定时器 T1 做为波特率发生器的时候，绝对不可以再使能定时器
T1 的中断。</p>
</blockquote>
<p>现在对上面单片机 IO 接口模拟串口通信的程序进行修改，改用单片机内置的
UART
模块来进行实验，由于大部份工作都已经自动化完成，因而程序代码将得到较大幅度的简化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  SCON = <span class="number">0x50</span>;                             <span class="comment">// 配置串口为工作方式 1</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                            <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;                            <span class="comment">// 配置定时器 T1 为工作模式 2</span></span><br><span class="line">  TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">// 计算定时器 T1 的定时值</span></span><br><span class="line">  TL1 = TH1;                               <span class="comment">// 将高位的定时值作为低位的初值</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                                 <span class="comment">// 禁用定时器 T1 中断</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                                 <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ConfigUART(<span class="number">9600</span>);  <span class="comment">// 配置波特率 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!RI);     <span class="comment">// 等待接收完成</span></span><br><span class="line">    RI = <span class="number">0</span>;          <span class="comment">// 清零接收中断标志位</span></span><br><span class="line">    SBUF = SBUF + <span class="number">1</span>; <span class="comment">// 将接收到的数据加 1 以后返回</span></span><br><span class="line">    <span class="keyword">while</span> (!TI);     <span class="comment">// 等待发送完成</span></span><br><span class="line">    TI = <span class="number">0</span>;          <span class="comment">// 清零发送中断标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码依然在<code>while</code>主循环里判断接收/发送中断标志位，实际工程开发当中则会直接使用串口中断，但是要需要注意：由于接收和发送触发的是相同的串口中断，所以中断服务函数内必须首先判断当前属于哪种类型中断，然后再进行相应的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 使能总中断</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 配置波特率为9600</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  SCON = <span class="number">0x50</span>;                             <span class="comment">// 设置串口为工作模式1</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                            <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;                            <span class="comment">// 设置定时器 T1 为工作方式 2</span></span><br><span class="line">  TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">// 设置定时器 T1 的定时值存储寄存器</span></span><br><span class="line">  TL1 = TH1;                               <span class="comment">// 将高位定时值作为低位初值</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                                 <span class="comment">// 禁止定时器 T1 中断</span></span><br><span class="line">  ES = <span class="number">1</span>;                                  <span class="comment">// 使能串口中断</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                                 <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line">  <span class="comment">/* 接收到字节 */</span></span><br><span class="line">  <span class="keyword">if</span> (RI) &#123;</span><br><span class="line">    RI = <span class="number">0</span>;          <span class="comment">// 接收中断标志位置 0</span></span><br><span class="line">    SBUF = SBUF + <span class="number">1</span>; <span class="comment">// 将接收到的数据加 1 以后返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 字节发送完毕 */</span></span><br><span class="line">  <span class="keyword">if</span> (TI) &#123;</span><br><span class="line">    TI = <span class="number">0</span>;          <span class="comment">// 发送中断标志位置 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ascii-编码的串行传输">ASCII 编码的串行传输</h2>
<p>串口通信经常用于不同设备之间的数据交互，比如可以通过计算机控制单片机功能，也可以将单片机相关的日志信息发送给计算机。本小节将会完成这样一个简单示例：将计算机上串口调试助手发送的数据，在单片机电路的数码管上进行显示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示字符编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管显示缓冲区 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;    <span class="comment">// 定时器 T0 存储寄存器高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;    <span class="comment">// 定时器 T0 存储寄存器低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> RxdByte = <span class="number">0</span>; <span class="comment">// 串口接收到的字节数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 总中断使能</span></span><br><span class="line">  ENLED = <span class="number">0</span>;        <span class="comment">// 使能数码管和LED</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);  <span class="comment">// 设置定时器 T0 定时 1ms</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 设置波特率 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将接收到的字节数据在数码管上以十六进制格式显示 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    LedBuff[<span class="number">0</span>] = LedChar[RxdByte &amp; <span class="number">0x0F</span>];</span><br><span class="line">    LedBuff[<span class="number">1</span>] = LedChar[RxdByte &gt;&gt; <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器初始值</span></span><br><span class="line">  tmp = tmp + <span class="number">13</span>;                   <span class="comment">// 中断响应延迟误差补偿</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 设置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;           <span class="comment">// 加载定时器 T0 初始值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  SCON = <span class="number">0x50</span>;                             <span class="comment">// 设置串口为工作模式 1</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                            <span class="comment">// 定时器 T1 控制位清零</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;                            <span class="comment">// 设置定时器 T1 为工作方式 2</span></span><br><span class="line">  TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">// 计算定时器 T1 初始值</span></span><br><span class="line">  TL1 = TH1;                               <span class="comment">// 将高位定时值作为低位的初值</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                                 <span class="comment">// 禁用定时器 T1 中断</span></span><br><span class="line">  ES = <span class="number">1</span>;                                  <span class="comment">// 串口中断使能</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                                 <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，定时中断内调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>; <span class="comment">// 动态扫描索引</span></span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                  <span class="comment">// 关闭所有数码管段选进行消隐</span></span><br><span class="line">  P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">// 位选索引值赋值给 P1 引脚的低 3 位</span></span><br><span class="line">  P0 = LedBuff[i];            <span class="comment">// 将缓冲区中索引位置的数据发送至单片机 P0 接口</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">6</span>)                  <span class="comment">// 索引递增循环，遍历缓冲区</span></span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于完成数码管扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL; <span class="comment">// 重新加载定时值</span></span><br><span class="line">  LedScan();  <span class="comment">// LED 扫描显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line">  <span class="comment">/* 接收到字节 */</span></span><br><span class="line">  <span class="keyword">if</span> (RI) &#123;</span><br><span class="line">    RI = <span class="number">0</span>;         <span class="comment">// 接收中断标志位置零</span></span><br><span class="line">    RxdByte = SBUF; <span class="comment">// 将接收到的数据保存至接收字节变量</span></span><br><span class="line">    SBUF = RxdByte; <span class="comment">// 返回接收到的数据，以此提示用户输入的信息是否已经正确接收</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 字节发送完毕 */</span></span><br><span class="line">  <span class="keyword">if</span> (TI) &#123;</span><br><span class="line">    TI = <span class="number">0</span>;         <span class="comment">// 发送中断标志位置零</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意：由于<strong>STC89C52RC</strong>是通过 UART
串口进行程序下载，当下载完成程序在单片机上开始运行以后，ISP
下载软件还会向串口发送一些额外数据，造成程序下载完成后并非显示<code>00</code>，遇到这种情况只需要将电路重新上电即可恢复正常状态。</p>
</blockquote>
<h1 id="rs485-与-modbus-协议">RS485 与 Modbus 协议</h1>
<p><strong>RS232</strong>标准诞生于<strong>RS485</strong>之前，电平达到十几伏容易损坏芯片，并且不兼容
TTL
电平标准，传输速率极限值仅为<code>100 ~ 200Kb/s</code>；使用信号线、<strong>GND</strong>与其它设备形成<strong>共地模式</strong>通信，容易受到干扰且抗干扰能力较弱；传输距离最多仅几十米，并且只能完成两点之间的通信，不能采用多机联网通信。</p>
<p><strong>RS485</strong>的出现弥补了<strong>RS232</strong>的不足，它采用了差分信号传输，可以抑制共模干扰提高通信可靠性，两根通信线通常使用<code>A</code>、<code>B</code>或者
<code>D+</code>和<code>D-</code>表示，两条通信线之间的电压差为<code>+(0.2 ~ 6)V</code>时表示高电平<code>1</code>，电压差为<code>-(0.2 ~ 6)V</code>时表示低电平<code>0</code>，属于典型的差分通信；<strong>RS485</strong>最大传输速率可以达到<code>10 Mb/s</code>以上，传输距离最远可以达到
1200
米左右（距离较远将会降低传输速度）；内部采用平衡驱动器与差分接收器组合，有效提高了抗干扰能力；可以在总线上进行多机联网通信，能够支持<code>32 ~ 256</code>个设备。<strong>RS485</strong>接口通过<strong>MAX485</strong>电平转换芯片，就可以方便的与单片机
UART
串口进行连接通信；但是由于<strong>RS485</strong>采用的是差分通信，因此数据的收发不能同时进行，属于<strong>半双工通信</strong>。</p>
<p><img src="/Embedded/STC89C52/UART/MAX485.png"></p>
<p>MAX485 电平转换芯片的 5 和 8 引脚是电源引脚，6 和 7
引脚是用于通信的<strong>A</strong>、<strong>B</strong>两个引脚（在它们之间并接了一个阻值为<code>1kΩ</code>的电阻<strong>R5</strong>以提升抗干扰能力），第
1 和 4
引脚分别连接至单片机的<strong>RXD</strong>与<strong>TXD</strong>引脚，第
2 脚（低电平使能接收）和第 3
脚（高电平使能输出）是方向引脚，电路当中将这组引脚连接在一起，不发送数据时保持为低电平处于接收状态，发送数据时就将这组引脚上拉至高电平，发送完毕之后再下拉为低电平。</p>
<p><img src="/Embedded/STC89C52/UART/RS485.png"></p>
<p>接下来的<strong>RS485</strong>实验当中，将<strong>MAX485</strong>的通信引脚连接至单片机的<strong>P3.0</strong>和<strong>P3.1</strong>，方向控制引脚连接至单片机的<strong>P1.7</strong>引脚。接下来，基于前面小节<strong>RS232</strong>串口通信实验的思路，通过电脑上的串口调试助手发送任意个数字符，单片机接收到到后在末尾添加【回车+换行】符以后返回，并在调试助手上显示出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** RS485.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit RS485_DIR = P1 ^ <span class="number">7</span>;        <span class="comment">// RS485方向选择引脚</span></span><br><span class="line"></span><br><span class="line">bit flagFrame = <span class="number">0</span>;              <span class="comment">// 数据帧接收完成标志位，表示接收到了一帧新数据</span></span><br><span class="line">bit flagTxd = <span class="number">0</span>;                <span class="comment">// 单字节发送完成标志位，用来替代 TXD 中断标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cntRxd = <span class="number">0</span>;       <span class="comment">// 接收字节计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pdata bufRxd[<span class="number">64</span>]; <span class="comment">// 接收字节缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  RS485_DIR = <span class="number">0</span>;                           <span class="comment">// 将 RS485 设置为接收</span></span><br><span class="line"></span><br><span class="line">  SCON = <span class="number">0x50</span>;                             <span class="comment">// 配置串口为工作方式 1</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                            <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;                            <span class="comment">// 配置定时器 T1 为工作模式 2</span></span><br><span class="line">  TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">// 计算定时器 T1 初始值</span></span><br><span class="line">  TL1 = TH1;                               <span class="comment">// 将高位定时值作为低位的初值</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                                 <span class="comment">// 禁用定时器 T1 中断</span></span><br><span class="line">  ES = <span class="number">1</span>;                                  <span class="comment">// 串口中断使能</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                                 <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件延时函数，延时 t * 10 微秒的时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayX10us</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">  &#125; <span class="keyword">while</span> (--t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据写入函数，参数 buf 是等待发送数据的指针，参数 len 是发送的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  RS485_DIR = <span class="number">1</span>;       <span class="comment">// 将 RS485 设置为发送</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环发送所有的字节 */</span></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    flagTxd = <span class="number">0</span>;       <span class="comment">// 发送完成标志位清零</span></span><br><span class="line">    SBUF = *buf++;     <span class="comment">// 发送 1 个字节的数据</span></span><br><span class="line">    <span class="keyword">while</span> (!flagTxd) ; <span class="comment">// 等待该字节发送完成</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DelayX10us(<span class="number">5</span>);       <span class="comment">// 等待最后的停止位完成，延时时间由波特率决定</span></span><br><span class="line">  RS485_DIR = <span class="number">0</span>;       <span class="comment">// 将 RS485 设置为接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据读取函数，参数 buf 表示接收指针的指针，参数 len 表示读取的长度，返回值是实际读取到的长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">UartRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="comment">/* 当指定的读取长度大于实际接收到的数据长度时，将读取长度设置为实际接收到的数据长度 */</span></span><br><span class="line">  <span class="keyword">if</span> (len &gt; cntRxd) &#123;</span><br><span class="line">    len = cntRxd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将接收到的数据拷贝至接收指针 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    *buf++ = bufRxd[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cntRxd = <span class="number">0</span>; <span class="comment">// 接收计数器清零</span></span><br><span class="line">  <span class="keyword">return</span> len; <span class="comment">// 返回实际读取的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口接收监控函数，基于空闲时间来判定帧结束，在定时中断中调用，参数 ms 表示定时间隔 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> cntbkp = <span class="number">0</span>;  <span class="comment">// 接收计数变量</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> idletmr = <span class="number">0</span>; <span class="comment">// 总线空闲计时变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当接收计数变量大于零时，监听总线的空闲时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (cntRxd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果接收计数变量发生改变（即刚接收到数据时），空闲计时变量清零 */</span></span><br><span class="line">    <span class="keyword">if</span> (cntbkp != cntRxd) &#123;</span><br><span class="line">      cntbkp = cntRxd;</span><br><span class="line">      idletmr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果接收计数变量没有改变（即总线保持空闲时），将空闲时间进行累加 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 总线空闲计时小于 30ms 持续累加 */</span></span><br><span class="line">      <span class="keyword">if</span> (idletmr &lt; <span class="number">30</span>) &#123;</span><br><span class="line">        idletmr += ms;</span><br><span class="line">        <span class="comment">/* 总线空闲计时达到 30ms，就认为一帧数据接收完毕 */</span></span><br><span class="line">        <span class="keyword">if</span> (idletmr &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">          flagFrame = <span class="number">1</span>;            <span class="comment">// 设置数据帧接收完成标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cntbkp = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口驱动函数，用于监听数据帧的接收并调用相应功能，主函数循环中进行调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> pdata buf[<span class="number">40</span>];</span><br><span class="line">  <span class="comment">/* 当数据帧到达时，读取并处理该命令 */</span></span><br><span class="line">  <span class="keyword">if</span> (flagFrame) &#123;</span><br><span class="line">    flagFrame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len = UartRead(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">2</span>); <span class="comment">// 将接收到的命令读取至缓冲区</span></span><br><span class="line">    UartAction(buf, len);                 <span class="comment">// 传递数据帧，调用动作执行函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line">  <span class="comment">/* 接收到新的字节数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (RI) &#123;</span><br><span class="line">    RI = <span class="number">0</span>;      <span class="comment">// 接收中断标志位清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收缓冲区尚未用完时，保存接收字节，并递增计数器 */</span></span><br><span class="line">    <span class="keyword">if</span> (cntRxd &lt; <span class="keyword">sizeof</span>(bufRxd)) &#123;</span><br><span class="line">      bufRxd[cntRxd++] = SBUF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 字节发送完毕 */</span></span><br><span class="line">  <span class="keyword">if</span> (TI) &#123;</span><br><span class="line">    TI = <span class="number">0</span>;      <span class="comment">// 发送中断标志位清零</span></span><br><span class="line">    flagTxd = <span class="number">1</span>; <span class="comment">// 发送完成标志位置 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 重载值的高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);  <span class="comment">// 配置定时器 T0 定时 1ms</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 设置波特率 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UartDriver();   <span class="comment">// 调用串口驱动程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，参数 buf 是接收到的命令帧指针，参数 len 是命令帧的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  buf[len++] = <span class="string">&#x27;\r&#x27;</span>; <span class="comment">// 在接收到的数据帧后添加回车符</span></span><br><span class="line">  buf[len++] = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 在接收到的数据帧后添加换行符</span></span><br><span class="line"></span><br><span class="line">  UartWrite(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器初始值</span></span><br><span class="line">  tmp = tmp + <span class="number">33</span>;                   <span class="comment">// 补偿由于中断响应延迟造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 拆分定时值为高低位</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 定时器 T0 控制位置 0</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;                       <span class="comment">// 定时值存储寄存器赋初值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;       <span class="comment">// 定时值存储寄存器重新赋初值</span></span><br><span class="line">  UartRxMonitor(<span class="number">1</span>); <span class="comment">// 调用串口接收监控函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序当中<strong>MAX485</strong>正常情况下为接收状态，只有在数据发送时才会置为发送状态，因此<code>UartWrite()</code>函数开头将<strong>MAX485</strong>电平转换芯片的方向引脚上拉为高电平，函数执行完成之前再下拉至低电平。</p>
<p>另外还有一个值得注意的细节，单片机发送和接收中断发生的时刻都处于停止位中间位置，即每当停止位传输至一半时，<code>RI</code>或<code>TI</code>就会置位并且进入中断服务函数，这种方式在接收的时候一切正常，但是在发送的时候，会紧接着向<strong>SBUF</strong>寄存器写入
1 个字节数据；单片机 UART
会在上一个停止位发送完成之后，再开始新的字节发送，如果此时不继续发送下一个字节，而是处于已经发送完毕的状态，这种情况下停止发送并将<strong>MAX485</strong>方向引脚拉低以使<strong>MAX485</strong>重新处于接收状态的逻辑就存在问题，因为最后的停止位此时只被发送了一半。</p>
<p>正因为如此，上面代码里通过在<code>UartWrite()</code>内部执行<code>DelayX10us(5)</code>函数，手动增加了<code>50us</code>延时（<em>延时时间为波特率周期的一半</em>），以便让剩下的一半停止位有足够的时间完成发送，从而有效避免了问题的发生。</p>
<h2 id="modbus-通信协议">Modbus 通信协议</h2>
<p>Modbus 是由施耐德电气于 1979
年提出的应用层的串行通信协议，目前已经成为一种常用的工业领域通信标准。Modbus
属于<strong>主从架构协议</strong>，只有一个节点作为主设备（所有通信都由它发起），其它参与通信的节点为从设备（最大可支持
247
个从设备）；每个从设备都拥有唯一地址，每条命令也都会包含需要执行该命令的目标设备地址，主设备发出命令之后所有从设备都会收到该命令，但只有指定地址的从设备能够执行并响应。此外，每条
Modbus 命令还包含有校验码，以确保命令的完整性。由于 Modbus
协议涉及内容较多，这里只重点介绍数据的<strong>帧结构</strong>以及<strong>通信控制方式</strong>。</p>
<p>Modbus
协议包含<strong>ASCII</strong>、<strong>RTU</strong>、<strong>TCP</strong>等传输方式，其中
ASCII 模式每个字节仅由 7 个 bit 位组成，标准 8051
架构单片机无法实现并且实际应用较少；而 TCP 与 RTU 极为类似，只需去除 RTU
的两个字节校验码，然后在协议开头添加五个<code>0</code>和一个<code>6</code>，最后通过
TCP/IP
网络协议发出即可。因此，这里将会重点介绍<strong>RTU</strong>模式，一条典型的
RTU 数据帧如下表所示：</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 10%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 29%">
</colgroup>
<thead>
<tr>
<th>起始位</th>
<th>设备地址</th>
<th>功能码</th>
<th>数据</th>
<th>CRC 校验</th>
<th>结束符</th>
</tr>
</thead>
<tbody>
<tr>
<td>间隔 3.5 Byte 通信时间</td>
<td>8 bit</td>
<td>8 bit</td>
<td>n × 8 bit</td>
<td>16 bit</td>
<td>间隔 3.5 Byte 通信时间</td>
</tr>
</tbody>
</table>
<p>RTU 模式规定每个数据帧前后都至少需要间隔 3.5
个字节的通信时间，如果超过这个时间，接收设备就会认为是一个新的数据帧。每个数据帧都会包含一个目标从设备的地址，如果地址为<code>0x00</code>就会认为这是一个所有从机设备都要执行的广播命令。<strong>功能码</strong>部分由
Modbus
协议进行约定，设备将会根据功能码来执行相应的动作，常用的功能码如下表所示：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 30%">
<col style="width: 54%">
</colgroup>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>读线圈状态</td>
<td>取得一组逻辑线圈的当前状态，ON 或者 OFF</td>
</tr>
<tr>
<td>02</td>
<td>读离散输入状态</td>
<td>取得一组开关输入的当前状态，ON 或者 OFF</td>
</tr>
<tr>
<td>03</td>
<td>读保持寄存器</td>
<td>从一个或多个保持寄存器当中获取二进制值</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>从一个或多个输入寄存器当中获取二进制值</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>强制一个逻辑线圈的通断状态</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>将二进值写入一个保持寄存器</td>
</tr>
<tr>
<td><code>7 ~ 14</code></td>
<td>其它功能</td>
<td>- - -</td>
</tr>
<tr>
<td>15</td>
<td>写多个线圈</td>
<td>强制一串连续逻辑线圈的通断</td>
</tr>
<tr>
<td>16</td>
<td>写多个保持寄存器</td>
<td>将二进制值写入一串连续的保持寄存器</td>
</tr>
<tr>
<td><code>17 ~ 21</code></td>
<td>其它功能</td>
<td>- - -</td>
</tr>
<tr>
<td><code>22 ~ 64</code></td>
<td>保留，作为协议扩展备用</td>
<td>- - -</td>
</tr>
<tr>
<td><code>65 ~ 72</code></td>
<td>保留，作为用户扩展备用</td>
<td>- - -</td>
</tr>
<tr>
<td><code>73 ~ 119</code></td>
<td>非法功能</td>
<td>- - -</td>
</tr>
<tr>
<td><code>120 ~ 127</code></td>
<td>保留，作为内部作用</td>
<td>- - -</td>
</tr>
<tr>
<td><code>128 ~ 25</code></td>
<td>保留，用于异常应答</td>
<td>- - -</td>
</tr>
</tbody>
</table>
<p>紧跟在功能码后面的 8 bit
数据具体个数由功能码来确定，例如功能码为<code>0x03</code>（参考上表，即读保持寄存器），那么主机发送的数据如下表所示：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>起始地址</th>
<th>寄存器数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 个字节功能码</td>
<td>2 个字节寄存器起始地址</td>
<td>2 个字节寄存器数量</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td><code>0x0000</code> ~ <code>0xFFFF</code></td>
<td><code>1</code> ~ <code>125</code></td>
</tr>
</tbody>
</table>
<p>从机接收到上述命令之后，响应数据的结构如下表所示：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>字节数</th>
<th>寄存器值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 个字节功能码</td>
<td>1 个字节</td>
<td><code>2 × 寄存器数量</code>个字节</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td><code>2 × 寄存器数量</code></td>
<td>- - -</td>
</tr>
</tbody>
</table>
<p>最后的 CRC
校验是将前面的所有字节数据进行计算，并生成一个<code>16 bit</code>位的数据作为校验码添加在每帧数据最后。接收方接收到该帧数据以后会进行同样的
CRC 计算，并且将计算结果与接收到的 CRC
校验位进行比较，从而完成每帧数据的完整性校验。</p>
<blockquote>
<p><strong>RTU</strong>模式下，每个字节由 1 个起始位、8
个数据位（由低至高进行发送）、1 个奇偶校验位（可选）、1
位停止位（有校验位时）或 2 个停止位（无校验位时）组成。</p>
</blockquote>
<h2 id="modbus-多机通信示例">Modbus 多机通信示例</h2>
<p>主机通过给从机下发不同指令，然后从机去执行指令对应的操作。与前面的串口实验类似，基于
Modbus 多机通信只需增加一个设备地址判断，接下来就使用计算机的 Modbus
调试精灵作为主机，<strong>STC89C52RC</strong>单片机作为从机，并通过 USB
转 RS485 模块进行通信实验。先设置 Modbus
调试精灵：波特率<code>9600</code>，<code>无校验位</code>，<code>8</code>位数据位，<code>1</code>位停止位，设备地址为<code>1</code>。</p>
<p>写寄存器时，如果需要将<code>01</code>写到地址为<code>0000</code>的寄存器地址，Modbus
调试精灵就会自动生成指令<code>01 06 00 00 00 01 48 0A</code>，其中<code>01</code>是设备地址，<code>06</code>是写寄存器功能码，<code>00 00</code>表示要写入的寄存器地址，<code>00 01</code>为待写入的数据，<code>48 0A</code>是自动计算出的
CRC 校验码。根据 Modbus
协议，从机完成写寄存器指令操作以后，会直接返回主机发送的指令，此时调试精灵应接收到的数据帧为：<code>01 06 00 00 00 01 48 0A</code>。</p>
<p>如果要从地址<code>0002</code>开始读取寄存器，并且读取的数量为<code>2</code>个，就会发送指令<code>01 03 00 02 00 02 65 CB</code>，其中<code>01</code>是设备地址，<code>03</code>是读寄存器功能码，<code>00 02</code>是读寄存器的起始地址，<code>00 02</code>是要读取两个寄存器的数值，<code>65 CB</code>是
CRC
校验。此时调试精灵应接收到的返回数据帧为<code>01 03 04 00 00 00 00 FA 33</code>，其中<code>01</code>是设备地址，<code>03</code>是功能码，<code>04</code>代表的是后边读到的数据字节数是
4
个，<code>00 00 00 00</code>分别是地址为<code>00 02</code>和<code>00 03</code>的寄存器内部的数据，而<code>FA 33</code>就是
CRC 校验了。</p>
<p>由于当前使用的开发板不具备 Modbus
协议功能码定义的诸多功能，因此在程序中通过数组<code>regGroup[5]</code>定义了
5 个模拟的寄存器，以及 1 个用于控制蜂鸣器的寄存器，Modbus
调试精灵可以通过下发不同指令改变<strong>STC89C52RC</strong>上寄存器的数据或者调整蜂鸣器的开关状态，即将单片机作为从机解析串口接收到的数据并执行相应操作。</p>
<p>Modbus 协议中寄存器的地址和数值都为 16 位（即 2
个字节），这里默认高字节是<code>0x00</code>低字节为数组<code>regGroup[5]</code>的值，其中地址<code>0x0000</code>到<code>0x0004</code>对应的是<code>regGroup[5]</code>数组的元素，完成写入以后会将数字显示到
1602
液晶，而对于地址<code>0x0005</code>，如果写入<code>0x00</code>蜂鸣器不会鸣叫，写入其它值就会报警。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lcd1602.c ... 此处省略，代码内容请参考后续小节 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** RS485.C ... 此处省略，代码内容请参考之前小节 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** CRC16.C */</span></span><br><span class="line"><span class="comment">/* CRC16计算函数，参数 ptr 表示数据指针，len 表示数据长度，返回计算的 CRC16 结果 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">GetCRC16</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crch = <span class="number">0xFF</span>; <span class="comment">// CRC 高字节</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crcl = <span class="number">0xFF</span>; <span class="comment">// CRC 低字节</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* CRC 高位字节值列表 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code TabH[] = &#123;<span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, ..., <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>&#125;;</span><br><span class="line">  <span class="comment">/* CRC 低位字节值列表 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code TabL[] = &#123;<span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, ..., <span class="number">0x81</span>, <span class="number">0x80</span>, <span class="number">0x40</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算指定长度的 CRC */</span></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    index = crch ^ *ptr++;</span><br><span class="line">    crch = crcl ^ TabH[index];</span><br><span class="line">    crcl = TabL[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((crch &lt;&lt; <span class="number">8</span>) | crcl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>;</span><br><span class="line">bit flagBuzzOn = <span class="number">0</span>; <span class="comment">//蜂鸣器启动标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;    <span class="comment">// 定时器 T0 定时值的高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;    <span class="comment">// 定时器 T0 定时值的低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> regGroup[<span class="number">5</span>]; <span class="comment">// Modbus 寄存器组，地址范围 0x00～0x04</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">GetCRC16</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);  <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 设置波特率 9600</span></span><br><span class="line">  InitLcd1602();    <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UartDriver();   <span class="comment">// 调用串口驱动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，根据接收到的命令帧执行相应动作，参数 buf</span></span><br><span class="line"><span class="comment"> * 表示接收到的命令帧指针，len 表示命令帧的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> cnt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> crc;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crch, crcl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 例子中从机地址设置为 0x01，如数据帧中地址与本机不符，则不做任何处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="number">0x01</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果地址相符，则对本帧数据进行校验 */</span></span><br><span class="line">  crc = GetCRC16(buf, len - <span class="number">2</span>); <span class="comment">// 计算 CRC 校验值</span></span><br><span class="line">  crch = crc &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  crcl = crc &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((buf[len - <span class="number">2</span>] != crch) || (buf[len - <span class="number">1</span>] != crcl)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;                     <span class="comment">// 如果 CRC 校验错误直接退出</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 地址和 CRC 校验都正确时，解析功能码并执行相应操作 */</span></span><br><span class="line">  <span class="keyword">switch</span> (buf[<span class="number">1</span>]) &#123;</span><br><span class="line">  <span class="comment">/* 读取一个连续的寄存器 */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x03</span>:</span><br><span class="line">    <span class="comment">/* 仅支持 0x0000 ~ 0x0005 地址范围 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf[<span class="number">2</span>] == <span class="number">0x00</span>) &amp;&amp; (buf[<span class="number">3</span>] &lt;= <span class="number">0x05</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buf[<span class="number">3</span>] &lt;= <span class="number">0x04</span>) &#123;</span><br><span class="line">        i = buf[<span class="number">3</span>];                   <span class="comment">// 获取寄存器地址</span></span><br><span class="line">        cnt = buf[<span class="number">5</span>];                 <span class="comment">// 获取待读取的寄存器数量</span></span><br><span class="line">        buf[<span class="number">2</span>] = cnt * <span class="number">2</span>;             <span class="comment">// 读取数据字节数，即寄存器数量乘以 2</span></span><br><span class="line">        len = <span class="number">3</span>;                      <span class="comment">// 数据帧已经拥有地址、功能码、字节数一共 3 个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">          buf[len++] = <span class="number">0x00</span>;          <span class="comment">// 寄存器高字节补 0</span></span><br><span class="line">          buf[len++] = regGroup[i++]; <span class="comment">// 寄存器低字节</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 地址 0x05 为蜂鸣器状态 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[<span class="number">2</span>] = <span class="number">2</span>;  <span class="comment">// 读取字节数</span></span><br><span class="line">        buf[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">        buf[<span class="number">4</span>] = flagBuzzOn;</span><br><span class="line">        len = <span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果寄存器地址不被支持 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      buf[<span class="number">1</span>] = <span class="number">0x83</span>;                  <span class="comment">// 功能码最高位置 1</span></span><br><span class="line">      buf[<span class="number">2</span>] = <span class="number">0x02</span>;                  <span class="comment">// 设置异常码为 02，即无效地址</span></span><br><span class="line">      len = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* 写入单个寄存器 */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x06</span>:</span><br><span class="line">    <span class="comment">/* 仅支持 0x0000 ~ 0x0005 地址范围 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf[<span class="number">2</span>] == <span class="number">0x00</span>) &amp;&amp; (buf[<span class="number">3</span>] &lt;= <span class="number">0x05</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buf[<span class="number">3</span>] &lt;= <span class="number">0x04</span>) &#123;</span><br><span class="line">        i = buf[<span class="number">3</span>];                   <span class="comment">// 获取寄存器地址</span></span><br><span class="line">        regGroup[i] = buf[<span class="number">5</span>];         <span class="comment">// 保存寄存器数据</span></span><br><span class="line">        cnt = regGroup[i] &gt;&gt; <span class="number">4</span>;       <span class="comment">// 显示至 1602 液晶</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">0xA</span>)</span><br><span class="line">          str[<span class="number">0</span>] = cnt - <span class="number">0xA</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          str[<span class="number">0</span>] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        cnt = regGroup[i] &amp; <span class="number">0x0F</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">0xA</span>)</span><br><span class="line">          str[<span class="number">1</span>] = cnt - <span class="number">0xA</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          str[<span class="number">1</span>] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        str[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        LcdShowStr(i * <span class="number">3</span>, <span class="number">0</span>, str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 地址0x05为蜂鸣器状态 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        flagBuzzOn = (bit)buf[<span class="number">5</span>];     <span class="comment">// 寄存器值转为蜂鸣器的开关</span></span><br><span class="line">      &#125;</span><br><span class="line">      len -= <span class="number">2</span>;                       <span class="comment">// 长度减去 2 ，重新计算 CRC 并且返回原始帧</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果寄存器地址不被支持 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      buf[<span class="number">1</span>] = <span class="number">0x86</span>;                  <span class="comment">// 功能码最高位置 1</span></span><br><span class="line">      buf[<span class="number">2</span>] = <span class="number">0x02</span>;                  <span class="comment">// 异常码设置为 02，即无效地址</span></span><br><span class="line">      len = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* 其它不被支持的功能码 */</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    buf[<span class="number">1</span>] |= <span class="number">0x80</span>;                   <span class="comment">// 功能码最高位置1</span></span><br><span class="line">    buf[<span class="number">2</span>] = <span class="number">0x01</span>;                    <span class="comment">// 异常码设置为 01，即无效功能</span></span><br><span class="line">    len = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  crc = GetCRC16(buf, len);           <span class="comment">// 计算返回帧的 CRC 校验值</span></span><br><span class="line">  buf[len++] = crc &gt;&gt; <span class="number">8</span>;              <span class="comment">// CRC 高字节</span></span><br><span class="line">  buf[len++] = crc &amp; <span class="number">0xFF</span>;            <span class="comment">// CRC 低字节</span></span><br><span class="line">  UartWrite(buf, len);                <span class="comment">// 发送返回帧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;     <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>; <span class="comment">// 计算所需要的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;       <span class="comment">// 计算定时器的定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">33</span>;          <span class="comment">// 补偿中断响应延迟造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器初始值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;            <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;            <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;              <span class="comment">// 加载定时器 T0 重载值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                 <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                 <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，监听串口接收并驱动蜂鸣器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;       <span class="comment">// 重新加载定时值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 蜂鸣器控制 */</span></span><br><span class="line">  <span class="keyword">if</span> (flagBuzzOn)</span><br><span class="line">    BUZZ = ~BUZZ;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    BUZZ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  UartRxMonitor(<span class="number">1</span>); <span class="comment">// 监听串口接收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="液晶">1602 液晶</h1>
<p>1602 液晶可以显示 2 行信息（每行 16
个字符），驱动电压在<code>3.0V ~ 5.0V</code>，但逻辑电压为<code>4.8V ~ 5.2V</code>，液晶工作电流最大为<code>1.7mA</code>，加上背光以后工作电流可达<code>24.0mA</code>。液晶模块一共拥有
16 个引脚，每个引脚具体功能定义如下：</p>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 6%">
<col style="width: 55%">
<col style="width: 5%">
<col style="width: 10%">
<col style="width: 16%">
</colgroup>
<thead>
<tr>
<th>引脚号</th>
<th>符号</th>
<th>描述</th>
<th>引脚号</th>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>GND</strong></td>
<td>电源负极 <code>0V</code></td>
<td>9</td>
<td><strong>DB2</strong></td>
<td>数据 2</td>
</tr>
<tr>
<td>2</td>
<td><strong>VCC</strong></td>
<td>电源正极 <code>5V</code></td>
<td>10</td>
<td><strong>DB3</strong></td>
<td>数据 3</td>
</tr>
<tr>
<td>3</td>
<td><strong>VO</strong></td>
<td>LCD 显示偏压输入（ 可以通过输入电压调整显示对比度）</td>
<td>11</td>
<td><strong>DB4</strong></td>
<td>数据 4</td>
</tr>
<tr>
<td>4</td>
<td><strong>RS</strong></td>
<td>指令/数据的选择端（高电平<code>1</code>表示命令，低电平<code>0</code>表示数据）</td>
<td>12</td>
<td><strong>DB5</strong></td>
<td>数据 5</td>
</tr>
<tr>
<td>5</td>
<td><strong>WR</strong></td>
<td>读/写的选择端（选择读取液晶的数据、状态还是写入数据、命令）</td>
<td>13</td>
<td><strong>DB6</strong></td>
<td>数据 6</td>
</tr>
<tr>
<td>6</td>
<td><strong>E</strong></td>
<td>使能信号</td>
<td>14</td>
<td><strong>DB7</strong></td>
<td>数据 7</td>
</tr>
<tr>
<td>7</td>
<td><strong>DB0</strong></td>
<td>数据 0</td>
<td>15</td>
<td><strong>BG VCC</strong></td>
<td>背光 LED 正极 <code>5V</code></td>
</tr>
<tr>
<td>8</td>
<td><strong>DB1</strong></td>
<td>数据 1</td>
<td>16</td>
<td><strong>BG GND</strong>3</td>
<td>背光 LED 负极 <code>0V</code></td>
</tr>
</tbody>
</table>
<p>1602 液晶的第 4、5
管脚分别通过跳线插座<strong>ADDR0</strong>、<strong>ADDR1</strong>与单片机的<strong>P1.0</strong>、<strong>P1.1</strong>引脚连接，第
6
管脚则通过<strong>LCD_CS</strong>跳线座接到至单片机<strong>P1.5</strong>引脚，下面是具体的电路连接原理图：</p>
<p><img src="/Embedded/STC89C52/LCD/1602.png"></p>
<p>1602 液晶内部带有<code>80 Byte</code>字节的 RAM
显示缓冲区，用以存储需要发送的数据，其具体结构如下图所示：</p>
<p><img src="/Embedded/STC89C52/LCD/sequence.png"></p>
<p>上图当中，第 1 行地址范围<code>0x00 ~ 0x0F</code>与液晶第 1 行的 16
个字符显示位置对应，第 2 行地址范围<code>0x40 ~ 0x4F</code>与液晶第 2
行的 16 个字符显示位置对应，每行中多出来的部分可用于显示移动字幕。1602
液晶显示的字符与 ASCII
字符码表对应，例如向地址<code>0x00</code>写入十进制数<code>97</code>，液晶左上方小块就会显示出字母<code>a</code>。此外，1602
液晶内部还拥有一个数据指针，用于指向数据将要发送到的地址。以及一个 8
位的状态字节，用于获取 1602
液晶模块内部的一些运行情况，其第<code>0 ~ 6</code>位表示的是当前数据的指针值，第<code>7</code>位表示读写操作使能（<code>0</code>允许读写/<code>1</code>禁止读写）。</p>
<h2 id="操作时序">操作时序</h2>
<p>1602 液晶一共拥有 4 个基本操作时序（采用摩托罗拉的 6800
时序），这里先将需要使用到的接口和引脚进行声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB = P0</span></span><br><span class="line"></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>读状态</strong>（<code>RS = L, R/W = H, E = H</code>）：编写具体代码时，可以考虑将液晶的状态字读取到一个<code>sta</code>变量，通过判断其最高位来查询液晶的忙闲状态，以及查询数据指针的位置。如果读取到当前液晶处于【空闲】状态，那么程序就可以进行相应的读写操作；如果读取到的状态为【正忙】，就要继续等待并再重新判断液晶状态；另外，由于电路中的流水灯、数码管、LED
点阵、1602
液晶共用了单片机<strong>P0</strong>引脚，为了不干扰其它外设的工作，需要在读取液晶状态之后，在<code>do while</code>循环中将引脚电平拉低，避免引起不必要的干扰。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  sta = LCD1602_DB;   <span class="comment">// 读取液晶状态字</span></span><br><span class="line">  LCD1602_E = <span class="number">0</span>;      <span class="comment">// 液晶状态读取完毕之后拉低电平，避免干扰其它外设</span></span><br><span class="line">&#125; <span class="keyword">while</span> (sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果第 7 位等于 1 表示液晶正忙，需要循环进行检测直至等于 0 为止</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>读数据</strong>（<code>RS = H, R/W = H, E = H</code>）：不常用，这里不作详细介绍。</li>
<li><strong>写指令</strong>（<code>RS = L，R/W = L，D0 ~ D7 = 指令码，E = 高脉冲</code>）：这里<code>E = 高脉冲</code>是指将引脚<strong>E</strong>从低电平拉高，再从高电平拉低，从而形成高脉冲。</li>
<li><strong>写数据</strong>（<code>RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</code>）：与上面的写指令类似，需要将<code>RS</code>改成<code>H</code>，再把总线修改为数据即可。</li>
</ol>
<p>如前所述，由于 1602
液晶使能引脚<strong>E</strong>属于高电平有效，为了不影响其它外设的工作，需要在不使用液晶时在代码顶部声明一句<code>LCD1602_E = 0</code>，上述程序未添加该语句，是由于电路在该引脚上增加了一个
<code>15 KΩ</code>下拉电阻<strong>R72</strong>，从硬件上保证了该引脚上电后默认为低电平状态。</p>
<p><img src="/Embedded/STC89C52/LCD/jumper.png"></p>
<h2 id="设置指令">设置指令</h2>
<p>1602
液晶使用的时候，需要通过一些特定指令来进行相应功能的配置和初始化：</p>
<ol type="1">
<li><strong>显示模式设置指令</strong>：<code>0x38</code>，设置 1602
液晶的工作模式为<strong>16 x 2 显示，5 x 7 点阵，8
位数据接口</strong>。</li>
<li><strong>显示开/关以及光标设置指令</strong>：这里涉及两条指令，第一条指令高
5 位是固定的<code>0b00001</code>，低 3
位分别采用<code>DCB</code>（<code>D=1/0</code>打开关闭显示，<code>C=1/0</code>显示或隐藏光标；<code>B=1/0</code>光标闪烁或者不闪烁）从高到低进行表示。第二条指令高
6 位为固定的<code>0b000001</code>，低 2
位分别用<code>NS</code>（<code>N = 1/0</code>表示读或写一个字符后指针自动加减<code>1</code>，<code>S = 1/0</code>表示写入一个字符以后整屏显示左右移动或者不移动）从高到低进行表示。</li>
<li><strong>清屏指令</strong>：<code>0x01</code>表示显示清屏，包含数据指针以及所有的显示清零；<code>0x02</code>
则仅仅清零数据指针，显示则不进行清零。</li>
<li><strong>RAM 地址设置指令</strong>：该指令最高位为<code>1</code>，低
7 位为 RAM 地址，RAM 地址与液晶显示字符的映射关系如前图所示。</li>
</ol>
<h2 id="简单实例">简单实例</h2>
<p>注意下面代码中的<code>LcdWriteDat( *str++ )</code>语句先将指针<code>str</code>指向的数据取出，然后<code>str++</code>自增<code>1</code>从而指向下一个数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB  P0</span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E  = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello Hank&quot;</span>;</span><br><span class="line"></span><br><span class="line">    InitLcd1602();</span><br><span class="line">    LcdShowStr(<span class="number">2</span>, <span class="number">0</span>, str);</span><br><span class="line">    LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;Welcome to Chengdu&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备就绪 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;</span><br><span class="line">        sta = LCD1602_DB; <span class="comment">// 读取液晶状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (sta &amp; <span class="number">0x80</span>); <span class="comment">// 第 7 位等于 1 表示液晶正忙，循环检测直至等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节的命令，参数 cmd 表示待写入的命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">    LcdWaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E  = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E  = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节的数据，参数 dat 表示待写入的数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">    LcdWaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E  = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E  = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，同时也是光标的位置，参数 x, y 表示屏幕上字符的坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)               <span class="comment">// 通过输入的屏幕坐标计算出显示 RAM 的地址</span></span><br><span class="line">        addr = <span class="number">0x00</span> + x;      <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addr = <span class="number">0x40</span> + x;      <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">    LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    LcdSetCursor(x, y);      <span class="comment">//设置起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 连续写入字符串数据，直到检测到结束符 */</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        LcdWriteDat(*str++); <span class="comment">// 先获取 str 指针所指向的数据，然后再自增 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">    LcdWriteCmd(<span class="number">0x38</span>);  <span class="comment">// 16 x 2 显示，5 x 7 点阵，8 位数据接口</span></span><br><span class="line">    LcdWriteCmd(<span class="number">0x0C</span>);  <span class="comment">// 打开显示，关闭光标</span></span><br><span class="line">    LcdWriteCmd(<span class="number">0x06</span>);  <span class="comment">// 文字不动，地址自动加 1</span></span><br><span class="line">    LcdWriteCmd(<span class="number">0x01</span>);  <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通信时序">通信时序</h1>
<p><strong>通信时序</strong>这个概念可以从<strong>时间</strong>和<strong>顺序</strong>两个维度进行理解，所谓<strong>顺序</strong>是指通信的数据与操作必须保持一定的先后顺序，例如：UART
串口通信当中，首先 1 位起始位，然后 8 位数据位，最后 1 位停止位；虽然
1602
液晶写指令对于<code>RS = L，R/W = L，D0 ~ D7 = 指令码</code>的顺序没有要求，但是<code>E = 高脉冲</code>操作必须放置在最后。</p>
<p>而所谓的<strong>时间</strong>则内容相对复杂，例如 UART
通信里每一位的时间宽度为<code>1 / 波特率</code>，前面内容中有提到单片机读取
RXD 引脚数据时，每一位数据的传输时间都被平均分为 16 等份，如果第 7、8、9
次读到的结果有两次为高电平<code>1</code>就认为该位为高电平，有两次为低电平<code>0</code>就认为该位为低电平，如果波特率产生的误差，让第
7、8、9
次采样还能够位于停止位范围内，这样的采样率就被认为是正确可用的，请仔细观察下图：</p>
<p><img src="/Embedded/STC89C52/LCD/uart-deviation.png"></p>
<p>上图使用三个箭头来表示第 7、8、9 次采样的位置，注意采样至 D7
位时，有一个采样点已经偏移出去，由于另外两次采样位置正确，因此采集到数据依然被认为是正确可信的。事实上
UART
通信的波特率允许存储一定范围的误差，波特率计算的时候，如果发现结果当中出现了小数，就需要格外留心出现误差。
实验电路中之所以采用<code>11.0592 MHz</code>晶振，就是由于<code>11059200 ÷ 12 ÷ 32 ÷ 9600</code>得到的结果是一个整数，如果改用<code>12 MHz</code>晶振则将会得到一个小数，设置较高波特率时将会产生错误。</p>
<p>接下来研究 1602
液晶的时序问题，参考数据手册提供的时序图，下面的读操作时序图当中，<strong>RS</strong>引脚和<strong>R/W</strong>引脚首先进行变化，由于是读操作，所以<strong>R/W</strong>引脚被置为高电平。又由于读取的可以是数据也可以是指令，所以<strong>RS</strong>引脚有可能是高电平也可能是低电平，注意下图中的表示方法。</p>
<p>当<strong>RS</strong>与<strong>R/W</strong>变化之后再经历<code>Tsp1</code>长度的时间，使能引脚<strong>E</strong>才会发生正跳变。而使能引脚<strong>E</strong>拉高持续<strong>tD</strong>长度时间以后，引脚<strong>DB</strong>才会输出有效数据，读取完成之后，再将使能引脚<strong>E</strong>下拉为低电平，一段时间以后<strong>RS</strong>、<strong>R/W</strong>、<strong>DB</strong>就可以准备下一次读写了。</p>
<p><img src="/Embedded/STC89C52/LCD/read.png"></p>
<p>下面的写操作时序图与读操作的区别，在于写操作是由单片机来改变<strong>DB</strong>的状态，因此需要在使能引脚<strong>E</strong>变化之前进行操作。</p>
<p><img src="/Embedded/STC89C52/LCD/write.png"></p>
<p>上述两张时序图上存在着诸多时序参数标签，例如使能引脚<strong>E</strong>的上升时间<code>tR</code>下降时间时间<code>tF</code>，从一个上升沿至下一个上升沿之间的长度周期<code>tC</code>；以及使能引脚<strong>E</strong>下降沿之后，<strong>R/W</strong>和<strong>RS</strong>变化的时间间隔<code>tHD1</code>等等。根据数据手册内容，将
1602 液晶的相关时序参数总结如下表：</p>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 4%">
<col style="width: 4%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th>符号</th>
<th>时序参数</th>
<th>最小值</th>
<th>最大值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>tC</strong></td>
<td>E 信号周期</td>
<td>400 纳秒</td>
<td>--</td>
<td>使能引脚<strong>E</strong>从本次上升沿到下次上升沿的最短时间为<code>400 ns</code>，每条
C
语句需要耗费一个甚至多个机器周期，每个机器周期需要耗费<code>1 us</code>以上，则该条件满足。</td>
</tr>
<tr>
<td><strong>tPW</strong></td>
<td>E 脉冲宽度</td>
<td>150 纳秒</td>
<td>--</td>
<td>使能引脚<strong>E</strong>高电平持续时间最短为<code>150 ns</code>，该条件也同样满足。</td>
</tr>
<tr>
<td><strong>tR, tF</strong></td>
<td>E 上升沿/下降沿时间</td>
<td>--</td>
<td>25 纳秒</td>
<td>使能引脚<strong>E</strong>的上升沿/下降沿时间不能超过<code>25 ns</code>，示波器实际测量该引脚上升下降沿时间在<code>10 ns ~ 15 ns</code>范围，该条件满足。</td>
</tr>
<tr>
<td><strong>tSP1</strong></td>
<td>地址建立时间</td>
<td>30 纳秒</td>
<td>--</td>
<td><strong>RS</strong>和<strong>R/W</strong>引脚使能之后至少保持<code>30 ns</code>，使能引脚<strong>E</strong>才会变为高电平，该条件依然满足。</td>
</tr>
<tr>
<td><strong>tHD1</strong></td>
<td>地址保持时间</td>
<td>10 纳秒</td>
<td>--</td>
<td>使能引脚<strong>E</strong>下拉为低电平以后至少保持<code>10ns</code>以上，<strong>RS</strong>与<strong>R/W</strong>才能进行变化，该条件满足。</td>
</tr>
<tr>
<td><strong>tD</strong></td>
<td>数据建立时间(读)</td>
<td>--</td>
<td>100 纳秒</td>
<td>使能引脚<strong>E</strong>变为高电平最多<code>100 ns</code>之后，1602
液晶模块就会将数据送出，从而能够正常去读取状态和数据。</td>
</tr>
<tr>
<td><strong>tHD2</strong></td>
<td>数据保持时间(读)</td>
<td>20 纳秒</td>
<td>--</td>
<td>读操作过程当中，使能引脚<strong>E</strong>变为低电平以后至少保持<code>20 ns</code>，数据总线<strong>DB</strong>才可以发生变化，该条件满足。</td>
</tr>
<tr>
<td><strong>tSP2</strong></td>
<td>数据建立时间（写）</td>
<td>40 纳秒</td>
<td>--</td>
<td><strong>DB</strong>数据总线准备好以后需要至少保持<code>40 ns</code>，使能引脚<strong>E</strong>才可以从低电平变为高电平使能，该条件完全满足。</td>
</tr>
<tr>
<td><strong>tHD2</strong></td>
<td>数据保持时间（写）</td>
<td>10 纳秒</td>
<td>--</td>
<td>写操作过程当中，引脚<strong>E</strong>变为低电平以后至少保持<code>10 ns</code>，数据总线<strong>DB</strong>才能够变化，该条件也完全满足。</td>
</tr>
</tbody>
</table>
<h1 id="液晶综合实验">1602 液晶综合实验</h1>
<h2 id="字符串移动显示">字符串移动显示</h2>
<p>这里动手编写一段代码在 1602
液晶上显示两行字符串，并实现整屏的重复左移；首先将 1602
液晶的底层功能函数<code>LcdWaitReady()</code>、<code>LcdWriteCmd()</code>、<code>LcdWriteDat()</code>、<code>LcdShowStr()</code>、<code>LcdSetCursor()</code>、<code>InitLcd1602()</code>封装为一个独立的<code>Lcd1602.c</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0</span></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备完毕 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">  LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    sta = LCD1602_DB;    <span class="comment">// 读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果 bit7 等于 1 表示液晶正忙，循环检测直至等于表示空闲的 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节命令到液晶，参数 cmd 表示待写入的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = cmd;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节数据到液晶，参数 dat 表示待写入的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = dat;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，即光标位置，参数 x 和 y 分别对应屏幕的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据屏幕坐标计算显示 RAM 地址 */</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    addr = <span class="number">0x00</span> + x;        <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    addr = <span class="number">0x40</span> + x;        <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">  LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，参数 x 和 y 对应屏幕上的起始坐标，参数 str 是字符串指针，参数 len 是需要显示的字符长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y);    <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入 len 个字符数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    LcdWriteDat(*str++); <span class="comment">// 首先获得 str 指向的数据，然后 str 再自增 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化1602液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x38</span>); <span class="comment">// 16×2显示，5×7点阵，8位数据接口</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>); <span class="comment">// 开启显示器，关闭光标</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x06</span>); <span class="comment">// 文字保持不动，地址自增 1</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>); <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再建立一个<code>main.c</code>文件，通过<code>extern</code>关键字分别调用上面<code>Lcd1602.c</code>文件中用于初始化液晶的<code>InitLcd1602()</code>和显示内容的<code>LcdShowStr()</code>函数，注意代码当中<code>for</code>语句在数组上的灵活应用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bit flag500ms = <span class="number">0</span>;      <span class="comment">// 定时标志位 500ms</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code str1[] = <span class="string">&quot;Hello Hank...&quot;</span>; <span class="comment">// 待显示第 1 行字符串</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code str2[] = <span class="string">&quot;Hello Abel...&quot;</span>; <span class="comment">// 待显示第 2 行字符串，需要保持与第 1 行长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">0</span>;                              <span class="comment">// 移动索引</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> pdata bufMove1[<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) + <span class="number">16</span>]; <span class="comment">// 移动显示缓冲区 1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> pdata bufMove2[<span class="number">16</span> + <span class="keyword">sizeof</span>(str2) + <span class="number">16</span>]; <span class="comment">// 移动显示缓冲区 2</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                                               <span class="comment">// 开总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">10</span>);                                     <span class="comment">// 配置定时器 T0 定时 10ms</span></span><br><span class="line">  InitLcd1602();                                        <span class="comment">// 初始化液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示缓冲区头部填充空格 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    bufMove1[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    bufMove2[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 将待显示字符串拷贝至显示缓冲区中间位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>); i++) &#123;</span><br><span class="line">    bufMove1[<span class="number">16</span> + i] = str1[i];</span><br><span class="line">    bufMove2[<span class="number">16</span> + i] = str2[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 显示缓冲区尾部填充空格 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = (<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>); i &lt; <span class="keyword">sizeof</span>(bufMove1); i++) &#123;</span><br><span class="line">    bufMove1[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    bufMove2[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每间隔 500ms 移动一次屏幕 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag500ms) &#123;</span><br><span class="line">      flag500ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 从显示缓冲区提取一段字符显示到液晶 */</span></span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, bufMove1 + index, <span class="number">16</span>);</span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, bufMove2 + index, <span class="number">16</span>);</span><br><span class="line">      index++;                                         <span class="comment">// 移动索引自增，完成左移</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 起始位置到达字符串尾部以后返回从头开始 */</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= (<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>)) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                <span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 的控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;                       <span class="comment">// 加载定时器 T0 的定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr500ms = <span class="number">0</span>;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL; <span class="comment">// 重新加载定时值</span></span><br><span class="line">  tmr500ms++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tmr500ms &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">    tmr500ms = <span class="number">0</span>;</span><br><span class="line">    flag500ms = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于按键与液晶的计算器">基于按键与液晶的计算器</h2>
<p>接下来再编写一个相对更复杂的实验，一个由 3
个源文件组成的简易整数计算器程序。为了简化程序实现，这里暂时不考虑连加、连减、小数的情况。上下左右按键分别用来表示<code>+ - × ÷</code>，回车和
ESC 键则分别表示<code>=</code>和<code>归 0</code>。程序共划分为用于 1602
液晶显示的<code>Lcd1602.c</code>，以及用于按键动作扫描的<code>keyboard.c</code>和主函数<code>main.c</code>一共
3
个源文件。首先，<code>Lcd1602.c</code>文件根据当前实验的需要，添加了区域清屏<code>LcdAreaClear()</code>和整屏清屏<code>LcdFullClear()</code>两个功能函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0</span></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备完毕 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">  LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    sta = LCD1602_DB;    <span class="comment">// 读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果 bit7 等于 1 表示液晶正忙，循环检测直至等于表示空闲的 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节命令到液晶，参数 cmd 表示待写入的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = cmd;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节数据到液晶，参数 dat 表示待写入的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = dat;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，即光标位置，参数 x 和 y 分别对应屏幕的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据屏幕坐标计算显示 RAM 地址 */</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    addr = <span class="number">0x00</span> + x;        <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    addr = <span class="number">0x40</span> + x;        <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">  LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，参数 x 和 y 对应屏幕上的起始坐标，参数 str 是字符串指针，参数 len 是需要显示的字符长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y);    <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入字符串，直至检测到结束符 */</span></span><br><span class="line">  <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    LcdWriteDat(*str++); <span class="comment">// 首先获得 str 指向的数据，然后 str 再自增 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 区域清屏，清除 x、y 坐标起始的 len 个字符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdAreaClear</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y); <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    LcdWriteDat(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 循环写入空格</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整屏清除 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdFullClear</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化1602液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x38</span>); <span class="comment">// 16×2显示，5×7点阵，8位数据接口</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>); <span class="comment">// 开启显示器，关闭光标</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x06</span>); <span class="comment">// 文字保持不动，地址自增 1</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>); <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，<code>keyboard.c</code>封装了前面小节当中使用的矩阵按键驱动，这个按键驱动只负责调用上层实现的按键动作函数，而每个按键的具体动作则会放置到后续的<code>main.c</code>文件里实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit KEY_IN_1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KEY_IN_2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KEY_IN_3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KEY_IN_4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY_OUT_1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KEY_OUT_2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KEY_OUT_3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KEY_OUT_4 = P2 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键编号和标准键盘键码的映射表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x26</span>&#125;,   <span class="comment">// 数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="number">0x25</span>&#125;,   <span class="comment">// 数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="number">0x28</span>&#125;,   <span class="comment">// 数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123;<span class="string">&#x27;0&#x27;</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span>&#125;  <span class="comment">// 数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵按键的当前状态 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pdata KeySta[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 键值备份，保存前一次的矩阵按键状态 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> pdata backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环扫描 4*4 矩阵按键 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测按键动作 */</span></span><br><span class="line">      <span class="keyword">if</span> (backup[i][j] != KeySta[i][j]) &#123;</span><br><span class="line">        <span class="comment">/* 按键按下时需要执行的任务 */</span></span><br><span class="line">        <span class="keyword">if</span> (backup[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">          KeyAction(KeyCodeMap[i][j]); <span class="comment">// 调用按键动作函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        backup[i][j] = KeySta[i][j]; <span class="comment">// 更新前一次备份的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用，推荐调用间隔1ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keyout = <span class="number">0</span>;     <span class="comment">// 矩阵按键扫描输出索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 矩阵按键扫描缓冲区 */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将一行上 4 个按键的值移入缓冲区 */</span></span><br><span class="line">  keybuf[keyout][<span class="number">0</span>] = (keybuf[keyout][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_1;</span><br><span class="line">  keybuf[keyout][<span class="number">1</span>] = (keybuf[keyout][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_2;</span><br><span class="line">  keybuf[keyout][<span class="number">2</span>] = (keybuf[keyout][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_3;</span><br><span class="line">  keybuf[keyout][<span class="number">3</span>] = (keybuf[keyout][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KEY_IN_4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 完成消抖之后更新按键的状态，因为每行 4 个按键，所以要循环 4 次 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 0 ，即 16ms 内都只检测到按下状态，就认为按键已经稳定按下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连续 4 次扫描值都为 1 ，即 16ms 内都只检测到弹起状态，就认为按键已经稳定弹起 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((keybuf[keyout][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>) &#123;</span><br><span class="line">      KeySta[keyout][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行下一次扫描输出 */</span></span><br><span class="line">  keyout++;                           <span class="comment">// 输出索引自增</span></span><br><span class="line">  keyout &amp;= <span class="number">0x03</span>;             <span class="comment">// 索引值自增到 4 以后归零</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据索引值释放当前输出引脚，并拉低下次的输出引脚 */</span></span><br><span class="line">  <span class="keyword">switch</span> (keyout) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: KEY_OUT_4 = <span class="number">1</span>; KEY_OUT_1 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: KEY_OUT_1 = <span class="number">1</span>; KEY_OUT_2 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: KEY_OUT_2 = <span class="number">1</span>; KEY_OUT_3 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: KEY_OUT_3 = <span class="number">1</span>; KEY_OUT_4 = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>main.c</code>文件用于实现全部应用层面的功能，例如：计算信息显示、按键动作响应以及定时器中断的调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> step = <span class="number">0</span>; <span class="comment">// 操作步骤</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> oprt = <span class="number">0</span>; <span class="comment">// 运算类型</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> num1 = <span class="number">0</span>;   <span class="comment">// 操作数 1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> num2 = <span class="number">0</span>;   <span class="comment">// 操作数 2</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> result = <span class="number">0</span>; <span class="comment">// 运算结果</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 重载值的高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdAreaClear</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdFullClear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                 <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);        <span class="comment">// 配置定时器 T0 定时 1ms</span></span><br><span class="line">  InitLcd1602();          <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line">  LcdShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>); <span class="comment">// 初始显示数字 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();          <span class="comment">// 调用按键驱动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 长整型数据转换为字符串，参数 str 是字符串指针，参数 dat</span></span><br><span class="line"><span class="comment"> * 是待转换数值，返回字符串长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">LongToString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">signed</span> <span class="type">long</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果为负数，首先取绝对值，然后向指针上添加负号 */</span></span><br><span class="line">  <span class="keyword">if</span> (dat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    dat = -dat;</span><br><span class="line">    *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 转换为低位在前的十进制数组 */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = dat % <span class="number">10</span>;</span><br><span class="line">    dat /= <span class="number">10</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (dat &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  len += i;    <span class="comment">// 局部变量 i 最后的值为有效字符个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将数组值转换为ASCII码反向拷贝到接收指针上 */</span></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    *str++ = buf[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len;  <span class="comment">// 返回字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示运算符，参数 y 是显示位置，参数 type 是运算符类型 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOprt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> type)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: LcdShowStr(<span class="number">0</span>, y, <span class="string">&quot;+&quot;</span>); <span class="keyword">break</span>; <span class="comment">// 0 代表 +</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: LcdShowStr(<span class="number">0</span>, y, <span class="string">&quot;-&quot;</span>); <span class="keyword">break</span>; <span class="comment">// 1 代表 -</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: LcdShowStr(<span class="number">0</span>, y, <span class="string">&quot;*&quot;</span>); <span class="keyword">break</span>; <span class="comment">// 2 代表 *</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: LcdShowStr(<span class="number">0</span>, y, <span class="string">&quot;/&quot;</span>); <span class="keyword">break</span>; <span class="comment">// 3 代表 /</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算器复位，清零变量值与屏幕显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">()</span> &#123;</span><br><span class="line">  num1 = <span class="number">0</span>;</span><br><span class="line">  num2 = <span class="number">0</span>;</span><br><span class="line">  step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LcdFullClear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数字按键动作函数，参数 n 表示按键输入数值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NumKeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果计算已经完成，就开始新的计算 */</span></span><br><span class="line">  <span class="keyword">if</span> (step &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    Reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 输入第 1 个操作数 */</span></span><br><span class="line">  <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">    num1 = num1 * <span class="number">10</span> + n;          <span class="comment">// 输入数值累加到原来的操作数</span></span><br><span class="line">    len = LongToString(str, num1); <span class="comment">// 新的数值转换为字符串</span></span><br><span class="line">    LcdShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str);  <span class="comment">// 显示到液晶第 2 行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 输入第 2 个操作数 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    num2 = num2 * <span class="number">10</span> + n;          <span class="comment">// 输入数值累加到原来的操作数</span></span><br><span class="line">    len = LongToString(str, num2); <span class="comment">// 新的数值转换为字符串</span></span><br><span class="line">    LcdShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str);  <span class="comment">// 显示到液晶第 2 行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运算符按键动作函数，运算符类型type */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OprtKeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> type)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 2 个操作数尚未输入时响应，即不支持连续操作 */</span></span><br><span class="line">  <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">    len = LongToString(str, num1); <span class="comment">// 第 1 个操作数转换为字符串</span></span><br><span class="line"></span><br><span class="line">    LcdAreaClear(<span class="number">0</span>, <span class="number">0</span>, <span class="number">16</span> - len);  <span class="comment">// 清除第 1 行左边的字符位置</span></span><br><span class="line">    LcdShowStr(<span class="number">16</span> - len, <span class="number">0</span>, str);  <span class="comment">// 字符串靠右显示在第 1 行</span></span><br><span class="line">    ShowOprt(<span class="number">1</span>, type);             <span class="comment">// 在第 2 行显示操作符</span></span><br><span class="line">    LcdAreaClear(<span class="number">1</span>, <span class="number">1</span>, <span class="number">14</span>);        <span class="comment">// 清除第 2 行中间的字符位置</span></span><br><span class="line">    LcdShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);        <span class="comment">// 在第 2 行最右端显示 0</span></span><br><span class="line"></span><br><span class="line">    oprt = type;                   <span class="comment">// 记录操作类型</span></span><br><span class="line">    step = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算结果函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 2 个操作数输入以后才执行计算 */</span></span><br><span class="line">  <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">    step = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据运算符类型计算结果（未考虑溢出） */</span></span><br><span class="line">    <span class="keyword">switch</span> (oprt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: result = num1 + num2; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: result = num1 - num2; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: result = num1 * num2; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: result = num1 / num2; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将之前的第 2 操作数和运算符显示至第 1 行 */</span></span><br><span class="line">    len = LongToString(str, num2);</span><br><span class="line">    ShowOprt(<span class="number">0</span>, oprt);</span><br><span class="line">    LcdAreaClear(<span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span> - <span class="number">1</span> - len);</span><br><span class="line">    LcdShowStr(<span class="number">16</span> - len, <span class="number">0</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算结果、等号显示到第 2 行 */</span></span><br><span class="line">    len = LongToString(str, result);</span><br><span class="line">    LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">    LcdAreaClear(<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span> - <span class="number">1</span> - len);</span><br><span class="line">    LcdShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据按键码执行相应操作，参数 keycode 表示按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((keycode &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (keycode &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">    NumKeyAction(keycode - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    OprtKeyAction(<span class="number">0</span>);           <span class="comment">// 向上键，+</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) &#123;</span><br><span class="line">    OprtKeyAction(<span class="number">1</span>);           <span class="comment">// 向下键，-</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x25</span>) &#123;</span><br><span class="line">    OprtKeyAction(<span class="number">2</span>);           <span class="comment">// 向左键，*</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x27</span>) &#123;</span><br><span class="line">    OprtKeyAction(<span class="number">3</span>);           <span class="comment">// 向右键，÷</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x0D</span>) &#123;</span><br><span class="line">    GetResult();                <span class="comment">// 回车键，计算结果</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x1B</span>) &#123;</span><br><span class="line">    Reset();                    <span class="comment">// Esc键，清除</span></span><br><span class="line">    LcdShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;     <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>; <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;       <span class="comment">// 计算定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">28</span>;          <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时值拆分为高、低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;           <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;           <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;             <span class="comment">// 加载定时器 T0 初始值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，执行按键扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL; <span class="comment">// 重新加载定时值</span></span><br><span class="line">  KeyScan();  <span class="comment">// 调用按键扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="液晶与串口通信综合试验">1602 液晶与串口通信综合试验</h2>
<p>实际工作当中，单片机经常需要通过串口与电脑上安装的上位机软件进行交互，从而执行不同的功能。本小节试验会通过电脑上的串口调试助手发送
3
条指令：<code>buzz on</code>打开蜂鸣器、<code>buzz off</code>关闭蜂鸣器、<code>showstr</code>将命令后面的字符串显示到
1602 液晶，单片机接收到这些命令以后会将其原样返回。</p>
<p>发送一帧包含多个字节的数据时，这些数据会逐个字节连续不断进行发送，中间没有间隔或者间隔时间极短，当该帧数据发送完毕之后，将会间隔相对较长的一段时间不再发送数据，通信总线也就会空闲一段较长时间，因此可以在代码当中设置一个<strong>总线空闲定时器</strong>，该定时器在有数据传输时清零，而在总线空闲时累加，当累加至<code>30 ms</code>毫秒时间之后，就认为一帧数据已经传输完毕，其它程序可以开始进行数据的处理。本次数据处理完毕后就恢复到初始状态，并开始准备下一轮接收。这里用于判定每帧结束的空闲时间并无一个固定值，开发时需要综合考虑如下两个原则：</p>
<ol type="1">
<li><strong>该时间必须大于波特率周期</strong>，这是由于单片机接收中断产生于一个字节数据接收完毕之后，程序无法了解其具体接收过程，因而在至少一个波特率周期内，不能认为达到了每帧结束的空闲时间。</li>
<li><strong>需要考虑到发送者的系统延时</strong>，发送者并不总是能保证数据严格无间隔发送，因此需要再附加几十毫秒处理时间，本实验选取的<code>30 ms</code>能适应大部分波特率（大于<code>1200</code>）以及大部分计算机或其它单片机设备的系统延时。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Uart.c 文件，基于帧模式的 UART 串口驱动程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bit flagFrame = <span class="number">0</span>;              <span class="comment">// 帧接收完成标志，即接收到一帧新数据</span></span><br><span class="line">bit flagTxd = <span class="number">0</span>;                <span class="comment">// 单字节发送完成标志，用来替代TXD中断标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cntRxd = <span class="number">0</span>;       <span class="comment">// 接收字节计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pdata bufRxd[<span class="number">64</span>]; <span class="comment">// 接收字节缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> &#123;</span><br><span class="line">  SCON = <span class="number">0x50</span>;                             <span class="comment">// 配置串口为工作方式 1</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                            <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x20</span>;                            <span class="comment">// 配置定时器 T1 为工作模式 2</span></span><br><span class="line">  TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">// 计算定时器 T1 的定时值</span></span><br><span class="line">  TL1 = TH1;                               <span class="comment">// 将高位的定时值作为低位的初值</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                                 <span class="comment">// 禁用定时器 T1 中断</span></span><br><span class="line">  ES = <span class="number">1</span>;                                  <span class="comment">// 使能串口中断</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                                 <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据写入函数，参数 buf 是等待发送数据的指针，参数 len 是发送的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">/* 循环发送所有的字节 */</span></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    flagTxd = <span class="number">0</span>;      <span class="comment">// 发送完成标志位清零</span></span><br><span class="line">    SBUF = *buf++;    <span class="comment">// 发送 1 个字节的数据</span></span><br><span class="line">    <span class="keyword">while</span> (!flagTxd); <span class="comment">// 等待该字节发送完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据读取函数，参数 buf 表示接收指针的指针，参数 len 表示读取的长度，返回值是实际读取到的长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">UartRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="comment">/* 当指定的读取长度大于实际接收到的数据长度时，将读取长度设置为实际接收到的数据长度 */</span></span><br><span class="line">  <span class="keyword">if</span> (len &gt; cntRxd) &#123;</span><br><span class="line">    len = cntRxd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将接收到的数据拷贝至接收指针 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    *buf++ = bufRxd[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cntRxd = <span class="number">0</span>; <span class="comment">// 接收计数器清零</span></span><br><span class="line">  <span class="keyword">return</span> len; <span class="comment">// 返回实际读取的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口接收监控函数，基于空闲时间来判定帧结束，在定时中断中调用，参数 ms 表示定时间隔 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> cntbkp = <span class="number">0</span>;  <span class="comment">// 接收计数变量</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> idletmr = <span class="number">0</span>; <span class="comment">// 总线空闲计时变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当接收计数变量大于零时，监听总线的空闲时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (cntRxd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果接收计数变量发生改变（即刚接收到数据时），空闲计时变量清零 */</span></span><br><span class="line">    <span class="keyword">if</span> (cntbkp != cntRxd) &#123;</span><br><span class="line">      cntbkp = cntRxd;</span><br><span class="line">      idletmr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果接收计数变量没有改变（即总线保持空闲时），将空闲时间进行累加 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 总线空闲计时小于 30ms 持续累加 */</span></span><br><span class="line">      <span class="keyword">if</span> (idletmr &lt; <span class="number">30</span>) &#123;</span><br><span class="line">        idletmr += ms;</span><br><span class="line">        <span class="comment">/* 总线空闲计时达到 30ms，就认为一帧数据接收完毕 */</span></span><br><span class="line">        <span class="keyword">if</span> (idletmr &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">          flagFrame = <span class="number">1</span>;            <span class="comment">// 设置数据帧接收完成标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cntbkp = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口驱动函数，监测数据帧的接收，调度功能函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> pdata buf[<span class="number">40</span>];</span><br><span class="line">  <span class="comment">/* 当数据帧到达时，读取并处理该命令 */</span></span><br><span class="line">  <span class="keyword">if</span> (flagFrame) &#123;</span><br><span class="line">    flagFrame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len = UartRead(buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 将接收到的命令读取至缓冲区</span></span><br><span class="line">    UartAction(buf, len);             <span class="comment">// 传递数据帧，调用动作执行函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line">  <span class="comment">/* 接收到新的字节数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (RI) &#123;</span><br><span class="line">    RI = <span class="number">0</span>;      <span class="comment">// 接收中断标志位清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收缓冲区尚未用完时，保存接收字节，并递增计数器 */</span></span><br><span class="line">    <span class="keyword">if</span> (cntRxd &lt; <span class="keyword">sizeof</span>(bufRxd)) &#123;</span><br><span class="line">      bufRxd[cntRxd++] = SBUF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 字节发送完毕 */</span></span><br><span class="line">  <span class="keyword">if</span> (TI) &#123;</span><br><span class="line">    TI = <span class="number">0</span>;      <span class="comment">// 发送中断标志位清零</span></span><br><span class="line">    flagTxd = <span class="number">1</span>; <span class="comment">// 发送完成标志位置 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>Uart.c</code>文件里存在两个需要注意的知识点，首先对于接收数据的处理，串口中断时会将接收到的字节保存至<code>bufRxd</code>缓冲区，同时在其它定时器中断内不断调用<code>UartRxMonitor()</code>监控一帧数据是否接收完毕（判定原则即如前所述的空闲时间）；如果判断一帧数据已经接收完毕，就会设置<code>flagFrame</code>标志位，主循环可以通过调用<code>UartDriver()</code>对该标志位进行检测并处理接收到的数据；处理接收到的数据时，将会首先通过串口读取函数<code>UartRead()</code>将接收缓冲区<code>bufRxd</code>内的数据读取出来，然后再对读取到的数据进行判断处理。</p>
<p>代码中之所以不直接对<code>bufRxd</code>接收到的数据进行处理，主要是为了提高串行接口的收发效率：如果在<code>bufRxd</code>中处理数据，由于新接收的数据会破坏之前的数据，此时将不能再接收任何其它的数据；另外，数据处理过程可能会耗费较长时间，在这个时间里如果无法接收新的命令，可能会被发送方认为已经失去响应了。上面代码里实现的这种<strong>双缓冲机制</strong>大大改善了这些问题，由于数据拷贝所需的时间较短，只要完成拷贝以后，<code>bufRxd</code>就可以马上开始接收新的数据。</p>
<p>另外，串口数据写入函数<code>UartWrite()</code>会将数据指针<code>buf</code>指向的数据块连续发送出去，虽然串口程序启用了中断，但是此时发送功能并没有在中断里完成，而是仍然依靠查询发送中断标志位<code>flagTxd</code>来完成（由于中断函数内部必须清零发送中断请求标志位<code>TI</code>，否则中断将会重复进入执行，所以新建了<code>flagTxd</code>标志位来替代<code>TI</code>）；虽然也可以采用先将发送数据拷贝至一个缓冲区，然后再在中断内将缓冲区数据发送的方式，但是这样会耗费额外的内存，并且让程序更加复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c 文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>; <span class="comment">// 蜂鸣器控制引脚</span></span><br><span class="line"></span><br><span class="line">bit flagBuzzOn = <span class="number">0</span>;     <span class="comment">// 蜂鸣器启动标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdAreaClear</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);  <span class="comment">// 配置定时器 T0 定时 1ms</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 配置波特率为 9600</span></span><br><span class="line">  InitLcd1602();    <span class="comment">// 初始化液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UartDriver();   <span class="comment">// 调用串口驱动程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存比较函数，比较两个指针所指向的内存数据是否相同；参数 ptr1 是待比较指针 1，参数 ptr2 是待比较指针 2，参数 len 是待比较长度 */</span></span><br><span class="line">bit <span class="title function_">CmpMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr1, <span class="type">unsigned</span> <span class="type">char</span> *ptr2, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    <span class="comment">/* 遇到不相等数据时即刻返回0 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptr1++ != *ptr2++) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 两段内存数据不相同返回 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 两段内存数据完全相同返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，根据接收到的命令帧执行相应的动作；参数 buf 是接收到的命令帧指针，参数 len 是命令帧的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmd0[] = <span class="string">&quot;buzz on&quot;</span>;  <span class="comment">// 打开蜂鸣器命令</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmd1[] = <span class="string">&quot;buzz off&quot;</span>; <span class="comment">// 关闭蜂鸣器命令</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmd2[] = <span class="string">&quot;showstr &quot;</span>; <span class="comment">// 1602 液晶字符串显示命令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 命令长度数组 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmdLen[] = &#123; <span class="keyword">sizeof</span>(cmd0) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd1) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd2) - <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 命令指针数组 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code *cmdPtr[] = &#123; &amp;cmd0[<span class="number">0</span>], &amp;cmd1[<span class="number">0</span>], &amp;cmd2[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历命令长度数组，查找相同的命令 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmdLen); i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收到的数据长度不能小于命令长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= cmdLen[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CmpMemory(buf, cmdPtr[i], cmdLen[i])) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 比较相同时退出循环</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 上面的循环退出时，i 的值就是当前命令的索引值 */</span></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: flagBuzzOn = <span class="number">1</span>; <span class="keyword">break</span>; <span class="comment">// 开启蜂鸣器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: flagBuzzOn = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// 关闭蜂鸣器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      buf[len] = <span class="string">&#x27;\0&#x27;</span>;                   <span class="comment">// 为接收到的字符串添加结束符</span></span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, buf + cmdLen[<span class="number">2</span>]); <span class="comment">// 显示命令后面的字符串</span></span><br><span class="line">      i = len - cmdLen[<span class="number">2</span>];               <span class="comment">// 计算有效字符个数，如果少于 16 就清除屏幕上的后续字符位</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        LcdAreaClear(i, <span class="number">0</span>, <span class="number">16</span> - i);</span><br><span class="line">      &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果没有找到相符的命令，就给上位机发送【错误命令】提示</span></span><br><span class="line">    <span class="keyword">default</span>: UartWrite(<span class="string">&quot;bad command.\r\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;bad command.\r\n&quot;</span>) - <span class="number">1</span>); <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf[len++] = <span class="string">&#x27;\r&#x27;</span>;                     <span class="comment">// 有效命令被执行后，在原命令帧之后添加</span></span><br><span class="line">  buf[len++] = <span class="string">&#x27;\n&#x27;</span>;                     <span class="comment">// 回车换行符后返回给上位机，表示已执行</span></span><br><span class="line">  UartWrite(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 表示定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器初始值</span></span><br><span class="line">  tmp = tmp + <span class="number">33</span>;                   <span class="comment">// 补偿由于中断响应延迟造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 拆分定时值为高低位</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 定时器 T0 控制位置 0</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;                       <span class="comment">// 定时值存储寄存器赋初值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于监听串口接收和驱动蜂鸣器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;       <span class="comment">// 重新加载定时值</span></span><br><span class="line">  <span class="keyword">if</span> (flagBuzzOn)</span><br><span class="line">    BUZZ = ~BUZZ;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    BUZZ = <span class="number">1</span>;</span><br><span class="line">  UartRxMonitor(<span class="number">1</span>); <span class="comment">// 监听串口接收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中，串口接收数据的解析方法具有较强普适性，需要用心体会并灵活运用。首先，<code>CmpMemory()</code>函数用于比较两段内存数据，函数将会接收两段数据的指针，然后通过语句<code>if (*ptr1++ != *ptr2++)</code>逐个字节进行比较，并在比较完成以后将两个指针都自增<code>1</code>。从而判断接收到的数据与程序内置命令字符串是否相同，便于后续代码检索出相应的命令。</p>
<p>其次，<code>UartAction()</code>函数会对接收到的数据进行解析与处理，即先将接收到的数据与命令字符串逐条比较，比较时需要先确保接收到的长度大于命令字符串长度，然后再通过<code>CmpMemory()</code>函数逐字节进行比较，如果比较相同就退出循环，不相同则继续对比下一条命令。当出现相符的命令字符串时，最终循环索引变量<code>i</code>就是该命令在列表中的索引位置，如果没有查询到相符命令，最后<code>i</code>的值将等于命令总数，那么最后就会采用<code>switch</code>语句，根据<code>i</code>的值来执行相应的具体动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lcd1602.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0</span></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备完毕 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">  LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    sta = LCD1602_DB;    <span class="comment">// 读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果 bit7 等于 1 表示液晶正忙，循环检测直至等于表示空闲的 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节命令到液晶，参数 cmd 表示待写入的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = cmd;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节数据到液晶，参数 dat 表示待写入的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = dat;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，即光标位置，参数 x 和 y 分别对应屏幕的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据屏幕坐标计算显示 RAM 地址 */</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    addr = <span class="number">0x00</span> + x;        <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    addr = <span class="number">0x40</span> + x;        <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">  LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，参数 x 和 y 对应屏幕上的起始坐标，参数 str 是字符串指针，参数 len 是需要显示的字符长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y);    <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入字符串，直至检测到结束符 */</span></span><br><span class="line">  <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    LcdWriteDat(*str++); <span class="comment">// 首先获得 str 指向的数据，然后 str 再自增 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 区域清屏，清除 x、y 坐标起始的 len 个字符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdAreaClear</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y); <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    LcdWriteDat(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 循环写入空格</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化1602液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x38</span>); <span class="comment">// 16×2显示，5×7点阵，8位数据接口</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>); <span class="comment">// 开启显示器，关闭光标</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x06</span>); <span class="comment">// 文字保持不动，地址自增 1</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>); <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="i²c-总线">I²C 总线</h1>
<p><strong>I²C</strong>总线是由 PHILIPS
公司开发的两线式串行总线，多用于连接微处理器与外围芯片，两条线可以挂载多个器件组成<strong>多机模式</strong>，任何一个器件都可以作为主设备（同一时刻只能有一个主设备）。</p>
<p>从原理角度来看，<strong>UART</strong>属于异步通信，例如前面例子中，计算机只负责将数据通过<strong>TXD</strong>发送，而接收数据是单片机自己的工作；而<strong>I²C</strong>属于同步通信，<strong>SCL</strong>时钟线负责收发双方的时钟节拍，<strong>SDA</strong>数据线负责传输数据，收发双方都是以
SCL
这个时钟节拍为基准进行数据的传输。从应用角度而言，<strong>UART</strong>通常用于板间通信，例如计算机与单片机或者单片机与单片机；而<strong>I²C</strong>多用于板内通信，例如后续将会介绍的单片机
与 EEPROM 之间。</p>
<h2 id="i²c-时序">I²C 时序</h2>
<p>I²C 硬件上由<strong>时钟总线 SCL</strong>与<strong>数据总线
SDA</strong>构成，总线上所有设备的<strong>SCL</strong>相互连接在一起，所有<strong>SDA</strong>同样相互连接在一起。I²C
总线属于开漏引脚并联结构，因此外部需要添加上拉电阻<strong>R63</strong>和<strong>R64</strong>，从而在总线上构成一个【线与】关系，即所有接入总线的器件保持高电平，总线才是高电平，而任何一个器件输出低电平，则总线就会保持低电平。换而言之，总线上的任何器件都可以拉低电平作为主设备。</p>
<p><img src="/Embedded/STC89C52/I2C/pull-up-resistance.png"></p>
<p>通常情况下，I²C
总线上都是由单片机微控制器作为主机，总线上挂载的诸多设备都拥有各自的唯一地址，信息传输时将会通过这个地址识别属于各自设备的信息，当前的实验电路上已经挂载了<strong>24C02</strong>和<strong>PCF8591</strong>两个
I²C 总线设备。与 UART 串行通信类似，I²C
总线时序也分为起始信号、数据传输信号、停止信号，如下图所示：</p>
<p><img src="/Embedded/STC89C52/I2C/sequence-1.png"></p>
<p>UART 传输的每个字节都有 1 个起始位、8 个数据位、1 个停止位，而 I²C
分为起始信号、数据传输部分、停止信号，其中数据传输部分可以一次传输多个字节，而每个字节数据的最后也会跟着一个应答位（用<strong>ACK</strong>表示）。此外，虽然
UART
也使用了<strong>TXD</strong>和<strong>RXD</strong>两条通信线路，但是实际上每次通信只需要通过一条线来完成，采用两条线只是为了区分<strong>接收</strong>和<strong>发送</strong>；而
I²C
每次通信无论收发，两条通信线路都必须<strong>同时</strong>参加工作。为了更直观的观察每位的传输流程，这里在上面时序图基础上添加了辅助分析的分隔线：</p>
<p><img src="/Embedded/STC89C52/I2C/sequence-2.png"></p>
<ul>
<li><strong>起始信号</strong>：<strong>UART</strong>是将持续高电平时突然出现的低电平作为起始位；而<strong>I²C</strong>起始信号是在<strong>SCL</strong>为高电平期间，由<strong>SDA</strong>高电平向低电平跳变产生的下降沿作为起始信号，即上图中<strong>Start</strong>阶段所示。</li>
<li><strong>数据传输</strong>：<strong>UART</strong>是低位在前高位在后；而<strong>I²C</strong>是<strong>高位在前低位在后</strong>。此外，<strong>UART</strong>通信的数据位是波特率分之一的固定长度，逐位在固定时间完成发送即可；而<strong>I²C</strong>虽然没有固定波特率，但是在时序上要求<strong>SCL</strong>为低电平时，<strong>SDA</strong>允许变化，即发送方必须首先保持<strong>SCL</strong>为低电平，才能够改变<strong>SDA</strong>状态输出一位待发送的数据；当<strong>SCL</strong>为高电平时<strong>SDA</strong>的状态不能被改变，因为此时接收方需要读取<strong>SDA</strong>的电平状态，所以必需保证<strong>SDA</strong>状态的稳定，上图中每位数据的变化都是发生在<strong>SCL</strong>的低电平位置。</li>
<li><strong>停止信号</strong>：<strong>UART</strong>的停止位固定为一位高电平信号，而<strong>I²C</strong>停止信号是在<strong>SCL</strong>为高电平期间，由<strong>SDA</strong>从低电平向高电平跳变产生的一个上升沿，即上图中<strong>Stop</strong>部分所示。</li>
</ul>
<h2 id="i²c-寻址模式">I²C 寻址模式</h2>
<p>上一小节介绍了 I²C 位级信号的时序流程，而 I²C
在字节级依然存在固定的时序要求。I²C
起始信号<strong>Start</strong>之后，需要首先发送一个 7
位从机地址，接下来紧随其后的第 8
位是数据方向位<strong>R/W</strong>，如果为<code>0</code>就表示接下来的数据为接收数据（写操作），为<code>1</code>就表示接下来的数据为是请求数据（读操作），最后第
9 位<strong>ACK</strong>的作用是在 7 位地址位和 1
位方向位发送完毕以后，如果发送地址真实存在，那么该地址的设备将会响应一位<strong>ACK</strong>，即拉低<strong>SDA</strong>输出<code>0</code>；如果不存在，则没有设备回应<strong>ACK</strong>，<strong>SDA</strong>将会持续保持高电平状态<code>1</code>。</p>
<p>接下来编写一个程序，通过 I²C 访问一下实验电路上的 EEPROM
地址，另外再访问一个不存在的地址设备，观察是否能够返回<strong>ACK</strong>。实验电路中采用的<strong>EEPROM</strong>型号为<strong>24C02</strong>，其
7 位地址中高 4 位固定为<code>0b1010</code>，而低 3
位地址取决于具体电路设计，由芯片上<strong>A2</strong>、<strong>A1</strong>、<strong>A0</strong>三个引脚的电平状态确定，下面是<strong>24C02</strong>的电路图：</p>
<p><img src="/Embedded/STC89C52/I2C/diagram.png"></p>
<p>上图中，<strong>A2</strong>、<strong>A1</strong>、<strong>A0</strong>全都连接到了<strong>GND</strong>，三个引脚的电平状态全部为<code>0</code>，因此<strong>24C02</strong>的
7
位二进制地址应为<code>0b1010000</code>，换算成十六进制也就是<code>0x50</code>。下面代码将采用
I²C
协议来寻址<code>0x50</code>以及一个不存在的地址<code>0x62</code>，寻址完毕以后返回<strong>ACK</strong>的状态并显示到
1602 液晶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lcd1602.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0</span></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备完毕 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">  LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    sta = LCD1602_DB;    <span class="comment">// 读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果 bit7 等于 1 表示液晶正忙，循环检测直至等于表示空闲的 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节命令到液晶，参数 cmd 表示待写入的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = cmd;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节数据到液晶，参数 dat 表示待写入的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = dat;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，即光标位置，参数 x 和 y 分别对应屏幕的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据屏幕坐标计算显示 RAM 地址 */</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    addr = <span class="number">0x00</span> + x;        <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    addr = <span class="number">0x40</span> + x;        <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">  LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，参数 x 和 y 对应屏幕上的起始坐标，参数 str 是字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y);       <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入字符串，直至检测到结束符 */</span></span><br><span class="line">  <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    LcdWriteDat(*str++);    <span class="comment">// 首先获得 str 指向的数据，然后 str 再自增 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化1602液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x38</span>);        <span class="comment">// 16×2 显示，5×7 点阵，8 位数据接口</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>);        <span class="comment">// 开启显示器，关闭光标</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x06</span>);        <span class="comment">// 文字保持不动，地址自增 1</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>);        <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CDelay() &#123;_nop_();_nop_();_nop_();_nop_();&#125;</span></span><br><span class="line">sbit I2C_SCL = P3 ^ <span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3 ^ <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">bit <span class="title function_">I2CAddressing</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">  InitLcd1602();              <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  ack = I2CAddressing(<span class="number">0x50</span>);  <span class="comment">// 查询地址为 0x50 的器件</span></span><br><span class="line">  str[<span class="number">0</span>] = <span class="string">&#x27;5&#x27;</span>;               <span class="comment">// 将地址和响应值转换为字符串</span></span><br><span class="line">  str[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">  str[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)ack + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);      <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  ack = I2CAddressing(<span class="number">0x62</span>);  <span class="comment">// 查询地址为 0x62 的设备</span></span><br><span class="line">  str[<span class="number">0</span>] = <span class="string">&#x27;6&#x27;</span>;               <span class="comment">// 将地址和响应值转换为字符串</span></span><br><span class="line">  str[<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">  str[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)ack + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  LcdShowStr(<span class="number">8</span>, <span class="number">0</span>, str);      <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span> &#123;</span><br><span class="line">  I2C_SDA = <span class="number">1</span>;               <span class="comment">// 确保 SDA、SCL 都是高电平</span></span><br><span class="line">  I2C_SCL = <span class="number">1</span>;</span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SDA = <span class="number">0</span>;               <span class="comment">// 拉低 SDA</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;               <span class="comment">// 拉低 SCL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span> &#123;</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;               <span class="comment">// 确保 SDA、SCL 都是低电平</span></span><br><span class="line">  I2C_SDA = <span class="number">0</span>;</span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>;               <span class="comment">// 拉高 SCL</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SDA = <span class="number">1</span>;               <span class="comment">// 拉高 SDA</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C总线写操作，参数 dat 中待写入的字节数据，返回从设备响应位的值 */</span></span><br><span class="line">bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  bit ack;                   <span class="comment">// 用于暂存响应位的值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;        <span class="comment">// 用于检测字节内某一位值的掩码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从高位至低位依次执行 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x80</span>; mask != <span class="number">0</span>; mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将该位的值输出至 SDA */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) == <span class="number">0</span>)</span><br><span class="line">      I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      I2C_SDA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;             <span class="comment">// 拉高 SCL</span></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;             <span class="comment">// 拉低 SCL，完成一个位周期</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_SDA = <span class="number">1</span>;               <span class="comment">// 8 位数据发送完毕后，主设备释放 SDA 以检测从设备响应</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>;               <span class="comment">// 拉高 SCL</span></span><br><span class="line">  ack = I2C_SDA;             <span class="comment">// 读取此时 SDA 的值，即从设备响应值</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;               <span class="comment">// 再次拉低 SCL 完成响应</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack;                <span class="comment">// 返回从设备的响应值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I²C 寻址函数，addr 参数是待检测的设备地址，最后返回从设备响应值 */</span></span><br><span class="line">bit <span class="title function_">I2CAddressing</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line"></span><br><span class="line">  I2CStart();                <span class="comment">// 生成起始位，即启动一次总线操作</span></span><br><span class="line">  ack = I2CWrite(addr &lt;&lt; <span class="number">1</span>); <span class="comment">// 寻址命令最低位为读写位，用于表示之后操作的读写状态，因此设备地址左移一位</span></span><br><span class="line">  I2CStop();                 <span class="comment">// 直接停止本次总线操作，无需再进行后续的读写操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码利用了前面提到的库函数<code>_nop_()</code>进行精确延时，一个<code>_nop_()</code>的运行时间就是一个机器周期，该库函数包含在<code>intrins.h</code>头文件。程序编译运行之后，主设备发送一个真实的从设备地址，从设备会回复一个应答位<code>0</code>；主设备如果发送一个不存在的从设备地址，由于没有从设备响应，此时应答位为<code>1</code>。</p>
<p>I²C
通信分为<code>100 kbit/s</code>的低速模式、<code>400 kbit/s</code>的快速模式、<code>3.4 Mbit/s</code>的高速模式，由于所有
I²C 设备都支持低速模式，而未必同时支持另外两种模式，因此上面代码作为通用
I²C
程序选择了<code>100 kbit/s</code>的低速模式实现。换而言之，单片机实际产生的时序必须小于或等于这个速率，也就是说<strong>SCL</strong>高低电平的持续时间不得短于<code>5 us</code>，因此代码在时序函数中插入了总线延时函数<code>I2CDelay()</code>（实质就是
4
次<code>_nop_()</code>库函数调用），加上改变<strong>SCL</strong>值的语句本身需要消耗至少一个周期，最终就满足了低速模式下的速率限制。如果后续想要提升速度，那么减小此处的总线延时时间即可。</p>
<blockquote>
<p><strong>注意</strong>：<code>I2CWrite()</code>函数当中<code>for(mask=0x80; mask!=0; mask&gt;&gt;=1)</code>循环语句的使用技巧，由于
I²C
通信从高位开始发送数据，所以先从最高位开始，<code>0x80</code>和<code>dat</code>进行按位与运算，从而得知<code>dat</code>的第
7 位是<code>0</code>还是<code>1</code>，然后右移 1
位变为<code>0x40</code>和<code>dat</code>的按位与运算，进而得知第 6
位是<code>0</code>还是<code>1</code>，如此循环直至第<code>0</code>位结束，最终通过<code>if</code>语句将<code>dat</code>的
8 位数据依次发送出去。</p>
</blockquote>
<h1 id="eeprom-24c02">EEPROM 24C02</h1>
<p>保存在单片机<strong>RAM</strong>内的数据掉电后就会丢失，而保存在单片机<strong>FLASH</strong>内的数据又不能用于记录变化的数值，而实际开发场景当中又经常需要记录下一些需要经常进行修改的数据，并且在掉电之后还不会丢失。本小节将要介绍的
EEPROM 就是能够满足这一特性的存储器，当前实验电路中选用的是 ATMEL
公司型号为<strong>24C02</strong>的<strong>EEPPROM</strong>，其容量大小为<code>256 Byte</code>，并且基于
I²C 通信协议。</p>
<h2 id="eeprom-单字节读写时序">EEPROM 单字节读写时序</h2>
<h3 id="eeprom-写数据流程">EEPROM 写数据流程</h3>
<ol type="1">
<li>I²C 起始信号和设备地址，并且读写方向上选择为【写】操作。</li>
<li>发送数据的存储地址，<strong>24C02</strong>拥有 256
字节存储空间，地址从<code>0x00 ~ 0xFF</code>，需要将数据存储在哪个位置就填写哪个地址。</li>
<li>发送待存储数据的第 1、2、...个字节，注意 EEPROM
每个字节都会回应一个应答位<code>0</code>，用于通知写数据成功，如果未返回应答位，则说明写入不成功。</li>
</ol>
<blockquote>
<p>写数据过程中，每成功写入 1 个字节，EEPROM
存储空间地址就会自增<code>1</code>，当加至<code>0xFF</code>以后再进行写入，地址就溢出为<code>0x00</code>。</p>
</blockquote>
<h3 id="eeprom-读数据流程">EEPROM 读数据流程</h3>
<ol type="1">
<li>I²C
起始信号和设备地址，读写方向上依然选择【写】操作，之所以这里仍然选择写，是为了通知
EEPROM 当前需要读取数据位于哪个地址。</li>
<li>发送待读取数据的地址，注意这里是地址而非存储在 EEPROM
中的数据本身。</li>
<li>重新发送 I²C 起始信号与器件地址，并且读写方向位选择【读】操作。</li>
<li>读取 EEPROM 响应的数据，1
个字节读取完成之后，如果需要继续读取下个字节，应答位<strong>ACK</strong>发送<code>0</code>；如果不需要再读取，则发送<code>1</code>通知
EEPROM 不再进行读取数据。</li>
</ol>
<blockquote>
<p>前 3 个步操作当中，每个字节本质上都处于【写】操作，因此 EEPROM
每个字节的应答位都是<code>0</code>。</p>
</blockquote>
<p>与上面的写数据流程类似，每读取一个字节，地址就会自动加<code>1</code>，如果需要继续读取，就向
EEPROM
发送一个<strong>ACK</strong>低电平<code>0</code>，并且再继续给<strong>SCL</strong>提供完整的时序，此时
EEPROM 会继续往外发送数据。如果无需再进行读取，就直接向 EEPROM
发送一个<strong>NAK</strong>高电平<code>1</code>，通知 EEPROM
不再读取数据，下面再梳理一下此处的逻辑顺序：</p>
<ol type="1">
<li>假如<strong>STC89C52RC</strong>单片机是主设备，<strong>24C02</strong>是从设备；</li>
<li>无论读还是写，<strong>SCL</strong>始终由主设备单片机控制；</li>
<li>写的时候应答信号由从设备<strong>24C02</strong>提供，表示从设备是否正确接收了数据；</li>
<li>读的时候应答信号由主设备<strong>STC89C52RC</strong>提供，表示是否继续进行读取。</li>
</ol>
<p>接下来编写一段程序，读取 EEPROM
上地址为<code>0x02</code>上的数据，加<code>1</code>以后再将结果回写到该地址上。与前面将
1602
液晶显示相关的操作封装至<code>Lcd1602.c</code>文件一样，下面代码也会将
I²C
总线的操作函数（起始、停止、字节写、字节读和应答、字节读和非应答）封装至一个独立的<code>I2C.c</code>文件，便于程序代码的复用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** I2C.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CDelay() &#123;_nop_();_nop_();_nop_();_nop_();&#125;</span></span><br><span class="line">sbit I2C_SCL = P3 ^ <span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3 ^ <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span> &#123;</span><br><span class="line">  I2C_SDA = <span class="number">1</span>; <span class="comment">// 确保 SDA、SCL 都是高电平</span></span><br><span class="line">  I2C_SCL = <span class="number">1</span>;</span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SDA = <span class="number">0</span>; <span class="comment">// 拉低 SDA</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>; <span class="comment">// 拉低 SCL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span> &#123;</span><br><span class="line">  I2C_SCL = <span class="number">0</span>; <span class="comment">// 确保 SDA、SCL 都是低电平</span></span><br><span class="line">  I2C_SDA = <span class="number">0</span>;</span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>; <span class="comment">// 拉高 SCL</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SDA = <span class="number">1</span>; <span class="comment">// 拉高 SDA</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  bit ack;            <span class="comment">// 用于暂存响应位的值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask; <span class="comment">// 用于检测字节内某一位值的掩码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从高位至低位依次执行 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x80</span>; mask != <span class="number">0</span>; mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 将该位的值输出至 SDA */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) == <span class="number">0</span>)</span><br><span class="line">      I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      I2C_SDA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;      <span class="comment">// 拉高 SCL</span></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;      <span class="comment">// 拉低 SCL，完成一个位周期</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_SDA = <span class="number">1</span>;        <span class="comment">// 8 位数据发送完毕后，主设备释放 SDA 以检测从设备响应</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>;        <span class="comment">// 拉高 SCL</span></span><br><span class="line">  ack = I2C_SDA;      <span class="comment">// 读取此时 SDA 的值，即从设备响应值</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;        <span class="comment">// 再次拉低 SCL 完成响应</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (~ack);      <span class="comment">// 应答值取反以符合日常逻辑，0 表示不存在/忙/写入失败，1 表示存在/空闲/写入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I²C 总线读操作，并且发送 NAK 非应答信号，返回读取到的字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadNAK</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  I2C_SDA = <span class="number">1</span>;        <span class="comment">// 确保主设备释放 SDA</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从高位到低位依次进行 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x80</span>; mask != <span class="number">0</span>; mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;      <span class="comment">// 拉高 SCL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SDA 的值为 0 时，dat 对应位置清零，为 1 时对应位置 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_SDA == <span class="number">0</span>)</span><br><span class="line">      dat &amp;= ~mask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dat |= mask;</span><br><span class="line"></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;      <span class="comment">// 拉低 SCL 让从设备发送下一位</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_SDA = <span class="number">1</span>;        <span class="comment">// 8 位数据发送完毕后拉高 SDA，发送非应答信号</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>;        <span class="comment">// 拉高 SCL</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;        <span class="comment">// 拉低 SCL 完成非应答位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I²C 总线读操作，并且发送 ACK 应答信号，返回读取到的字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadACK</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  I2C_SDA = <span class="number">1</span>;        <span class="comment">// 确保主设备释放 SDA</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从高位到低位依次进行 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x80</span>; mask != <span class="number">0</span>; mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;      <span class="comment">// 拉高 SCL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SDA 的值为 0 时，dat 对应位置清零，为 1 时对应位置 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_SDA == <span class="number">0</span>)</span><br><span class="line">      dat &amp;= ~mask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dat |= mask;</span><br><span class="line"></span><br><span class="line">    I2CDelay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;      <span class="comment">// 拉低 SCL 让从设备发送下一位</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2C_SDA = <span class="number">0</span>;        <span class="comment">// 8 位数据发送完毕后拉高 SDA，发送应答信号</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">1</span>;        <span class="comment">// 拉高 SCL</span></span><br><span class="line">  I2CDelay();</span><br><span class="line">  I2C_SCL = <span class="number">0</span>;        <span class="comment">// 拉低 SCL 完成应答位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，此处省略 Lcd1602.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadNAK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">E2ReadByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">E2WriteByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  InitLcd1602();               <span class="comment">// 初始化液晶</span></span><br><span class="line">  dat = E2ReadByte(<span class="number">0x02</span>);      <span class="comment">// 读取指定地址上的 1 个字节数据</span></span><br><span class="line"></span><br><span class="line">  str[<span class="number">0</span>] = (dat / <span class="number">100</span>) + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 将字节数据转换为十进制字符串格式</span></span><br><span class="line">  str[<span class="number">1</span>] = (dat / <span class="number">10</span> % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">2</span>] = (dat % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);       <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line">  dat++;                       <span class="comment">// 将数据自增 1</span></span><br><span class="line">  E2WriteByte(<span class="number">0x02</span>, dat);      <span class="comment">// 重新回写至原地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 EEPROM 的 1 个字节，参数 addr 是字节地址 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">E2ReadByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line"></span><br><span class="line">  I2CStart();</span><br><span class="line">  I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>);          <span class="comment">// 设备寻址，并设置后续为写操作</span></span><br><span class="line">  I2CWrite(addr);               <span class="comment">// 写入存储地址</span></span><br><span class="line">  I2CStart();                   <span class="comment">// 发送重复启动信号</span></span><br><span class="line">  I2CWrite((<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>); <span class="comment">// 设备寻址，并设置后续为读操作</span></span><br><span class="line">  dat = I2CReadNAK();           <span class="comment">// 读取 1 个字节的数据</span></span><br><span class="line">  I2CStop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定数 1 个字节数据到 EEPROM，参数 addr 是字节地址 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2WriteByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  I2CStart();</span><br><span class="line">  I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>);          <span class="comment">// 设备寻址，并设置后续为写操作</span></span><br><span class="line">  I2CWrite(addr);               <span class="comment">// 写入存储地址</span></span><br><span class="line">  I2CWrite(dat);                <span class="comment">// 写入 1 个字节的数据</span></span><br><span class="line">  I2CStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序读取 EEPROM 时候，只读取一个字节后就通知 EEPROM
不再需要读取数据，读取完成以后直接发送一个<code>NAK</code>，因此只调用了<code>I2CReadNAK()</code>函数，并未调用<code>I2CReadACK()</code>函数。如果遇到需要连续读取多个字节数据的场景，<code>I2CReadACK()</code>函数就会派上用场了。</p>
<h2 id="eeprom-多字节读写时序">EEPROM 多字节读写时序</h2>
<p>读取 EEPROM 的过程较为简单，EEPROM
会根据程序发送的时序将数据送出。但是 EEPROM 的写入较为复杂，向 EEPROM
发送的数据首先保存在其缓存当中，然后 EEPROM
必须将缓存中的数据迁移至【非易失】存储区域，才能最终达到掉电不丢失的目的。但是这个【非易失】存储区域的写需要一定时间，<strong>24C02</strong>的写入时间最高不超过<code>5 ms</code>。将数据迁移至【非易失】存储区域的过程当中，EEPROM
不会再响应其它的访问，既接收不到任何数据也无法进行寻址，待数据迁移完成之后
EEPROM 才能够恢复正常读写。</p>
<p>前面写入数据的实验代码里，每次只写入一个字节数据，下次重新上电再进行写入时，时间已经远远超过<code>5 ms</code>。但是如果连续写入多个字节数据，就必须考虑到应答位的问题；即写入
1 个字节后，再写入下个字节之前必须等待 EEPROM
重新响应，下面代码展示了多字节读写 EEPROM 的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c，多字节读写模式访问 EEPROM，依次累加 1, 2, 3...之后再回写到之前存储位置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadACK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadNAK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  InitLcd1602();                   <span class="comment">// 初始化液晶</span></span><br><span class="line">  E2Read(buf, <span class="number">0x90</span>, <span class="keyword">sizeof</span>(buf));  <span class="comment">// 读取一段数据</span></span><br><span class="line">  MemToStr(str, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 转换为十六进制字符串</span></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);           <span class="comment">// 显示至 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数据依次累加 1, 2, 3... */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buf); i++) &#123;</span><br><span class="line">    buf[i] = buf[i] + <span class="number">1</span> + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  E2Write(buf, <span class="number">0x90</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 将结果写回 EEPROM</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一段内存数据转换为十六进制字符串，参数 str 是字符串指针，参数 src 是源数据地址，参数 len 是数据长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    tmp = *src &gt;&gt; <span class="number">4</span>;           <span class="comment">// 取出高 4 位</span></span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= <span class="number">9</span>)              <span class="comment">// 转换为 0-9 或 A-F</span></span><br><span class="line">      *str++ = tmp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *str++ = tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    tmp = *src &amp; <span class="number">0x0F</span>;         <span class="comment">// 取出低 4 位</span></span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= <span class="number">9</span>)              <span class="comment">// 转换为 0-9 或 A-F</span></span><br><span class="line">      *str++ = tmp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *str++ = tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    *str++ = <span class="string">&#x27; &#x27;</span>;              <span class="comment">// 转换完 1 个字节就添加 1 个空格</span></span><br><span class="line">    src++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;                 <span class="comment">// 添加字符串结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EEPROM 多字节读写函数，参数 buf 是数据接收指针，参数 addr 是 EEPROM 里的起始地址，参数 len 是读取的数据长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">/* 通过寻址方式查询当前是否能够进行读写操作 */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    I2CStart();</span><br><span class="line">    <span class="comment">/* 应答就跳出循环，非应答就进行下次查询 */</span></span><br><span class="line">    <span class="keyword">if</span> (I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    I2CStop();</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  I2CWrite(addr);               <span class="comment">// 写入起始地址</span></span><br><span class="line">  I2CStart();                   <span class="comment">// 发送重复启动信号</span></span><br><span class="line">  I2CWrite((<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>); <span class="comment">// 设备寻址，并设置后续为读操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续读取 len-1 个字节的数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    *buf++ = I2CReadACK();      <span class="comment">// 最后 1 个字节之前为读取操作 + 应答</span></span><br><span class="line">    len--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *buf = I2CReadNAK();          <span class="comment">// 最后 1 个字节为读取操作 + 非应答</span></span><br><span class="line">  I2CStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EEPROM 写入函数，参数 buf 是源数据指针，参数 addr 是 EEPROM 中的起始地址，参数 len 是待写入的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    <span class="comment">/* 通过寻址方式查询当前是否能够进行读写操作 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      I2CStart();</span><br><span class="line">      <span class="comment">/* 应答就跳出循环，非应答就进行下次查询 */</span></span><br><span class="line">      <span class="keyword">if</span> (I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      I2CStop();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    I2CWrite(addr++); <span class="comment">// 写入起始地址</span></span><br><span class="line">    I2CWrite(*buf++); <span class="comment">// 写入 1 个字节数据</span></span><br><span class="line">    I2CStop();        <span class="comment">// 结束写操作，并等待写入完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MemToStr()</code>函数：用于将一段内存数据转换成十六进制字符串格式，这是由于从
EEPROM 读取的是正常数据，而 1602 液晶接收的是 ASCII
码字符，要显示必须进行转换。方法是将每个字节数据的高 4 位与低 4
位分别与<code>9</code>进行比较，如果小于或等于<code>9</code>就直接加<code>0</code>转为<code>0 ~ 9</code>的
ASCII
码，如果大于<code>9</code>则先减去<code>10</code>再加上<code>A</code>即可转换为<code>A ~ F</code>的
ASCII 码。</p>
<p><code>E2Read()</code>函数：读取 EEPROM
数据之前，需要首先查询当前是否能够进行读写操作，EEPROM
正常响应后才能进行。读取到最后 1
个字节之前全部设置为<strong>ACK</strong>，读取到最后一个字节以后就设置为<strong>NAK</strong>。</p>
<p><code>E2Write()</code>函数：每次进行写操作之前，都需要查询判断当前
EEPROM 是否响应，正常响应以后才能进行数据写入。</p>
<h2 id="eeprom-的页写入">EEPROM 的页写入</h2>
<p>EEPROM 连续写入多个字节数据时，如果每写入 1
个字节都要等待几毫秒，就会明显影响写入效率。因此 EEPROM
通常实行分页管理，当前实验电路使用的<strong>24C02</strong>拥有 256
个字节，其中每 8 个字节 1 页，总共拥有 32 页。</p>
<p>存储空间进行分页之后，如果在同一个页内连续写入几个字节，最后再发送停止位时序，EEPROM
检测到该停止位之后，就会一次性将整页的数据迁移至【非易失】存储区域，不需要每写
1 个字节进行 1
次检测，并且页写入时间也不会超过<code>5 ms</code>。如果需要写入跨页的数据，那么每写完了一页之后就要发送一个停止位，然后等待并且检测
EEPROM
空闲模式，直至将上一页数据迁移至【非易失】存储区域以后，再进行下一页的写入，这样就有效提高了数据的写入效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** eeprom.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadACK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadNAK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EEPROM 读取函数，参数 buf 是数据接收指针，参数 addr 是 EEPROM 中起始地址，参数 len 是待读取的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">/* 采用寻址操作查询当前是否可以进行读写操作 */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    I2CStart();</span><br><span class="line">    <span class="comment">/* 应答就跳出循环，非应答就进行下次查询 */</span></span><br><span class="line">    <span class="keyword">if</span> (I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    I2CStop();</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  I2CWrite(addr);               <span class="comment">// 写入起始地址</span></span><br><span class="line">  I2CStart();                   <span class="comment">// 发送重复启动信号</span></span><br><span class="line">  I2CWrite((<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>); <span class="comment">// 设备寻址，并设置后续为读操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续读取 len-1 个字节的数据 */</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    *buf++ = I2CReadACK(); <span class="comment">// 最后 1 个字节之前为读取操作 + 应答</span></span><br><span class="line">    len--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *buf = I2CReadNAK(); <span class="comment">// 最后 1 个字节为读取操作 + 非应答</span></span><br><span class="line">  I2CStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* EEPROM 写入函数，参数 buf 是源数据指针，参数 addr 是 EEPROM 的起始地址，参数 len 是待写入的数据长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">E2Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">/* 等待上次写入操作完成 */</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 采用寻址操作查询当前是否可以进行读写操作 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      I2CStart();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 应答就跳出循环，非应答就进行下次查询 */</span></span><br><span class="line">      <span class="keyword">if</span> (I2CWrite(<span class="number">0x50</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      I2CStop();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 采用页模式连续的写入多个字节 */</span></span><br><span class="line">    I2CWrite(addr); <span class="comment">// 写入起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      I2CWrite(*buf++); <span class="comment">// 写入一个字节数据</span></span><br><span class="line">      len--;            <span class="comment">// 待写入长度计数递减</span></span><br><span class="line">      addr++;           <span class="comment">// EEPROM 地址递增</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 通过检测低 3 位是否为零来判断检查地址是否到达了页边界 */</span></span><br><span class="line">      <span class="keyword">if</span> ((addr &amp; <span class="number">0x07</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 如果到达了页边界，就跳出循环结束本次写操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    I2CStop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循模块化原则，上面代码将 EEPROM
读写函数独立为<code>eeprom.c</code>文件，其中<code>E2Read()</code>函数与上一节实验代码保持相同，因为
I²C
读操作与存储区分页无关。关键点在于<code>E2Write()</code>函数，写入数据时需要计算下一个待写入数据的地址，是否为一个页的起始地址，如果是就必须跳出循环，等待
EEPROM 将当前页写入至【非易失】存储区域，然后再行写入后续的存储页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用 连续读 和 分页写 模式访问 EEPROM，并且依次加 1 加 2 加 3...最后将结果回写至原地址，此处省略 Lcd1602.c 和 I2C.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">E2Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">E2Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  InitLcd1602();                   <span class="comment">// 初始化液晶</span></span><br><span class="line">  E2Read(buf, <span class="number">0x8E</span>, <span class="keyword">sizeof</span>(buf));  <span class="comment">// 从 EEPROM 读取一段数据</span></span><br><span class="line">  MemToStr(str, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 转换为十六进制字符串</span></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);           <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 数据依次累加 1, 2, 3... */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buf); i++) &#123;</span><br><span class="line">    buf[i] = buf[i] + <span class="number">1</span> + i;</span><br><span class="line">  &#125;</span><br><span class="line">  E2Write(buf, <span class="number">0x8E</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 将结果写回 EEPROM</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一段内存数据转换为十六进制字符串，参数 str 是字符串指针，参数 src 是源数据地址，参数 len 是数据长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> *src, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    tmp = *src &gt;&gt; <span class="number">4</span>;           <span class="comment">// 取出高 4 位</span></span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= <span class="number">9</span>)              <span class="comment">// 转换为 0-9 或 A-F</span></span><br><span class="line">      *str++ = tmp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *str++ = tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    tmp = *src &amp; <span class="number">0x0F</span>;         <span class="comment">// 取出低 4 位</span></span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= <span class="number">9</span>)              <span class="comment">// 转换为 0-9 或 A-F</span></span><br><span class="line">      *str++ = tmp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *str++ = tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    *str++ = <span class="string">&#x27; &#x27;</span>;              <span class="comment">// 转换完 1 个字节就添加 1 个空格</span></span><br><span class="line">    src++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;                 <span class="comment">// 添加字符串结束符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样写入 5
个字节的数据，逐个字节写入会消耗<code>8.4 ms</code>左右的时间，而采用页写入则只耗费了<code>3.5 ms</code>左右的时间。</p>
</blockquote>
<h2 id="i²c-和-eeprom-综合实验">I²C 和 EEPROM 综合实验</h2>
<p>空调温度设置、电视频道记忆等场景都可能会使用到 EEPROM
存储器，其存储的数据不仅可以顺意改变，而且掉电后数据不会丢失，因此在各类电子设备上大量使用。本节的实验类似于完成一个广告屏，实验电路上电之后，1602
液晶第 1 行显示 EEPROM 从<code>0x20</code>地址开始的 16 个字符，第 2
行显示 EERPOM 从<code>0x40</code>开始的 16 个字符，并且可以通过 UART
串口通信手动修改 EEPROM 内部保存的这个数据，当然同时也会改变 1602
液晶显示的内容，实验电路下次上电后将会显示这个手动更新之后的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c，此处省略了 Lcd1602.c、I2C.c、eeprom.c、Uart.c 源文件*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitShowStr</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">E2Read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">E2Write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> addr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartRxMonitor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UartWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;           <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);  <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  ConfigUART(<span class="number">9600</span>); <span class="comment">// 设置波特率为 9600</span></span><br><span class="line">  InitLcd1602();    <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line">  InitShowStr();    <span class="comment">// 初始化显示内容</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UartDriver(); <span class="comment">// 调用串口驱动程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理液晶屏初始显示内容 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitShowStr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line">  str[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;        <span class="comment">// 添加字符串结束符</span></span><br><span class="line">  E2Read(str, <span class="number">0x20</span>, <span class="number">16</span>); <span class="comment">// 读取第 1 行字符串，EEPROM 起始地址为 0x20</span></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str); <span class="comment">// 显示到 1602 液晶屏</span></span><br><span class="line">  E2Read(str, <span class="number">0x40</span>, <span class="number">16</span>); <span class="comment">// 读取第 2 行字符串，EEPROM 起始地址为 0x40</span></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, str); <span class="comment">// 显示到 1602 液晶屏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存比较函数，比较两个指针所指向的内存数据是否相同；参数 ptr1 是待比较指针 1，参数 ptr2 是待比较指针 2，参数 len 是待比较的数据长度 */</span></span><br><span class="line">bit <span class="title function_">CmpMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr1, <span class="type">unsigned</span> <span class="type">char</span> *ptr2, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    <span class="comment">/* 遇到不相等数据时即刻返回0 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptr1++ != *ptr2++) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 两段内存数据不相同返回 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 两段内存数据完全相同返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将字符串转换为 16 字节固定长度的字符串，不足部分直接填充空格，参数 out 是整理后的字符串指针，参数 in 是待整理字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TrimString16</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *out, <span class="type">unsigned</span> <span class="type">char</span> *in)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 拷贝字符串直至结束符 */</span></span><br><span class="line">  <span class="keyword">while</span> (*in != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    *out++ = *in++;</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拷贝长度达到 16 个字节就强制跳出循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不足 16 个字节部分使用空格补齐 */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    *out++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *out = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，根据接收到的命令帧执行相应动作，参数 buf 是接收到的命令帧指针，参数 len 是命令帧的长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UartAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">17</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmd0[] = <span class="string">&quot;showstr1 &quot;</span>; <span class="comment">// 1602液晶 第 1 行字符显示命令</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmd1[] = <span class="string">&quot;showstr2 &quot;</span>; <span class="comment">// 1602液晶 第 2 行字符显示命令</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code cmdLen[] = &#123;<span class="keyword">sizeof</span>(cmd0) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd1) - <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code *cmdPtr[] = &#123;&amp;cmd0[<span class="number">0</span>], &amp;cmd1[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历命令列表，查找相同命令 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmdLen); i++) &#123;</span><br><span class="line">    <span class="comment">/* 接收到的数据长度不能小于命令长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= cmdLen[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CmpMemory(buf, cmdPtr[i], cmdLen[i])) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 比较相同时退出循环</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据比较结果执行相应命令 */</span></span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      buf[len] = <span class="string">&#x27;\0&#x27;</span>;                    <span class="comment">// 添加结束符</span></span><br><span class="line">      TrimString16(str, buf + cmdLen[<span class="number">0</span>]); <span class="comment">// 整理为 16 字节固定长度字符串</span></span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);              <span class="comment">// 显示字符串 1</span></span><br><span class="line">      E2Write(str, <span class="number">0x20</span>, <span class="keyword">sizeof</span>(str));    <span class="comment">// 保存字符串 1，起始地址为 0x20</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      buf[len] = <span class="string">&#x27;\0&#x27;</span>;                    <span class="comment">// 添加结束符</span></span><br><span class="line">      TrimString16(str, buf + cmdLen[<span class="number">1</span>]); <span class="comment">// 整理为 16 字节固定长度字符串</span></span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, str);              <span class="comment">// 显示字符串 1</span></span><br><span class="line">      E2Write(str, <span class="number">0x40</span>, <span class="keyword">sizeof</span>(str));    <span class="comment">// 保存字符串 2，起始地址为 0x40</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                              <span class="comment">// 如果未找到相符命令，向上位机发送 bad command 提示</span></span><br><span class="line">      UartWrite(<span class="string">&quot;bad command.\r\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;bad command.\r\n&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf[len++] = <span class="string">&#x27;\r&#x27;</span>;                    <span class="comment">// 添加回车符</span></span><br><span class="line">  buf[len++] = <span class="string">&#x27;\n&#x27;</span>;                    <span class="comment">// 添加换行符</span></span><br><span class="line">  UartWrite(buf, len);                  <span class="comment">// 将命令返回上位机，表示已经执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时器 T0 的定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;     <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>; <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;       <span class="comment">// 计算定时器定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">33</span>;          <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 将定时值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;            <span class="comment">// 定时器 T0 控制位清零</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;            <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;              <span class="comment">// 加载定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                 <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                 <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于监听串口接收 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;       <span class="comment">// 重新加载定时值</span></span><br><span class="line">  UartRxMonitor(<span class="number">1</span>); <span class="comment">// 串口接收监控</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>STC89C52RC</strong>内部集成了 UART
通信模块，通过简单的寄存器配置就可以实现通信功能；而<strong>STC89C52RC</strong>并没有集成
I²C 总线控制模块，因此只能通过 IO
引脚进行模拟，虽然代码较为冗长，但是有助于理解 I²C 的底层实现机制。</p>
</blockquote>
<h1 id="spi-总线">SPI 总线</h1>
<p>SPI 是串行外围设备接口（Serial Peripheral
Interface）的英文缩写，属于一种高速全双工的同步通信总线，常用于单片机微控制器与
EEPROM、FLASH、实时时钟、数字信号处理器等等元件的通信。SPI 通信原理相对
I²C 更加简单，采用了主从模式进行通信（一个主设备与多个从设备），标准 SPI
拥有 4 根信号线：</p>
<ul>
<li><strong>SSEL</strong>：片选，也记为<strong>SCS</strong>，传输从设备的片选使能信号，如果从设备是低电平使能，那么拉低引脚以后，该从设备就会被选中，主设备就可以与这个被选中的从设备进行通信；</li>
<li><strong>SCLK</strong>：时钟信号，也记为<strong>SCK</strong>，由主设备产生，作用类似于
I²C 的<strong>SCL</strong>；</li>
<li><strong>MOSI</strong>：主设备输出从设备输入（Master Output/Slave
Input），主设备给从设备发送指令或数据的通道；</li>
<li><strong>MISO</strong>：主设备输入从设备输出（Master Input/Slave
Output）主设备读取从设备状态或数据的通道。</li>
</ul>
<blockquote>
<p>根据实际生产环境需要，也可以用将 SPI 总线剪裁为 3 根或者 2
根通信线，例如主设备只给从设备发送命令，而从设备无需回复数据时 MISO
就可以省略；如果主设备只读取从设备数据，而无需给从设备发送命令就可以省略
MOSI；如果只有 1 个主设备和 1
个从设备时，从设备片选可以固定为有效的使能电平，这样 SSEL
就可以省略，如果此时主设备只需要向从设备发送数据，那么 SSEL 和 MISO
都可以省去；而如果主设备只读取从设备发送的数据，则可以同时省去 SSEL 和
MOSI。</p>
</blockquote>
<p>SPI 总线的主设备通常为单片机/微控制器，读写数据的工作时序有 4
种工作模式，在进一步了解这些工作模式之前，需要首先了解如下 2
个概念：</p>
<ul>
<li><strong>CPOL</strong>: 时钟的极性（Clock
Polarity），通信过程分为空闲时刻和通信时刻，如果<strong>SCLK</strong>在空闲状态为高电平，那么<code>CPOL = 1</code>；如果<strong>SCLK</strong>在空闲状态为低电平，那么<code>CPOL=1</code>。</li>
<li><strong>CPHA</strong>: 时钟的相位（Clock
Phase），，主从设备交换数据时，涉及到主设备何时输出数据到 MOSI
而从设备何时采样该数据，或者从设备何时输出数据到 MISO
而主设备何时采样该数据的一系列问题。同步通信的特点在于所有数据的变化与采样都是伴随时钟沿进行，数据总是在时钟边沿附近变化或者采样，基于周期的定义，一个时钟周期必然包含
1 个上升沿与 1
个下降沿，又由于数据从产生到稳定需要一定时间，因而如果主设备在上升沿输出数据到
MOSI，从设备就只能在下降沿去采样该数据；反之，一个设备在下降沿输出数据，那么另一个设备就必须在上升沿采样它。</li>
</ul>
<p><code>CPHA = 1</code>表示数据的输出位于一个时钟周期的第 1
个上升沿或者下降沿（此时如果<code>CPOL = 1</code>就是下降沿，反之为上升沿），而数据的采样自然就位于第
2 个上升/下降沿。<code>CPHA = 0</code>表示数据采样位于一个时钟周期的第 1
个上升/下降沿（具体是上升还是下降沿依然由<code>CPOL</code>决定），此时数据的输出自然就位于第
2 个上升/下降沿。</p>
<p>当某一帧数据开始传输第 1 个 bit 位时，在第 1
个时钟沿上就会开始采样该数据，该数据何时输出分两种情况：一是<strong>SSEL</strong>使能的边沿，二是前一帧数据的最后
1
个时钟沿，有时两种情况可能会同时生效，下面以<code>CPOL=1/CPHA=1</code>情况下的时序图为例：</p>
<p><img src="/Embedded/STC89C52/SPI/sequence-1.png"></p>
<p>上图当中，当数据【未发送】和【发送完毕】之后，<strong>SCK</strong>都为高电平，因此<code>CPOL = 1</code>。在<strong>SCK</strong>第
1
个时钟沿的时候，<strong>MOSI</strong>与<strong>MISO</strong>均会发生变化，同时在<strong>SCK</strong>第
2
个时钟沿时数据保持稳定，此刻适合进行数据采样，即在该时钟周期的后沿锁存读取数据，即<code>CPHA = 1</code>。最隐蔽的是<strong>SSEL</strong>片选，该引脚通常用于确定需要进行通信的主从设备。剩余的三种模式的时序图如下所示，为了简化将<strong>MOSI</strong>和<strong>MISO</strong>合并在了一起。</p>
<p><img src="/Embedded/STC89C52/SPI/sequence-2.png"></p>
<blockquote>
<p>SPI 的通信时序相比 I²C 要简单许多，没有了起始、停止、应答信号；UART
与 SPI 进行通信的时候，只负责通信本身而不负责通信成功与否，而 I²C
由于需要通过应答信息获取通信成功与否的状态，相对而言 UART 和 SPI
在时序上都要比 I²C 更加简单。</p>
</blockquote>
<h1 id="实时时钟-ds1302">实时时钟 DS1302</h1>
<p>DS1302 是美信 MAXIM
半导体出品的一款涓流充电时钟芯片，可以提供年、月、日、时、分、秒等实时时钟信息，还能够配置
24 小时或 12 小时格式。DS1302 拥有<code>31 Byte</code>字节的数据存储
RAM（掉电丢失数据，较少使用）。采用串行 IO 通信方式，有效节省单片机 IO
引脚资源；工作电压较宽，位于<code>2.0V ~ 5.5V</code>范围；功耗极低，工作电压<code>2.0 V</code>时工作电流小于<code>300 nA</code>。</p>
<p>当前实验电路使用的 DS1302 拥有 8 个引脚，并采用 SOP
小外型封装，芯片两侧都引出 L 形引脚。供电电压为<code>5V</code>时兼容标准
TTL 电平标准，能够直接与 STC89C52RC 进行通信。此外 DS1302
拥有主、备两个电源输入，可以分别连接电源、电池或电容，可以在系统掉电的情况下继续走时。</p>
<p><img src="/Embedded/STC89C52/SPI/DS1302.png"></p>
<p>1 脚<strong>VCC2</strong>是主电源正极的引脚，2
脚<strong>X1</strong>和 3 脚<strong>X2</strong>是晶振输入和输出引脚，4
脚是<strong>GND</strong>负极，5
脚<strong>CE</strong>是使能引脚（连接至单片机），6
脚<strong>I/O</strong>是数据传输引脚（连接至单片机），7
脚<strong>SCLK</strong>是通信时钟引脚（连接至单片机），8
脚<strong>VCC1</strong>是备用电源引脚，下面表格描述了 DS1302
的各引脚功能：</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 86%">
</colgroup>
<thead>
<tr>
<th>引脚编号</th>
<th>引脚名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><strong>VCC2</strong></td>
<td>主电源引脚，当<code>Vcc2</code>比<code>Vcc1</code>高出<code>0.2V</code>以上时，DS1302
由<code>Vcc2</code>供电，当<code>Vcc2</code>低于<code>Vcc1</code>时则由<code>Vcc1</code>供电。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>X1</strong></td>
<td>接<code>32.768 kHz</code>晶振为 DS1302
提供计时基准，注意该晶振引脚负载电容必须为<code>6pF</code>。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>X2</strong></td>
<td>同上。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>GND</strong></td>
<td>接地。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>CE</strong></td>
<td>使能输入引脚，读写 DS1302
时该引脚必须为高电平，该引脚内置了一个<code>40kΩ</code>的下拉电阻。</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>I/O</strong></td>
<td>该引脚为双向通信引脚，即数据的读写都通过该引脚完成，该引脚同样内置了一个<code>40kΩ</code>下拉电阻。</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>SCLK</strong></td>
<td>输入引脚，用来作为通信的时钟信号，该引脚依然内置有一个<code>40kΩ</code>下拉电阻。</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>VCC1</strong></td>
<td>备用电源引脚。</td>
</tr>
</tbody>
</table>
<p>当前实验电路第 8
脚未连接备用电池，而是连接了一枚<code>10uF</code>电容，可以在掉电以后仍维持
DS1302 持续工作 1
分钟左右。出于成本原因，实际应用中极少会使用充电电池作为备用电源，因而基本不会使用到
DS1302
提供的涓流充电功能。下面电路图当中，直接在<strong>VCC1</strong>主电源处并联了一枚二极管，主电源上电时为电容充电，主电源掉电时二极管可以防止电容向主电路放电，而仅仅用于维持
DS1302 的供电，确保更换电池的场景下实时时钟的运行不会停止。此外，在
DS1302
主电源引脚<strong>VCC2</strong>还串联一个<code>1KΩ</code>的电阻<strong>R6</strong>，用于防止电源对芯片造成冲击，其它的<strong>R9</strong>、<strong>R26</strong>、<strong>R32</strong>都是上拉电阻。</p>
<p><img src="/Embedded/STC89C52/SPI/diagram.png"></p>
<p>上面实时时钟的核心是一枚<code>32.768 kHz</code>晶振，而时钟的精度就主要取决于晶振精度、晶振的引脚负载电容以及晶振的<strong>温漂</strong>。</p>
<h2 id="ds1302-寄存器介绍">DS1302 寄存器介绍</h2>
<p>DS1302 每条指令占用 1 个字节共 8 位，其中最高位第 7
位固定为<code>1</code>；第 6 位用于选择 RAM 功能（<code>1</code>）还是
CLOCK 功能（<code>0</code>），前面已经提到 RAM
存储功能较少使用，所以这里固定选择 CLOCK 时钟功能；第 1 ~ 5
位决定了寄存器的五位地址（<code>0b00000 ~ 0b00111</code>）；第 0
位为读写位，其中<code>0</code>表示写<code>1</code>表示读，指令字节的分配示意图如下所示：</p>
<p><img src="/Embedded/STC89C52/SPI/command.png"></p>
<p>DS1302 数据手册直接给出了第 0、6、7
位取值的十六进制命令<code>0x80</code>、<code>0x81</code>...，详细如下图表格所示：</p>
<p><img src="/Embedded/STC89C52/SPI/register-address-definition.png"></p>
<p>DS1302 拥有 8 个与时钟相关的寄存器，具体请参考下面的列表：</p>
<ul>
<li><strong>寄存器
0</strong>：最高位<strong>CH</strong>是<strong>时钟停止标志位</strong>，如果时钟电路拥有备用电源，上电后需要首先检测该位状态，为<code>0</code>说明时钟芯片在系统掉电后可由备用电源来保持正常运行，为<code>1</code>说明时钟芯片在系统掉电后就不工作了。如果<strong>Vcc1</strong>悬空或者电池没电，下次重新上电时该位的状态为<code>1</code>，因此可以通过该位判断时钟在掉电后能否正常工作。剩下
7 位中的高 3 位是【秒数】的十位，低 4 位是【秒数】的个位，由于 DS1302
内部使用 BCD
编码来表示时间，而秒的十位最大是<code>5</code>，所以三个二进制位就足够表达。</li>
<li><strong>寄存器 1</strong>：最高位没有使用，剩下 7 位中的高 3
位是【分钟数】的十位，低 4 位是【分钟数】的个位。</li>
<li><strong>寄存器 2</strong>：最高位为<code>1</code>表示当前是 12
小时制，为<code>0</code>表示当前是 24 小时制；第 6
位固定为<code>0</code>，第 5 位在【12
小时制】里<code>0</code>代表上午<code>1</code>代表下午，在【24
小时制】里与第 4 位一起代表【小时数】的十位，低 4
位代表【小时数】的个位。</li>
<li><strong>寄存器 3</strong>：最高的 2 位固定为<code>0</code>，第 5
和第 4 位是【日期数】的十位，而低 4 位是【日期数】的个位。</li>
<li><strong>寄存器 4</strong>：最高的 3 位固定为<code>0</code>，第 4
位是【月数】的十位，低 4 位是【月数】的个位。</li>
<li><strong>寄存器 5</strong>：最高的 5 位固定为<code>0</code>，低 3
位代表【星期】。</li>
<li><strong>寄存器 6</strong>：最高的 4 位代表了【年】的十位，低 4
位代表了【年】的个位，注意这里的<code>00 ~ 99</code>指的是<code>2000年 ~ 2099年</code>。</li>
<li><strong>寄存器
7</strong>：最高位为写保护位，为<code>1</code>表示禁止给任何其它寄存器或者
31 字节 RAM
写数据，因而在进行写数据操作之前，该位必须置为<code>0</code>。</li>
</ul>
<blockquote>
<p><strong>BCD 码</strong>（Binary-Coded
Decimal）也称为<strong>二-十进制码</strong>，使用 4 位二进制数来表达 1
位<code>0 ~ 9</code>的十进制数，是一种采用二进制编码的十进制表达格式，可以方便的进行二进制与十进制之间的转换。<code>0 ~ 9</code>对应的
BCD
编码范围为<code>0b0000 ~ 0b1001</code>，不存在<code>0b1010</code>、<code>0b1011</code>、<code>0b1100</code>、<code>0b1101</code>、<code>0b1110</code>、<code>0b1111</code>六个数字。如果
BCD
码计数达到了最高的<code>0b1001</code>，再加<code>1</code>结果就变为<code>0b00010000</code>，相当于使用
8 位二进制数字表达了 2 位的十进制数字。</p>
</blockquote>
<p>本节使用的 DS1302 时钟芯片将时间日期以 BCD
编码方式存储，当需要将其转换为 1602 液晶可直观显示的 ASCII
编码时，可以直接将 BCD 码的 4 个二进制位加上<code>0x30</code>即可得到
ASCII 编码的字节。</p>
<h2 id="ds1302-通信时序介绍">DS1302 通信时序介绍</h2>
<p>DS1302 一共拥有<strong>CE 使能线</strong>、<strong>I/O
数据线</strong>、<strong>SCLK 时钟线</strong>三条链路连接到
STC89C52RC，虽然采用了 SPI 的时序，但是并未完全按照 SPI
总线的规则来进行通信，下面我们一点点解剖 DS1302 的变异 SPI
通信方式。DS1302 单字节写操作与<code>CPOL=0/CPHA=0</code>时 SPI
操作时序的比较如下图：</p>
<p><img src="/Embedded/STC89C52/SPI/sequence-compare.png"></p>
<p>上图当中，两种时序的<strong>CE</strong>和<strong>SSEL</strong>使能控制相反，SPI
写数据都位于 SCK
上升沿，即从设备进行采样的时候，下降沿时则主设备发送数据；而 DS1302
时序里需要预先写一个字节指令，指定需要写入的寄存器地址以及后续操作为写操作，然后再写入一个字节数据。DS1302
单字节读操作这里不作探讨，具体参考下面的时序图：</p>
<p><img src="/Embedded/STC89C52/SPI/sequence-single-byte-read.png"></p>
<p>读操作的时序里有两个需要注意的地方：首先，DS1302
时序图上的箭头都是针对 DS1302 而言，因此读操作时先写第 1
个字节指令，上升沿的时候 DS1302
锁存数据，下降沿则由单片机发送数据。到了第 2
个字数据，由于该时序过程相当于<code>CPOL=0/CPHA=0</code>，前沿发送数据，后沿读取数据，所以第
2 个字节就是 DS1302
下降沿输出数据，单片机在上升沿读取这些数据，因此箭头对于 DS1302
而言出现在下降沿。</p>
<p>其次，当前单片机没有标准 SPI 接口，与 I²C 一样需要通过单片机 IO
引脚来模拟通信过程。读 DS1302 的时候 SPI
理论上是上升沿读取，但是由于程序是通过单片机 IO
模拟，所以数据的读取和时钟沿的变化不可能同时进行，而必然存在着一个先后顺序。通过实验发现，如果先读取<strong>I/O</strong>线路上的数据，再拉高<strong>SCLK</strong>产生上升沿，那么读到的数据一定是正确的，而颠倒顺序后数据就有可能出现错误。产生这个问题的原因在于
DS1302 通信协议与标准 SPI 协议存在差异而造成，标准 SPI
的数据会一直保持到下一个周期的下降沿才会发生变化，所以读取数据与上升沿的先后顺序无关紧要；但是
DS1302 的<strong>I/O</strong>线路会在时钟上升沿之后被 DS1302
释放，即从<strong>强推挽</strong>输出变为<strong>弱下拉</strong>状态，此时在
STC89C52RC
单片机引脚内部上拉电阻的作用下，<strong>I/O</strong>线路上的实际电平会逐渐上升，导致在上升沿产生后再读取<strong>I/O</strong>数据可能会出现错误。因此这里需要先读取<strong>I/O</strong>数据，再拉高<strong>SCLK</strong>产生上升沿的顺序。</p>
<p>下面完成一个实验程序，使用<strong>单次读写模式</strong>，将【2013 年
10 月 8 号星期二 12 点 30 分 00 秒】这个时间写入
DS1302，让其正常运行以后再反复读取 DS1302 上的当前时间，并且显示在 1602
液晶上面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，文件 Lcd1602.c 省略 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit DS1302_CE = P1 ^ <span class="number">7</span>;</span><br><span class="line">sbit DS1302_CK = P3 ^ <span class="number">5</span>;</span><br><span class="line">sbit DS1302_IO = P3 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">bit flag200ms = <span class="number">0</span>;           <span class="comment">// 200ms 定时标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;      <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;      <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302SingleRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> psec = <span class="number">0xAA</span>; <span class="comment">// 秒数备份，初始值 0xAA 可以确保首次读取时间以后能够刷新显示</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> time[<span class="number">8</span>];     <span class="comment">// 当前时间数组</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];     <span class="comment">// 字符串转换缓冲区</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                    <span class="comment">// 使能总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);           <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  InitDS1302();              <span class="comment">// 初始化 DS1302 实时时钟</span></span><br><span class="line">  InitLcd1602();             <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每间隔 200ms 读取一次时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag200ms) &#123;</span><br><span class="line">      flag200ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 读取 DS1302 当前时间 */</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        time[i] = DS1302SingleRead(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测到时间变化时刷新显示 */</span></span><br><span class="line">      <span class="keyword">if</span> (psec != time[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">/* 添加年份的高两位 20 */</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        str[<span class="number">2</span>] = (time[<span class="number">6</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 年份的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">3</span>] = (time[<span class="number">6</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 年份的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">4</span>] = <span class="string">&#x27;-&#x27;</span>;                    <span class="comment">// 日期分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">5</span>] = (time[<span class="number">4</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 月份的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">6</span>] = (time[<span class="number">4</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 月份的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">7</span>] = <span class="string">&#x27;-&#x27;</span>;                    <span class="comment">// 日期分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">8</span>] = (time[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 日期的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">9</span>] = (time[<span class="number">3</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 日期的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;                  <span class="comment">// 日期结束符</span></span><br><span class="line">        LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);           <span class="comment">// 显示到 1602 液晶的第 1 行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (time[<span class="number">5</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 星期数</span></span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;                   <span class="comment">// 星期结束符</span></span><br><span class="line">        LcdShowStr(<span class="number">11</span>, <span class="number">0</span>, <span class="string">&quot;week&quot;</span>);</span><br><span class="line">        LcdShowStr(<span class="number">15</span>, <span class="number">0</span>, str);          <span class="comment">// 显示到 1602 液晶第 1 行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (time[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 小时数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">1</span>] = (time[<span class="number">2</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 小时数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;                    <span class="comment">// 时间分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">3</span>] = (time[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 分钟数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">4</span>] = (time[<span class="number">1</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 分钟数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">5</span>] = <span class="string">&#x27;:&#x27;</span>;                    <span class="comment">// 时间分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">6</span>] = (time[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 秒数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">7</span>] = (time[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 秒数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;                   <span class="comment">// 时间分隔符</span></span><br><span class="line">        LcdShowStr(<span class="number">4</span>, <span class="number">1</span>, str);           <span class="comment">// 显示到 1602 液晶第 2 行</span></span><br><span class="line"></span><br><span class="line">        psec = time[<span class="number">0</span>];                  <span class="comment">// 使用当前的时间值更新上次的秒数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送 1 个字节到 DS1302 通信总线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302ByteWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 首先输出该位数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) != <span class="number">0</span>)</span><br><span class="line">      DS1302_IO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      DS1302_IO = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DS1302_CK = <span class="number">1</span>;         <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>;         <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DS1302_IO = <span class="number">1</span>;           <span class="comment">// 确保释放 IO 引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 DS1302 通信总线 读取 1 个字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302ByteRead</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先读取此时 IO 引脚，并设置 dat 的对应位 */</span></span><br><span class="line">    <span class="keyword">if</span> (DS1302_IO != <span class="number">0</span>) &#123;</span><br><span class="line">      dat |= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CK = <span class="number">1</span>; <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>; <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;      <span class="comment">// 返回读取的字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器写入 1 个字节，参数 reg 是寄存器地址，参数 dat 是待写入的字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302SingleWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x80</span>); <span class="comment">// 发送【写】寄存器指令</span></span><br><span class="line">  DS1302ByteWrite(dat);               <span class="comment">// 写入字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器读取 1 个字节，参数 reg 是寄存器地址，返回读取到的字节数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302SingleRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line"></span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x81</span>); <span class="comment">// 发送【读】寄存器指令</span></span><br><span class="line">  dat = DS1302ByteRead();             <span class="comment">// 读取字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 DS1302，如果掉电就重新设置初始时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code InitTime[] = &#123;<span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0x12</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x02</span>, <span class="number">0x13</span>&#125;; <span class="comment">// 2013年10月8日 星期二 12:30:00</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 DS1302 通信引脚 */</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">  DS1302_CK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  i = DS1302SingleRead(<span class="number">0</span>);      <span class="comment">// 读取秒寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过秒寄存器的最高位 CH 来判断 DS1302 是否停止运行 */</span></span><br><span class="line">  <span class="keyword">if</span> ((i &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    DS1302SingleWrite(<span class="number">7</span>, <span class="number">0x00</span>); <span class="comment">// 撤销写保护，允许写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 DS1302 为默认初始时间 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">      DS1302SingleWrite(i, InitTime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms　是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加载定时器 T0 定时值 */</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;</span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，进行 200ms 定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr200ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加载定时器 T0 定时值 */</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;</span><br><span class="line">  tmr200ms++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时 200ms */</span></span><br><span class="line">  <span class="keyword">if</span> (tmr200ms &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">    tmr200ms = <span class="number">0</span>;</span><br><span class="line">    flag200ms = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ds1302-突发模式">DS1302 突发模式</h2>
<p>上面读写 DS1302
的实验程序存在一个不太严谨的问题，当<strong>STC89C52RC</strong>定时器时间达到<code>200ms</code>之后，就连续读取了
DS1302 时间参数的 7
个字节。但是由于读取时存在一个时间差，极端情况可能会导致这样一种情况：如果当前时间是【00:00:59】，首先读取秒数<code>59</code>，然后再读取分钟数，在读完秒数但还未开始读取分钟数的这段时间，时间刚好发生了进位变成【00:01:00】，此时读到的分钟数为<code>01</code>，导致
1602
液晶上出现一个错误的时间【00:01:59】。这个问题的出现概率极小，但是问题确确实实是存在的。</p>
<p>为此，DS1302 提供了<strong>突发模式（Burst
Mode）</strong>来解决这个问题，突发模式分为<strong>RAM
突发模式</strong>和<strong>时钟突发模式（Clock Burst
Mode）</strong>，前者这里暂且不表，只研究实时时钟相关的模式。</p>
<p>当向 DS1302 写入指令时，只需要将 5
位地址全部写为<code>1</code>，即读操作用<code>0xBF</code>，写操作用<code>0xBE</code>，指令发送之后
DS1302 就会自动识别出当前为<strong>突发（Burst）</strong>
模式。然后马上会将所有 8 个字节同时锁存到另外 8
个字节的寄存器缓冲区，时钟继续走时，而数据则是从另一个缓冲区内读取的。同理，如果采用突发模式写数据，同样也是先将数据写入到该缓冲区，DS1302
最终会将该缓冲区内的数据一次性发送到它的时钟寄存器。</p>
<p>下面采用<strong>突发读写模式</strong>重写前一小节的实验代码，访问
DS1302 并将日期时间显示到 1602 液晶：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，另 Lcd1602.c 文件省略 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit DS1302_CE = P1 ^ <span class="number">7</span>;</span><br><span class="line">sbit DS1302_CK = P3 ^ <span class="number">5</span>;</span><br><span class="line">sbit DS1302_IO = P3 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">bit flag200ms = <span class="number">0</span>;      <span class="comment">// 200ms 定时标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302BurstRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> psec = <span class="number">0xAA</span>; <span class="comment">// 秒数备份，初始值 0xAA 可以确保首次读取时间以后能够刷新显示</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> time[<span class="number">8</span>];     <span class="comment">// 当前时间数组</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];     <span class="comment">// 字符串转换缓冲区</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                    <span class="comment">// 使能总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);           <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  InitDS1302();              <span class="comment">// 初始化 DS1302 实时时钟</span></span><br><span class="line">  InitLcd1602();             <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每间隔 200ms 读取一次时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag200ms) &#123;</span><br><span class="line">      flag200ms = <span class="number">0</span>;</span><br><span class="line">      DS1302BurstRead(time);            <span class="comment">// 读取 DS1302 当前时间</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测到时间变化时刷新显示 */</span></span><br><span class="line">      <span class="keyword">if</span> (psec != time[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">/* 添加年份的高两位 20 */</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        str[<span class="number">2</span>] = (time[<span class="number">6</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 年份的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">3</span>] = (time[<span class="number">6</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 年份的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">4</span>] = <span class="string">&#x27;-&#x27;</span>;                    <span class="comment">// 日期分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">5</span>] = (time[<span class="number">4</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 月份的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">6</span>] = (time[<span class="number">4</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 月份的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">7</span>] = <span class="string">&#x27;-&#x27;</span>;                    <span class="comment">// 日期分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">8</span>] = (time[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 日期的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">9</span>] = (time[<span class="number">3</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 日期的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;                  <span class="comment">// 日期结束符</span></span><br><span class="line">        LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);           <span class="comment">// 显示到 1602 液晶的第 1 行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (time[<span class="number">5</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 星期数</span></span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;                   <span class="comment">// 星期结束符</span></span><br><span class="line">        LcdShowStr(<span class="number">11</span>, <span class="number">0</span>, <span class="string">&quot;week&quot;</span>);</span><br><span class="line">        LcdShowStr(<span class="number">15</span>, <span class="number">0</span>, str); <span class="comment">// 显示到 1602 液晶第 1 行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (time[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 小时数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">1</span>] = (time[<span class="number">2</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 小时数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;                    <span class="comment">// 时间分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">3</span>] = (time[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 分钟数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">4</span>] = (time[<span class="number">1</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 分钟数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">5</span>] = <span class="string">&#x27;:&#x27;</span>;                    <span class="comment">// 时间分隔符</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">6</span>] = (time[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 秒数的高位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">7</span>] = (time[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 秒数的低位数值转换为 ASCII 编码</span></span><br><span class="line">        str[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;                   <span class="comment">// 时间分隔符</span></span><br><span class="line">        LcdShowStr(<span class="number">4</span>, <span class="number">1</span>, str);           <span class="comment">// 显示到 1602 液晶第 2 行</span></span><br><span class="line"></span><br><span class="line">        psec = time[<span class="number">0</span>];                  <span class="comment">// 使用当前的时间值更新上次的秒数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送 1 个字节到 DS1302 通信总线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302ByteWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 首先输出该位数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) != <span class="number">0</span>)</span><br><span class="line">      DS1302_IO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      DS1302_IO = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DS1302_CK = <span class="number">1</span>;         <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>;         <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DS1302_IO = <span class="number">1</span>;           <span class="comment">// 确保释放 IO 引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 DS1302 通信总线 读取 1 个字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302ByteRead</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先读取此时 IO 引脚，并设置 dat 的对应位 */</span></span><br><span class="line">    <span class="keyword">if</span> (DS1302_IO != <span class="number">0</span>) &#123;</span><br><span class="line">      dat |= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CK = <span class="number">1</span>; <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>; <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;      <span class="comment">// 返回读取的字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器写入 1 个字节，参数 reg 是寄存器地址，参数 dat 是待写入的字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302SingleWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x80</span>); <span class="comment">// 发送【写】寄存器指令</span></span><br><span class="line">  DS1302ByteWrite(dat);               <span class="comment">// 写入字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器读取 1 个字节，参数 reg 是寄存器地址，返回读取到的字节数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302SingleRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line"></span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x81</span>); <span class="comment">// 发送【读】寄存器指令</span></span><br><span class="line">  dat = DS1302ByteRead();             <span class="comment">// 读取字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用【突发模式】连续写入 8 个寄存器数据，参数 dat 是待写入的数据指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302BurstWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;</span><br><span class="line">  DS1302ByteWrite(<span class="number">0xBE</span>); <span class="comment">// 发送【突发写】寄存器指令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入 8 字节数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    DS1302ByteWrite(dat[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用【突发模式】连续读取 8 个寄存器数据，参数 dat 是读取数据的接收指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302BurstRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;</span><br><span class="line">  DS1302ByteWrite(<span class="number">0xBF</span>); <span class="comment">// 发送【突发读】寄存器指令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续读取 8 字节数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    dat[i] = DS1302ByteRead();</span><br><span class="line">  &#125;</span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 DS1302，如果掉电就重新设置初始时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code InitTime[] = &#123;<span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0x12</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x02</span>, <span class="number">0x13</span>, <span class="number">0x00</span>&#125;; <span class="comment">// 2013年10月8日 星期二 12:30:00</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 DS1302 通信引脚 */</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">  DS1302_CK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dat = DS1302SingleRead(<span class="number">0</span>);    <span class="comment">// 读取秒寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过秒寄存器的最高位 CH 来判断 DS1302 是否停止运行 */</span></span><br><span class="line">  <span class="keyword">if</span> ((dat &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    DS1302SingleWrite(<span class="number">7</span>, <span class="number">0x00</span>); <span class="comment">// 撤销写保护，允许写入数据</span></span><br><span class="line">    DS1302BurstWrite(InitTime); <span class="comment">// 设置 DS1302 为默认初始时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms　是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器重载值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时器重载值拆分为高低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加载定时器 T0 定时值 */</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;</span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，进行 200ms 定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr200ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加载定时器 T0 定时值 */</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;</span><br><span class="line">  tmr200ms++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时 200ms */</span></span><br><span class="line">  <span class="keyword">if</span> (tmr200ms &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">    tmr200ms = <span class="number">0</span>;</span><br><span class="line">    flag200ms = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>无论读写，只要使用了突发模式，就必须一次性读写
8 个寄存器，即对时钟寄存器完全读取或者完全写入。</p>
</blockquote>
<h2 id="电子时钟实例">电子时钟实例</h2>
<p>本实验将会实现一个加入了按键调时的简易万年历，通过上、下、左、右、回车、ESC
六个按键调整时间（忽略了星期数），下面列出了代码实现当中的一些要点：</p>
<ol type="1">
<li>将 DS1302
底层操作封装为一个<code>DS1302.c</code>文件，对上层应用提供基本实时时间操作函数。</li>
<li>定义结构体类型<code>sTime</code>来封装日期时间的各个元素，又使用该结构体定义了一个时间缓冲区变量<code>bufTime</code>来暂存从
DS1302 读取的时间以及时间的设定值；</li>
<li>定义一个<code>setIndex</code>变量，用于判断当前是否处于时间设置状态以及设置的是时间的哪一位，该值为<code>0</code>表示正常运行，<code>1 ~ 12</code>分别代表可以修改日期时间的十二个位；</li>
<li>由于本实验需要进行时间调整，所以需要使用到 1602
液晶的光标功能，改变哪一位数字就在液晶屏对应的位置上闪烁光标，因此<code>Lcd1602.c</code>文件需要添加了
2 个光标控制函数；</li>
<li>时间的显示、增减、设置移位等功能都放在<code>main.c</code>中实现，如果按键需要使用这些功能函数，可以在按键代码文件内进行外部声明，从而避免各功能函数分散在不同文件当中导致混乱。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** DS1302.c，实时时钟 DS1302 驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit DS1302_CE = P1 ^ <span class="number">7</span>;</span><br><span class="line">sbit DS1302_CK = P3 ^ <span class="number">5</span>;</span><br><span class="line">sbit DS1302_IO = P3 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义时间结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> year;  <span class="comment">// 年</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mon;  <span class="comment">// 月</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> day;  <span class="comment">// 日</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> hour; <span class="comment">// 时</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> min;  <span class="comment">// 分</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sec;  <span class="comment">// 秒</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> week; <span class="comment">// 星期</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送 1 个字节到 DS1302 通信总线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302ByteWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 首先输出该位数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) != <span class="number">0</span>)</span><br><span class="line">      DS1302_IO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      DS1302_IO = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DS1302_CK = <span class="number">1</span>; <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>; <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DS1302_IO = <span class="number">1</span>; <span class="comment">// 确保释放 IO 引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 DS1302 通信总线 读取 1 个字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302ByteRead</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在前，逐位进行移出 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先读取此时 IO 引脚，并设置 dat 的对应位 */</span></span><br><span class="line">    <span class="keyword">if</span> (DS1302_IO != <span class="number">0</span>) &#123;</span><br><span class="line">      dat |= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CK = <span class="number">1</span>; <span class="comment">// 然后拉高时钟</span></span><br><span class="line">    DS1302_CK = <span class="number">0</span>; <span class="comment">// 再拉低时钟，完成 1 个位的操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat; <span class="comment">// 返回读取的字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器写入 1 个字节，参数 reg 是寄存器地址，参数 dat 是待写入的字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302SingleWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x80</span>); <span class="comment">// 发送【写】寄存器指令</span></span><br><span class="line">  DS1302ByteWrite(dat);               <span class="comment">// 写入字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用单次写操作向某寄存器读取 1 个字节，参数 reg 是寄存器地址，返回读取到的字节数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302SingleRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line"></span><br><span class="line">  DS1302_CE = <span class="number">1</span>;                      <span class="comment">// 使能片选信号</span></span><br><span class="line">  DS1302ByteWrite((reg &lt;&lt; <span class="number">1</span>) | <span class="number">0x81</span>); <span class="comment">// 发送【读】寄存器指令</span></span><br><span class="line">  dat = DS1302ByteRead();             <span class="comment">// 读取字节数据</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;                      <span class="comment">// 移除片选信号使能</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用【突发模式】连续写入 8 个寄存器数据，参数 dat 是待写入的数据指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302BurstWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;</span><br><span class="line">  DS1302ByteWrite(<span class="number">0xBE</span>); <span class="comment">// 发送【突发写】寄存器指令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入 8 字节数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    DS1302ByteWrite(dat[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 采用【突发模式】连续读取 8 个寄存器数据，参数 dat 是读取数据的接收指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302BurstRead</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">  DS1302_CE = <span class="number">1</span>;</span><br><span class="line">  DS1302ByteWrite(<span class="number">0xBF</span>); <span class="comment">// 发送【突发读】寄存器指令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续读取 8 字节数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    dat[i] = DS1302ByteRead();</span><br><span class="line">  &#125;</span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取实时时间，读取 DS1302 当前时间并转换为时间结构体格式 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetRealTime</span><span class="params">(<span class="keyword">struct</span> sTime *time)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">  DS1302BurstRead(buf);</span><br><span class="line"></span><br><span class="line">  time-&gt;year = buf[<span class="number">6</span>] + <span class="number">0x2000</span>;</span><br><span class="line">  time-&gt;mon = buf[<span class="number">4</span>];</span><br><span class="line">  time-&gt;day = buf[<span class="number">3</span>];</span><br><span class="line">  time-&gt;hour = buf[<span class="number">2</span>];</span><br><span class="line">  time-&gt;min = buf[<span class="number">1</span>];</span><br><span class="line">  time-&gt;sec = buf[<span class="number">0</span>];</span><br><span class="line">  time-&gt;week = buf[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置实时时间，将时间结构体格式的设置时间转换为数组并写入 DS1302 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetRealTime</span><span class="params">(<span class="keyword">struct</span> sTime *time)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  buf[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">6</span>] = time-&gt;year;</span><br><span class="line">  buf[<span class="number">5</span>] = time-&gt;week;</span><br><span class="line">  buf[<span class="number">4</span>] = time-&gt;mon;</span><br><span class="line">  buf[<span class="number">3</span>] = time-&gt;day;</span><br><span class="line">  buf[<span class="number">2</span>] = time-&gt;hour;</span><br><span class="line">  buf[<span class="number">1</span>] = time-&gt;min;</span><br><span class="line">  buf[<span class="number">0</span>] = time-&gt;sec;</span><br><span class="line"></span><br><span class="line">  DS1302BurstWrite(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 DS1302，如果掉电就重新设置初始时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> code InitTime[] = &#123;<span class="number">0x2013</span>, <span class="number">0x10</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x02</span>&#125;; <span class="comment">// 2013年10月8日 12:30:00 星期二</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 DS1302 通信引脚 */</span></span><br><span class="line">  DS1302_CE = <span class="number">0</span>;</span><br><span class="line">  DS1302_CK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dat = DS1302SingleRead(<span class="number">0</span>); <span class="comment">// 读取秒寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过秒寄存器的最高位 CH 来判断 DS1302 是否停止运行 */</span></span><br><span class="line">  <span class="keyword">if</span> ((dat &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    DS1302SingleWrite(<span class="number">7</span>, <span class="number">0x00</span>); <span class="comment">// 撤销写保护，允许写入数据</span></span><br><span class="line">    DS1302BurstWrite(InitTime); <span class="comment">// 设置 DS1302 为默认初始时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>DS1302.c</code>文件提供了与时钟芯片寄存器位置无关的、由时间结构类型<code>sTime</code>作为参数的实时时间读写函数，如果未来需要更换时钟芯片型号，只需要提供同样以<code>sTime</code>为参数的操作函数即可，而应用层无需进行任何调整。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lcd1602.c，1602 液晶显示驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0</span></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备完毕 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWaitReady</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sta;</span><br><span class="line"></span><br><span class="line">  LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    sta = LCD1602_DB;   <span class="comment">// 读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (sta &amp; <span class="number">0x80</span>); <span class="comment">// 如果 bit7 等于 1 表示液晶正忙，循环检测直至等于表示空闲的 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节命令到 1602 液晶，参数 cmd 表示待写入的命令 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = cmd;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 1 字节数据到 1602 液晶，参数 dat 表示待写入的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  LcdWaitReady();</span><br><span class="line">  LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">  LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">  LCD1602_DB = dat;</span><br><span class="line">  LCD1602_E = <span class="number">1</span>;</span><br><span class="line">  LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 的起始地址，即光标位置，参数 x 和 y 分别对应屏幕的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据屏幕坐标计算显示 RAM 地址 */</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    addr = <span class="number">0x00</span> + x;        <span class="comment">// 第 1 行字符地址从 0x00 起始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    addr = <span class="number">0x40</span> + x;        <span class="comment">// 第 2 行字符地址从 0x40 起始</span></span><br><span class="line"></span><br><span class="line">  LcdWriteCmd(addr | <span class="number">0x80</span>); <span class="comment">// 设置 RAM 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，参数 x 和 y 对应屏幕上的起始坐标，参数 str 是字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  LcdSetCursor(x, y);    <span class="comment">// 设置起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 连续写入字符串，直至检测到结束符 */</span></span><br><span class="line">  <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    LcdWriteDat(*str++); <span class="comment">// 首先获得 str 指向的数据，然后 str 再自增 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开光标闪烁 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdOpenCursor</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x0F</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭光标闪烁 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdCloseCursor</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化1602液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span> &#123;</span><br><span class="line">  LcdWriteCmd(<span class="number">0x38</span>); <span class="comment">// 16×2 显示，5×7 点阵，8 位数据接口</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x0C</span>); <span class="comment">// 开启显示器，关闭光标</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x06</span>); <span class="comment">// 文字保持不动，地址自增 1</span></span><br><span class="line">  LcdWriteCmd(<span class="number">0x01</span>); <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.c</code>在之前代码基础上添加了用于控制光标效果开<code>LcdOpenCursor()</code>、关<code>LcdCloseCursor()</code>的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义时间结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> year;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mon;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> day;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> hour;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> min;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sec;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> week;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bit flag200ms = <span class="number">1</span>;          <span class="comment">// 200ms 定时标志位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span> <span class="title">bufTime</span>;</span>       <span class="comment">// 日期时间缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> setIndex = <span class="number">0</span>; <span class="comment">// 时间设置索引</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;     <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;     <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RefreshTimeShow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitDS1302</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">GetRealTime</span><span class="params">(<span class="keyword">struct</span> sTime *time)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SetRealTime</span><span class="params">(<span class="keyword">struct</span> sTime *time)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdSetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdOpenCursor</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdCloseCursor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> psec = <span class="number">0xAA</span>; <span class="comment">// 秒数备份，初始值 0xAA 可以确保首次读取时间以后能够刷新显示</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 使能总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>); <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  InitDS1302();    <span class="comment">// 初始化 DS1302 实时时钟</span></span><br><span class="line">  InitLcd1602();   <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 1602 液晶屏幕上固定不变的内容 */</span></span><br><span class="line">  LcdShowStr(<span class="number">3</span>, <span class="number">0</span>, <span class="string">&quot;20  -  -  &quot;</span>);</span><br><span class="line">  LcdShowStr(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;  :  :  &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();             <span class="comment">// 调用按键驱动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 间隔 200ms 并且没有处于设置状态的时候 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag200ms &amp;&amp; (setIndex == <span class="number">0</span>)) &#123;</span><br><span class="line">      flag200ms = <span class="number">0</span>;</span><br><span class="line">      GetRealTime(&amp;bufTime); <span class="comment">// 获取当前时间</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测时间变化时刷新 1602 液晶显示 */</span></span><br><span class="line">      <span class="keyword">if</span> (psec != bufTime.sec) &#123;</span><br><span class="line">        RefreshTimeShow();</span><br><span class="line">        psec = bufTime.sec;  <span class="comment">// 使用当前值更新秒数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将 BCD 码显示到 1602 液晶屏幕，参数 x, y 是屏幕起始坐标，参数 bcd 是待显示的 BCD 码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowBcdByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> bcd)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  str[<span class="number">0</span>] = (bcd &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">1</span>] = (bcd &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  str[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  LcdShowStr(x, y, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 刷新日期时间显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RefreshTimeShow</span><span class="params">()</span> &#123;</span><br><span class="line">  ShowBcdByte(<span class="number">5</span>, <span class="number">0</span>, bufTime.year);</span><br><span class="line">  ShowBcdByte(<span class="number">8</span>, <span class="number">0</span>, bufTime.mon);</span><br><span class="line">  ShowBcdByte(<span class="number">11</span>, <span class="number">0</span>, bufTime.day);</span><br><span class="line">  ShowBcdByte(<span class="number">4</span>, <span class="number">1</span>, bufTime.hour);</span><br><span class="line">  ShowBcdByte(<span class="number">7</span>, <span class="number">1</span>, bufTime.min);</span><br><span class="line">  ShowBcdByte(<span class="number">10</span>, <span class="number">1</span>, bufTime.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 刷新当前设置位的光标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RefreshSetShow</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (setIndex) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:  LcdSetCursor(<span class="number">5</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:  LcdSetCursor(<span class="number">6</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:  LcdSetCursor(<span class="number">8</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:  LcdSetCursor(<span class="number">9</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:  LcdSetCursor(<span class="number">11</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:  LcdSetCursor(<span class="number">12</span>, <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:  LcdSetCursor(<span class="number">4</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:  LcdSetCursor(<span class="number">5</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:  LcdSetCursor(<span class="number">7</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>: LcdSetCursor(<span class="number">8</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>: LcdSetCursor(<span class="number">10</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>: LcdSetCursor(<span class="number">11</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递增 BCD 码高位 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IncBcdHigh</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bcd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((bcd &amp; <span class="number">0xF0</span>) &lt; <span class="number">0x90</span>)</span><br><span class="line">    bcd += <span class="number">0x10</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bcd &amp;= <span class="number">0x0F</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递增 BCD 码低位 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IncBcdLow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bcd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((bcd &amp; <span class="number">0x0F</span>) &lt; <span class="number">0x09</span>)</span><br><span class="line">    bcd += <span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bcd &amp;= <span class="number">0xF0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递减 BCD 码高位 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DecBcdHigh</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bcd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((bcd &amp; <span class="number">0xF0</span>) &gt; <span class="number">0x00</span>)</span><br><span class="line">    bcd -= <span class="number">0x10</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bcd |= <span class="number">0x90</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递减 BCD 码低位 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DecBcdLow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bcd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((bcd &amp; <span class="number">0x0F</span>) &gt; <span class="number">0x00</span>)</span><br><span class="line">    bcd -= <span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bcd |= <span class="number">0x09</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递增时间当前设置位的值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncSetTime</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (setIndex) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  bufTime.year = IncBcdHigh(bufTime.year); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:  bufTime.year = IncBcdLow(bufTime.year); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:  bufTime.mon = IncBcdHigh(bufTime.mon); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:  bufTime.mon = IncBcdLow(bufTime.mon); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:  bufTime.day = IncBcdHigh(bufTime.day); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:  bufTime.day = IncBcdLow(bufTime.day); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:  bufTime.hour = IncBcdHigh(bufTime.hour); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:  bufTime.hour = IncBcdLow(bufTime.hour); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:  bufTime.min = IncBcdHigh(bufTime.min); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: bufTime.min = IncBcdLow(bufTime.min); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>: bufTime.sec = IncBcdHigh(bufTime.sec); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: bufTime.sec = IncBcdLow(bufTime.sec); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RefreshTimeShow();</span><br><span class="line">  RefreshSetShow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递减时间当前设置位的值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DecSetTime</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (setIndex) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  bufTime.year = DecBcdHigh(bufTime.year); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:  bufTime.year = DecBcdLow(bufTime.year); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:  bufTime.mon = DecBcdHigh(bufTime.mon); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:  bufTime.mon = DecBcdLow(bufTime.mon); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:  bufTime.day = DecBcdHigh(bufTime.day); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:  bufTime.day = DecBcdLow(bufTime.day); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:  bufTime.hour = DecBcdHigh(bufTime.hour); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:  bufTime.hour = DecBcdLow(bufTime.hour); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:  bufTime.min = DecBcdHigh(bufTime.min); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: bufTime.min = DecBcdLow(bufTime.min); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>: bufTime.sec = DecBcdHigh(bufTime.sec); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: bufTime.sec = DecBcdLow(bufTime.sec); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RefreshTimeShow();</span><br><span class="line">  RefreshSetShow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右移时间设置位 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightShiftTimeSet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (setIndex != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setIndex &lt; <span class="number">12</span>)</span><br><span class="line">      setIndex++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      setIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    RefreshSetShow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左移时间设置位 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftShiftTimeSet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (setIndex != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setIndex &gt; <span class="number">1</span>)</span><br><span class="line">      setIndex--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      setIndex = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    RefreshSetShow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入时间设置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnterTimeSet</span><span class="params">()</span> &#123;</span><br><span class="line">  setIndex = <span class="number">2</span>;       <span class="comment">// 将设置索引赋值为 2 进入设置状态</span></span><br><span class="line">  LeftShiftTimeSet(); <span class="comment">// 调用左移操作函数，移至位置 1 并完成显示刷新</span></span><br><span class="line">  LcdOpenCursor();    <span class="comment">// 打开光标闪烁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出时间设置，参数 save 是否保存当前设置的时间值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ExitTimeSet</span><span class="params">(bit save)</span> &#123;</span><br><span class="line">  setIndex = <span class="number">0</span>;       <span class="comment">// 设置索引为 0 退出设置状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果需要保存，就将当前设置时间写入 DS1302 */</span></span><br><span class="line">  <span class="keyword">if</span> (save) &#123;</span><br><span class="line">    SetRealTime(&amp;bufTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LcdCloseCursor();   <span class="comment">// 关闭光标显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="comment">/* 本实验无需响应字符按键 */</span></span><br><span class="line">  <span class="keyword">if</span> ((keycode &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (keycode &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;&#125;</span><br><span class="line">  <span class="comment">/* 向上键，递增当前设置位的值 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    IncSetTime();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向下键，递减当前设置位的值 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) &#123;</span><br><span class="line">    DecSetTime();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向左键，向左切换设置位 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x25</span>) &#123;</span><br><span class="line">    LeftShiftTimeSet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向右键，向右切换设置位 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x27</span>) &#123;</span><br><span class="line">    RightShiftTimeSet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 回车键，进入设置模式或者确认当前设置值 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x0D</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果不处于设置状态，那么就进入设置状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (setIndex == <span class="number">0</span>) &#123;</span><br><span class="line">      EnterTimeSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 已处于设置状态时，保存时间并退出设置状态 */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      ExitTimeSet(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Esc键，取消当前设置 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x1B</span>) &#123;</span><br><span class="line">    ExitTimeSet(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是需要的定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">28</span>;                   <span class="comment">// 补偿中断响应延时误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时值拆分为高、低字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;                       <span class="comment">// 加载定时器 T0 的定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，执行按键扫描和200ms定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr200ms = <span class="number">0</span>;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL; <span class="comment">// 重新加载定时值</span></span><br><span class="line">  KeyScan();  <span class="comment">// 调用按键扫描函数</span></span><br><span class="line">  tmr200ms++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时 200ms */</span></span><br><span class="line">  <span class="keyword">if</span> (tmr200ms &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">    tmr200ms = <span class="number">0</span>;</span><br><span class="line">    flag200ms = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>文件负责所有应用层功能的实现，虽然代码较长显得较为繁琐，但是实现原理方面并不存在难度。</p>
<h1 id="红外通信与-nec-协议">红外通信与 NEC 协议</h1>
<p>红外线是波长介于微波与可见光之间的电磁波（波长<code>760 纳米 ~ 1 毫米</code>），物体温度只要高于绝对零度<code>-273</code>就会由于分子、原子的无序运动而不停的辐射红外线。单片机开发电路当中，<strong>红外发射管</strong>类似于发光二极管，红外线的发射强度会随着电流的增大而增强；<strong>红外接收管</strong>是可以接收红外线波长的光敏二极管，内部是一个具有红外敏感特征的
PN
节；没有红外线时接收管不导通，有红外线时接收管导通，并在一定范围内电流随着红外线强度的增加而增大。</p>
<p><img src="/Embedded/STC89C52/Infrared/infrared-emitter-receiving-tube.jpg"></p>
<p>红外发射/接收管也用于避障、循迹小车等单片机实验，有兴趣的同学可以参考下面的原理图来搭建电路：</p>
<p><img src="/Embedded/STC89C52/Infrared/tracking-avoidance-car.png"></p>
<p>上图中的<strong>发射控制</strong>端与<strong>接收检测</strong>端都连接到单片机
IO
引脚：<strong>发射部分</strong>在发射控制端输出高电平时，三极管<strong>Q1</strong>不导通，红外发射管<strong>L1</strong>不会发射红外信号；当发射控制输出低电平时，三极管<strong>Q1</strong>导通<strong>L1</strong>开始发射红外信号。</p>
<p><strong>接收部分</strong>通过电位器<strong>R4</strong>向<strong>LM393</strong>的
2
号引脚提供一个阈值电压（该电压值可以通过调整电位器来确定），由于红外接收管<strong>L2</strong>接收红外线时会产生电流，并且随着红外线强度的增加，通过的电流也会变大。当没有红外线或者红外线较弱的时候，3
号引脚的电压值趋近于<strong>VCC</strong>，如果 3 号引脚电压高于 2
号，经过<strong>LM393</strong>比较器之后，红外接收检测端将输出一个高电平。随着红外线强度的增大，通过的电流也在变大。由于
3
号引脚的电压值等于<code>VCC - I × R3</code>，所以电压会越来越小，直至小于
2 号引脚电压时，红外接收检测引脚就会变为低电平。</p>
<p>该电路用于避障时，发射管先发送红外信号，红外信号会随着距离的加大而逐渐衰减，如果遇到障碍物就会形成反射。当反射回来的信号比较弱时，光敏二极管<strong>L2</strong>接收的红外线较弱，比较器<strong>LM393</strong>的
3 号引脚电压高于 2
号，此时接收检测引脚将输出高电平，说明障碍物当前距离较远；当反射回来的信号变强，接收检测引脚输出低电平时，说明障碍物已经距离较近了。</p>
<p>该电路用于小车循迹时，地面必须铺设黑色、白色轨道；当红外信号发送至黑色轨道时，由于黑色的光线吸收能力较强，被反射回的红外线信号较微弱，而白色轨道则会将大部分红外信号反射回来。循迹小车通常采用多个红外模块同时进行检测，从多个角度判断轨道，并以此调整小车行驶轨迹。</p>
<h2 id="红外遥控通信原理">红外遥控通信原理</h2>
<p><strong>基带信号（Baseband）</strong>是指未经过调制的原始电信号，，信号频谱从零频附近开始并且频率较低，具有低通形式。</p>
<p>由于基带信号并不适合直接在信道中传输，为了便于传输、提高抗干扰能力、有效利用带宽，通常需要将信号调制为适当的频率范围（高频）进行传输，这个过程就称为信号<strong>调制</strong>。而接收端需要对接收到的调制信号进行<strong>解调</strong>，将其恢复为原始的基带信号。</p>
<p>家用电器中常用的红外遥控器，使用了<strong>38K</strong>左右的载波进行调制，所谓调制就是利用<strong>待传输的信号</strong>去控制<strong>某个高频信号</strong>的幅度、相位、频率等参数变化的过程，简而言之，就是使用一个信号去装载另一个信号。</p>
<p><img src="/Embedded/STC89C52/Infrared/modulation.png"></p>
<p>上图中，原始信号是待发送的 1 位低电平<code>0</code>和 1
位高电平<code>1</code>，所谓<strong>38K
载波</strong>是指频率为<code>38 KHz</code>的方波信号，调制后的信号就是最终发射出去的波形。这里使用了原始信号去控制
38K 载波，当原始信号为低电平<code>0</code>时 38K
载波原样发送，当原始信号为高电平<code>1</code>时不发送任何载波信号。</p>
<p><img src="/Embedded/STC89C52/Infrared/emitter.png"></p>
<p>38K 载波可以通过<code>455 KHz</code>晶振，经过<strong>12
分频</strong>后得到<code>37.91 KHz</code>，也可以通过时基集成电路<strong>NE555</strong>来生成，或者通过单片机的<strong>PWM</strong>来产生。当信号输出引脚输出高电平时，三极管<strong>Q2</strong>截止，无论<code>38 KHz</code>载波信号如何控制三极管<strong>Q1</strong>，右侧纵向的支路都不会导通，红外线发送管<strong>L1</strong>不会发送任何信息；当信号输出为低电平时，<code>38 KHz</code>载波会通过三极管<strong>Q1</strong>传输过来，并在<strong>L1</strong>上产生<code>38 KHz</code>载波信号。需要特别说明的是：大多数家用电器遥控器的<code>38 KHz</code>的占空比为<code>1/2</code>或<code>1/3</code>。</p>
<p>生产环境下，接收端还需要对信号进行检测、放大、滤波、解调等处理，然后输出基带信号。但是实验电路采用的一体化红外接收头<strong>HS0038B</strong>已经集成了这些电路，因此电路得到了大幅的简化：</p>
<p><img src="/Embedded/STC89C52/Infrared/receiver.png"></p>
<p>红外线接收头内置放大器的增益较大容易引起干扰，因此在接收头供电引脚上添加了<code>10uF</code>的滤波电容，并在
HS0038B
供电引脚<strong>VDD</strong>与<code>5V</code>电源之间串联了一个<code>100 Ω</code>的电阻<strong>R69</strong>，进一步降低干扰。</p>
<p>前面两幅电路图，分别代表了红外线通信实验中的<strong>发送</strong>与<strong>接收</strong>方，当
HS0038B
检测到<code>38 KHz</code>红外信号时，<strong>OUT</strong>引脚就会输出低电平，如果未检测到，<strong>OUT</strong>引脚就会输出高电平。由于<strong>OUT</strong>引脚输出的是解调之后的基带信号，所以将其连接至单片机
IO 引脚，即可以获取红外线发送过来的信号。</p>
<h2 id="nec-红外通信协议">NEC 红外通信协议</h2>
<p>红外通信的硬件成本明显低于其它无线通信方式，因此在家电遥控器当中始终占有一席之地。红外遥控器的基带通信协议有几十种，常用的就有
ITT、NEC、Sharp、Philips RC-5、Sony SIRC 协议等等，其中应用较多的是 NEC
协议，因此实验电路配套的遥控器直接采用了 NEC 协议。</p>
<p><img src="/Embedded/STC89C52/Infrared/NEC.png"></p>
<p>NEC
协议的数据格式包括<strong>引导码</strong>、<strong>用户码</strong>、<strong>用户码</strong>（或用户码反码）、<strong>按键键码</strong>、<strong>键码反码</strong>、<strong>停止位</strong>，其中数据编码有<code>4 Byte</code>共<code>32 bit</code>；其中，第
1 个字节是用户码，第 2
个字节即可能是用户码也可能是用户码反码（具体由生产商决定），第 3
个字节是当前按键的键码，第 4 个字节是键码的反码，主要用于数据纠错。NEC
协议每一位数据本身都需要编码，然后再进行载波调制：</p>
<ul>
<li>引导码：<code>9ms</code>载波加上<code>4.5ms</code>空闲；</li>
<li>比特值<code>0</code>：<code>560us</code>载波加上<code>560us</code>空闲；</li>
<li>比特值<code>1</code>：<code>560us</code>载波加上<code>1.68ms</code>空闲。</li>
</ul>
<p>结合协议分析上面的 NEC
协议示意图，最前面的整块黑色是<code>9ms</code>载波所表达的引导码，紧接着是<code>4.5ms</code>空闲，接下来的数据码由多个载波和空闲交替组成，其长短具体由需要传输的数据来决定。HS0038B
接收到载波信号时会输出低电平，空闲时则会输出高电平，采用逻辑分析仪抓取一个红外遥控器按键经
HS0038B 解码后的波形图：</p>
<p><img src="/Embedded/STC89C52/Infrared/decode.png"></p>
<p>上图当中，首先是<code>9ms</code>载波加上<code>4.5ms</code>空闲起始码，而<strong>数据码是低位在前高位在后</strong>，数据码第
1
个字节是八组<code>560us</code>的载波加上<code>560us</code>空闲，即<code>0x00</code>；第
2
个字节是八组<code>560us</code>载波加上<code>1.68ms</code>空闲，即<code>0xFF</code>；这两个字节就是<strong>用户码</strong>和<strong>用户码的反码</strong>。按键的二进制键码为<code>0x0C</code>，反码就是<code>0xF3</code>，最后再跟随了一个<code>560us</code>载波停止位。对于红外遥控器而言，不同按键仅仅是<strong>键码</strong>和<strong>键码反码</strong>的区别，而<strong>用户码</strong>是相同的。</p>
<p>标准 51 单片机拥有<strong>外部中断 0</strong>和<strong>外部中断
1</strong>两个外部中断，实验电路将红外接收引脚连接到<strong>STC89C52RC</strong>的<strong>P3.3</strong>引脚，该引脚功能之一就是作为外部中断
1。寄存器<strong>TCON</strong>中的第 2、3 两位与外部中断 1
相关，其中<code>IE1</code>是外部中断标志位，当外部中断发生以后该位自动置<code>1</code>；而<code>IT1</code>用于设置外部中断类型，如果等于<code>0</code>则只需<strong>P3.3</strong>为低电平即可触发中断，如果为<code>1</code>则会在<strong>P3.3</strong>从高电平向低电平产生下降沿时才会触发中断。此外，外部中断
1 的使能位是<strong>EX1</strong>。</p>
<p>接下来着手编写一个实验程序，使用动态数码管将红外遥控器的用户码和键码显示出来。<code>Infrared.c</code>文件主要用于检测红外通信，当发生外部中断之后，进入外部中断并通过定时器
1
定时，首先判断引导码，然后根据数据码逐位获取高低电平时间，进而得知每一位上是<code>0</code>还是<code>1</code>，进而最终完成解码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Infrared.c，使用 NEC 编码协议的红外遥控驱动程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit IR_INPUT = P3 ^ <span class="number">3</span>;     <span class="comment">// 红外接收引脚</span></span><br><span class="line">bit irflag = <span class="number">0</span>;             <span class="comment">// 红外接收标志位，接收到一帧数据以后置 1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ircode[<span class="number">4</span>];    <span class="comment">// 红外数据接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化红外接收功能 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitInfrared</span><span class="params">()</span> &#123;</span><br><span class="line">  IR_INPUT = <span class="number">1</span>;             <span class="comment">// 确保红外接收引脚被释放</span></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;             <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x10</span>;             <span class="comment">// 设置定时器 T1 为工作模式 1</span></span><br><span class="line">  TR1 = <span class="number">0</span>;                  <span class="comment">// 停止定时器 T1 计数</span></span><br><span class="line">  ET1 = <span class="number">0</span>;                  <span class="comment">// 禁止定时器 T1 中断</span></span><br><span class="line">  IT1 = <span class="number">1</span>;                  <span class="comment">// 设置 INT1 为下降沿触发</span></span><br><span class="line">  EX1 = <span class="number">1</span>;                  <span class="comment">// 使能 INT1 外部中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前高电平的持续时间 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">GetHighTime</span><span class="params">()</span> &#123;</span><br><span class="line">  TH1 = <span class="number">0</span>; TL1 = <span class="number">0</span>;         <span class="comment">// 定时器 T1 定时值置 0</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                  <span class="comment">// 启动定时器 T1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 红外输入引脚为 1 时循环进行检测，变为 0 时则结束循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (IR_INPUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当定时器 T1 的定时值大于 0x4000，即高电平持续时间超过约 18ms 时强制退出循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (TH1 &gt;= <span class="number">0x40</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;                <span class="comment">// 避免信号异常致使程序跑飞</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TR1 = <span class="number">0</span>;                  <span class="comment">// 定时器 T1 停止</span></span><br><span class="line">  <span class="keyword">return</span> (TH1 * <span class="number">256</span> + TL1); <span class="comment">// 将定时器 T1 的计数值转换为 16 位整型数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前低电平的持续时间 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">GetLowTime</span><span class="params">()</span> &#123;</span><br><span class="line">  TH1 = <span class="number">0</span>;</span><br><span class="line">  TL1 = <span class="number">0</span>;                  <span class="comment">// 定时器 T1 定时值置 0</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                  <span class="comment">// 启动定时器 T1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 红外输入引脚为 0 时循环进行检测，变为 1 时则结束循环 */</span></span><br><span class="line">  <span class="keyword">while</span> (!IR_INPUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当定时器 T1 的定时值大于 0x4000，即低电平持续时间超过约 18ms 时强制退出循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (TH1 &gt;= <span class="number">0x40</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;                <span class="comment">// 避免信号异常致使程序跑飞</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TR1 = <span class="number">0</span>;                  <span class="comment">// 定时器 T1 停止</span></span><br><span class="line">  <span class="keyword">return</span> (TH1 * <span class="number">256</span> + TL1); <span class="comment">// 将定时器 T1 的计数值转换为 16 位整型数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外部中断 INT1 中断服务函数，用于红外信号的接收与解码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXINT1_ISR</span><span class="params">()</span> interrupt 2 &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> byt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">  time = GetLowTime();      <span class="comment">// 接收并且判断引导码的 9ms 低电平</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 时间判定范围为 8.5ms ~ 9.5ms，超过此范围则说明为错误码，直接退出 */</span></span><br><span class="line">  <span class="keyword">if</span> ((time &lt; <span class="number">7833</span>) || (time &gt; <span class="number">8755</span>)) &#123;</span><br><span class="line">    IE1 = <span class="number">0</span>; <span class="comment">// 退出前清零 INT1 中断标志位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time = GetHighTime();     <span class="comment">// 接收并且判定引导码的4.5ms 高电平</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 时间判定范围为 4.0ms ~ 5.0ms，超过此范围则说明为错误码，直接退出 */</span></span><br><span class="line">  <span class="keyword">if</span> ((time &lt; <span class="number">3686</span>) || (time &gt; <span class="number">4608</span>)) &#123;</span><br><span class="line">    IE1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环接收并且判断后续 4 个字节的数据 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 循环判定每个字节的 8 个位数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      time = GetLowTime();  <span class="comment">// 接收并且判断引导码的 560us 低电平</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 时间判定范围为 340us ~ 780us，超过此范围则说明为错误码，直接退出 */</span></span><br><span class="line">      <span class="keyword">if</span> ((time &lt; <span class="number">313</span>) || (time &gt; <span class="number">718</span>)) &#123;</span><br><span class="line">        IE1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      time = GetHighTime(); <span class="comment">// 接收每位的高电平持续时间，并且判断该位的值</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 时间判定范围为 340us ~ 780us，在此范围以内说明该位为 0 */</span></span><br><span class="line">      <span class="keyword">if</span> ((time &gt; <span class="number">313</span>) &amp;&amp; (time &lt; <span class="number">718</span>)) &#123;</span><br><span class="line">        byt &gt;&gt;= <span class="number">1</span>;          <span class="comment">// 由于低位在前，所以数据右移，高位为 0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 时间判定范围为 1460 ~ 1900us，在此范围以内说明该位为 1 */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((time &gt; <span class="number">1345</span>) &amp;&amp; (time &lt; <span class="number">1751</span>)) &#123;</span><br><span class="line">        byt &gt;&gt;= <span class="number">1</span>;          <span class="comment">// 由于低位在前，所以数据右移</span></span><br><span class="line">        byt |= <span class="number">0x80</span>;        <span class="comment">// 让高位置 1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果不在上述时间范围以内说明为错误码，直接退出 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        IE1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ircode[i] = byt;        <span class="comment">// 接收完 1 个字节以后，将其保存至缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  irflag = <span class="number">1</span>;               <span class="comment">// 接收完毕后设置标志位</span></span><br><span class="line">  IE1 = <span class="number">0</span>;                  <span class="comment">// 清零 INT1 中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在获取高低电平时间的时候，使用<code>if (TH1 &gt;= 0x40)</code>语句进行了一个超时判断，该判断主要是为了处理输入信号异常的情况。如果没有做超时判断，一旦输入的信号异常，由于程序等待的跳变沿无法到来，从而造成程序假死。此外，红外遥控器【单次按下按键】与【持续按下按键】所产生的信号时序不同，下面可以对比一下两者的波形：</p>
<p><img src="/Embedded/STC89C52/Infrared/key-sequence-compare.png"></p>
<p>持续按键首先会发送一个与单次按键类似的波形，经历大约<code>40ms</code>之后，将产生<code>9ms</code>载波加上<code>2.25ms</code>空闲，再跟随
1
个停止位波形，这被称为<strong>重复码</strong>，只要依然持续按住按键，每隔约<code>108ms</code>就会产生一个重复码。上面代码忽略了这个重复码的解析，这并不会影响正常按键数据的接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管编码表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                                <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动态数码管显示缓冲区*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">// 将初始值设置为 0xFF，确保启动时数码管处于熄灭状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;  <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;  <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> bit irflag;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> ircode[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitInfrared</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 总中断使能</span></span><br><span class="line">  ENLED = <span class="number">0</span>;       <span class="comment">// 使能网络标号为 U3 的 74HC138 译码器</span></span><br><span class="line">  ADDR3 = <span class="number">1</span>;</span><br><span class="line">  InitInfrared();  <span class="comment">// 初始化红外功能</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>); <span class="comment">// 定时器 T0 定时 1ms</span></span><br><span class="line">  PT0 = <span class="number">1</span>;         <span class="comment">// 设置定时器 T0 中断为高优先级，可消除信号接收时的闪烁问题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 当接收到红外数据时，动态数码管刷新显示 */</span></span><br><span class="line">    <span class="keyword">if</span> (irflag) &#123;</span><br><span class="line">      irflag = <span class="number">0</span>;</span><br><span class="line">      LedBuff[<span class="number">5</span>] = LedChar[ircode[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>]; <span class="comment">// 显示用户码</span></span><br><span class="line">      LedBuff[<span class="number">4</span>] = LedChar[ircode[<span class="number">0</span>] &amp; <span class="number">0x0F</span>];</span><br><span class="line">      LedBuff[<span class="number">1</span>] = LedChar[ircode[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>]; <span class="comment">// 显示按键码</span></span><br><span class="line">      LedBuff[<span class="number">0</span>] = LedChar[ircode[<span class="number">2</span>] &amp; <span class="number">0x0F</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">// 计算定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;          <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                <span class="comment">// 计算定时器定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">13</span>;                   <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>); <span class="comment">// 定时值拆分为高、低字节</span></span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                     <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                     <span class="comment">// 设置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;           <span class="comment">// 加载定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                          <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                          <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LedScan</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;  <span class="comment">// 动态扫描索引</span></span><br><span class="line"></span><br><span class="line">  P0 = <span class="number">0xFF</span>;                   <span class="comment">// 关闭所有段选位，数码管显示消隐</span></span><br><span class="line">  P1 = (P1 &amp; <span class="number">0xF8</span>) | i;        <span class="comment">// 将位选索引赋值给单片机 P1 接口低 3 位</span></span><br><span class="line">  P0 = LedBuff[i];             <span class="comment">// 将缓冲区中的索引位置发送至单片机 P0 接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 索引位置自增，遍历缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(LedBuff) - <span class="number">1</span>)</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，执行数码管扫描显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;      <span class="comment">// 重新加载定时值</span></span><br><span class="line">  LedScan();                   <span class="comment">// 数码管显示扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>将获取的红外遥控器用户码、键码发传至数码管上动态显示，并通过定时器
T0
间隔<code>1ms</code>对数码管进行动态刷新。程序运行之后，如果按下遥控器按键，数码管显示会发生闪烁，这是由于单片机程序顺序执行时，一旦按下遥控器按键，单片机就会进入遥控器解码中断程序，而该程序执行时间较长（大约需要几十毫秒），如果数码管动态刷新间隔超过<code>10ms</code>，肉眼就会感觉到闪烁。</p>
<p>解决这个问题，需要利用到 STC89C52RC
中断的嵌套特性。上面程序中存在两个中断程序，一个是用于接收红外数据的外部中断程序，一个是负责数码管扫描的定时器中断程序，接收红外信号时如果希望不要影响到数码管的动态扫描，那么必须让定时器中断去嵌套外部中断，即将定时器中断设置为高抢占优先级。</p>
<p>定时器中断程序执行时间仅有几十微秒，即使打断了红外接收中断代码的执行，顶多对每位的时间测量造成这几十微秒的误差，而该误差在最短<code>560us</code>的时间判断内是可接受的，所以中断嵌套并不会影响红外数据的正常接收。上面<code>main()</code>函数当中的<code>PT0 = 1</code>语句就是将定时器
T0 中断设置为高抢占式优先级，从而成功解决了上述的闪烁问题。</p>
<h1 id="温度传感器-ds18b20">温度传感器 DS18B20</h1>
<p>DS18B20 是 Maxim 美信半导体推出的一款温度传感器，可以采用 1-Wire
总线协议获取温度数据。<strong>1-Wire</strong>总线的硬连接比较简单，只需将
DS18B20 的数据引脚与单片机 IO
引脚直接相连即可。但是其总线时序较为复杂，下面首先来看一下 DS18B20
的硬件原理图：</p>
<p><img src="/Embedded/STC89C52/Infrared/DS18B20.png"></p>
<p>DS18B20
能够存储高达<code>12 bit</code>的温度值，在寄存器中是以补码形式式存储，如下图所示：</p>
<p><img src="/Embedded/STC89C52/Infrared/DS18B20-storage-format.png"></p>
<p>一共 2
个字节，其中<strong>LSB</strong>为低字节<strong>MSB</strong>为高字节，低
11
位都是<code>2ˣ</code>的指数形式，用于表示温度，字母<strong>S</strong>用于标识符号位。DS18B20
的温度测量范围在<code>-55℃ ~ +125℃</code>之间，因此温度数据有正负之分，寄存器每个数值如同卡尺刻度一样分布，请参考下面的温度数据关系表：</p>
<p><img src="/Embedded/STC89C52/Infrared/temperature-data-relationship.png"></p>
<p>二进制数值最低位增减<code>1</code>就代表温度增减了<code>0.0625℃</code>，<code>0℃</code>时对应的十六进制为<code>0x0000</code>，<code>125℃</code>时对应的十六进制为<code>0x07D0</code>，<code>-55℃</code>时对应的十六进制为<code>0xFC90</code>。换个角度，十六进制数<code>0x0001</code>对应的温度就是<code>0.0625℃</code>。</p>
<p>接下来的内容，将会对 DS18B20 工作协议过程进行详细的梳理：</p>
<h2 id="初始化">初始化</h2>
<p>与 I²C 总线寻址类似，<strong>1-Wire</strong>总线也会检测是否存在
DS18B20
设备。如果存在，总线会根据时序要求返回一个低电平脉冲；如果不存，总线就保持高电平不返回任何脉冲；该操作习惯上被称为<strong>存在脉冲</strong>检测。此外，存在脉冲不仅检测设备存在与否，还会通知
DS18B20 进行操作前的准备，具体请参考下面的时序图：</p>
<p><img src="/Embedded/STC89C52/Infrared/DS18B20-sequence-1.png"></p>
<p>时序图中的【实心粗线】是由于单片机 IO
接口拉低该引脚，【虚粗线】是由于 DS18B20
拉低该引脚，【浅色细线】是单片机依靠上拉电阻将 IO
接口上拉为高电平释放总线。<strong>存在脉冲检测过程</strong>，首先由单片机拉低电平，持续约<code>480us ~ 960us</code>时间即可；然后，单片机输出高电平释放总线，DS18B20
等待约<code>15us ~ 60us</code>以后，下拉为低电平并持续<code>60us ~ 240us</code>；最后
DS18B20 释放总线，IO
引脚通过上拉电阻自动拉高。下面通过一段程序逐句进行解释，首先由于 DS18B20
时序要求非常严格，所以操作时序时为了防止中断干扰总线时序，需要关闭总中断；然后拉低
DS18B20
引脚并持续<code>500us</code>；接下来，延时<code>60us</code>；最后，读取<strong>存在脉冲</strong>并等待存在脉冲结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bit <span class="title function_">Get18B20Ack</span><span class="params">()</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">0</span>;            <span class="comment">// 禁用总中断</span></span><br><span class="line">  IO_18B20 = <span class="number">0</span>;      <span class="comment">// 产生 500us 复位脉冲</span></span><br><span class="line">  DelayX10us(<span class="number">50</span>);</span><br><span class="line">  IO_18B20 = <span class="number">1</span>;</span><br><span class="line">  DelayX10us(<span class="number">6</span>);     <span class="comment">// 延时 60us</span></span><br><span class="line">  ack = IO_18B20;    <span class="comment">// 读取存在脉冲</span></span><br><span class="line">  <span class="keyword">while</span> (!IO_18B20); <span class="comment">// 等待存在脉冲结束</span></span><br><span class="line">  EA = <span class="number">1</span>;            <span class="comment">// 使能总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时序图上标注 DS18B20
需要等待<code>15us ~ 60us</code>，程序代码中延时<code>60us</code>就是要确保能够读到存在脉冲。</p>
</blockquote>
<h2 id="rom-操作指令">ROM 操作指令</h2>
<p>1-Wire 总线同样可以挂载多个设备，每个 DS18B20 内部都有一个唯一的 64
位长度序列号，该序列号保存在 DS18B20 内部 ROM 当中。前 8
位是产品类型编码（DS18B20 为<code>0x10</code>），接下来 48
位是每个设备的唯一序列号，最后 8 位是 CRC 校验码。</p>
<p>1-Wire 总线有效长度可以达到数十米，单片机通过 1-Wire 与多个 DS18B20
设备通信可以获取多组温度信息，也可以同时向所有 DS18B20
设备发送指令，这种一对多的指令相对而言较为复杂，这里只对 1-Wire
总线只连接一个设备的情况进行分析。当总线上只有一个设备的时候，可以通过<code>0xCC</code>指令跳过
ROM 检测。</p>
<h2 id="ram-存储器操作指令">RAM 存储器操作指令</h2>
<p>本小节只列出 DS18B20 的两条 RAM
读取指令，更多指令可以通过查询官方数据手册来获取。</p>
<ul>
<li><code>0xBE</code>：读暂存寄存器（<em>Read Scratchpad</em>），注意
DS18B20 提供的温度数据为 2
个字节，读取数据的时候，首先读取到的是低字节的低位，第 1
个字节读取完毕以后再读取高字节的低位，直至两个字节全部读取完毕。</li>
<li><code>0x44</code>：启用温度转换（<em>Convert
Temperature</em>），该指令发送后 DS18B20
开始进行温度转换，从开始转换到获取温度，DS18B20
根据自身的精度需要耗费一定时间。DS18B20
可以选用<strong>12</strong>、<strong>11</strong>、<strong>10</strong>、<strong>9</strong>位四种格式来呈现温度，位数越高精度就越高，9
位模式下最低位变化 1 个数字，虽然温度只会变化
<code>0.5℃</code>，但是与此同时其转换速度相对更快，具体请参考下表所示：</li>
</ul>
<p><img src="/Embedded/STC89C52/Infrared/thermometer-resolution-configuration.png"></p>
<p>上述表格中的寄存器<strong>R1</strong>和<strong>R0</strong>决定了其转换位数，出厂时默认值为<code>11</code>，即采用<strong>12</strong>位格式来表达温度，最大转换时间为<code>750ms</code>。开始温度转换之后，至少要再等待<code>750ms</code>才能读取温度，否则有可能会读到错误的值。</p>
<h2 id="ds18b20-位读写时序">DS18B20 位读写时序</h2>
<p><img src="/Embedded/STC89C52/Infrared/DS18B20-write-red-sequence.png"></p>
<p>上图上半部分是 DS18B20 的<strong>位写入</strong>时序图，当向 DS18B20
写入<code>0</code>时单片机将引脚拉低，持续<code>60us ~ 120us</code>时间即可。当单片机拉低<code>15us</code>以后，DS18B20
会在<code>15us ~ 60us</code>之间读取该位，典型时间一般是在<code>30us</code>左右进行读取。当向
DS18B20
写入<code>1</code>时单片机将引脚拉低，持续时间大于<code>1us</code>即可；然后马上拉高电平释放总线，持续时间大于<code>60us</code>即可；同样的，DS18B20
会在<code>15us ~ 60us</code>之间对其进行读取。</p>
<p>DS18B20
对时序的要求极为严格，写入过程最好不要产生中断，但是两个数据位之间的间隔时间大于<code>1us</code>且小于无穷，在这个时间段可以开启中断处理其它程序，下面是一个向
DS18B20 写入<code>1Byte</code>数据的示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Write18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  EA = <span class="number">0</span>;         <span class="comment">// 禁用总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在先，依次移出 8 个位 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    IO_18B20 = <span class="number">0</span>; <span class="comment">// 产生 2us 低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出该位的值 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) == <span class="number">0</span>)</span><br><span class="line">      IO_18B20 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      IO_18B20 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    DelayX10us(<span class="number">6</span>); <span class="comment">// 延时 60us</span></span><br><span class="line">    IO_18B20 = <span class="number">1</span>;  <span class="comment">// 拉高电平释放总线</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 使能总中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图的下半部分是 DS18B20 的<strong>位读取</strong>时序图，读取
DS18B20
数据时，首先单片机拉低引脚并保持至少<code>1us</code>时间，然后释放引脚。释放完毕以后需要尽快读取，从拉低该引脚到读取引脚状态不能超过<code>15us</code>。从上图可以看出，主机（MASTER
SAMPLES）的采样时间必须在<code>15us</code>以内完成，下面是一个从 DS18B20
读取<code>1Byte</code>数据的示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read18B20</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  EA = <span class="number">0</span>;          <span class="comment">// 禁用总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在先，依次采集 8 个位 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    IO_18B20 = <span class="number">0</span>;  <span class="comment">// 产生 2us 低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    IO_18B20 = <span class="number">1</span>;  <span class="comment">// 拉高电平状态，等待 18B20 输出数据</span></span><br><span class="line">    _nop_();       <span class="comment">// 延时 2us</span></span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取通信引脚的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (!IO_18B20)</span><br><span class="line">      dat &amp;= ~mask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dat |= mask;</span><br><span class="line">    DelayX10us(<span class="number">6</span>); <span class="comment">// 延时 60us</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 使能总中断</span></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="液晶温度显示实验">1602 液晶温度显示实验</h2>
<p>DS18B20
提供的温度值包含了小数和整数两部分，带小数的数据处理方法通常有两种：第一种是定义成浮点型直接处理，第二种是定义为整型，然后将小数与整数部分进行分离，最后在合适位置添加小数点。本实验程序采用了第二种方法，将读到的温度值显示在
1602 液晶，并且保留一位小数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DS18B20.c，温度传感器 DS18B20 驱动程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit IO_18B20 = P3 ^ <span class="number">2</span>; <span class="comment">// 声明用于 DS18B20 的单片机通信引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件延时函数，延时时间(t × 10)us */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayX10us</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">  &#125; <span class="keyword">while</span> (--t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在脉冲检测，并且初始化 DS18B20 */</span></span><br><span class="line">bit <span class="title function_">Get18B20Ack</span><span class="params">()</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">0</span>;            <span class="comment">// 禁用总中断</span></span><br><span class="line">  IO_18B20 = <span class="number">0</span>;      <span class="comment">// 产生 500us 复位脉冲</span></span><br><span class="line">  DelayX10us(<span class="number">50</span>);</span><br><span class="line">  IO_18B20 = <span class="number">1</span>;</span><br><span class="line">  DelayX10us(<span class="number">6</span>);     <span class="comment">// 延时 60us</span></span><br><span class="line">  ack = IO_18B20;    <span class="comment">// 读取存在脉冲</span></span><br><span class="line">  <span class="keyword">while</span> (!IO_18B20); <span class="comment">// 等待存在脉冲结束</span></span><br><span class="line">  EA = <span class="number">1</span>;            <span class="comment">// 使能总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 DS18B20 写入 1 个字节，参数 dat 是待写入的字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  EA = <span class="number">0</span>;          <span class="comment">// 禁用总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在先，依次移出 8 个位 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    IO_18B20 = <span class="number">0</span>;  <span class="comment">// 产生 2us 低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出该位的值 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; dat) == <span class="number">0</span>)</span><br><span class="line">      IO_18B20 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      IO_18B20 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    DelayX10us(<span class="number">6</span>); <span class="comment">// 延时 60us</span></span><br><span class="line">    IO_18B20 = <span class="number">1</span>;  <span class="comment">// 拉高电平释放总线</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 使能总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 DS18B20 读取 1 个字节，返回值为读取到的字节 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read18B20</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> mask;</span><br><span class="line">  EA = <span class="number">0</span>;          <span class="comment">// 禁用总中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 低位在先，依次采集 8 个位 */</span></span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">0x01</span>; mask != <span class="number">0</span>; mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    IO_18B20 = <span class="number">0</span>;  <span class="comment">// 产生 2us 低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    IO_18B20 = <span class="number">1</span>;  <span class="comment">// 拉高电平状态，等待 18B20 输出数据</span></span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();       <span class="comment">// 延时 2us</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取通信引脚的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (!IO_18B20)</span><br><span class="line">      dat &amp;= ~mask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dat |= mask;</span><br><span class="line"></span><br><span class="line">    DelayX10us(<span class="number">6</span>); <span class="comment">// 延时 60us</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;          <span class="comment">// 总中断使能</span></span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动 1 次 DS18B20 温度转换，返回启动是否成功的状态 */</span></span><br><span class="line">bit <span class="title function_">Start18B20</span><span class="params">()</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line">  ack = Get18B20Ack(); <span class="comment">// 总线复位，并且获取 18B20 响应</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 18B20 正确响应，则启动 1 次转换 */</span></span><br><span class="line">  <span class="keyword">if</span> (ack == <span class="number">0</span>) &#123;</span><br><span class="line">    Write18B20(<span class="number">0xCC</span>);  <span class="comment">// 跳过ROM操作</span></span><br><span class="line">    Write18B20(<span class="number">0x44</span>);  <span class="comment">// 启动 1 次温度转换</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ~ack;         <span class="comment">// 由于使用了 ack = 0 表示操作成功，所以需要对返回值进行取反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 DS18B20 转换出的温度值，返回读取是否成功的状态 */</span></span><br><span class="line">bit <span class="title function_">Get18B20Temp</span><span class="params">(<span class="type">int</span> *temp)</span> &#123;</span><br><span class="line">  bit ack;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> LSB, MSB;          <span class="comment">// 声明 16 位温度值的高低字节</span></span><br><span class="line">  ack = Get18B20Ack();             <span class="comment">// 总线复位，并且获取 18B20 响应</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 18B20 正确响应，则读取温度值 */</span></span><br><span class="line">  <span class="keyword">if</span> (ack == <span class="number">0</span>) &#123;</span><br><span class="line">    Write18B20(<span class="number">0xCC</span>);              <span class="comment">// 跳过 ROM 操作</span></span><br><span class="line">    Write18B20(<span class="number">0xBE</span>);              <span class="comment">// 发送读命令</span></span><br><span class="line">    LSB = Read18B20();             <span class="comment">// 读取温度值低字节</span></span><br><span class="line">    MSB = Read18B20();             <span class="comment">// 读取温度值高字节</span></span><br><span class="line">    *temp = ((<span class="type">int</span>)MSB &lt;&lt; <span class="number">8</span>) + LSB; <span class="comment">// 转换为 16 位整型数据</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ~ack;                     <span class="comment">// 由于 ack = 0 表示操作正确响应，所以需要对其进行取反</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，采用 DS18B20 测量温度并显示到1602 液晶，此处省略 Lcd1602.c 文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bit flag1s = <span class="number">0</span>;                      <span class="comment">// 定时 1 秒标志位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;              <span class="comment">// 定时器 T0 重载值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;              <span class="comment">// 定时器 T0 重载值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IntToString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">int</span> dat)</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">Start18B20</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">Get18B20Temp</span><span class="params">(<span class="type">int</span> *temp)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  bit res;</span><br><span class="line">  <span class="type">int</span> temp;                          <span class="comment">// 当前读取到的温度值</span></span><br><span class="line">  <span class="type">int</span> intT, decT;                    <span class="comment">// 温度值的整数与小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                            <span class="comment">// 总中断使能</span></span><br><span class="line">  ConfigTimer0(<span class="number">10</span>);                  <span class="comment">// 定时器 T0 定时 10ms</span></span><br><span class="line">  Start18B20();                      <span class="comment">// 启动 DS18B20</span></span><br><span class="line">  InitLcd1602();                     <span class="comment">// 初始化 1602 液晶</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每间隔 1 秒更新一次温度显示 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag1s) &#123;</span><br><span class="line">      flag1s = <span class="number">0</span>;</span><br><span class="line">      res = Get18B20Temp(&amp;temp);      <span class="comment">// 读取当前温度值</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果读取成功，就刷新当前温度显示 */</span></span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        intT = temp &gt;&gt; <span class="number">4</span>;             <span class="comment">// 分离温度值整数部分</span></span><br><span class="line">        decT = temp &amp; <span class="number">0xF</span>;            <span class="comment">// 分离温度值小数部分</span></span><br><span class="line">        len = IntToString(str, intT); <span class="comment">// 整数部分转换为字符串</span></span><br><span class="line">        str[len++] = <span class="string">&#x27;.&#x27;</span>;             <span class="comment">// 添加小数点</span></span><br><span class="line">        decT = (decT * <span class="number">10</span>) / <span class="number">16</span>;      <span class="comment">// 二进制小数部分转换为十进制</span></span><br><span class="line">        str[len++] = decT + <span class="string">&#x27;0&#x27;</span>;      <span class="comment">// 十进制小数转换为 ASCII 字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 使用空格补齐至 6 个字符长度 */</span></span><br><span class="line">        <span class="keyword">while</span> (len &lt; <span class="number">6</span>) &#123;</span><br><span class="line">          str[len++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str[len] = <span class="string">&#x27;\0&#x27;</span>;              <span class="comment">// 添加字符串结束符</span></span><br><span class="line">        LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, str);        <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果读取失败时，则提示错误信息 */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;error!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Start18B20();                   <span class="comment">// 开始下一次温度转换</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将整型数据转换为字符串类型，参数 str 是字符串指针，参数 dat 是待转换的数据，返回值是字符串长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IntToString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">int</span> dat)</span> &#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果待转换的数据为负数，那么取得绝对值后在指针上添加负号 */</span></span><br><span class="line">  <span class="keyword">if</span> (dat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    dat = -dat;</span><br><span class="line">    *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将数据转换为低位在前的十进制数组 */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = dat % <span class="number">10</span>;</span><br><span class="line">    dat /= <span class="number">10</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (dat &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  len += i;                <span class="comment">// 变量 i 的最终值是有效字符的个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将数组值转换为 ASCII 码，并反向拷贝到接收指针上 */</span></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    *str++ = buf[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;             <span class="comment">// 添加字符串结束符</span></span><br><span class="line">  <span class="keyword">return</span> len;              <span class="comment">// 返回字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时的时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;     <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>; <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;       <span class="comment">// 计算定时器的定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;          <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时值拆分为高低字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;            <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;            <span class="comment">// 配置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH;TL0 = T0RL;   <span class="comment">// 加载定时器 T0 的定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                 <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                 <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于完成 1 秒的定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr1s = <span class="number">0</span>;</span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;  <span class="comment">// 重新加载定时值</span></span><br><span class="line">  tmr1s++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时 1 秒 */</span></span><br><span class="line">  <span class="keyword">if</span> (tmr1s &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    tmr1s = <span class="number">0</span>;</span><br><span class="line">    flag1s = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模数-ad-数模-da">模数 AD / 数模 DA</h1>
<p>单片机处理的是数字信号，而工业控制领域与消费类电子领域中大量的信号都是模拟量，比如温度、距离、压力、速度等等，这就需要对模拟量和数字量进行相应的转换，这正是本节将要探讨的内容。</p>
<p><strong>A/D</strong>是模拟量 ➡
数字量的转换，依靠的是模数转换器(ADC，Analog to Digital
Converter)；<strong>D/A</strong>是数字量 ➡
模拟量的转换，依靠的是数模转换器(DAC，Digital to Analog
Converter)。两者原理基本相同，区别仅在于转换方向的不同，本节内容主要以<strong>A/D</strong>为例子来进行讨论。可以将
AD
分为<strong>积分型</strong>、<strong>逐次逼近型</strong>、<strong>并行/串行比较型</strong>、<strong>Σ-Δ
型</strong>等多种类型，但通常都会涉及到如下技术指标：</p>
<ol type="1">
<li><strong>ADC 的位数</strong>：ADC 有<code>n</code>位就表示该 ADC
拥有<code>2ⁿ</code>个刻度，例如 8 位 ADC
可以输出<code>2⁸ = 256</code>个数字量（数据刻度）。</li>
<li><strong>基准源</strong>：也称为基准电压，要想准确测量输入的 ADC
信号，基准源必须要准确，例如基准源应为<code>5.10V</code>，但实际只提供<code>4.5V</code>，那么就会造成较大的偏差。</li>
<li><strong>分辨率</strong>：是数字量变化 1
个最小刻度时，模拟信号的变化量，计算方法为<code>满刻度量程 / (2n-1)</code>，例如<code>5.10V</code>的电压使用
8 位 ADC 测量，相当于采用 256 个刻度将<code>5.10V</code>平均分为 255
等份，那么分辨率就等于<code>5.10V / (256 - 1) = 0.02V</code>。</li>
<li><strong>转换速率</strong>：指 ADC
每秒能够进行采样转换的最大次数，其单位为<code>sa/s</code>、<code>s/s</code>或<code>sps</code>（即
Samples Per Second 缩写），其与 ADC 完成 1
次模数转换所需的时间互为倒数。积分型 ADC 转换时间为毫秒级的，属于低速
ADC；逐次逼近型 ADC 转换时间为微秒级，属于中速 ADC；并行/串行 ADC
转换时间可达到纳秒级，属于高速 ADC。</li>
<li><strong>INL</strong>(积分非线性度，Integral
NonLiner)和<strong>DNL</strong>(差分非线性度，Differencial
NonLiner)：分辨率与精度是两个容易混淆的概念，通常认为分辨率越高精度越高，但实际上，两者之间并没有必然联系。分辨率是用来描述<strong>刻度划分</strong>，精度则主要用来描述<strong>准确程度</strong>。
INL 和 DNL 分别是衡量 ADC 精度的两个重要指标。</li>
</ol>
<p><strong>INL</strong>是指 ADC
在所有数值上对应的模拟值与真实值之间误差最大那个点的误差值，单位是<strong>LSB</strong>（最低有效位，Least
Significant Bit），其实质对应的是 ADC
的分辨率。例如基准为<code>5.10V</code>的 8 位
ADC，其分辨率为<code>0.02V</code>，如果用其测量一个电压信号得到的结果为<code>100</code>，则表示其所测得的电压值为<code>100 × 0.02V = 2V</code>，假如其
INL
为<code>1 LSB</code>，就表示该电压信号真实准确值位于<code>1.98V ~ 2.02V</code>之间，理想情况下对应得到的数值应在<code>99 ~ 101</code>范围，测量误差为一个最低有效位<code>1 LSB</code>。</p>
<p><strong>DNL</strong>是指 ADC
相邻两个刻度之间的最大误差，单位同样为<strong>LSB</strong>。这是由于 ADC
两个刻度线之间并不总是准确的等于分辨率，而是存在一定的误差
DNL。例如基准为<code>5.10V</code>的 8 位 ADC，其 DNL
假定为<code>0.5 LSB</code>，那么当其转换结果从 100 增加至 101
时，理想情况下实际电压应该增加 0.02V，但 DNL 为 <code>0.5 LSB</code>
情况下实际电压增加值应位于<code>0.01～0.03V</code>范围。此外，DNL
并不一定小于<code>1 LSB</code>，也可能会等于或大于<code>1 LSB</code>，当实际电压保持不变时，ADC
得出的结果可能会在多个数值之间跳跃。</p>
<h1 id="pcf8591-数据采集">PCF8591 数据采集</h1>
<p>PCF8591 是一个单电源低功耗的 8 位 CMOS 数据采集器件，具备 4
路模拟输入、1 路模拟输出以及 1 个用于与单片机通信的 I²C
总线接口。与之前实验电路所使用的 24C02
类似，三个地址引脚<strong>A0</strong>、<strong>A1</strong>、<strong>A2</strong>分别用于硬件地址编程，可以允许
8 个设备连接至 I²C
总线而无需额外的片选电路，器件的地址、控制、数据都通过 I²C
进行传输，下图是 PCF8591 的电路原理图：</p>
<p><img src="/Embedded/STC89C52/AD-DA/PCF8591.png"></p>
<p>上图当中，第 1、2、3、4 号引脚为四路模拟输入，第 5、6、7 号引脚为 I²C
设备地址，第 8 脚是接地<strong>GND</strong>，第 9、10 脚是 I²C
总线的<strong>SDA</strong>与<strong>SCL</strong>，第 12
脚是时钟选择引脚（<em>高电平表示采用外部时钟输入，低电平表示使用内部时钟</em>），当前实验电路将第
12 脚接 GND，所以采用的是内部时钟，第 11 脚悬空，第 13
脚是<strong>模拟地
AGND</strong>，实际开发中，对于较为复杂的模拟电路，AGND
部分在布局布线上需要特殊处理。当前实验电路并不存在复杂的模拟电路，所以将
AGND 和 GND 连接在一起；第 14 脚是基准源，第 15 脚是 DAC 模拟输出，第 16
脚是<strong>VCC</strong>供电电源。</p>
<p>PCF8591 的 ADC
属于<strong>逐次逼近型</strong>，虽然转换速率属于中速，但是其速度瓶颈在于
I²C 总线。由于 I²C 通信速度较慢，所以 PCF8591 的最终转换速度取决于 I²C
的通信速率。因为 I²C 通信速率的限制，所以 PCF8591 只能算作低速
AD/DA，主要用于一些转换速度要求不高、成本较低的场合，例如用于检测电池供电电压低于某值时提醒更换电池。</p>
<p><strong>Vref
基准电压</strong>有两种提供方式：一是采用简易原则直接连接到<strong>VCC</strong>，但是<strong>VCC</strong>可能会受到整个实验电路上元件功耗的影响，一方面可能不是准确的<code>5V</code>，另一方面伴随电路负载的变动会产生波动，所以只能用于精度要求较低的场合。二是使用<strong>TL431</strong>这样的专用基准电压器件，采用其提供的高精度<code>2.5V</code>电压基准。</p>
<p><img src="/Embedded/STC89C52/AD-DA/TL431.png"></p>
<p>上图中的<strong>J17</strong>是双排插针，可以使用杜邦线或者跳线帽连接其它外部电路，这里直接将<strong>J17</strong>的
3 脚和 4
脚用跳线帽短接，因此当前<strong>Vref</strong>基准源为<code>2.5V</code>。如果分别将<code>5 ~ 12</code>引脚用跳线帽短接，那么<strong>AIN0</strong>实际测量到的就是电位器分压值，<strong>AIN1</strong>和<strong>AIN2</strong>测的是
GND
的值，<strong>AIN3</strong>测的是<code>+5V</code>的值。需要注意：<strong>AIN3</strong>虽然测量的是<code>+5V</code>，但是对于
AD 而言，只要输入信号超过<strong>Vref
基准源</strong>，得到的始终都是最大值<code>255</code>，换而言之，实际上
AD
无法测量超过其<strong>Vref</strong>的电压信号。此外，所有输入信号的电压值都不能超过<code>+5V</code>的<strong>VCC</strong>，否则可能会导致
ADC 芯片损坏。</p>
<p>由于 PCF8591 采用了 I²C 总线与单片机通信，单片机发送 3
个字节就可以完成对 PCF8591 的初始化：第 1 个字节与 EEPROM
通信时类似，是器件的地址字节，其中 7 位代表地址（高 4
位固定为<code>0b1001</code>，低 3
位<strong>A2</strong>，<strong>A1</strong>，<strong>A0</strong>全部接<strong>GND</strong>取值为<code>0b000</code>）
1 位代表读写方向，具体如下图所示：</p>
<p><img src="/Embedded/STC89C52/AD-DA/address-byte.png"></p>
<p>单片机通过 I²C 总线发送到<strong>PCF8591</strong>的第 2
个字节用于控制 PCF8591 的各种功能，其中第 0 和第 1
位是通道选择位，<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>分别代表从
0 到 3 共四个通道的选择；第 2
位是自动增量控制位，自动增量是指：假如当前一共有 4 个通道，读取完通道 0
以后下次会自动读取通道 1，由于 A/D
每次读到的数据都是前一次的转换结果，所以使用自动增量时需要注意，当前读取的实质是上一通道的值（出于程序通用性的考量，后续实验代码未启用该功能）；第
3 和第 7 位固定为<code>0</code>；第 6 位为 DA
使能位，该位置<code>1</code>表示<strong>DA</strong>输出引脚使能，启动模拟电压的输出；第
4 和第 5 位用于将 PCF8591
的四路模拟输入配置为<strong>单端模式</strong>和<strong>差分模式</strong>；具体请参考如下示意图：</p>
<p><img src="/Embedded/STC89C52/AD-DA/control-byte.png"></p>
<p>单片机通过 I²C 总线发送到<strong>PCF8591</strong>的第 3 个字节表示
D/A 模拟输出的电压值，如果仅使用 A/D 功能可以不发送该字节。</p>
<p>接下来着手编写一个实验程序，将模拟输入通道<strong>AIN0</strong>、<strong>AIN1</strong>、<strong>AIN3</strong>测得的电压值显示到
1602
液晶，当转动实验电路中的电位器时，<strong>AIN0</strong>的值会发生改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，此处省略 I2C.c 与 Lcd1602.c 文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bit flag300ms = <span class="number">1</span>;      <span class="comment">// 定时标志位 500ms</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">GetADCValue</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> chn)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ValueToString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> val)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadACK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2CReadNAK</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitLcd1602</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LcdShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> val;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>;                               <span class="comment">// 开总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">10</span>);                     <span class="comment">// 配置定时器 T0 定时 10ms</span></span><br><span class="line">  InitLcd1602();                        <span class="comment">// 初始化液晶</span></span><br><span class="line">  LcdShowStr(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;AIN0  AIN1  AIN3&quot;</span>); <span class="comment">// 显示通道指示</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag300ms) &#123;</span><br><span class="line">      flag300ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 显示通道 0 的电压 */</span></span><br><span class="line">      val = GetADCValue(<span class="number">0</span>);             <span class="comment">// 获取 ADC 通道 0 的转换值</span></span><br><span class="line">      ValueToString(str, val);          <span class="comment">// 转为字符串格式</span></span><br><span class="line">      LcdShowStr(<span class="number">0</span>, <span class="number">1</span>, str);            <span class="comment">// 显示到 1602 液晶</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 显示通道 1 的电压 */</span></span><br><span class="line">      val = GetADCValue(<span class="number">1</span>);</span><br><span class="line">      ValueToString(str, val);</span><br><span class="line">      LcdShowStr(<span class="number">6</span>, <span class="number">1</span>, str);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 显示通道 3 的电压 */</span></span><br><span class="line">      val = GetADCValue(<span class="number">3</span>);</span><br><span class="line">      ValueToString(str, val);</span><br><span class="line">      LcdShowStr(<span class="number">12</span>, <span class="number">1</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取当前的ADC转换值，参数 chn 表示 ADC 的 0~3 通道号 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">GetADCValue</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> chn)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> val;</span><br><span class="line">  I2CStart();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 寻址 PCF8591 设备，如果没有应答，则停止操作并返回 0 */</span></span><br><span class="line">  <span class="keyword">if</span> (!I2CWrite(<span class="number">0x48</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">    I2CStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  I2CWrite(<span class="number">0x40</span> | chn);                 <span class="comment">// 写入控制字节，选择转换通道</span></span><br><span class="line">  I2CStart();</span><br><span class="line">  I2CWrite((<span class="number">0x48</span> &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>);         <span class="comment">// 寻址 PCF8591 设备，指定后续为读操作</span></span><br><span class="line">  I2CReadACK();                         <span class="comment">// 空读 1 个字节，提供采样转换时间</span></span><br><span class="line">  val = I2CReadNAK();                   <span class="comment">// 读取刚刚转换完的值</span></span><br><span class="line">  I2CStop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 ADC 转换值转为实际电压的字符串形式，参数 str 为字符串指针，参数 val 是 AD 转换值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ValueToString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">  <span class="comment">/* 电压值=转换结果*2.5V/255，式中的25隐含了一位十进制小数 */</span></span><br><span class="line">  val = (val * <span class="number">25</span>) / <span class="number">255</span>;</span><br><span class="line">  str[<span class="number">0</span>] = (val / <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;            <span class="comment">// 整数位字符</span></span><br><span class="line">  str[<span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>;                         <span class="comment">// 小数点</span></span><br><span class="line">  str[<span class="number">2</span>] = (val % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;            <span class="comment">// 小数位字符</span></span><br><span class="line">  str[<span class="number">3</span>] = <span class="string">&#x27;V&#x27;</span>;                         <span class="comment">// 电压单位</span></span><br><span class="line">  str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;                        <span class="comment">// 结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时器 T0 的定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                    <span class="comment">// 声明临时变量</span></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;                  <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;              <span class="comment">// 计算所需计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                    <span class="comment">// 计算定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">12</span>;                       <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时值拆分为高低字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                         <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                         <span class="comment">// 设置置定时器 T0 为工作模式 1</span></span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL;                           <span class="comment">// 设置定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                              <span class="comment">// 定时器 T0 中断使能</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                              <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于进行 300ms 的定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> tmr300ms = <span class="number">0</span>;</span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;               <span class="comment">// 重新设置定时值</span></span><br><span class="line">  tmr300ms++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定时 300ms 时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (tmr300ms &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    tmr300ms = <span class="number">0</span>;</span><br><span class="line">    flag300ms = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序在进行 A/D 读取数据时，一共使用了两条语句去分别读取 2
个字节：<code>I2CReadACK();</code>、<code>val = I2CReadNAK();</code>，PCF8591
的转换时钟为 I²C 的<strong>SCL</strong>，8 个 SCL
周期完成一次转换，所以当前转换结果总是在下一字节的 8
个<strong>SCL</strong>上才能读取，因此第 1
条语句的作用是产生一个<strong>SCL</strong>时钟给 PCF8591 进行 A/D
转换，而第 2 次则是读取当前的转换结果。如果这里只使用第 2
条语句，每次读取到的都会是上次的转换结果。</p>
<h2 id="ad-差分输入信号">A/D 差分输入信号</h2>
<p><strong>差分输入</strong>是模拟电路当中的知识，严格意义上所有信号都是差分信号，因为所有的电压是相对于另一个电压而言，而多数单片机系统将电路上的<strong>GND</strong>作为基准点。对于
A/D 而言，差分输入通常是指除 GND 以外的 2
路幅度相同极性相反的输入信号。换而言之，差分输入是由 2 个输入端构成的 1
组输入，PCF8591 一共拥有 4 个模拟输入端，可以被配置为 4
种模式，比较典型的配置就是由 4 个输入端构成的 2 路差分模式：</p>
<p><img src="/Embedded/STC89C52/AD-DA/differential-signal.png"></p>
<p>当控制字节第 4、5 位都为<code>1</code>的时候，4 路模输入会被配置为 2
路差分模式输入<strong>channel 0</strong>和<strong>channel
1</strong>，这里以<strong>channel
0</strong>为例，其中<strong>AIN0</strong>是正向输入端，<strong>AIN1</strong>是反向输入端，它们之间的输入信号幅度相同极性相反，通过减法器以后，得到的是两个输入通道的差值：</p>
<p><img src="/Embedded/STC89C52/AD-DA/differential-signal-channels.png"></p>
<p>通常情况下，<strong>差分输入</strong>的中线是基准电压的一半，当前的基准电压为<code>2.5V</code>，如果以<code>1.25V</code>作为中线，<strong>V+</strong>就是<strong>AIN0</strong>的输入波形，<strong>V-</strong>就是<strong>AIN1</strong>的输入波形，上图中的<code>Signal Value</code>就是经过减法器之后的波形，由于差分输入相比单端输入具有更强的抗干扰能力，因此许多
A/D 都采用了差分方式输入。</p>
<p><strong>单端输入</strong>信号，如果一条数据线由于干扰发生了变化，例如幅度增大<code>5mv</code>而<strong>GND</strong>不变，那么测量到的数据就会存在偏差；而差分信号输入时，外界存在的干扰信号将同时被耦合到两条数据线上，幅度增大<code>5mv</code>时两者都会增大<code>5mv</code>，由于接收端只关心两个信号的差值，所以外界的这种共模噪声干扰能够被完全抵消掉。又由于两条信号线的极性相反，其对外辐射的电磁场可以得到相互抵消，进而也有效的抑制了辐射到外界的电磁能量。</p>
<h2 id="da-输出">D/A 输出</h2>
<p>D/A 和 A/D 的操作方向相反，一个 8 位
D/A，如果用<code>0 ~ 255</code>分别代表<code>0 ~ 2.55V</code>，那么如果单片机给第
3 个字节发送<code>100</code>，D/A
引脚就会输出一个<code>1V</code>电压，发送<code>200</code>就输出一个<code>2V</code>电压。下面编写一段实验程序实现这个功能，并且通过【上】、【下】按键调节输出幅度值的大小（增加或减小<code>0.1V</code>）。与此同时，可以使用万用表测量一下实验电路<strong>AOUT</strong>点上的输出电压，并且观察其变化。由于
PCF8591
的<strong>DA</strong>输出偏置误差最大为<code>50mv</code>，所以万用表测得的电压值与理论值误差也应在<code>50mV</code>以内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，此处 I2C.c、keyboard.c 文件省略 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>; <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;               <span class="comment">// 开启总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);      <span class="comment">// 配置定时器 T0 定时 1ms</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();        <span class="comment">// 按键驱动调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 DAC 输出值，参数 val 为设定值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDACOut</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">  I2CStart();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* PCF8591 寻址，如果没有应答，则停止操作并且返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (!I2CWrite(<span class="number">0x48</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">    I2CStop();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2CWrite(<span class="number">0x40</span>);       <span class="comment">// 写入控制字节</span></span><br><span class="line">  I2CWrite(val);        <span class="comment">// 写入 DA 的值</span></span><br><span class="line">  I2CStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应操作，参数 keycode 是按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> volt = <span class="number">0</span>;  <span class="comment">// 输出电压值，隐含有 1 位十进制小数位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果按下向上键，则增加 0.1V 电压 */</span></span><br><span class="line">  <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (volt &lt; <span class="number">25</span>) &#123;</span><br><span class="line">      volt++;</span><br><span class="line">      SetDACOut(volt * <span class="number">255</span> / <span class="number">25</span>); <span class="comment">// 转换为 AD 输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果按下向下键，则减小 0.1V 电压 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (volt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      volt--;</span><br><span class="line">      SetDACOut(volt * <span class="number">255</span> / <span class="number">25</span>); <span class="comment">// 转换为 AD 输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;       <span class="comment">// 临时变量</span></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;     <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>; <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;       <span class="comment">// 计算定时器定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">28</span>;          <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时器的定时值拆分为高、低字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;            <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;            <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;  <span class="comment">// 加载定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                 <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                 <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，执行按键扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH;</span><br><span class="line">  TL0 = T0RL; <span class="comment">// 重新加载定时值</span></span><br><span class="line">  KeyScan();  <span class="comment">// 按键扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号发生器实例">信号发生器实例</h2>
<p>D/A
不仅可以输出方波信号，也可以输出其它任意波形，例如正弦波、三角波、锯齿波等。以正弦波为例，首先建立一个正弦波的波表，这里可以根据时间参数选取其中的一些定量数据作为实验程序中的波表，这里一共选取了
32 个点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.c，此处 I2C.c、keyboard.c 文件省略 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正弦波表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SinWave[] = &#123; <span class="number">127</span>, <span class="number">152</span>, <span class="number">176</span>, <span class="number">198</span>, <span class="number">217</span>, <span class="number">233</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">255</span>, <span class="number">252</span>, <span class="number">245</span>, <span class="number">233</span>, <span class="number">217</span>, <span class="number">198</span>, <span class="number">176</span>, <span class="number">152</span>, <span class="number">127</span>, <span class="number">102</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">37</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">102</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 三角波表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code TriWave[] = &#123; <span class="number">0</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">255</span>, <span class="number">240</span>, <span class="number">224</span>, <span class="number">208</span>, <span class="number">192</span>, <span class="number">176</span>, <span class="number">160</span>, <span class="number">144</span>, <span class="number">128</span>, <span class="number">112</span>, <span class="number">96</span>, <span class="number">80</span>, <span class="number">64</span>, <span class="number">48</span>, <span class="number">32</span>, <span class="number">16</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 锯齿波表 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SawWave[] = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">56</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">88</span>, <span class="number">96</span>, <span class="number">104</span>, <span class="number">112</span>, <span class="number">120</span>, <span class="number">128</span>, <span class="number">136</span>, <span class="number">144</span>, <span class="number">152</span>, <span class="number">160</span>, <span class="number">168</span>, <span class="number">176</span>, <span class="number">184</span>, <span class="number">192</span>, <span class="number">200</span>, <span class="number">208</span>, <span class="number">216</span>, <span class="number">224</span>, <span class="number">232</span>, <span class="number">240</span>, <span class="number">248</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code *pWave; <span class="comment">// 波表指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RH = <span class="number">0</span>;    <span class="comment">// 定时器 T0 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T0RL = <span class="number">0</span>;    <span class="comment">// 定时器 T0 定时值低字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T1RH = <span class="number">1</span>;    <span class="comment">// 定时器 T1 定时值高字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> T1RL = <span class="number">1</span>;    <span class="comment">// 定时器 T1 定时值低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetWaveFreq</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> freq)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyDriver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStart</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">I2CStop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> bit <span class="title function_">I2CWrite</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  EA = <span class="number">1</span>;                  <span class="comment">// 开启总中断</span></span><br><span class="line">  ConfigTimer0(<span class="number">1</span>);         <span class="comment">// 配置定时器 T0 定时 1ms</span></span><br><span class="line">  pWave = SinWave;         <span class="comment">// 默认为正弦波</span></span><br><span class="line">  SetWaveFreq(<span class="number">10</span>);         <span class="comment">// 默认频率为 10Hz</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    KeyDriver();           <span class="comment">// 调用按键驱动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应操作，参数 keycode 是按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyAction</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> keycode)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 按下向上键，用于切换波形 */</span></span><br><span class="line">  <span class="keyword">if</span> (keycode == <span class="number">0x26</span>) &#123;</span><br><span class="line">    <span class="comment">/* 在 3 种波形间循环切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      i = <span class="number">1</span>;</span><br><span class="line">      pWave = TriWave;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      i = <span class="number">2</span>;</span><br><span class="line">      pWave = SawWave;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      pWave = SinWave;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 DAC 输出值，参数 val 为设定值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDACOut</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">  I2CStart();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* PCF8591 设备寻址，如果没有应答，则停止操作并且返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (!I2CWrite(<span class="number">0x48</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">    I2CStop();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I2CWrite(<span class="number">0x40</span>);           <span class="comment">// 写入控制字节</span></span><br><span class="line">  I2CWrite(val);            <span class="comment">// 写入 DA 值</span></span><br><span class="line">  I2CStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置输出波形的频率，参数 freq 为设定的频率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetWaveFreq</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> freq)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">  tmp = (<span class="number">11059200</span> / <span class="number">12</span>) / (freq * <span class="number">32</span>); <span class="comment">// 定时器计数频率为波形频率的 32 倍</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                   <span class="comment">// 计算定时器的定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">36</span>;                      <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时器的定时值拆分为高、低字节 */</span></span><br><span class="line">  T1RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T1RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0x0F</span>;                        <span class="comment">// 清零定时器 T1 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x10</span>;                        <span class="comment">// 配置定时器 T1 为模式 1</span></span><br><span class="line">  TH1 = T1RH; TL1 = T1RL;              <span class="comment">// 加载定时器 T1 定时值</span></span><br><span class="line">  ET1 = <span class="number">1</span>;                             <span class="comment">// 使能定时器 T1 中断</span></span><br><span class="line">  PT1 = <span class="number">1</span>;                             <span class="comment">// 设置为高优先级</span></span><br><span class="line">  TR1 = <span class="number">1</span>;                             <span class="comment">// 启动定时器 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动定时器 T0，参数 ms 是定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tmp;                   <span class="comment">// 临时变量</span></span><br><span class="line">  tmp = <span class="number">11059200</span> / <span class="number">12</span>;                 <span class="comment">// 定时器计数频率</span></span><br><span class="line">  tmp = (tmp * ms) / <span class="number">1000</span>;             <span class="comment">// 计算所需的计数值</span></span><br><span class="line">  tmp = <span class="number">65536</span> - tmp;                   <span class="comment">// 计算定时器定时值</span></span><br><span class="line">  tmp = tmp + <span class="number">28</span>;                      <span class="comment">// 补偿中断响应延时造成的误差</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将定时器的定时值拆分为高、低字节 */</span></span><br><span class="line">  T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line"></span><br><span class="line">  TMOD &amp;= <span class="number">0xF0</span>;                        <span class="comment">// 清零定时器 T0 控制位</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;                        <span class="comment">// 配置定时器 T0 为模式 1</span></span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;              <span class="comment">// 加载定时器 T0 定时值</span></span><br><span class="line">  ET0 = <span class="number">1</span>;                             <span class="comment">// 使能定时器 T0 中断</span></span><br><span class="line">  TR0 = <span class="number">1</span>;                             <span class="comment">// 启动定时器 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T0 中断服务函数，用于执行按键扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">  TH0 = T0RH; TL0 = T0RL;              <span class="comment">// 重新加载定时值</span></span><br><span class="line">  KeyScan();                           <span class="comment">// 调用按键扫描函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 T1 中断服务函数，用于执行波形的输出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer1</span><span class="params">()</span> interrupt 3 &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  TH1 = T1RH; TL1 = T1RL;              <span class="comment">// 重新加载定时值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环输出波表数据 */</span></span><br><span class="line">  SetDACOut(pWave[i]);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序可以通过【向上】按键实现波形输出的切换，波形输出的刷新由定时器
T1 来完成，修改定时器 T1 的定时周期就可以改变波形的输出频率，D/A
信号的输出无法直接显示到屏幕，下面采用示波器抓取波形来进行展示：</p>
<p><img src="/Embedded/STC89C52/AD-DA/waveforms.png"></p>
<blockquote>
<p>上图波形上的许多小锯齿，并未平滑的连接起来，这是因为当前 DA
最大只能输出<code>0 ~ Vref</code>之间的 256
个离散电压值，而非一串连续的数值，所以每个离散值都会持续一定时间，然后跳变到下一个离散值，于是乎波形上就呈现出了这样的锯齿。实际开发当中，可以在
DA
电路后级添加<strong>低通滤波电路</strong>，就可以平滑带有锯齿的波形。</p>
</blockquote>
</div><div class="article-licensing box"><div class="licensing-title"><p>宏晶 STC89C52RC 微控制器实践小书</p><p><a href="http://www.uinio.com/Embedded/STC89C52/">http://www.uinio.com/Embedded/STC89C52/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2013-06-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2014-12-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Web/Angularjs/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">AngularJS 1.6.x 最佳实践总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Electronics/LDO/"><span class="level-item">常见 LDO 线性稳压芯片的对比选型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#stc89c52rc-简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">STC89C52RC 简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#电源"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">电源</span></span></a></li><li><a class="level is-mobile" href="#晶振"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">晶振</span></span></a></li><li><a class="level is-mobile" href="#复位电路"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">复位电路</span></span></a></li></ul></li><li><a class="level is-mobile" href="#配置-keil-uvision-5"><span class="level-left"><span class="level-item">2</span><span class="level-item">配置 Keil uVision 5</span></span></a></li><li><a class="level is-mobile" href="#发光二极管-led"><span class="level-left"><span class="level-item">3</span><span class="level-item">发光二极管 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#电源开关指示-led"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">电源/开关指示 LED</span></span></a></li><li><a class="level is-mobile" href="#数字电路中三极管的应用"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">数字电路中三极管的应用</span></span></a></li><li><a class="level is-mobile" href="#hc245-双向缓冲器"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">74HC245 双向缓冲器</span></span></a></li><li><a class="level is-mobile" href="#hc138-三八译码器"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">74HC138 三八译码器</span></span></a></li><li><a class="level is-mobile" href="#led-闪烁实验"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">LED 闪烁实验</span></span></a></li><li><a class="level is-mobile" href="#软件延时"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">软件延时</span></span></a></li><li><a class="level is-mobile" href="#led-流水灯实验"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">LED 流水灯实验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#静态数码管-定时器"><span class="level-left"><span class="level-item">4</span><span class="level-item">静态数码管 &amp; 定时器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定时器概念"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">定时器概念</span></span></a></li><li><a class="level is-mobile" href="#定时器应用"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">定时器应用</span></span></a></li><li><a class="level is-mobile" href="#静态数码管显示"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">静态数码管显示</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态数码管-中断"><span class="level-left"><span class="level-item">5</span><span class="level-item">动态数码管 &amp; 中断</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数码管显示残影与抖动"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">数码管显示残影与抖动</span></span></a></li><li><a class="level is-mobile" href="#中断机制"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">中断机制</span></span></a></li><li><a class="level is-mobile" href="#中断优先级与中断嵌套"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">中断优先级与中断嵌套</span></span></a></li></ul></li><li><a class="level is-mobile" href="#led-点阵"><span class="level-left"><span class="level-item">6</span><span class="level-item">LED 点阵</span></span></a></li><li><a class="level is-mobile" href="#独立按键"><span class="level-left"><span class="level-item">7</span><span class="level-item">独立按键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按键消抖"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">按键消抖</span></span></a></li></ul></li><li><a class="level is-mobile" href="#矩阵键盘"><span class="level-left"><span class="level-item">8</span><span class="level-item">矩阵键盘</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加法计算器试验"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">加法计算器试验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#步进电机"><span class="level-left"><span class="level-item">9</span><span class="level-item">步进电机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按键控制步进电机实验"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">按键控制步进电机实验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#蜂鸣器"><span class="level-left"><span class="level-item">10</span><span class="level-item">蜂鸣器</span></span></a></li><li><a class="level is-mobile" href="#高精度数字秒表"><span class="level-left"><span class="level-item">11</span><span class="level-item">高精度数字秒表</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定时器中断的精度补偿"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">定时器中断的精度补偿</span></span></a></li><li><a class="level is-mobile" href="#不可位寻址寄存器的位操作"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">不可位寻址寄存器的位操作</span></span></a></li><li><a class="level is-mobile" href="#改进数码管扫描函数"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">改进数码管扫描函数</span></span></a></li><li><a class="level is-mobile" href="#编写秒表实验程序"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">编写秒表实验程序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#脉冲宽度调制-pwm"><span class="level-left"><span class="level-item">12</span><span class="level-item">脉冲宽度调制 PWM</span></span></a></li><li><a class="level is-mobile" href="#ram-与长短按键"><span class="level-left"><span class="level-item">13</span><span class="level-item">RAM 与长短按键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数据存储空间-ram-的划分"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">数据存储空间 RAM 的划分</span></span></a></li><li><a class="level is-mobile" href="#长短按键试验"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">长短按键试验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#串行通信-uart-与-rs232"><span class="level-left"><span class="level-item">14</span><span class="level-item">串行通信 UART 与 RS232</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#rs232-标准接口"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">RS232 标准接口</span></span></a></li><li><a class="level is-mobile" href="#uart-串口行通信实验"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">UART 串口行通信实验</span></span></a></li><li><a class="level is-mobile" href="#ascii-编码的串行传输"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">ASCII 编码的串行传输</span></span></a></li></ul></li><li><a class="level is-mobile" href="#rs485-与-modbus-协议"><span class="level-left"><span class="level-item">15</span><span class="level-item">RS485 与 Modbus 协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#modbus-通信协议"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">Modbus 通信协议</span></span></a></li><li><a class="level is-mobile" href="#modbus-多机通信示例"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">Modbus 多机通信示例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#液晶"><span class="level-left"><span class="level-item">16</span><span class="level-item">1602 液晶</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#操作时序"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">操作时序</span></span></a></li><li><a class="level is-mobile" href="#设置指令"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">设置指令</span></span></a></li><li><a class="level is-mobile" href="#简单实例"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">简单实例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#通信时序"><span class="level-left"><span class="level-item">17</span><span class="level-item">通信时序</span></span></a></li><li><a class="level is-mobile" href="#液晶综合实验"><span class="level-left"><span class="level-item">18</span><span class="level-item">1602 液晶综合实验</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符串移动显示"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">字符串移动显示</span></span></a></li><li><a class="level is-mobile" href="#基于按键与液晶的计算器"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">基于按键与液晶的计算器</span></span></a></li><li><a class="level is-mobile" href="#液晶与串口通信综合试验"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">1602 液晶与串口通信综合试验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#i²c-总线"><span class="level-left"><span class="level-item">19</span><span class="level-item">I²C 总线</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#i²c-时序"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">I²C 时序</span></span></a></li><li><a class="level is-mobile" href="#i²c-寻址模式"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">I²C 寻址模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#eeprom-24c02"><span class="level-left"><span class="level-item">20</span><span class="level-item">EEPROM 24C02</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#eeprom-单字节读写时序"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">EEPROM 单字节读写时序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#eeprom-写数据流程"><span class="level-left"><span class="level-item">20.1.1</span><span class="level-item">EEPROM 写数据流程</span></span></a></li><li><a class="level is-mobile" href="#eeprom-读数据流程"><span class="level-left"><span class="level-item">20.1.2</span><span class="level-item">EEPROM 读数据流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#eeprom-多字节读写时序"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">EEPROM 多字节读写时序</span></span></a></li><li><a class="level is-mobile" href="#eeprom-的页写入"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">EEPROM 的页写入</span></span></a></li><li><a class="level is-mobile" href="#i²c-和-eeprom-综合实验"><span class="level-left"><span class="level-item">20.4</span><span class="level-item">I²C 和 EEPROM 综合实验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#spi-总线"><span class="level-left"><span class="level-item">21</span><span class="level-item">SPI 总线</span></span></a></li><li><a class="level is-mobile" href="#实时时钟-ds1302"><span class="level-left"><span class="level-item">22</span><span class="level-item">实时时钟 DS1302</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ds1302-寄存器介绍"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">DS1302 寄存器介绍</span></span></a></li><li><a class="level is-mobile" href="#ds1302-通信时序介绍"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">DS1302 通信时序介绍</span></span></a></li><li><a class="level is-mobile" href="#ds1302-突发模式"><span class="level-left"><span class="level-item">22.3</span><span class="level-item">DS1302 突发模式</span></span></a></li><li><a class="level is-mobile" href="#电子时钟实例"><span class="level-left"><span class="level-item">22.4</span><span class="level-item">电子时钟实例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#红外通信与-nec-协议"><span class="level-left"><span class="level-item">23</span><span class="level-item">红外通信与 NEC 协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#红外遥控通信原理"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">红外遥控通信原理</span></span></a></li><li><a class="level is-mobile" href="#nec-红外通信协议"><span class="level-left"><span class="level-item">23.2</span><span class="level-item">NEC 红外通信协议</span></span></a></li></ul></li><li><a class="level is-mobile" href="#温度传感器-ds18b20"><span class="level-left"><span class="level-item">24</span><span class="level-item">温度传感器 DS18B20</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#初始化"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">初始化</span></span></a></li><li><a class="level is-mobile" href="#rom-操作指令"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">ROM 操作指令</span></span></a></li><li><a class="level is-mobile" href="#ram-存储器操作指令"><span class="level-left"><span class="level-item">24.3</span><span class="level-item">RAM 存储器操作指令</span></span></a></li><li><a class="level is-mobile" href="#ds18b20-位读写时序"><span class="level-left"><span class="level-item">24.4</span><span class="level-item">DS18B20 位读写时序</span></span></a></li><li><a class="level is-mobile" href="#液晶温度显示实验"><span class="level-left"><span class="level-item">24.5</span><span class="level-item">1602 液晶温度显示实验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#模数-ad-数模-da"><span class="level-left"><span class="level-item">25</span><span class="level-item">模数 AD / 数模 DA</span></span></a></li><li><a class="level is-mobile" href="#pcf8591-数据采集"><span class="level-left"><span class="level-item">26</span><span class="level-item">PCF8591 数据采集</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ad-差分输入信号"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">A/D 差分输入信号</span></span></a></li><li><a class="level is-mobile" href="#da-输出"><span class="level-left"><span class="level-item">26.2</span><span class="level-item">D/A 输出</span></span></a></li><li><a class="level is-mobile" href="#信号发生器实例"><span class="level-left"><span class="level-item">26.3</span><span class="level-item">信号发生器实例</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/CAN/"><img src="/Electronics/Motor-PWM/logo.png" alt="控制器区域网络 CAN 总线协议图解"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-30T16:00:00.000Z">2025-05-01</time></p><p class="title"><a href="/Electronics/CAN/">控制器区域网络 CAN 总线协议图解</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Embedded/FOC/"><img src="/Embedded/FOC/logo.png" alt="剖析无刷电机的 FOC 磁场定向控制算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-14T16:00:00.000Z">2025-04-15</time></p><p class="title"><a href="/Embedded/FOC/">剖析无刷电机的 FOC 磁场定向控制算法</a></p><p class="categories"><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Power-Switching/"><img src="/Electronics/Power-Switching/logo.png" alt="开关电源 SMPS 基本原理 &amp; 拓扑结构剖析"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-05T16:00:00.000Z">2025-03-06</time></p><p class="title"><a href="/Electronics/Power-Switching/">开关电源 SMPS 基本原理 &amp; 拓扑结构剖析</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Embedded/PID/"><img src="/Embedded/PID/logo.png" alt="闭环控制算法 PID 的原理剖析与实现"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-02-04T16:00:00.000Z">2025-02-05</time></p><p class="title"><a href="/Embedded/PID/">闭环控制算法 PID 的原理剖析与实现</a></p><p class="categories"><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Motor-PWM/"><img src="/Electronics/Motor-PWM/logo.png" alt="直流无刷电机的 PWM 驱动控制原理简述"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-06T16:00:00.000Z">2024-11-07</time></p><p class="title"><a href="/Electronics/Motor-PWM/">直流无刷电机的 PWM 驱动控制原理简述</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BA%BF/"><span class="tag">总线</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>