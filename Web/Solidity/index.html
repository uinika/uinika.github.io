<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Solidity 是一款以由以太坊（ETH，Ethereum）开源社区推出的面向对象的静态程序设计语言，主要用于在 Web 3.0 世界创建智能合约，其语法特性受到了 C++、Python、JavaScript 等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的 Solidity 版本，从而获得安全修复以及各种新特"><meta property="og:type" content="blog"><meta property="og:title" content="基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0"><meta property="og:url" content="http://www.uinio.com/Web/Solidity/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="Solidity 是一款以由以太坊（ETH，Ethereum）开源社区推出的面向对象的静态程序设计语言，主要用于在 Web 3.0 世界创建智能合约，其语法特性受到了 C++、Python、JavaScript 等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的 Solidity 版本，从而获得安全修复以及各种新特"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2023-05-21T16:00:00.000Z"><meta property="article:modified_time" content="2025-06-25T14:55:36.790Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="Solidity"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Web/Solidity/"},"headline":"基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0","image":["http://www.uinio.com/Web/Solidity/logo.png"],"datePublished":"2023-05-21T16:00:00.000Z","dateModified":"2025-06-25T14:55:36.790Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"Solidity\r 是一款以由以太坊（ETH，Ethereum）开源社区推出的面向对象的静态程序设计语言，主要用于在\r Web 3.0 世界创建智能合约，其语法特性受到了\r C++、Python、JavaScript\r 等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的\r Solidity 版本，从而获得安全修复以及各种新特"}</script><link rel="canonical" href="http://www.uinio.com/Web/Solidity/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-21T16:00:00.000Z" title="2023/5/22 00:00:00">2023-05-22</time>发表</span><span class="level-item"><time dateTime="2025-06-25T14:55:36.790Z" title="2025/6/25 22:55:36">2025-06-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Web-%E5%BC%80%E5%8F%91/">Web 开发</a></span><span class="level-item">1 小时读完 (大约13096个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0</h1><div class="content"><p><a target="_blank" rel="noopener" href="https://docs.soliditylang.org"><strong>Solidity</strong></a>
是一款以由<strong>以太坊</strong>（<strong>ETH</strong>，Ethereum）开源社区推出的<strong>面向对象</strong>的<strong>静态</strong>程序设计语言，主要用于在
<strong>Web 3.0</strong> 世界创建智能合约，其语法特性受到了
C++、Python、JavaScript
等编程语言的影响。支持继承、库、复杂的用户自定义类型以及其它特性。官方推荐在生产环境撰写以太坊智能合约的时候，总是使用最新的
Solidity 版本，从而获得安全修复以及各种新特性，本篇文章撰写时 Solidity
最新的生产环境版本为 <code>v0.8.24</code>。</p>
<p><img src="/Web/Solidity/logo.png"></p>
<p>除了 Solidity 的各种常用语言特性之外，还会介绍一系列 Web 3.0
开发过程当中，所经常使用的第三方开源项目。其中 Hardhat
是一个用于编译、部署、测试、调试以太坊应用的开发环境，而 <a target="_blank" rel="noopener" href="https://trufflesuite.com/ganache/"><strong>Ganache</strong></a>
则是一款用于开发测试 <strong>dApps</strong>（Decentralized
Applications）的本地区块链应用。除此之外，<a target="_blank" rel="noopener" href="https://wizard.openzeppelin.com/"><strong>OpenZeppelin</strong></a>
的 <a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/5.x/"><strong>Contract</strong></a>
则是一款用于开发安全智能合约的库，提供有 <strong>ERC20</strong> 和
<strong>ERC721</strong>
的标准实现，以及灵活的的权限方案，乃至于各种常用的工具组件。</p>
<span id="more"></span>
<h2 id="web-3.0-简介">Web 3.0 简介</h2>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Web 3.0 术语</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>区块</strong></td>
<td style="text-align: left;"><strong>区块</strong>包含有大量捆绑的交易，以其作为最小单位在所有节点当中进行分发，如果两个交易相互矛盾，那么排在第二位的交易会被拒绝，不会成为区块的一部分。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>区块链</strong></td>
<td style="text-align: left;"><strong>区块链</strong>就是指<strong>区块</strong>按照<strong>时间</strong>形成的线性序列，区块每间隔一段时间就会被添加到链上面，其本质上就类似于一个公共的事务型数据库。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>以太坊虚拟机</strong></td>
<td style="text-align: left;"><strong>以太坊虚拟机</strong>（EVM，Ethereum
Virtual Machine）是以太坊智能合约的运行环境。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>以太坊账户</strong></td>
<td style="text-align: left;">以太坊账户主要分为两种：<strong>外部账户</strong>（由公私钥对控制，地址由公钥确定）、<strong>合约账户</strong>（由与账户一起存储的代码控制，地址在合约创建时被确定）。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>以太坊账户余额</strong></td>
<td style="text-align: left;">以太坊账户<strong>余额</strong>的最小单位是
<code>Wei</code>（<span class="math inline">\(1 ETH = 10^{18}
wei\)</span>）)，余额会因为发生以太币的交易而改变。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>交易</strong></td>
<td style="text-align: left;"><strong>交易</strong>可以视为帐户之间相互发送的消息，每笔交易都会消耗一定数量的
Gas（由交易的发起人支付）。</td>
</tr>
</tbody>
</table>
<h2 id="构建-hardhat-环境">构建 Hardhat 环境</h2>
<h3 id="npm-安装-hardhat">npm 安装 Hardhat</h3>
<p><a target="_blank" rel="noopener" href="https://hardhat.org/docs"><strong>Hardhat</strong></a>
是一款编译、部署、测试和调试以太坊应用的开发工具，可以用于实现智能合约与
dApps 开发过程当中的自动化任务，但是 Hardhat
最核心的地方依然是编译、运行、测试智能合约。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Hardhat 需要运行在 <a target="_blank" rel="noopener" href="https://nodejs.org/en">NodeJS</a> 基础之上，所以在安装 Hardhat
之前需要先行安装 NodeJS，并且将安装目录填写至 <code>PATH</code>
环境变量当中。</p>
</blockquote>
<p>通过上面的语句，可以在一个 npm 工程当中快速的安装
Hardhat，然后在工程目录里执行
<code>npx hardhat</code>，就可以快速查看当前可用的<strong>命令</strong>与<strong>任务</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat</span><br><span class="line"></span><br><span class="line">Hardhat version 2.20.1</span><br><span class="line"></span><br><span class="line">Usage: hardhat [GLOBAL OPTIONS] [SCOPE] &lt;TASK&gt; [TASK OPTIONS]</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line"></span><br><span class="line">  --config              A Hardhat config file.</span><br><span class="line">  --emoji               Use emoji <span class="keyword">in</span> messages.</span><br><span class="line">  --flamegraph          Generate a flamegraph of your Hardhat tasks</span><br><span class="line">  --<span class="built_in">help</span>                Shows this message, or a task<span class="string">&#x27;s help if its name is provided</span></span><br><span class="line"><span class="string">  --max-memory          The maximum amount of memory that Hardhat can use.</span></span><br><span class="line"><span class="string">  --network             The network to connect to.</span></span><br><span class="line"><span class="string">  --show-stack-traces   Show stack traces (always enabled on CI servers).</span></span><br><span class="line"><span class="string">  --tsconfig            A TypeScript config file.</span></span><br><span class="line"><span class="string">  --typecheck           Enable TypeScript type-checking of your scripts/tests</span></span><br><span class="line"><span class="string">  --verbose             Enables Hardhat verbose logging</span></span><br><span class="line"><span class="string">  --version             Shows hardhat&#x27;</span>s version.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVAILABLE TASKS:</span><br><span class="line"></span><br><span class="line">  check                 Check whatever you need</span><br><span class="line">  clean                 Clears the cache and deletes all artifacts</span><br><span class="line">  compile               Compiles the entire project, building all artifacts</span><br><span class="line">  console               Opens a hardhat console</span><br><span class="line">  coverage              Generates a code coverage report <span class="keyword">for</span> tests</span><br><span class="line">  flatten               Flattens and prints contracts and their dependencies. If no file is passed, all the contracts <span class="keyword">in</span> the project will be flattened.</span><br><span class="line">  gas-reporter:merge</span><br><span class="line">  <span class="built_in">help</span>                  Prints this message</span><br><span class="line">  node                  Starts a JSON-RPC server on top of Hardhat Network</span><br><span class="line">  run                   Runs a user-defined script after compiling the project</span><br><span class="line">  <span class="built_in">test</span>                  Runs mocha tests</span><br><span class="line">  typechain             Generate Typechain typings <span class="keyword">for</span> compiled contracts</span><br><span class="line">  verify                Verifies a contract on Etherscan or Sourcify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVAILABLE TASK SCOPES:</span><br><span class="line"></span><br><span class="line">  vars                  Manage your configuration variables</span><br><span class="line"></span><br><span class="line">To get <span class="built_in">help</span> <span class="keyword">for</span> a specific task run: npx hardhat <span class="built_in">help</span> [SCOPE] &lt;TASK&gt;</span><br></pre></td></tr></table></figure>
<h3 id="初始化-hardhat-工程">初始化 Hardhat 工程</h3>
<p>通过运行 <code>npx hardhat init</code> 可以初始化出一个基本的 Hardhat
工程目录结构：</p>
<ul>
<li><code>contracts</code> 目录：用于存放 <code>.sol</code>
智能合约</li>
<li><code>scripts</code> 目录：用于存放任务脚本。</li>
<li><code>test</code> 目录：用于存放测试文件。</li>
<li><code>hardhat.config.js</code> 文件：Hardhat 配置文件。</li>
</ul>
<h3 id="编译智能合约">编译智能合约</h3>
<p>在工程目录运行 <code>npx hardhat compile</code> 命令，可以编译
<code>contracts</code> 目录下的智能合约（例如该工程当中的
<code>contracts/Lock.sol</code> 文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat compile</span><br><span class="line"></span><br><span class="line">Downloading compiler 0.8.24</span><br><span class="line">Compiled 1 Solidity file successfully (evm target: paris).</span><br></pre></td></tr></table></figure>
<h3 id="测试智能合约">测试智能合约</h3>
<p>然后再运行 <code>npx hardhat test</code> 命令，可以执行
<code>contracts</code> 目录下的测试脚本文件（例如本工程当中的
<code>test/Lock.js</code> 文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">  Lock</span><br><span class="line">    Deployment</span><br><span class="line">      √ Should <span class="built_in">set</span> the right unlockTime (11217ms)</span><br><span class="line">      √ Should <span class="built_in">set</span> the right owner</span><br><span class="line">      √ Should receive and store the funds to lock</span><br><span class="line">      √ Should fail <span class="keyword">if</span> the unlockTime is not <span class="keyword">in</span> the future (141ms)</span><br><span class="line">    Withdrawals</span><br><span class="line">      Validations</span><br><span class="line">        √ Should revert with the right error <span class="keyword">if</span> called too soon</span><br><span class="line">        √ Should revert with the right error <span class="keyword">if</span> called from another account (39ms)</span><br><span class="line">        √ Shouldn<span class="string">&#x27;t fail if the unlockTime has arrived and the owner calls it (42ms)</span></span><br><span class="line"><span class="string">      Events</span></span><br><span class="line"><span class="string">        √ Should emit an event on withdrawals</span></span><br><span class="line"><span class="string">      Transfers</span></span><br><span class="line"><span class="string">        √ Should transfer the funds to the owner (88ms)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  9 passing (12s)</span></span><br></pre></td></tr></table></figure>
<h3 id="部署智能合约">部署智能合约</h3>
<p>继续运行 <code>npx hardhat run scripts/deploy.js</code>
命令，就可以执行 <code>scripts</code> 目录下的 Hardhat
任务脚本（例如本工程当中的 <code>scripts/deploy.js</code> 文件），此时
Hardhat 会将智能合约部署到执行命令时，自动启动的 Hardhat Network
本地测试网络服务当中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat run scripts/deploy.js</span><br><span class="line"></span><br><span class="line">Lock with 0.001ETH and unlock timestamp 1708929986 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br></pre></td></tr></table></figure>
<h3 id="启动-hardhat-network">启动 Hardhat Network</h3>
<p>除此之外，也可以通过手动运行 <code>npx hardhat node</code>
命令，启动该本地测试网络服务的同时，还会生成一系列测试用账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat node</span><br><span class="line"></span><br><span class="line">Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/</span><br><span class="line"></span><br><span class="line">Accounts</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">WARNING: These accounts, and their private keys, are publicly known.</span><br><span class="line">Any funds sent to them on Mainnet or any other live network WILL BE LOST.</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)</span></span><br><span class="line">Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000 ETH)</span></span><br><span class="line">Private Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#2: 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC (10000 ETH)</span></span><br><span class="line">Private Key: 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#3: 0x90F79bf6EB2c4f870365E785982E1f101E93b906 (10000 ETH)</span></span><br><span class="line">Private Key: 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#4: 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 (10000 ETH)</span></span><br><span class="line">Private Key: 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a</span><br><span class="line"></span><br><span class="line">Account <span class="comment">#5: 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc (10000 ETH)</span></span><br><span class="line">Private Key: 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba</span><br><span class="line"></span><br><span class="line">..... ..... ..... ..... ..... .....</span><br><span class="line">..... ..... ..... ..... ..... .....</span><br><span class="line"></span><br><span class="line">WARNING: These accounts, and their private keys, are publicly known.</span><br><span class="line">Any funds sent to them on Mainnet or any other live network WILL BE LOST.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Hardhat 内置的 Hardhat Network
是一个为开发而设计的<strong>本地以太坊网络</strong>。</p>
</blockquote>
<h3 id="连接-hardhat-network">连接 Hardhat Network</h3>
<p>通过 <code>npx hardhat node</code> 启动 Hardhat Network
本地测试网络服务之后，就会向外暴露一个 JSON-RPC 服务接口
<code>http://127.0.0.1:8545/</code>，把区块链钱包等应用连接至该接口就可以使用。此时如果需要将上面的
<code>Lock.sol</code>
智能合约，部署到上述这个已经启动了的测试网络，则需要再添加上一个
<code>--network localhost</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ npx hardhat run scripts/deploy.js --network localhost</span><br><span class="line"></span><br><span class="line">Lock with 0.001ETH and unlock timestamp 1708931638 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br></pre></td></tr></table></figure>
<h3 id="日志打印-console.log">日志打印 console.log()</h3>
<p>通过向 Hardhat 项目当中的 <code>.sol</code> 智能合约里引入
<code>console.sol</code>，就可以愉快的在项目当中使用
<code>console.log();</code> 日志打印方法，从而能够更加便捷的在 Hardhat
Network 控制台查看到智能合约打印的调试信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;hardhat/console.sol&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="引入以太坊-web3.js">引入以太坊 Web3.js</h2>
<p><a target="_blank" rel="noopener" href="https://docs.web3js.org/">web3.js</a>
是以太坊官方开源社区提供的一个 JavaScript 库，允许通过
HTTP、IPC、WebSocket 与本地或者远程的<strong>以太坊</strong> EVM
区块链节点进行各种交互，可以通过下面的命令将其安装在 Hardhat
工程当中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev web3</span><br></pre></td></tr></table></figure>
<p>除此之外，也可以通过在 Hardhat 项目当中安装插件的形式，将 Web3.js
无缝整合到到工程当中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-web3-v4</span><br></pre></td></tr></table></figure>
<p>通过在 <strong>Hardhat</strong> 当中编写 <code>script</code>
脚本，就可以借助 <strong>Web3.js</strong> 与 Hardhat
本地的测试网络进行交互，具体步骤请参考下面的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Web3</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;http://127.0.0.1:8545/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 本地 Hardhat 测试网络账户地址 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">TestAccounts</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC&quot;</span>,</span><br><span class="line">      <span class="attr">privateKey</span>: <span class="string">&quot;0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 查询区块链信息 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">BlockNumber</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getBlockNumber</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块号: &quot;</span>, <span class="title class_">BlockNumber</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Balance</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;指定账户地址的余额: &quot;</span>, <span class="title class_">Balance</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ChainId</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getChainId</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块链 ID: &quot;</span>, <span class="title class_">ChainId</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">TransactionCount</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getTransactionCount</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;指定账户的交易数量: &quot;</span>, <span class="title class_">TransactionCount</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">GasPrice</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getGasPrice</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前区块链网络的 Gas 价格: &quot;</span>, <span class="title class_">GasPrice</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 设置 Web3.js 本地钱包 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">WalletAccounts</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="property">wallet</span>.<span class="title function_">create</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;随机生成 3 个钱包账户: &quot;</span>, <span class="title class_">WalletAccounts</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">PrivateWalletAccount</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="property">wallet</span>.<span class="title function_">add</span>(<span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">privateKey</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通过私钥生成的钱包账户地址: &quot;</span>, <span class="title class_">PrivateWalletAccount</span>[<span class="number">0</span>].<span class="property">address</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;通过私钥生成的钱包账户私钥: &quot;</span>, <span class="title class_">PrivateWalletAccount</span>[<span class="number">0</span>].<span class="property">privateKey</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 向 Hardhat 测试网络发起交易 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">TX</span> = &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="title class_">TestAccounts</span>[<span class="number">1</span>].<span class="property">address</span>,</span><br><span class="line">    <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.000001&quot;</span>, <span class="string">&quot;ether&quot;</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> txReceipt = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(<span class="variable constant_">TX</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;转账交易哈希:&quot;</span>, txReceipt.<span class="property">transactionHash</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 智能合约 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlAddress</span> = <span class="string">&quot;0x322813Fd9A801c5507c9de605d63CEA4f2CE6c44&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlABI</span> = <span class="built_in">require</span>(<span class="string">&quot;../artifacts/contracts/TestAccessControl.sol/TestAccessControl.json&quot;</span>).<span class="property">abi</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">AccessControlContract</span> = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(<span class="title class_">AccessControlABI</span>, <span class="title class_">AccessControlAddress</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 读取智能合约方法的返回值 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ReturnValue</span> = <span class="keyword">await</span> <span class="title class_">AccessControlContract</span>.<span class="property">methods</span>.<span class="title function_">securedFunction</span>().<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;智能合约调用返回值 :&quot;</span>, <span class="title class_">ReturnValue</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** =============== 向智能合约方法写入参数 =============== */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ReceiptTX</span> = <span class="keyword">await</span> <span class="title class_">AccessControlContract</span>.<span class="property">methods</span>.<span class="title function_">addToRole</span>(<span class="title class_">TestAccounts</span>[<span class="number">1</span>].<span class="property">address</span>).<span class="title function_">send</span>(&#123; <span class="attr">from</span>: <span class="title class_">TestAccounts</span>[<span class="number">0</span>].<span class="property">address</span> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;智能合约调用交易哈希:&quot;</span>, <span class="title class_">ReceiptTX</span>.<span class="property">transactionHash</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  process.<span class="property">exitCode</span> = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="智能合约基本结构">智能合约基本结构</h2>
<p>Solidity 将 Web 3.0
当中的<strong>智能合约</strong>视为面向对象编程当中的<strong>类</strong>，每一份智能合约可以包含<code>状态变量</code>、<code>函数</code>、<code>函数修饰器</code>、<code>事件</code>、<code>错误</code>、<code>结构体类型</code>、<code>枚举类型</code>
的声明，并且智能合约之间也可以相互进行继承。</p>
<h3 id="许可标识-编译指示">许可标识 &amp; 编译指示</h3>
<ol type="1">
<li>第 1 行的 <code>// SPDX-License-Identifier: MIT</code> 称为 <a target="_blank" rel="noopener" href="https://spdx.org/licenses/"><strong>SPDX
许可标识符</strong></a>，用于声明当前 Solidity 源代码基于 MIT
开源协议编写。</li>
<li>第 2 行的 <code>pragma solidity &gt;=0.8.24 &lt;0.9.0;</code>
称为<strong>版本编译指示</strong>，用于声明当前代码所要使用的 Solidity
编译器版本（大于或等于 <code>0.8.24</code> 但是低于 <code>0.9.0</code>
的版本）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 智能合约内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：访问 Solidity
智能合约当中的状态变量（例如上面的 <code>data</code>
状态变量），通常不需要添加 <code>this</code>
关键字，通过变量名称就可以直接进行访问。</p>
</blockquote>
<h3 id="状态变量">状态变量</h3>
<p><strong>状态变量</strong>是指其值被永久地存储在合约存储中的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint data; <span class="comment">// 状态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p><strong>函数</strong> <code>function</code>
用于接受参数并且返回变量，即可以在智能合约 <code>contract</code>
的内部定义，也可以在智能合约的外部定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint data;  <span class="comment">// 声明一个无符号整型的状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置状态变量函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取状态变量函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数修饰器">函数修饰器</h3>
<p>函数<strong>修饰器</strong> <code>modifier</code>
可以用于以声明的方式修改函数的语义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address public user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义函数修饰器 */</span></span><br><span class="line">    modifier <span class="title function_">onlyUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.<span class="property">sender</span> == user,</span><br><span class="line">            <span class="string">&quot;Only user can invoke this.&quot;</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应用函数修饰器 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) public view onlyUser &#123;</span><br><span class="line">        <span class="comment">// ... ... ... ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：修饰器与函数一样也可以被<strong>重载</strong>。</p>
</blockquote>
<h3 id="事件">事件</h3>
<p><strong>事件</strong> <code>event</code>
可以用于方便的调用以太坊虚拟机 EVM 的日志功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    event <span class="title function_">myEvent</span>(address user, uint money);  <span class="comment">// 声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">triggerEvent</span>(<span class="params"></span>) public payable &#123;</span><br><span class="line">        emit <span class="title function_">myEvent</span>(msg.<span class="property">sender</span>, msg.<span class="property">value</span>);  <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体类型">结构体类型</h3>
<p><strong>结构体类型</strong> <code>struct</code>
是一种可以把多个具有关联关系的变量，组合在一起的自定义数据类型。当声明并且定义好一个结构体变量之后，就可以通过成员访问操作符
<code>.</code> 访问结构体的成员：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明结构体类型 */</span></span><br><span class="line">    struct <span class="title class_">Person</span> &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        bool isStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Person</span> public person; <span class="comment">// 定义结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化结构体成员 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        person = <span class="title class_">Person</span>(<span class="string">&quot;Hank&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 name 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getPersonName</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (string memory) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">name</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 age 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getPersonAge</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">age</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并且返回结构体的 isStudent 成员 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isPersonStudent</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (bool) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">isStudent</span>; <span class="comment">// 使用成员访问操作符(.)来访问结构体成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类型">枚举类型</h3>
<p>枚举可用来创建由一定数量的'常量值'构成的自定义类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyEnumContract</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明枚举类型 */</span></span><br><span class="line">    enum <span class="title class_">Color</span> &#123;</span><br><span class="line">        <span class="title class_">Red</span>,</span><br><span class="line">        <span class="title class_">Green</span>,</span><br><span class="line">        <span class="title class_">Blue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Color</span> public favoriteColor; <span class="comment">// 定义枚举类型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化枚举类型变量 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        favoriteColor = <span class="title class_">Color</span>.<span class="property">Blue</span>; <span class="comment">// 设置favoriteColor为Green</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回枚举类型变量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getFavoriteColor</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (<span class="title class_">Color</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> favoriteColor; <span class="comment">// 返回favoriteColor枚举变量的当前值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误">错误</h3>
<p><strong>错误</strong> <code>error</code>
可以用于为系统异常定义描述性的名称和信息，其 Gas
开销要比使用字符串更加便宜。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有足够的资金用于转账，需要的资金为 requested`，但是可用的只有 available */</span></span><br><span class="line">error <span class="title class_">NotEnough</span>(uint requested, uint available); <span class="comment">// 定义错误</span></span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address to, uint amount</span>) public &#123;</span><br><span class="line">        uint balance = balances[msg.<span class="property">sender</span>];</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amount)</span><br><span class="line">            revert <span class="title class_">NotEnough</span>(amount, balance); <span class="comment">// 回滚函数，并且抛出错误</span></span><br><span class="line">        <span class="comment">// ... ... ... ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释语句">注释语句</h2>
<p>Solidity 支持 C 语言风格的单行与多行注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一条       单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一条</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>除此之外，Solidity 还支持 NatSpec 风格的注释，也就是 <code>///</code>
和 <code>/** ... */</code>，主要用于函数声明和定义相关的语句上面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title 一个简单的状态变量存储示例</span></span><br><span class="line">contract <span class="title class_">SimpleStorage</span> &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 存储参数 x 的值</span></span><br><span class="line">    <span class="comment">/// @param 参数 x 指待存储的值</span></span><br><span class="line">    <span class="comment">/// @dev 将数字存储在状态变量 storedData 当中</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">uint x</span>) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取存储的状态变量</span></span><br><span class="line">    <span class="comment">/// @dev 获取状态变量 storedData 的值</span></span><br><span class="line">    <span class="comment">/// @return 状态变量存储的值</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint) &#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量作用域">变量作用域</h2>
<p>Solidity
当中的变量按照作用域可以划分为<strong>状态变量</strong>（State
Variable）、<strong>局部变量</strong>（Local
Variable）、<strong>全局变量</strong>（Global Variable）三种类型：</p>
<p><strong>状态变量</strong>是用于将数据保存在区块链上的变量，智能合约当中的函数都可以进行访问，所消耗的
Gas 比较高：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">  uint public x = <span class="number">1</span>;</span><br><span class="line">  uint public y = <span class="number">2</span>;</span><br><span class="line">  uint public z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>局部变量</strong>只在函数执行期间有效，存储在内存当中，不会上链，所消耗的
Gas 比较低：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) external pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 x = <span class="number">1</span>;</span><br><span class="line">        uint256 y = <span class="number">2</span>;</span><br><span class="line">        uint256 z = x + y;</span><br><span class="line">        <span class="keyword">return</span> (z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全局变量</strong>基本都是 Solidity
预留的关键字，可以在函数当中不声明直接进行使用，具体请叁考官方文档中的<a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">《单位和全局变量》</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">global</span>(<span class="params"></span>) external view <span class="title function_">returns</span>(<span class="params">address, uint, bytes memory</span>)&#123;</span><br><span class="line">        address mySender = msg.<span class="property">sender</span>;   <span class="comment">// 请求发起地址</span></span><br><span class="line">        uint256 myNumber = block.<span class="property">number</span>; <span class="comment">// 当前区块号</span></span><br><span class="line">        bytes memory myData = msg.<span class="property">data</span>;  <span class="comment">// 完整 calldata</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (mySender, myNumber, myData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量-constant">常量 constant</h2>
<p><strong>常量</strong> <code>constant</code>
必须在声明的同时进行初始化，后续不能再进行修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public constant year = <span class="number">2024</span>;</span><br><span class="line">    uint public constant month = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不变量-immutable">不变量 immutable</h2>
<p><strong>不变量</strong> <code>immutable</code>
可以在声明的时候，或者构造函数（非普通函数）当中进行初始化，使用起来将会更加便利。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public immutable year;</span><br><span class="line">    uint public immutable month = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        year = <span class="number">2024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件判断-循环控制">条件判断 &amp; 循环控制</h2>
<p>Solidity 同样提供有 <code>if else</code> 条件判断语句和
<code>for</code>、<code>while</code>、<code>do while</code>
循环控制语句，以及 <code>continue</code>、<code>break</code>
关键字和三元操作符。</p>
<h3 id="if-else-判断">if else 判断</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testIfElse</span>(<span class="params">uint256 number</span>) public pure <span class="title function_">returns</span> (bool) &#123;</span><br><span class="line">        <span class="comment">/* if else 判断 */</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-循环">for 循环</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testFor</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* for 循环 */</span></span><br><span class="line">        <span class="keyword">for</span> (uint256 index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-循环">while 循环</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testWhile</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line">        uint256 index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* while 循环 */</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-while-循环">do while 循环</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testDoWhile</span>(<span class="params"></span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 sum = <span class="number">0</span>;</span><br><span class="line">        uint256 index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* do while 循环 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum += index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (index &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元操作符">三元操作符</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">testTernaryOperator</span>(<span class="params">uint256 x, uint256 y</span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="comment">/* 三元操作符 */</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= y ? x : y;  <span class="comment">// 返回参数 x 和 y 的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数值类型-value-type">数值类型 Value Type</h2>
<p>对数值类型的变量进行赋值时候，直接传递的是数值本身。</p>
<h3 id="布尔类型-bool">布尔类型 bool</h3>
<p>Solidity 当中布尔类型 <code>bool</code> 可取的值只有
<code>true</code> 和 <code>false</code> 两个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bool truly = <span class="literal">true</span>;</span><br><span class="line">    bool falsely = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整型-intuint">整型 int/uint</h3>
<ul>
<li>关键字<code>int</code> 和 <code>uint</code>
分别表示<strong>有符号</strong>和<strong>无符号</strong>的整型变量（<code>uint</code>
和 <code>int</code> 本质上分别是 <code>uint256</code> 和
<code>int256</code> 的别名）。</li>
<li>关键字 <code>int8</code> 到 <code>int256</code> 以及
<code>uint8</code> 到 <code>uint256</code> 可以用于表示<strong>从 8 位到
256
位</strong>，以<strong>八位</strong>作为步长递增的<strong>有符号</strong>或者<strong>无符号</strong>整型变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    int intValue = <span class="number">2024</span>;</span><br><span class="line">    uint uintValue = <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line">    int8 int8Value = <span class="number">99</span>;</span><br><span class="line">    int32 int32Value = <span class="number">2024</span>;</span><br><span class="line">    int256 int256Value = <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line">    uint8   uint8Value = <span class="number">99</span>;</span><br><span class="line">    uint32  uint32Value = <span class="number">2024</span>;</span><br><span class="line">    uint256 uint256Value = <span class="number">2024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="地址类型-address">地址类型 address</h3>
<p>地址类型是 Solidity
提供的一种特殊数据类型，主要用于保存以太坊地址，并且拥有一系列的<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh/latest/units-and-global-variables.html#address-related">成员变量</a>：</p>
<ul>
<li><code>address</code>: 用于保存 20 字节的太坊地址，；</li>
<li><code>address payable</code>: 保存太坊地址的同时，还拥有额外的
<code>transfer()</code> 和 <code>send()</code> 方法；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address myAddress = <span class="number">0xd82b7E2f20C3FBAc76e74D1C8d8C6af8032bbEc0</span>;</span><br><span class="line">    address payable myPayableAddress = <span class="title function_">payable</span>(myAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述两种地址类型进行转换时，<code>address payable</code>
可以自动转换为 <code>address</code>，而 <code>address</code> 则需要通过
<code>payable(&lt;address&gt;)</code>，才能被强制转换为
<code>address payable</code>。</p>
</blockquote>
<h3 id="枚举类型-enum">枚举类型 enum</h3>
<p>枚举类型 <code>enum</code> 用于为从 <code>0</code> 开始计数的
<code>uint</code> 类型数据分配名称（最大不能超过
<code>256</code>），从而提高代码的可读性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    enum <span class="title class_">Cars</span> &#123;<span class="variable constant_">HAVAL</span>, <span class="variable constant_">GEELY</span>, <span class="variable constant_">CHERY</span>&#125;         <span class="comment">// 把 uint 类型的 0、1、2 表示为 HAVAL、GEELY、CHERY</span></span><br><span class="line">    <span class="title class_">Cars</span> public myFavoriteCar = <span class="title class_">Cars</span>.<span class="property">GEELY</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用类型-reference-type">引用类型 Reference Type</h2>
<p>对引用类型变量进行赋值的时候，实际上传递的是地址指针。</p>
<h3 id="数组">数组 [ ]</h3>
<p><strong>Solidity</strong>
的数组可以在声明时指定长度（<code>数组元素类型[长度]</code>），也可以动态调整长度（<code>数组元素类型[]</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    int[<span class="number">5</span>] intArray = [<span class="title function_">int</span>(<span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    uint[] uintArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint[] memory number = <span class="keyword">new</span> uint[](<span class="number">3</span>);</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1985</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2010</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">2024</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Solidity
判别数组元素类型的时候，总是会以<strong>第 1
个元素</strong>的数据类型作为判定依据。</p>
</blockquote>
<h3 id="定长字节数组-bytesx">定长字节数组 bytesX</h3>
<p>定长字节数组
<code>bytes1</code>、<code>bytes2</code>、<code>bytes3</code> ...
<code>bytes32</code> 用于表达从 <strong>1</strong> 至
<strong>32</strong> 长度的字节序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bytes1 one = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    bytes3 three = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    bytes5 five = <span class="string">&quot;uinio&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变长字节数组-bytesstring">变长字节数组 bytes/string</h3>
<p><strong>变长字节数组</strong> <code>bytes</code> 和<strong>变长 UTF-8
编码字符串</strong> <code>string</code> 本质上是一种特殊的数组。</p>
<ul>
<li><code>bytes</code> 类似于
<code>bytes1[]</code>，但是由于采用了紧打包，存储空间占用相对较少，更加节省
Gas 费用；</li>
<li><code>string</code> 与 <code>bytes</code>
相同，不过不允许通过长度或者索引来进行访问；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/* bytes1[] 类型 */</span></span><br><span class="line">    bytes1 one = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    bytes1[] bytes1Array = [one, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bytes 类型 */</span></span><br><span class="line">    bytes bytesArray = <span class="string">&quot;2024&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* string 类型 */</span></span><br><span class="line">    string test = <span class="string">&quot;Hello Hank!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<code>bytes</code> 和 <code>string</code>
类型都提供有一个 <code>concat()</code>
函数，用于连接两个字符串，该函数会分别返回 <code>bytes</code> 或
<code>string</code> 类型的 <code>memory</code> 存储位置数组。</p>
</blockquote>
<h3 id="结构体-struct">结构体 struct</h3>
<p>Solidity 可以通过<strong>结构体</strong> <code>struct</code>
来自定义数据类型，其中的元素既可以是<strong>数值类型</strong>，也可以是<strong>引用类型</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/* 声明 PCB 结构体 */</span></span><br><span class="line">    struct <span class="variable constant_">PCB</span>&#123;</span><br><span class="line">        uint256 width;   <span class="comment">// 长度</span></span><br><span class="line">        uint256 height;  <span class="comment">// 高度</span></span><br><span class="line">        uint256 layer;   <span class="comment">// 层数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">PCB</span> board = <span class="title function_">PCB</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">4</span>); <span class="comment">// 初始化 PCB 结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射类型-mapping">映射类型 mapping</h3>
<p>Solidity 的映射类型使用语法
<code>mapping(键类型 键名称 =&gt; 值类型 值名称)</code>，其中键和值的名称都可以被省略，映射的值只能在函数内进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MappingExampleWithNames</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances1;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(address user =&gt; uint balance) public balances2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Solidity 当中映射的存储位置必须为
<code>storage</code>，向映射新增键值对的语法为
<code>映射名称[键] = 值</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MappingExampleWithNames</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances1;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateBalances1</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        balances1[msg.<span class="property">sender</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(address user =&gt; uint balance) public balances2;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateBalances2</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        balances2[msg.<span class="property">sender</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存储位置">存储位置</h3>
<p>可以将引用类型的
<strong>数组</strong>、<strong>结构体</strong>、<strong>映射</strong>
存储位置，分别指定为
<code>storage</code>、<code>memory</code>、<code>calldata</code>，不同存储类型所耗费的
Gas 成本不同：</p>
<ul>
<li><code>storage</code>：智能合当中的<strong>状态变量</strong>都默认为
<code>storage</code> 类型，存储在链上面，消耗 Gas 较多。</li>
<li><code>memory</code>：函数当中的参数和临时变量都属于
<code>memory</code> 类型，主要存储在内存当中，不会上链，消耗 Gas
较少。</li>
<li><code>calldata</code>：类似于 memory
存储在内存且不会上链，区别在于存储位置的变量不能被修改，消耗 Gas
较少。</li>
</ul>
<h2 id="数据类型默认值">数据类型默认值</h2>
<p>不同于 JavaScript，在 Solidity 当中不存在 <code>未定义</code> 或者
<code>空</code>
值的概念，而且新声明的变量总是被指定为其所属数据类型的<strong>默认值</strong>。</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 12%">
<col style="width: 66%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">值类型</th>
<th style="text-align: left;">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>布尔类型</strong></td>
<td style="text-align: left;">boolean</td>
<td style="text-align: left;"><code>false</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>字符串类型</strong></td>
<td style="text-align: left;">string</td>
<td style="text-align: left;"><code>""</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>整型</strong></td>
<td style="text-align: left;">int</td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>无符号整型</strong></td>
<td style="text-align: left;">uint</td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>枚举类型</strong></td>
<td style="text-align: left;">enum</td>
<td style="text-align: left;"><code>首个元素</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>地址类型</strong></td>
<td style="text-align: left;">address</td>
<td style="text-align: left;"><code>0x0000000000000000000000000000000000000000</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>函数类型</strong></td>
<td style="text-align: left;">function</td>
<td style="text-align: left;"><code>空白函数</code></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 9%">
<col style="width: 78%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">名称</th>
<th style="text-align: left;">引用类型</th>
<th style="text-align: left;">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>映射</strong></td>
<td style="text-align: left;">mapping</td>
<td style="text-align: left;">所有元素都是其所属数据类型的默认值；</td>
</tr>
<tr>
<td style="text-align: left;"><strong>结构体</strong></td>
<td style="text-align: left;">struct</td>
<td style="text-align: left;">所有成员都是其所属数据类型的默认值；</td>
</tr>
<tr>
<td style="text-align: left;"><strong>数组</strong></td>
<td style="text-align: left;">array</td>
<td style="text-align: left;"><strong>动态数组</strong>默认为
<code>[]</code>，<strong>定长数组</strong>为元素所属数据类型的默认值；</td>
</tr>
</tbody>
</table>
<p>Solidity 提供了一个 <code>delete</code>
操作符，可以将指定的变换恢复为初始值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bool public boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) external &#123;</span><br><span class="line">        <span class="keyword">delete</span> boolean; <span class="comment">// 将 boolean 变换为默认值 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数类型-function">函数类型 function</h2>
<h3 id="函数的定义">函数的定义</h3>
<p>Solidity
当中的函数可以接收参数，并且返回相应的处理结果，其基本的定义形式为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名称(参数类型 _参数名称<span class="number">1</span>, 参数类型 _参数名称<span class="number">2</span>)  internal|external|public|private  pure|view|payable  <span class="title function_">returns</span>(<span class="params">返回值类型 返回值名称<span class="number">1</span>, 返回值类型 返回值名称<span class="number">2</span></span>)&#123;</span><br><span class="line"></span><br><span class="line">  返回值名称<span class="number">1</span> = _参数名称<span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">  返回值名称<span class="number">2</span> = _参数名称<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public result = <span class="title function_">add</span>(<span class="number">1</span>);  <span class="comment">// result = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a) &#123;</span><br><span class="line">        a = parameter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以显式的在 Solidity 当中使用 <code>return</code>
关键字返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名称(参数类型 _参数名称<span class="number">1</span>, 参数类型 _参数名称<span class="number">2</span>)  internal|external|public|private  pure|view|payable  <span class="title function_">returns</span>(<span class="params">返回值类型 返回值名称<span class="number">1</span>, 返回值类型 返回值名称<span class="number">2</span></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(返回值<span class="number">1</span>, 返回值<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint public result = <span class="title function_">add</span>(<span class="number">1</span>);  <span class="comment">// result = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a) &#123;</span><br><span class="line">        <span class="keyword">return</span> parameter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取返回值">读取返回值</h3>
<p>除此之外，Solidity
函数返回值的读取，可以采用解构的方式，一次性读取全部或者部分的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量类型 _变量名称<span class="number">1</span>;</span><br><span class="line">变量类型 _变量名称<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(_变量名称<span class="number">1</span>, _变量名称<span class="number">2</span>) = 函数名称() <span class="comment">// 读取所有返回值</span></span><br><span class="line">(_变量名称<span class="number">1</span>, ) = 函数名称()          <span class="comment">// 只读取部分返回值</span></span><br><span class="line">(, _变量名称<span class="number">2</span>) = 函数名称()          <span class="comment">// 只读取部分返回值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">uint parameter</span>) public pure <span class="title function_">returns</span> (uint a, uint b, uint c) &#123;</span><br><span class="line">        a = parameter + <span class="number">1</span>;</span><br><span class="line">        b = parameter + <span class="number">2</span>;</span><br><span class="line">        c = parameter + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params"></span>) public pure &#123;</span><br><span class="line">        uint resultA;</span><br><span class="line">        uint resultB;</span><br><span class="line">        uint resultC;</span><br><span class="line">        (resultA, resultB, resultC) = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态可变性-view-pure">状态可变性 view pure</h3>
<p>声明为 <code>view</code>
的函数，可以读取状态，但是不能修改状态，这里的<strong>状态</strong>是指：</p>
<ol type="1">
<li>修改状态变量；</li>
<li>产生事件；</li>
<li>创建其它智能合约；</li>
<li>使用了 <code>selfdestruct</code>；</li>
<li>通过调用发送 ETH 以太币；</li>
<li>调用没有被标记为 <code>view</code> 或者 <code>pure</code>
的函数；</li>
<li>使用了低级调用；</li>
<li>使用了包含特定操作码的内联汇编；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">uint256 a, uint256 b</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + block.<span class="property">timestamp</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明为 <code>pure</code>
的函数，即不能读取状态，也不能修改状态，而这里的<strong>状态</strong>则是指：</p>
<ol type="1">
<li>读取状态变量。</li>
<li>访问 <code>address(this).balance</code> 或者
<code>&lt;address&gt;.balance</code>。</li>
<li>访问 <code>block</code>、<code>tx</code>、<code>msg</code>
当中的成员（除 <code>msg.sig</code> 和 <code>msg.data</code>
之外）。</li>
<li>调用没有被标记为 <code>pure</code> 的函数。</li>
<li>使用了包含某些操作码的内联汇编。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">uint256 a, uint256 b</span>) public pure <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：由于被声明为 <code>pure</code> 和
<code>view</code>
的函数不能修改<strong>状态变量</strong>，因而调用时也就无需被收取 Gas
费用。</p>
</blockquote>
<h2 id="构造函数-constructor">构造函数 constructor</h2>
<p>每一份 Solidity 智能合约都可以定义一个 <code>constructor</code>
<strong>构造函数</strong>，该函数会在智能合约部署的时候自动被执行一次，因而可以用于初始化一些参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address owner; <span class="comment">// 定义一个 owner 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        owner = msg.<span class="property">sender</span>; <span class="comment">// 该智能合约部署的时候，会将 owner 设置为部署者的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数修饰器-modifier">函数修饰器 modifier</h2>
<p>Solidity 提供的 <code>modifier</code>
修饰器语法，能够以<strong>声明</strong>的方式来改变一些函数的行为，例如在执行函数之前自动进行一个检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    address owner;          <span class="comment">// 定义一个 owner 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        owner = msg.<span class="property">sender</span>; <span class="comment">// 该智能合约部署的时候，会将 owner 设置为部署者的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义一个 modifier 修饰器 */</span></span><br><span class="line">    modifier <span class="title function_">onlyOwner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.<span class="property">sender</span> == owner); <span class="comment">// 检查调用者地址</span></span><br><span class="line">        _;        <span class="comment">// 如果是就继续运行，否则报错并且回滚交易</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateOwner</span>(<span class="params">address _newOwner</span>) external onlyOwner &#123;</span><br><span class="line">        owner = _newOwner;  <span class="comment">// 只有 owner 地址运行这个函数，并改变owner</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：函数修饰器提供的<strong>占位符语句</strong>
<code>_</code>
用于表示添加了<strong>修饰符</strong>的函数主体被插入的位置。</p>
</blockquote>
<h2 id="函数与状态变量的可见性">函数与状态变量的可见性</h2>
<h3 id="状态变量可见性">状态变量可见性</h3>
<ol type="1">
<li><strong>声明为 <code>public</code>
的状态变量</strong>：编译器会自动为其生成 <code>Getter</code>
函数，从而允许其它智能合约读取其值。除此之外，同一个合约当中使用时，通过
<code>this.x</code> 外部访问时也会调用 <code>Getter</code> 函数，而通过
<code>x</code> 直接内部访问则会直接从存储获取变量值。 由于没有生成
<code>Setter</code> 函数，所以其它智能合约无法修改其值。</li>
<li><strong>声明为 <code>internal</code>
的状态变量</strong>：只能从其所定义的智能合约，或者派生出的智能合约当中进行访问，这也是状态变量的<strong>默认的可见性</strong>。</li>
<li><strong>声明为 <code>private</code>
的状态变量</strong>：类似于内部变量，但是在派生出的智能合约当中不可以访问。</li>
</ol>
<h3 id="函数的可见性">函数的可见性</h3>
<ol type="1">
<li><strong>声明为 <code>external</code>
的函数</strong>：只能被其它智能合约或者交易调用，不能从智能合约内部被调用（无法通过
<code>ext()</code> 调用，但是可以通过 <code>this.ext()</code>
调用）。</li>
<li><strong>声明为 <code>public</code>
的函数</strong>：可以被任何智能合约或者交易调用。</li>
<li><strong>声明为 <code>internal</code>
的函数</strong>：只能在当前智能合约内部或者派生的智能合约当中访问，不能从智能合约的外部进行访问。</li>
<li><strong>声明为 <code>private</code>
的函数</strong>：只能在被定义的智能合约内部进行访问，无论是外部还是派生的智能合约都无法进行访问。</li>
</ol>
<h2 id="事件-event">事件 event</h2>
<p>Solidity 当中事件 <code>event</code> 的本质是以太坊虚拟机 EVM
日志功能的抽象，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event 事件名称(事件变量类型 事件变量名称);</span><br></pre></td></tr></table></figure>
<p>下面的示例代码，每次调用 <code>transfer()</code>
函数进行转账的时候，都会触发 <code>Transfer</code>
事件，并且记录对应的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    event <span class="title class_">Transfer</span>(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义用于执行转帐的 transfer 函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transfer</span>(<span class="params">address <span class="keyword">from</span>, address to, uint256 value</span>) external &#123;</span><br><span class="line">        <span class="comment">// ... ... ... ...</span></span><br><span class="line">        emit <span class="title class_">Transfer</span>(<span class="keyword">from</span>, to, value); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面代码当中出现的 <code>indexed</code>
关键字，可以将变量保存在以太坊虚拟机 EVM 日志的 <code>topics</code>
当中，从而可以方便的在后续进行检索。</p>
</blockquote>
<p>以太坊虚拟机 EVM 会使用日志 <code>Log</code> 来存储 Solidity
事件，每一条 Log 日志都记录着 <code>topics</code> 主题和
<code>data</code> 数据两个部分：</p>
<ol type="1">
<li><strong>主题</strong> <code>Topics</code>：用于描述事件，只能容纳 32
个字节，且只能保存最多三个 <code>indexed</code> 参数；</li>
<li><strong>数据</strong> <code>Data</code>：用于保存没有被标注为
<code>indexed</code> 的参数，可以存储任意大小的数据；</li>
</ol>
<h2 id="异常处理-error">异常处理 error</h2>
<p>Solidity 可以使用 <code>error()</code>
方法定义一个不带参数的异常：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(); <span class="comment">// 定义一个没有参数的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，也可以使用 <code>error()</code>
方法定义一个携带有参数的异常：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(address sender); <span class="comment">// 定义一个带有地址参数的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，<code>error()</code> 必须搭配<strong>回退命令</strong>
<code>revert</code> 进行使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.8</span><span class="number">.24</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    error <span class="title class_">TransferError</span>(address sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">transferOwner</span>(<span class="params"></span>) public view  &#123;</span><br><span class="line">         revert <span class="title class_">TransferError</span>(msg.<span class="property">sender</span>); <span class="comment">// 使用 revert 回退命令抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，一些较早版本的 Solidity 还会使用已经废弃了的
<code>require()</code> 方法来处理异常，其缺点在于 Gas
费用会伴随异常描述字符串长度的增加而增加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(异常检查条件，<span class="string">&quot;异常描述信息&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而另外一个 <code>assert()</code>
方法则不能抛出自定义的异常信息，只能直接抛出默认的异常错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">assert</span>(异常检查条件);</span><br></pre></td></tr></table></figure>
<h2 id="继承机制-is">继承机制 is</h2>
<p>Solidity 当中的智能合约可以通过 <code>is</code>
关键字来<strong>继承</strong>其它合约，从而扩展其功能。<strong>子合约</strong>可以继承<strong>父合约</strong>当中
<code>internal</code> 和 <code>public</code>
的函数、状态变量以及事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 父合约 */</span></span><br><span class="line">contract <span class="title class_">ParentContract</span> &#123;</span><br><span class="line">    uint public parentVariable; <span class="comment">// 父合约状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parentFunction</span>(<span class="params"></span>) public virtual &#123;&#125; <span class="comment">// virtual 关键字用于明确标识一个函数可以在子合约当中被重写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父合约事件 */</span></span><br><span class="line">    event <span class="title class_">ParentEvent</span>(uint indexed value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子合约 */</span></span><br><span class="line">contract <span class="title class_">ChildContract</span> is <span class="title class_">ParentContract</span> &#123;</span><br><span class="line">    uint public childVariable; <span class="comment">// 子合约状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重写父合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parentFunction</span>(<span class="params"></span>) public override &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子合约函数 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">childFunction</span>(<span class="params"></span>) public &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触发父合约事件 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">triggerParentEvent</span>(<span class="params">uint value</span>) public &#123;</span><br><span class="line">        emit <span class="title class_">ParentEvent</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Solidity
只能实现<strong>单继承</strong>，即一个子合约只能直接继承自一个父合约。</p>
</blockquote>
<h2 id="模块化导入-import">模块化导入 import</h2>
<p>Solidity 支持 <code>import</code>
模块化导入，下面的一语句用于全局导入，可以将 <code>filename</code>
导入路径源文件中的<strong>全局符号</strong>引入到当前源文件，但是会污染当前
Solidity 源文件的命名空间，并不建议使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>下面的导入语句将 <code>filename</code>
当中的全局符号，导入到了一个新的命名空间 <code>symbolName</code>
当中，从而有效避免了命名空间的污染：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> symbolName <span class="keyword">from</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上述的语句，可以简化的写为如下的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;filename&quot;</span> <span class="keyword">as</span> symbolName;</span><br></pre></td></tr></table></figure>
<p>如果导入源文件当中的命名符号存在冲突，则可以在导入的时候对其进行重命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; symbol1 <span class="keyword">as</span> alias, symbol2 &#125; <span class="keyword">from</span> <span class="string">&quot;filename&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="openzeppelin-基础">OpenZeppelin 基础</h2>
<p><a target="_blank" rel="noopener" href="https://www.openzeppelin.com/">OpenZeppelin</a> 是一家成立于
2015 年的区块链技术企业，其推出的 <code>contracts</code>
是一款是用于开发<strong>安全智能合约</strong>的开源 Solidity
库，其主要提供了以下三方面的功能：</p>
<ol type="1">
<li><strong>访问控制</strong>：用于在智能合约当中，指定每个角色可以进行的操作。</li>
<li><strong>Tokens</strong>：创建可以交易的资产或数字藏品，例如 ERC20
或者 ERC721。</li>
<li><strong>工具</strong>：一些通用工具函数，包括不会溢出的数学运算、签名验证等。</li>
</ol>
<p>可以通过下面的 <code>npm</code> 命令快速安装
<strong>OpenZeppelin</strong> 的 <code>contracts</code> 库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure>
<p><strong>OpenZeppelin</strong> 提供的大多数特性，都需要通过 Solidity
的 <code>is</code> 关键字，以<strong>继承</strong>的方式来进行使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contracts/MyNFT.sol</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ERC721</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyNFT</span> is <span class="title class_">ERC721</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC721</span>(<span class="string">&quot;MyNFT&quot;</span>, <span class="string">&quot;MNFT&quot;</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以通过 Solidity 的 <code>overrides</code>
来重<strong>写</strong> <strong>OpenZeppelin</strong>
当中提供的功能，例如希望改变 <code>AccessControl</code> 中的
<code>revokeRole()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">AccessControl</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">ModifiedAccessControl</span> is <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="comment">// 重写 revokeRole() 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">revokeRole</span>(<span class="params">bytes32, address</span>) public override &#123;</span><br><span class="line">        <span class="title function_">revert</span>(<span class="string">&quot;ModifiedAccessControl: cannot revoke roles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候会想<strong>继承</strong>某一部分 <strong>OpenZeppelin</strong>
当中的功能，并非完全的重写它们，此时就需要用使用到 solidity 的
<code>super</code> 关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line">contract <span class="title class_">ModifiedAccessControl</span> is <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">revokeRole</span>(<span class="params">bytes32 role, address account</span>) public override &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            role != <span class="variable constant_">DEFAULT_ADMIN_ROLE</span>,</span><br><span class="line">            <span class="string">&quot;ModifiedAccessControl: cannot revoke default admin role&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// super.revokeRole 语句将会调用 AccessControll 的原始 revokeRole 方法</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">revokeRole</span>(role, account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问控制-ownerable.sol">访问控制 Ownerable.sol</h2>
<p><strong>OpenZeppelin</strong> 将发布智能合约的账户称为
<code>owner</code>，其提供了 <code>Ownerable.sol</code>
来管理智能合约当中的所有权。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/Ownable.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyContract</span> is <span class="title class_">Ownable</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">normalThing</span>(<span class="params"></span>) public &#123;&#125; <span class="comment">// 所有人都可以调用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">specialThing</span>(<span class="params"></span>) public onlyOwner &#123;&#125; <span class="comment">// 只有 Owner 才可以调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：示例代码当中的 <code>onlyOwner</code>
关键字是由 Openzeppelin 当中的 <code>Ownerable.sol</code> 所提供的。</p>
</blockquote>
<p><code>Ownerable.sol</code> 主要提供了如下两个功能函数：</p>
<ul>
<li><code>transferOwnership()</code>
将智能合约的所有权转移给另外一个账户；</li>
<li><code>renounceOwnership()</code> 放弃智能合约的所有权关系；</li>
</ul>
<h2 id="访问控制-accesscontrol.sol">访问控制 AccessControl.sol</h2>
<p>除此之外，<strong>OpenZeppelin</strong> 还提供了
<code>AccessControl.sol</code>
来基于<strong>角色</strong>进行访问控制（即定义多个角色，并且每个角色对应一组操作权限）。其使用非常简单，对于每个定义的角色都会创建一个<strong>角色标识符</strong>，用于授权、撤销、检查账户是否拥有该角色。</p>
<p>下面是一个基于 ERC20 Token 使用 <code>AccessControl.sol</code>
的例子，它定义了一个名为 <code>minter</code>
的角色，该角色允许账户创建新的 <code>token</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    <span class="comment">// 为 minter 角色创建一个新的角色标识符</span></span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address minter</span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">MINTER_ROLE</span>, minter); <span class="comment">// 将 minter 角色授予指定帐户</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public &#123;</span><br><span class="line">        <span class="built_in">require</span>(<span class="title function_">hasRole</span>(<span class="variable constant_">MINTER_ROLE</span>, msg.<span class="property">sender</span>), <span class="string">&quot;Caller is not a minter&quot;</span>); <span class="comment">// 检查调用帐号是否具有 minter 角色</span></span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>OpenZeppelin</strong> 提供的 <code>AccessControl.sol</code>
亮点在于需要细粒度权限控制的场景，这可以通过定义多个角色来实现。通过这样的拆分，可以实现比
<code>Ownerable.sol</code>
提供的简单所有权控制，层级要更多的访问控制。请注意，如果需要的话，<strong>同一个账户可以拥有多个不同的角色</strong>。</p>
<blockquote>
<p><strong>注意</strong>：限制系统中每个组件能做的事情被称为<strong>最小权限原则</strong>。</p>
</blockquote>
<p>接下来定义一个 <code>burner</code> 角色来扩展上面的 ERC20 token
示例，并且通过使用 <code>onlyRole</code> 修饰符来允许账户销毁
<code>token</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line">    bytes32 public constant <span class="variable constant_">BURNER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;BURNER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address minter, address burner</span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">MINTER_ROLE</span>, minter); <span class="comment">// 设置 minter 访问权限</span></span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">BURNER_ROLE</span>, burner); <span class="comment">// 设置 burner 访问权限</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过使用 `onlyRole` 修饰符来允许账户销毁 token</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">MINTER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">burn</span>(<span class="params">address <span class="keyword">from</span>, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">BURNER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_burn</span>(<span class="keyword">from</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码当中，使用了内部函数 <code>_setupRole()</code>
来分配角色，除此之外还可以使用以下的工具函数来管理角色：</p>
<ul>
<li><code>hasRole()</code>：判断角色。</li>
<li><code>grantRole()</code>：授予角色。</li>
<li><code>revokeRole()</code>：回收角色。</li>
</ul>
<p>除此之外，<strong>OpenZeppelin</strong> 提供的
<code>AccessControl.sol</code> 当中，还包含有一个称为
<code>DEFAULT_ADMIN_ROLE</code>
的特殊角色，它是<strong>所有角色的默认管理员</strong>，拥有该角色的账户可以去管理其它的角色，除非手工调用
<code>_setRoleAdmin()</code> 内部函数来指定一个新的管理员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/access/AccessControl.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">MyToken</span> is <span class="title class_">ERC20</span>, <span class="title class_">AccessControl</span> &#123;</span><br><span class="line">    bytes32 public constant <span class="variable constant_">MINTER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;MINTER_ROLE&quot;</span>);</span><br><span class="line">    bytes32 public constant <span class="variable constant_">BURNER_ROLE</span> = <span class="title function_">keccak256</span>(<span class="string">&quot;BURNER_ROLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC20</span>(<span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;TKN&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 授予合约部署者默认的 DEFAULT_ADMIN_ROLE 角色，使其能够授予和撤销任何角色</span></span><br><span class="line">        <span class="title function_">_setupRole</span>(<span class="variable constant_">DEFAULT_ADMIN_ROLE</span>, msg.<span class="property">sender</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">address to, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">MINTER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_mint</span>(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">burn</span>(<span class="params">address <span class="keyword">from</span>, uint256 amount</span>) public <span class="title function_">onlyRole</span>(<span class="params">BURNER_ROLE</span>) &#123;</span><br><span class="line">        <span class="title function_">_burn</span>(<span class="keyword">from</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>AccessControl.sol</code>
还提供了如下两个工具函数：</p>
<ul>
<li><code>getRoleMember()</code>：返回某个角色当中账户的地址；</li>
<li><code>getRoleMemberCount()</code>：返回某个角色当中账户的数量；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回某个角色当中账户的数量</span></span><br><span class="line"><span class="keyword">const</span> minterCount = <span class="keyword">await</span> myToken.<span class="title function_">getRoleMemberCount</span>(<span class="variable constant_">MINTER_ROLE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回某个角色当中账户的地址</span></span><br><span class="line"><span class="keyword">const</span> members = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minterCount; ++i) &#123;</span><br><span class="line">  members.<span class="title function_">push</span>(<span class="keyword">await</span> myToken.<span class="title function_">getRoleMember</span>(<span class="variable constant_">MINTER_ROLE</span>, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代币-erc20-token">代币 ERC20 Token</h2>
<p><strong>代币</strong>（Token）是指区块链上，各种可以通过智能合约来调用、交易、创建、销毁的虚拟资产，其中
<strong>ERC721</strong> 是以太坊上用于非同质化代币（NFT，Non Fungible
Token）的标准，<strong>OpenZeppelin</strong> 针对 ERC721
标准提供了大量的接口方法，下面的代码可以用于构建一个 ERC721
代币智能合约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/utils/Counters.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">GameItem</span> is <span class="title class_">ERC721URIStorage</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="title class_">Counters</span> <span class="keyword">for</span> <span class="title class_">Counters</span>.<span class="property">Counter</span>;</span><br><span class="line">    <span class="title class_">Counters</span>.<span class="property">Counter</span> private _tokenIds;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) <span class="title class_">ERC721</span>(<span class="string">&quot;GameItem&quot;</span>, <span class="string">&quot;ITM&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">awardItem</span>(<span class="params">address player, string memory tokenURI</span>) public <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 newItemId = _tokenIds.<span class="title function_">current</span>();</span><br><span class="line">        <span class="title function_">_mint</span>(player, newItemId);</span><br><span class="line">        <span class="title function_">_setTokenURI</span>(newItemId, tokenURI); <span class="comment">// 设置物品的元数据</span></span><br><span class="line"></span><br><span class="line">        _tokenIds.<span class="title function_">increment</span>();</span><br><span class="line">        <span class="keyword">return</span> newItemId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码当中，新的 NFT 可以通过执行如下代码来进行生成:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gameItem.awardItem(playerAddress, <span class="string">&quot;http://uinio.com/NFT.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">- Transfer(0x0000000000000000000000000000000000000000, playerAddress, 5)</span><br></pre></td></tr></table></figure>
<p>并且每个物品的所有者和元数据都可以通过如下的方式进行查询:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gameItem.ownerOf(5)</span><br><span class="line">playerAddress</span><br><span class="line"></span><br><span class="line">&gt; gameItem.tokenURI(5)</span><br><span class="line"><span class="string">&quot;http://uinio.com/NFT.json&quot;</span></span><br></pre></td></tr></table></figure>
<p>最终，获得的 <code>tokenURI</code> 就是一个如下所示的 JSON
格式数据:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;雷神之锤&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;一个漫威电影当中的道具&quot;</span>,</span><br><span class="line">    <span class="string">&quot;image&quot;</span>: <span class="string">&quot;http://localhost:1985/Web/Solidity/logo.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;strength&quot;</span>: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="财务功能-finance">财务功能 Finance</h2>
<p><strong>OpenZeppelin</strong> 在 Finance 目录下提供了
<strong>PaymentSplitter</strong>（只存在于 <strong>Contracts</strong>
库的 <code>4.x</code> 版本）和 <strong>VestingWallet</strong>（存在于
<strong>Contracts</strong> 库的 <code>4.x</code> 和 <code>5.x</code>
版本）两个财务相关的智能合约：</p>
<ul>
<li><strong><code>PaymentSplitter</code>
智能合约</strong>：通常用于管理和分配资金，可以允许将资金分割并发送到多个地址，通常基于预定义的分配规则或比例。通常用于众筹、团队资金分配或任何需要按照特定比例分割资金的场景。</li>
<li><strong><code>VestingWallet</code>
智能合约</strong>：则是一种特殊的钱包，用于管理资产的逐步解锁或归属。它通常用于确保代币或资金在一定时间段内逐步释放给接收者，而不是立即全部可用。通常用于激励计划、团队代币锁定或者任何需要时间限制的资金释放场景。</li>
</ul>
<p>概括起来，<code>PaymentSplitter</code> 与 <code>VestingWallet</code>
两者的区别主要体现在如下四个方面：</p>
<ol type="1">
<li><strong>目的不同</strong>：<code>PaymentSplitter</code>
旨在分割和分配资金，而 <code>VestingWallet</code>
旨在逐步解锁和释放资金。</li>
<li><strong>使用场景不同</strong>：<code>PaymentSplitter</code>
更适用于一次性的资金分配场景，而 <code>VestingWallet</code>
更适用于需要长期管理和逐步释放资金的场景。</li>
<li><strong>功能不同</strong>：<code>PaymentSplitter</code>
主要关注资金的即时分配，而 <code>VestingWallet</code>
关注资金的时间锁定和逐步解锁。</li>
<li><strong>透明度与可追踪性</strong>：两者都可能提供事件来增强透明度和可追踪性，但事件的具体内容和触发条件会根据合约的具体实现而有所不同。</li>
</ol>
<h3 id="paymentsplitter-分帐">PaymentSplitter 分帐</h3>
<p>OpenZeppelin 的 PaymentSplitter
智能合约库允许将一个以太坊地址收到的付款按照指定的<strong>份额</strong>（Shares）进行分割，并将这些部分按指定的份额值发送给收款人。这个合约非常适合用于在多个团队成员、投资者或合作伙伴之间分配资金的情况。</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">PaymentSplitter 提供的方法</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>constructor(payees, shares_)</code></td>
<td style="text-align: left;">构造函数，数组
<code>payees</code>（收款人）当中的每个账户，都会获得
<code>shares_</code>（份额）数组中匹配位置的份额值。</td>
</tr>
<tr>
<td style="text-align: left;"><code>receive()</code></td>
<td style="text-align: left;">接收 ETH 以太币（会被记录至
<code>PaymentReceived</code> 事件）。</td>
</tr>
<tr>
<td style="text-align: left;"><code>totalShares()</code></td>
<td style="text-align: left;">获取收款人 <code>payees</code>
持有的全部份额。</td>
</tr>
<tr>
<td style="text-align: left;"><code>totalReleased()</code></td>
<td style="text-align: left;">获取已经释放的 ETH 以太币总额。</td>
</tr>
<tr>
<td style="text-align: left;"><code>totalReleased(token)</code></td>
<td style="text-align: left;">获取已经释放的 <code>token</code>
代币总额。</td>
</tr>
<tr>
<td style="text-align: left;"><code>shares(account)</code></td>
<td style="text-align: left;">获取指定地址账户持有的份额值。</td>
</tr>
<tr>
<td style="text-align: left;"><code>released(account)</code></td>
<td style="text-align: left;">获取已释放给指定地址收款人的 ETH
以太币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>released(token, account)</code></td>
<td style="text-align: left;">获取已释放给指定地址收款人的
<code>token</code> 代币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>payee(index)</code></td>
<td style="text-align: left;">获取收款人数组 <code>payees</code> 指定
<code>index</code> 索引的收款人的账户地址。</td>
</tr>
<tr>
<td style="text-align: left;"><code>releasable(account)</code></td>
<td style="text-align: left;">获取指定账户地址的收款人，当前可以释放的
ETH 以太币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>releasable(token, account)</code></td>
<td style="text-align: left;">获取指定账户地址的收款人，当前可以释放的
<code>token</code> 代币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>release(account)</code></td>
<td style="text-align: left;">根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放
ETH 以太币。</td>
</tr>
<tr>
<td style="text-align: left;"><code>release(token, account)</code></td>
<td style="text-align: left;">根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放
<code>token</code> 代币。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">PaymentSplitter 提供的事件</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>PayeeAdded(account, shares)</code></td>
<td style="text-align: left;">收款人添加事件，需要指定其账户地址
<code>account</code> 以及所占份额 <code>shares</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><code>PaymentReceived(from, amount)</code></td>
<td style="text-align: left;">智能合约收款事件，向 <code>from</code>
地址收取 <code>amount</code> 数额 ETH 以太币的事件。</td>
</tr>
<tr>
<td style="text-align: left;"><code>PaymentReleased(to, amount)</code></td>
<td style="text-align: left;">受益人提款事件，即向 <code>to</code>
地址支付 <code>amount</code> 数额 ETH 以太币的事件。</td>
</tr>
<tr>
<td style="text-align: left;"><code>ERC20PaymentReleased(token, to, amount)</code></td>
<td style="text-align: left;">受益人提款事件，即向 <code>to</code>
地址支付 <code>amount</code> 数额 <code>token</code> 代币的事件。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上述表格当中的 <code>token</code> 是一个
IERC20 代币智能合约的地址。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../token/ERC20/utils/SafeERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../utils/Address.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../utils/Context.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">PaymentSplitter</span> is <span class="title class_">Context</span> &#123;</span><br><span class="line">    event <span class="title class_">PayeeAdded</span>(address account, uint256 shares);</span><br><span class="line">    event <span class="title class_">PaymentReleased</span>(address to, uint256 amount);</span><br><span class="line">    event <span class="title class_">ERC20PaymentReleased</span>(<span class="title class_">IERC20</span> indexed token, address to, uint256 amount);</span><br><span class="line">    event <span class="title class_">PaymentReceived</span>(address <span class="keyword">from</span>, uint256 amount);</span><br><span class="line"></span><br><span class="line">    uint256 private _totalShares;   <span class="comment">// 总份额</span></span><br><span class="line">    uint256 private _totalReleased; <span class="comment">// 总提款</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _shares;   <span class="comment">// 每个受益人占有的份额</span></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _released; <span class="comment">// 支付给每个受益人的金额</span></span><br><span class="line">    address[] private _payees;                     <span class="comment">// 受益人数组</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">IERC20</span> =&gt;</span> uint256) private _erc20TotalReleased;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">IERC20</span> =&gt;</span> <span class="title function_">mapping</span>(<span class="function"><span class="params">address</span> =&gt;</span> uint256)) private _erc20Released;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 构造函数，数组 payees（收款人）当中的每个账户，都会获得 shares_（份额）数组中匹配位置的份额值 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address[] memory payees, uint256[] memory shares_</span>) payable &#123;</span><br><span class="line">        <span class="built_in">require</span>(payees.<span class="property">length</span> == shares_.<span class="property">length</span>, <span class="string">&quot;PaymentSplitter: payees and shares length mismatch&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(payees.<span class="property">length</span> &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: no payees&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (uint256 i = <span class="number">0</span>; i &lt; payees.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">_addPayee</span>(payees[i], shares_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 接收 ETH 以太币（会被记录至 PaymentReceived 事件） */</span></span><br><span class="line">    <span class="title function_">receive</span>() external payable virtual &#123;</span><br><span class="line">        emit <span class="title class_">PaymentReceived</span>(<span class="title function_">_msgSender</span>(), msg.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取收款人 payees 持有的全部份额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalShares</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _totalShares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已经释放的 ETH 以太币总额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalReleased</span>(<span class="params"></span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _totalReleased;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已经释放的 token 代币总额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">totalReleased</span>(<span class="params">IERC20 token</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20TotalReleased[token];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定地址账户持有的份额值 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">shares</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _shares[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已释放给指定地址收款人的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _released[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取已释放给指定地址收款人的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">IERC20 token, address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20Released[token][account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取收款人数组 payees 指定 index 索引的收款人的账户地址 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">payee</span>(<span class="params">uint256 index</span>) public view <span class="title function_">returns</span> (address) &#123;</span><br><span class="line">        <span class="keyword">return</span> _payees[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定账户地址的收款人，当前可以释放的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 totalReceived = <span class="title function_">address</span>(<span class="variable language_">this</span>).<span class="property">balance</span> + <span class="title function_">totalReleased</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_pendingPayment</span>(account, totalReceived, <span class="title function_">released</span>(account));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取指定账户地址的收款人，当前可以释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">IERC20 token, address account</span>) public view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        uint256 totalReceived = token.<span class="title function_">balanceOf</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>)) + <span class="title function_">totalReleased</span>(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_pendingPayment</span>(account, totalReceived, <span class="title function_">released</span>(token, account));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放 ETH 以太币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">address payable account</span>) public virtual &#123;</span><br><span class="line">        <span class="built_in">require</span>(_shares[account] &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account has no shares&quot;</span>); <span class="comment">// account 必须是有效的受益人</span></span><br><span class="line">        uint256 payment = <span class="title function_">releasable</span>(account);                                   <span class="comment">// 计算 account 可以得到的金额</span></span><br><span class="line">        <span class="built_in">require</span>(payment != <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account is not due payment&quot;</span>);    <span class="comment">// 可以得到的金额不能低于零</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  更新支付总额 totalReleased 和支付给每一个受益人的金额 released */</span></span><br><span class="line">        _totalReleased += payment;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _released[account] += payment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 开始转帐 */</span></span><br><span class="line">        <span class="title class_">Address</span>.<span class="title function_">sendValue</span>(account, payment);</span><br><span class="line">        emit <span class="title class_">PaymentReleased</span>(account, payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 根据持有的份额比例和之前的提款历史，向指定账户地址的收款人释放 token 代币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">IERC20 token, address account</span>) public virtual &#123;</span><br><span class="line">        <span class="built_in">require</span>(_shares[account] &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account has no shares&quot;</span>);</span><br><span class="line">        uint256 payment = <span class="title function_">releasable</span>(token, account);</span><br><span class="line">        <span class="built_in">require</span>(payment != <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account is not due payment&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _erc20TotalReleased[token] += payment;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _erc20Released[token][account] += payment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">SafeERC20</span>.<span class="title function_">safeTransfer</span>(token, account, payment);</span><br><span class="line">        emit <span class="title class_">ERC20PaymentReleased</span>(token, account, payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@dev</span> 内部逻辑，计算一个账户的待支付金额，需要考虑该账户的历史余额和已提取的金额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_pendingPayment</span>(<span class="params"></span></span><br><span class="line"><span class="params">        address account,</span></span><br><span class="line"><span class="params">        uint256 totalReceived,</span></span><br><span class="line"><span class="params">        uint256 alreadyReleased</span></span><br><span class="line"><span class="params">    </span>) private view <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="comment">/* 收款总额 x 账户份额 / 总份额 - 已提取金额 */</span></span><br><span class="line">        <span class="keyword">return</span> (totalReceived * _shares[account]) / _totalShares - alreadyReleased;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 新增受益人 account 以及其所对应的份额 shares_ */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_addPayee</span>(<span class="params">address account, uint256 shares_</span>) private &#123;</span><br><span class="line">        <span class="built_in">require</span>(account != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;PaymentSplitter: account is the zero address&quot;</span>);  <span class="comment">// account 不能为零地址</span></span><br><span class="line">        <span class="built_in">require</span>(shares_ &gt; <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: shares are 0&quot;</span>);                           <span class="comment">// 份额不能为 0</span></span><br><span class="line">        <span class="built_in">require</span>(_shares[account] == <span class="number">0</span>, <span class="string">&quot;PaymentSplitter: account already has shares&quot;</span>);   <span class="comment">// 该账户是否已经拥有份额</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新收款人数组 _payees、份额数组 _shares、总份额 _totalShares */</span></span><br><span class="line">        _payees.<span class="title function_">push</span>(account);</span><br><span class="line">        _shares[account] = shares_;</span><br><span class="line">        _totalShares = _totalShares + shares_;</span><br><span class="line">        emit <span class="title class_">PayeeAdded</span>(account, shares_);  <span class="comment">// 触发增加受益人事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vestingwallet-归属权钱包">VestingWallet 归属权钱包</h3>
<p><strong>OpenZeppelin</strong> 的 <a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/5.x/api/finance#VestingWallet"><strong>VestingWallet</strong></a>
智能合约库，主要用于实现<strong>代币的逐步发放</strong>功能。这里的
<code>Vesting</code>
是一种<strong>归属权兑现</strong>机制，用于在一定时间内将<strong>代币</strong>
<code>token</code>
发放给特定的受益人。换而言之，就是在一定时间期限内，代币逐渐可用或者可提取的过程。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">VestingWallet 提供的方法</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>constructor(beneficiary, startTimestamp, durationSeconds)</code></td>
<td style="text-align: left;">默认将智能合约的发送方设置为<strong>初始所有者</strong>，其中
<code>beneficiary</code> 为受益人，<code>startTimestamp</code>
为开始时间戳，<code>durationSeconds</code> 为归属权存续时间。</td>
</tr>
<tr>
<td style="text-align: left;"><code>receive()</code></td>
<td style="text-align: left;">用于接收 ETH 以太币。</td>
</tr>
<tr>
<td style="text-align: left;"><code>start()</code></td>
<td style="text-align: left;">获取开始时间戳。</td>
</tr>
<tr>
<td style="text-align: left;"><code>end()</code></td>
<td style="text-align: left;">获取结束时间戳。</td>
</tr>
<tr>
<td style="text-align: left;"><code>duration()</code></td>
<td style="text-align: left;">获取归属权存续时间。</td>
</tr>
<tr>
<td style="text-align: left;"><code>released()</code></td>
<td style="text-align: left;">已被释放的 ETH 以太币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>released(address token)</code></td>
<td style="text-align: left;">已被释放的 <code>token</code>
代币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>releasable()</code></td>
<td style="text-align: left;">可以释放的 ETH 以太币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>releasable(address token)</code></td>
<td style="text-align: left;">可以释放的 <code>token</code>
代币数量。</td>
</tr>
<tr>
<td style="text-align: left;"><code>release()</code></td>
<td style="text-align: left;">释放已归属的 ETH 以太币。</td>
</tr>
<tr>
<td style="text-align: left;"><code>release(token)</code></td>
<td style="text-align: left;">释放已归属的 <code>token</code>
代币。</td>
</tr>
<tr>
<td style="text-align: left;"><code>vestedAmount(timestamp)</code></td>
<td style="text-align: left;">已归属的 ETH
以太币数量，默认实现为一个线性的释放曲线。</td>
</tr>
<tr>
<td style="text-align: left;"><code>vestedAmount(token, timestamp)</code></td>
<td style="text-align: left;">已归属的 <code>token</code>
代币数量，默认实现为一个线性的释放曲线。</td>
</tr>
<tr>
<td style="text-align: left;"><code>_vestingSchedule(totalAllocation, timestamp)</code></td>
<td style="text-align: left;">归属权公式的虚拟实现，返回值为已经释放的金额。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">VestingWallet 提供的事件</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>EtherReleased(amount)</code></td>
<td style="text-align: left;">以太币 ETH 被释放事件。</td>
</tr>
<tr>
<td style="text-align: left;"><code>ERC20Released(token, amount)</code></td>
<td style="text-align: left;">代币 <code>token</code> 被释放事件。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：上述表格当中的 <code>token</code> 是一个
IERC20 代币智能合约的地址。</p>
</blockquote>
<p><strong>OpenZeppelin</strong> 的 <strong>Contracts</strong> 库在其
<code>finance</code> 目录下的 <code>VestingWallet.sol</code>
智能合约当中提供了如下源代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">IERC20</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../token/ERC20/IERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">SafeERC20</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../token/ERC20/utils/SafeERC20.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Address</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../utils/Address.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Context</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../utils/Context.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Ownable</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../access/Ownable.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">VestingWallet</span> is <span class="title class_">Context</span>, <span class="title class_">Ownable</span> &#123;</span><br><span class="line">    event <span class="title class_">EtherReleased</span>(uint256 amount);</span><br><span class="line">    event <span class="title class_">ERC20Released</span>(address indexed token, uint256 amount);</span><br><span class="line"></span><br><span class="line">    uint256 private _released;</span><br><span class="line">    <span class="title function_">mapping</span>(address token =&gt; uint256) private _erc20Released;</span><br><span class="line">    uint64 private immutable _start;</span><br><span class="line">    uint64 private immutable _duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 默认将智能合约的发送方设置为初始所有者，其中 beneficiary 为受益人，startTimestamp 为开始时间戳，durationSeconds 为归属权存续时间 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address beneficiary, uint64 startTimestamp, uint64 durationSeconds</span>) payable <span class="title class_">Ownable</span>(beneficiary) &#123;</span><br><span class="line">        _start = startTimestamp;</span><br><span class="line">        _duration = durationSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 用于接收 ETH 以太币 */</span></span><br><span class="line">    <span class="title function_">receive</span>() external payable virtual &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取开始时间戳 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取归属权存续时间 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">duration</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 获取结束时间戳 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">end</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">start</span>() + <span class="title function_">duration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已被释放的 ETH 以太币数量。 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _released;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已被释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">released</span>(<span class="params">address token</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> _erc20Released[token];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 可以释放的 ETH 以太币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params"></span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vestedAmount</span>(<span class="title function_">uint64</span>(block.<span class="property">timestamp</span>)) - <span class="title function_">released</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 可以释放的 token 代币数量 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">releasable</span>(<span class="params">address token</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vestedAmount</span>(token, <span class="title function_">uint64</span>(block.<span class="property">timestamp</span>)) - <span class="title function_">released</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 释放已归属的 ETH 以太币 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params"></span>) public virtual &#123;</span><br><span class="line">        uint256 amount = <span class="title function_">releasable</span>();</span><br><span class="line">        _released += amount;</span><br><span class="line">        emit <span class="title class_">EtherReleased</span>(amount);</span><br><span class="line">        <span class="title class_">Address</span>.<span class="title function_">sendValue</span>(<span class="title function_">payable</span>(<span class="title function_">owner</span>()), amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 释放已归属的 token 代币。 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">release</span>(<span class="params">address token</span>) public virtual &#123;</span><br><span class="line">        uint256 amount = <span class="title function_">releasable</span>(token);                     <span class="comment">// 获取可以释放的 token 代币数量</span></span><br><span class="line">        _erc20Released[token] += amount;                        <span class="comment">// 更新已释放代币数量</span></span><br><span class="line">        emit <span class="title class_">ERC20Released</span>(token, amount);                      <span class="comment">// 触发代币 token 被释放事件</span></span><br><span class="line">        <span class="title class_">SafeERC20</span>.<span class="title function_">safeTransfer</span>(<span class="title class_">IERC20</span>(token), <span class="title function_">owner</span>(), amount); <span class="comment">// 安全转移代币</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已归属的 ETH 以太币数量，默认实现为一个线性的释放曲线 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">vestedAmount</span>(<span class="params">uint64 timestamp</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_vestingSchedule</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>).<span class="property">balance</span> + <span class="title function_">released</span>(), timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 已归属的 token 代币数量，默认实现为一个线性的释放曲线 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">vestedAmount</span>(<span class="params">address token, uint64 timestamp</span>) public view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_vestingSchedule</span>(<span class="title class_">IERC20</span>(token).<span class="title function_">balanceOf</span>(<span class="title function_">address</span>(<span class="variable language_">this</span>)) + <span class="title function_">released</span>(token), timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@dev</span> 归属权公式的虚拟实现，返回值为已经释放的金额 */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_vestingSchedule</span>(<span class="params">uint256 totalAllocation, uint64 timestamp</span>) internal view virtual <span class="title function_">returns</span> (uint256) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; <span class="title function_">start</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timestamp &gt;= <span class="title function_">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> totalAllocation;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (totalAllocation * (timestamp - <span class="title function_">start</span>())) / <span class="title function_">duration</span>(); <span class="comment">// 根据线性释放公式，计算已经释放的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>基于 Solidity、Hardhat、OpenZeppelin 迈向 Web3.0</p><p><a href="http://www.uinio.com/Web/Solidity/">http://www.uinio.com/Web/Solidity/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-05-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-06-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Solidity/">Solidity</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Project/UINIO-Monitor/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">运用 U8G2 与 TFT_eSPI 玩转 UINIO-Monitor 显示屏</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Project/Arduino-ESP32/"><span class="level-item">基于 UINIO-MCU-ESP32 核心板的 Arduino 进阶教程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#web-3.0-简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">Web 3.0 简介</span></span></a></li><li><a class="level is-mobile" href="#构建-hardhat-环境"><span class="level-left"><span class="level-item">2</span><span class="level-item">构建 Hardhat 环境</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#npm-安装-hardhat"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">npm 安装 Hardhat</span></span></a></li><li><a class="level is-mobile" href="#初始化-hardhat-工程"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">初始化 Hardhat 工程</span></span></a></li><li><a class="level is-mobile" href="#编译智能合约"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">编译智能合约</span></span></a></li><li><a class="level is-mobile" href="#测试智能合约"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">测试智能合约</span></span></a></li><li><a class="level is-mobile" href="#部署智能合约"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">部署智能合约</span></span></a></li><li><a class="level is-mobile" href="#启动-hardhat-network"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">启动 Hardhat Network</span></span></a></li><li><a class="level is-mobile" href="#连接-hardhat-network"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">连接 Hardhat Network</span></span></a></li><li><a class="level is-mobile" href="#日志打印-console.log"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">日志打印 console.log()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#引入以太坊-web3.js"><span class="level-left"><span class="level-item">3</span><span class="level-item">引入以太坊 Web3.js</span></span></a></li><li><a class="level is-mobile" href="#智能合约基本结构"><span class="level-left"><span class="level-item">4</span><span class="level-item">智能合约基本结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#许可标识-编译指示"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">许可标识 &amp; 编译指示</span></span></a></li><li><a class="level is-mobile" href="#状态变量"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">状态变量</span></span></a></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">函数</span></span></a></li><li><a class="level is-mobile" href="#函数修饰器"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">函数修饰器</span></span></a></li><li><a class="level is-mobile" href="#事件"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">事件</span></span></a></li><li><a class="level is-mobile" href="#结构体类型"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">结构体类型</span></span></a></li><li><a class="level is-mobile" href="#枚举类型"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">枚举类型</span></span></a></li><li><a class="level is-mobile" href="#错误"><span class="level-left"><span class="level-item">4.8</span><span class="level-item">错误</span></span></a></li></ul></li><li><a class="level is-mobile" href="#注释语句"><span class="level-left"><span class="level-item">5</span><span class="level-item">注释语句</span></span></a></li><li><a class="level is-mobile" href="#变量作用域"><span class="level-left"><span class="level-item">6</span><span class="level-item">变量作用域</span></span></a></li><li><a class="level is-mobile" href="#常量-constant"><span class="level-left"><span class="level-item">7</span><span class="level-item">常量 constant</span></span></a></li><li><a class="level is-mobile" href="#不变量-immutable"><span class="level-left"><span class="level-item">8</span><span class="level-item">不变量 immutable</span></span></a></li><li><a class="level is-mobile" href="#条件判断-循环控制"><span class="level-left"><span class="level-item">9</span><span class="level-item">条件判断 &amp; 循环控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#if-else-判断"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">if else 判断</span></span></a></li><li><a class="level is-mobile" href="#for-循环"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">for 循环</span></span></a></li><li><a class="level is-mobile" href="#while-循环"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">while 循环</span></span></a></li><li><a class="level is-mobile" href="#do-while-循环"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">do while 循环</span></span></a></li><li><a class="level is-mobile" href="#三元操作符"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">三元操作符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数值类型-value-type"><span class="level-left"><span class="level-item">10</span><span class="level-item">数值类型 Value Type</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#布尔类型-bool"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">布尔类型 bool</span></span></a></li><li><a class="level is-mobile" href="#整型-intuint"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">整型 int/uint</span></span></a></li><li><a class="level is-mobile" href="#地址类型-address"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">地址类型 address</span></span></a></li><li><a class="level is-mobile" href="#枚举类型-enum"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">枚举类型 enum</span></span></a></li></ul></li><li><a class="level is-mobile" href="#引用类型-reference-type"><span class="level-left"><span class="level-item">11</span><span class="level-item">引用类型 Reference Type</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">数组 [ ]</span></span></a></li><li><a class="level is-mobile" href="#定长字节数组-bytesx"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">定长字节数组 bytesX</span></span></a></li><li><a class="level is-mobile" href="#变长字节数组-bytesstring"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">变长字节数组 bytes/string</span></span></a></li><li><a class="level is-mobile" href="#结构体-struct"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">结构体 struct</span></span></a></li><li><a class="level is-mobile" href="#映射类型-mapping"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">映射类型 mapping</span></span></a></li><li><a class="level is-mobile" href="#存储位置"><span class="level-left"><span class="level-item">11.6</span><span class="level-item">存储位置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据类型默认值"><span class="level-left"><span class="level-item">12</span><span class="level-item">数据类型默认值</span></span></a></li><li><a class="level is-mobile" href="#函数类型-function"><span class="level-left"><span class="level-item">13</span><span class="level-item">函数类型 function</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数的定义"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">函数的定义</span></span></a></li><li><a class="level is-mobile" href="#读取返回值"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">读取返回值</span></span></a></li><li><a class="level is-mobile" href="#状态可变性-view-pure"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">状态可变性 view pure</span></span></a></li></ul></li><li><a class="level is-mobile" href="#构造函数-constructor"><span class="level-left"><span class="level-item">14</span><span class="level-item">构造函数 constructor</span></span></a></li><li><a class="level is-mobile" href="#函数修饰器-modifier"><span class="level-left"><span class="level-item">15</span><span class="level-item">函数修饰器 modifier</span></span></a></li><li><a class="level is-mobile" href="#函数与状态变量的可见性"><span class="level-left"><span class="level-item">16</span><span class="level-item">函数与状态变量的可见性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#状态变量可见性"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">状态变量可见性</span></span></a></li><li><a class="level is-mobile" href="#函数的可见性"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">函数的可见性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事件-event"><span class="level-left"><span class="level-item">17</span><span class="level-item">事件 event</span></span></a></li><li><a class="level is-mobile" href="#异常处理-error"><span class="level-left"><span class="level-item">18</span><span class="level-item">异常处理 error</span></span></a></li><li><a class="level is-mobile" href="#继承机制-is"><span class="level-left"><span class="level-item">19</span><span class="level-item">继承机制 is</span></span></a></li><li><a class="level is-mobile" href="#模块化导入-import"><span class="level-left"><span class="level-item">20</span><span class="level-item">模块化导入 import</span></span></a></li><li><a class="level is-mobile" href="#openzeppelin-基础"><span class="level-left"><span class="level-item">21</span><span class="level-item">OpenZeppelin 基础</span></span></a></li><li><a class="level is-mobile" href="#访问控制-ownerable.sol"><span class="level-left"><span class="level-item">22</span><span class="level-item">访问控制 Ownerable.sol</span></span></a></li><li><a class="level is-mobile" href="#访问控制-accesscontrol.sol"><span class="level-left"><span class="level-item">23</span><span class="level-item">访问控制 AccessControl.sol</span></span></a></li><li><a class="level is-mobile" href="#代币-erc20-token"><span class="level-left"><span class="level-item">24</span><span class="level-item">代币 ERC20 Token</span></span></a></li><li><a class="level is-mobile" href="#财务功能-finance"><span class="level-left"><span class="level-item">25</span><span class="level-item">财务功能 Finance</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#paymentsplitter-分帐"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">PaymentSplitter 分帐</span></span></a></li><li><a class="level is-mobile" href="#vestingwallet-归属权钱包"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">VestingWallet 归属权钱包</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Cadence-Skill/"><img src="/Electronics/Cadence-Skill/logo.png" alt="Cadence OrCAD/Allegro 设计技巧合集"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-09-27T16:00:00.000Z">2025-09-28</time></p><p class="title"><a href="/Electronics/Cadence-Skill/">Cadence OrCAD/Allegro 设计技巧合集</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/I2C/"><img src="/Electronics/I2C/logo.png" alt="内置集成电路总线协议 I²C 简明指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-09-05T16:00:00.000Z">2025-09-06</time></p><p class="title"><a href="/Electronics/I2C/">内置集成电路总线协议 I²C 简明指南</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/FPGA/"><img src="/Electronics/FPGA/logo.png" alt="硬件工程师必知必会的 Xilinx FPGA 知识"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-01T16:00:00.000Z">2025-07-02</time></p><p class="title"><a href="/Electronics/FPGA/">硬件工程师必知必会的 Xilinx FPGA 知识</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Ethernet/"><img src="/Electronics/Ethernet/logo.png" alt="一份面面俱到的 Ethernet 以太网技术摘要"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-06-04T16:00:00.000Z">2025-06-05</time></p><p class="title"><a href="/Electronics/Ethernet/">一份面面俱到的 Ethernet 以太网技术摘要</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/CAN/"><img src="/Electronics/CAN/logo.png" alt="控制器区域网络 CAN 总线协议图解"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-30T16:00:00.000Z">2025-05-01</time></p><p class="title"><a href="/Electronics/CAN/">控制器区域网络 CAN 总线协议图解</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BA%BF/"><span class="tag">总线</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8A%AF%E7%89%87/"><span class="tag">芯片</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/"><span class="tag">通信总线</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>