<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux C 标准程序设计语言 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="最早的 C 编程语言标准由美国国家标准协会（ANSI）在 1989 年首次发布（C89 版本），后于 1990 年由国际标准化组织（ISO）修订后发布（C90 版本）标准，而后经历了 C99、C11 等一系列主要版本的演进，截止目前最新的版本是 2018 年 10 月发布的 C18 版本。笔者当前使用的 Linux C 编译工具是 2018 年 1 月 25 日释出的GCC 7.3.0"><meta property="og:type" content="blog"><meta property="og:title" content="Linux C 标准程序设计语言"><meta property="og:url" content="http://www.uinio.com/C&amp;C++/C/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="最早的 C 编程语言标准由美国国家标准协会（ANSI）在 1989 年首次发布（C89 版本），后于 1990 年由国际标准化组织（ISO）修订后发布（C90 版本）标准，而后经历了 C99、C11 等一系列主要版本的演进，截止目前最新的版本是 2018 年 10 月发布的 C18 版本。笔者当前使用的 Linux C 编译工具是 2018 年 1 月 25 日释出的GCC 7.3.0"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2014-03-15T16:00:00.000Z"><meta property="article:modified_time" content="2017-05-20T16:00:00.000Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="C"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/C&C++/C/"},"headline":"Linux C 标准程序设计语言","image":["http://www.uinio.com/C&C++/C/logo.png"],"datePublished":"2014-03-15T16:00:00.000Z","dateModified":"2017-05-20T16:00:00.000Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"最早的 C 编程语言标准由美国国家标准协会（ANSI）在\r 1989 年首次发布（C89 版本），后于 1990\r 年由国际标准化组织（ISO）修订后发布（C90\r 版本）标准，而后经历了 C99、C11\r 等一系列主要版本的演进，截止目前最新的版本是 2018 年 10 月发布的 C18\r 版本。笔者当前使用的 Linux C 编译工具是 2018 年 1 月 25\r 日释出的GCC 7.3.0"}</script><link rel="canonical" href="http://www.uinio.com/C&amp;C++/C/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-03-15T16:00:00.000Z" title="2014/3/16 00:00:00">2014-03-16</time>发表</span><span class="level-item"><time dateTime="2017-05-20T16:00:00.000Z" title="2017/5/21 00:00:00">2017-05-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C-C-%E8%AF%AD%E8%A8%80/">C/C++ 语言</a></span><span class="level-item">3 小时读完 (大约24236个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux C 标准程序设计语言</h1><div class="content"><p>最早的 C 编程语言标准由<strong>美国国家标准协会（ANSI）</strong>在
1989 年首次发布（<em>C89 版本</em>），后于 1990
年由<strong>国际标准化组织（ISO）</strong>修订后发布（<em>C90
版本</em>）标准，而后经历了 C99、C11
等一系列主要版本的演进，截止目前最新的版本是 2018 年 10 月发布的 C18
版本。笔者当前使用的 Linux C 编译工具是 2018 年 1 月 25
日释出的<strong>GCC 7.3.0</strong>版本，提供了 C89/C90 、C99、C11
等一系列 ISO 标准特性的支持。</p>
<p><img src="/C&C++/C/logo.png"></p>
<p>本文将分为<a href>《语法规范》</a>与<a href>《应用程序》</a>两个姊妹篇，前者侧重于介绍 Linux C
各个数据类型的存储模型，并概括了函数、条件编译、动态内存管理、位运算、指针等嵌入式
C 程序设计的常用概念。后者将涉及 Linux 文件系统
IO、进程间通信、多线程、网络编程等应用程序开发方面的内容。</p>
<span id="more"></span>
<h1 id="hello-world">Hello World</h1>
<p>第一步，我们先来尝试编写一个老派的 Hello World
程序，<code>main</code>函数是 Linux C
语言程序的执行入口，因此也称为<strong>主函数</strong>。主函数的<code>argc</code>参数为整型，用于统计程序执行时传递给主函数的命令行参数的个数。而<code>argv</code>参数是一个字符串数组，数组中每个元素指向一个命令行输入的执行参数。</p>
<p>不同于 Python、JavaScript
这样的脚本语言，函数内部每条语句尾部的分号<code>;</code>都不能被省略。代码开头的<code>#include</code>预处理指令用于包含标准
IO
头文件，从而能够在后续主函数中调用<code>printf()</code>方法。另外值得注意的是，C
语言代码当中存在<code>/*块注释*/</code>和<code>//行注释</code>两种注释风格，但是<code>//</code>风格在
GCC 的 C89/C90
编译选项下会提示错误信息，开发人员可以根据实际情况酌情使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  块注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);      <span class="comment">// 行注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C99
标准规定主函数执行完成之后，需要显式书写<code>return 0;</code>语句表示程序正常退出，主函数返回类型的声明也需要显式的设置为<code>int</code>。</p>
</blockquote>
<h1 id="变量常量常变量">变量、常量、常变量</h1>
<p><strong>常量</strong>是 Linux C 程序运行时不能改变的量，Linux
当中使用的常量类型有<code>字符型</code>、<code>整型</code>、<code>浮点型</code>等数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="string">&#x27;U&#x27;</span>;           <span class="comment">// 字符型常量</span></span><br><span class="line">  <span class="string">&#x27;\n&#x27;</span>;          <span class="comment">// 转义字符常量</span></span><br><span class="line">  <span class="number">2019</span>;          <span class="comment">// 整型常量</span></span><br><span class="line">  <span class="number">3.141592654</span>;   <span class="comment">// 浮点型常量</span></span><br><span class="line">  <span class="string">&quot;Hello Hank!&quot;</span>; <span class="comment">// 字符数组常量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变量</strong>是一个具有名称的存储单元，编译系统会自动为<strong>变量名</strong>分配对应的内存地址。<strong>C
程序中的变量都是数据的补码形式进行存储</strong>，程序运行时计算机会通过<strong>变量名</strong>查找对应的内存单元地址，然后通过该地址操作其中保存的<strong>变量值</strong>。</p>
<p><img src="/C&C++/C/variable.png"></p>
<p>下面代码当中，声明了一个整型变量<code>date</code>，并将其赋值为<code>2019</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> date = <span class="number">2019</span>;</span><br></pre></td></tr></table></figure>
<p><strong>常变量</strong>具有变量的基本属性，带有数据类型并且占用存储空间；但与常量类似，在程序运行期间不允许修改其值。C99
规范允许使用<code>const</code>关键字声明一个常量，下面将声明一个常量<code>USER</code>并赋值为<code>Hank</code>（<em>通常约定常量名称全部大写</em>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DATE = <span class="number">2019</span>;</span><br></pre></td></tr></table></figure>
<p><strong>常量一旦声明之后就不能再次进行赋值和修改</strong>，否则 GCC
编译器将会提示错误信息：<code>error: assignment of read-only variable</code>，请参考下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> DATE = <span class="number">2019</span>;</span><br><span class="line">  DATE = <span class="number">2010</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">// main.c:6:8: error: assignment of read-only variable ‘DATE’</span></span><br><span class="line"><span class="comment">//    DATE = 2010;</span></span><br><span class="line"><span class="comment">//         ^</span></span><br></pre></td></tr></table></figure>
<h1 id="数据类型">数据类型</h1>
<p>C 语言是强类型语言，ANSI C
当中无论定义变量还是常量都需要事先声明数据类型，编译器将会根据数据类型来为变量和常量分配相应存储空间，不同数据类型具有不同的<strong>存储长度</strong>与<strong>存储方式</strong>，C99
标准中常用的数据类型见下表：</p>
<p><img src="/C&C++/C/data-type.png"></p>
<blockquote>
<p>注意：红色标注的部分表示的是 C99 标准当中新增的特性。</p>
</blockquote>
<h2 id="整型-int">整型 int</h2>
<p>整型数据会以整数补码的方式存储，Keil C51
编译器会分配<strong>2</strong>个字节共<strong>16</strong>位空间，而 GCC
编译器则会分配<strong>4</strong>个字节共<strong>32</strong>位空间。32
位当中最左边的一位是<strong>符号位</strong>，该位为<code>0</code>表示正数，为<code>1</code>则表示负数。接下来的表格展示了整型数据的存储空间以及取值范围：</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 9%">
<col style="width: 61%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">数据类型</th>
<th style="text-align: left;">字节数</th>
<th style="text-align: left;">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong><code>int</code></strong>
基本整型</td>
<td style="text-align: left;"><strong>4</strong> 个字节</td>
<td style="text-align: left;"><code>-2147483648 ~ 2147483647</code>，即<span class="math inline">\(-2^{31} \Rightarrow (2^{31}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>unsigned int</code></strong>
无符号基本整型</td>
<td style="text-align: left;"><strong>4</strong> 个字节</td>
<td style="text-align: left;"><code>0 ~ 4294967295</code>，即<span class="math inline">\(0 \Rightarrow (2^{32}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>short</code></strong>
短整型</td>
<td style="text-align: left;"><strong>2</strong> 个字节</td>
<td style="text-align: left;"><code>-32768 ~ 32767</code>，即<span class="math inline">\(-2^{15} \Rightarrow (2^{15}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>unsigned short</code></strong>
无符号短整型</td>
<td style="text-align: left;"><strong>2</strong> 个字节</td>
<td style="text-align: left;"><code>0 ~ 65535</code>，即<span class="math inline">\(0 \Rightarrow (2^{16}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>long</code></strong>
长整型</td>
<td style="text-align: left;"><strong>8</strong> 个字节</td>
<td style="text-align: left;"><code>-9223372036854775808 ~ 9223372036854775807</code>，即<span class="math inline">\(-2^{63} \Rightarrow (2^{63}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>unsigned long</code></strong>
无符号长整型</td>
<td style="text-align: left;"><strong>8</strong> 个字节</td>
<td style="text-align: left;"><code>0 ~ 18446744073709551615</code>，即<span class="math inline">\(0 \Rightarrow (2^{64}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>long long</code></strong>
双长整型</td>
<td style="text-align: left;"><strong>8</strong> 个字节</td>
<td style="text-align: left;"><code>-9223372036854775808 ~ 9223372036854775807</code>，即<span class="math inline">\(-2^{63} \Rightarrow (2^{63}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>unsigned long long</code></strong>
无符号双长整型</td>
<td style="text-align: left;"><strong>8</strong> 个字节</td>
<td style="text-align: left;"><code>0 ~ 18446744073709551615</code>，即<span class="math inline">\(0 \Rightarrow (2^{64}-1)\)</span>。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意上面表格当中，无符号类型由于需要有 1
位来作为符号位，因此取值范围计算公式的<strong>指数部分</strong>需要相应的减去<code>1</code>位（例如：<span class="math inline">\(2^{15}\)</span>、<span class="math inline">\(2^{31}\)</span>、<span class="math inline">\(-2^{63}\)</span>），而有符号类型计算公式的指数部分则与该数据类型可存储的字节数相匹配。另外，取值范围计算公式<span class="math inline">\(2^{n}-1\)</span>中出现的减去<code>1</code>的情况，是由于正整数一侧的取值范围包含了<code>0</code>（*虽然数学上<code>0</code>并非正整数_），因而需要将正整数部分的取值范围相应的减掉一。</p>
</blockquote>
<p>为了更加清晰的理解整型数据存储空间分配与取值范围的关系，下面的示意图展示了<strong>短整型</strong><code>short</code>的最大取值<code>32767</code>、<strong>无符号短整型</strong><code>unsigned short</code>的最大取值<code>65535</code>的存储空间占用情况：</p>
<p><img src="/C&C++/C/storage-structure/int.png"></p>
<p><code>sizeof()</code>并非一个函数调用，而是标准 C
语言提供的一个单目操作符，通常称为<strong>求字节宽度运算符</strong>；其作用是以<code>long unsigned int</code>数据类型返回当前操作数所占用存储空间的<strong>字节</strong>大小，因此下面例子的<code>printf()</code>语句中，格式化字符串需要使用<code>%ld</code>进行接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;int %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));                               <span class="comment">// int 4 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unsigned int %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>));             <span class="comment">// unsigned int 4 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;short %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));                           <span class="comment">// short 2 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unsigned short %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>));         <span class="comment">// unsigned short 2 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;long %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));                             <span class="comment">// long 8 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unsigned long %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>));           <span class="comment">// unsigned long 8 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;long long %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));                   <span class="comment">// long long 8 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unsigned long long %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)); <span class="comment">// unsigned long long 8 byte</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要使用<code>printf()</code>输出中文，源代码文件必须以<strong>GB2312</strong>编码格式保存。</p>
</blockquote>
<p>值得提醒的是，基本整型<code>int</code>默认是有符号的数据类型，而无符号类型变量原则上不能存放<code>-3</code>这样的负数；使用<code>printf()</code>输出无符号整型数据的时候，格式字符串需要选择<code>%u</code>进行输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> birthday= <span class="number">-1988</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, birthday);  <span class="comment">// -1988</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, birthday);  <span class="comment">// 4294965308</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符型-char">字符型 char</h2>
<p>Linux C
当中字符型数据必须以单引号<code>'c'</code>进行声明，每个字符型变量只能保存
1 个 ASCII 有效字符，这是由于字符类型实际存储的是该字符的 ASCII
编码，因为 ASCII 字符集编码通常表达为一个整型数据，所以 C99
规范当中也将其视为一种整型数据。下面的表格展示了字符型占用的存储空间以及取值范围：</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 13%">
<col style="width: 52%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">数据类型</th>
<th style="text-align: left;">字节数</th>
<th style="text-align: left;">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong><code>signed char</code></strong>
有符号字符型</td>
<td style="text-align: left;"><strong>1</strong> 个字节</td>
<td style="text-align: left;"><code>-128 ~ 127</code>，即<span class="math inline">\(-2^{7} \Rightarrow (2^{7}-1)\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>unsigned char</code></strong>
无符号字符型</td>
<td style="text-align: left;"><strong>1</strong> 个字节</td>
<td style="text-align: left;"><code>0 ~ 255</code>，即<span class="math inline">\(0 \Rightarrow (2^{8}-1)\)</span>。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;char %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));                   <span class="comment">// char 1 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;unsigned char %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)); <span class="comment">// unsigned char 1 byte</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有符号字符型数据允许存储的取值范围在<code>-128 ~ 127</code>之间，但字符型的
ASCII
编码不可能为负值，因而实际只会使用到<code>0 ~ 127</code>，即最左侧符号位总是为<code>0</code>。如果将负整数直接赋值给字符型变量，操作虽然合法但并不代表一个有效字符，而仅仅保存了一个负整数值。接下来的图片展示了保存字符型变量<code>'1'</code>时的存储情况，由于字符<code>'1'</code>的
ASCII
码为<code>49</code>，因此存储器中实质保存的是数字<code>49</code>的二进制表达形式。</p>
<p><img src="/C&C++/C/storage-structure/char.png"></p>
<p><code>printf()</code>输出字符型数据时，格式字符串需要选择<code>%c</code>；如果格式字符串选择为<code>%d</code>，则会输入该变量的
ASCII 码表达形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> test= <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test);  <span class="comment">// 104</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, test);  <span class="comment">// h</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，关键字<code>char</code>前的<code>signed</code>或者<code>unsigned</code>是否能够缺省由具体的编译器决定，这一点与<code>int</code>等其它数据类型不同。在
GCC 编译器当中，<code>char</code>缺省为<strong>有符号类型</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> test = <span class="number">255</span>; <span class="comment">// GCC默认字符型变量为有符号类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span>, test);  <span class="comment">// �</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, test);  <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>char</code>默认为有符号类型，所以赋值为<code>255</code>超出了有符号字符类型的表示范围，导致后面打印输出为<code>-1</code>。如果这里显式声明字符型<code>test</code>的值为无符号类型<code>unsigned</code>则能够正确的打印数值<code>255</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> test = <span class="number">255</span>; <span class="comment">// 显式声明字符型变量为无符号类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span>, test);  <span class="comment">// �</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, test);  <span class="comment">// 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点型-float">浮点型 float</h2>
<p>浮点型用来表示具有小数点的<strong>实数</strong>，并以规范化的二进制数指数形式存放在存储单元。之所以称为浮点型，是由于实数的指数形式有多种，比如对于<code>3.1416</code>，可以表示为<span class="math inline">\(3.14159 × 10^0\)</span>、<span class="math inline">\(0.314159 × 10^1\)</span>、<span class="math inline">\(0.0314159 ×
10^2\)</span>等形式，小数点的位置可以自由进行浮动。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 11%">
<col style="width: 7%">
<col style="width: 51%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">数据类型</th>
<th style="text-align: left;">字节数</th>
<th style="text-align: left;">有效数字</th>
<th style="text-align: left;">取值范围（绝对值）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong><code>float</code></strong>
单精度浮点型</td>
<td style="text-align: left;"><strong>4</strong> 个字节</td>
<td style="text-align: left;"><strong>6</strong></td>
<td style="text-align: left;"><span class="math inline">\(0\)</span>
以及 <span class="math inline">\((1.2×10^{-38}) \Rightarrow
(3.4×10^{38})\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>double</code></strong>
双精度浮点型</td>
<td style="text-align: left;"><strong>8</strong> 个字节</td>
<td style="text-align: left;"><strong>15</strong></td>
<td style="text-align: left;"><span class="math inline">\(0\)</span>
以及 <span class="math inline">\((2.3×10^{-308}) \Rightarrow
(1.7×10^{308})\)</span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong><code>long double</code></strong>
长双精度浮点型</td>
<td style="text-align: left;"><strong>16</strong> 个字节</td>
<td style="text-align: left;"><strong>19</strong></td>
<td style="text-align: left;"><span class="math inline">\(0\)</span>
以及 <span class="math inline">\((3.4×10^{-4932}) \Rightarrow
(1.1×10^{4932})\)</span>。</td>
</tr>
</tbody>
</table>
<p>为了保持存储结构的一致性，必须将实数转换为<strong>规范化的指数形式</strong>后再保存至存储单元，即小数点前数字为<code>0</code>，小数点之后第
1
位数字不为<code>0</code>，对应于前面例子<code>3.1416</code>的规范化的指数形式是<span class="math inline">\(0.314159 ×
10^1\)</span>，下图展示了其具体的存储结构，注意小数部分<code>.314159</code>实际是以二进制形式保存在存储单元中的。</p>
<p><img src="/C&C++/C/storage-structure/float.png"></p>
<p>C99 和 C11
标准并未明确定义浮点类型的指数和小数部分各占据总存储单元的多少，具体数值由各个编译器指定。同时，各个编译器对于浮点数据类型所占用的存储空间长度也有所不同，例如<code>long double</code>类型的长度在
GCC 当中被定义为 16 个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> pi_f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">double</span> pi_b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> pi_ld = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(pi_f));         <span class="comment">// float 4 byte</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double int %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(pi_b));    <span class="comment">// double int 8 byte</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long double %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(pi_ld));  <span class="comment">// long double 16 byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：Linux C
当中对于浮点类型的<strong>常量值</strong>默认会按照<code>double</code>类型来进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> i  = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="comment">/* 打印一个变量占用的空间 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float is %d byte\n&quot;</span>, <span class="keyword">sizeof</span>(i));        <span class="comment">// float is 4 byte</span></span><br><span class="line">    <span class="comment">/* 打印一个常量占用的空间 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double is %d byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">3.14159</span>)); <span class="comment">// double is 8 byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型转换">基本数据类型转换</h2>
<h3 id="自动类型转换">自动类型转换</h3>
<p>当两个不同的基本数据类型进行算术运算时，所得结果的数据类型总是存储占用空间更大的那一个。比如下面例子中，整型的<code>i</code>（占用
4 字节存储空间）与字符类型的<code>c</code>（占用 1
字节存储空间）分别与浮点类型<code>f</code>相加（占用 4
字节存储空间）时，得到的<code>sizeof</code>结果总是 4 个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i  = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result have %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(i+f)); <span class="comment">// result have 4 byte</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result have %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(c+f)); <span class="comment">// result have 4 byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强制类型转换">强制类型转换</h3>
<p>可以利用强制类型转换将数据转换为需要的数据类型，使用格式为<code>(目标数据类型)表达式</code>，例如：<code>(double)1</code>、<code>(double)(3+5)</code>都会将整型的结果转换为双精度浮点类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> i  = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result still have %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>((<span class="type">float</span>)i)); <span class="comment">// result still have 4 byte</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="布尔类型-bool">布尔类型 bool</h2>
<p>C++当中存在专门的<code>bool</code>类型，但是 C89/90
当中没有提供专用的布尔类型，因此通常会在代码中使用基本整型来模拟布尔类型数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">bool</span> test = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (test != <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;工作情况良好！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C99
规范里新增了<code>_Bool</code>关键字，用于原生定义布尔类型，该类型占用一个字节存储空间，仅拥有<code>0</code>和<code>1</code>两个取值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">_Bool</span> <span class="literal">true</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="type">_Bool</span> <span class="literal">false</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;_Bool is %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">_Bool</span>)); <span class="comment">// _Bool is 1 byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C99
当中由<code>&lt;stdbool.h&gt;</code>头文件将<code>_Bool</code>关键字重新定义为别名<code>bool</code>，<code>1</code>和<code>0</code>分别被定义为了<code>true</code>和<code>false</code>，因此引入该头文件后，可以直接使用<code>bool</code>作为声明布尔数据类型的关键字，使用<code>true</code>和<code>false</code>作为布尔类型的取值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> truly = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> falsely = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;true is %d and false is %d.\n&quot;</span>, truly, falsely); <span class="comment">// true is 1 and false is 0.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行数据类型转换的时候，<strong>GCC
会将任意非零值自动转换为<code>1</code></strong>，也就是<code>true</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> year = <span class="number">1985</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ops, year equals %d!\n&quot;</span>, year); <span class="comment">// Ops, year equals 1!</span></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复数类型-complex">复数类型 complex</h2>
<p>C99
新增了复数类型的关键字<code>_Complex</code>，正如同上面提到的<code>_Bool</code>类型与<code>&lt;stdbool.h&gt;</code>中<code>bool</code>的关系一样，包含头文件<code>&lt;complex.h&gt;</code>之后，就可以方便的使用<code>complex</code>来代替<code>_Complex</code>关键字的使用。定义复数类型时，<code>complex</code>需要与<strong>浮点数据类型</strong>（<em><code>float</code>、<code>double</code>、<code>long double</code></em>）组合起来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;float complex %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span> <span class="type">complex</span>));              <span class="comment">// float complex 8 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;double complex  %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span> <span class="type">complex</span>));           <span class="comment">// double complex  16 byte</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;long double complex  %ld byte\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">double</span> <span class="type">complex</span>)); <span class="comment">// long double complex  32 byte</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GCC 暂不支持 ISO C99 当中定义的虚数类型<code>_Imaginary</code>。</p>
</blockquote>
<h2 id="数组-array">数组 array</h2>
<p>数组是一组有序数据的集合，数组中每一个元素都是相同的数据类型，并且保存在<strong>一个连续的存储空间</strong>。C
语言中使用数组必须先声明其长度，以便于事先开辟一个指定大小的存储空间。例如：下图展示了一个包含有
10
个元素的数组<code>int a[10]</code>，该数组每个元素的存储空间只能用于存放整型数据。</p>
<p><img src="/C&C++/C/storage-structure/array.png"></p>
<p>Linux C 当中，无论当前 GCC 编译选项是 C89 还是
C11，程序代码当中都可以动态的定义数组长度。例如下面的例子当中，根据控制台输入的数值来分配数组长度，然后再将动态分配后的数组长度打印出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number); <span class="comment">// 输入数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[number];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="number">4</span>);  <span class="comment">// 打印整型数组长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意，数组长度一旦声明之后，就禁止再次进行修改，否则 GCC
会在编译过程中提示<code>redeclaration of ‘array’ with no linkage</code>错误，请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[number];</span><br><span class="line"></span><br><span class="line">    number = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[number];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">// main.c:8:9: error: redeclaration of ‘array’ with no linkage</span></span><br><span class="line"><span class="comment">//      int array[number];</span></span><br><span class="line"><span class="comment">//          ^~~~~</span></span><br><span class="line"><span class="comment">// main.c:5:9: note: previous declaration of ‘array’ was here</span></span><br><span class="line"><span class="comment">//      int array[number];</span></span><br><span class="line"><span class="comment">//          ^~~~~</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>static</code>关键字将数组定义为静态存储方式，那么数组的长度必须是一个<strong>常量</strong>，否则
GCC 编译器依然会提示错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="built_in">array</span>[number];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c:6:16: error: storage size of ‘array’ isn’t constant</span></span><br><span class="line"><span class="comment">//      static int array[number];</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>对于一个已经声明了长度的数组，可以选择<strong>一次性初始化全部数组元素</strong>，也可以选择<strong>只初始化部分数组元素</strong>，长度之内未进行显式初始化的元素，将会被隐式的初始化为该数组的数据类型所对应的默认值，例如：整型数组缺省元素的默认值将会被置为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;  <span class="comment">// 初始化指定长度的数组。</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">// 缺省数组长度进行初始化，数组长度为实际元素个数。</span></span><br><span class="line">    <span class="type">int</span> c[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;          <span class="comment">// 下面数组初始化结果为：&#123;1,2,3,4,5,0,0,0,0,0&#125;。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维数组结构上类似于线性代数中的矩阵，其声明与初始化方式与上面的一维数组类似，但是出于代码可读性的考虑，推荐使用<code>&#123;&#125;</code>符号对元素进行分组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> [<span class="number">2</span>,<span class="number">5</span>] = [&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;]; <span class="comment">// 声明并初始化一个二维数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符数组">字符数组</h3>
<p>字符类型数据以字符的 ASCII 编码进行存储，由于 ASCII
编码是整数形式，因此 C99
标准当中，将字符类型视为整型数据的一种。字符数组当中的每个元素存放一个字符，其定义与初始化的方式与普通数组类似。下面的示例代码，定义并初始化了一个名为<code>c[]</code>的字符数组，并最终将其打印至控制台：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> c[] = &#123;<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, c); <span class="comment">// I am Hank!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子代码当中，每个字符占据着<code>1</code>个字节的存储单元，数组<code>c[]</code>最终形成的存储结构如下图所示：</p>
<p><img src="/C&C++/C/storage-structure/array-char-1.png"></p>
<p>由于 C
语言当中没有字符串类型，因此<strong>字符串被存放在字符类型数组当中进行处理</strong>，请看接下来的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> c1[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c1 is %ld bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(c1)); <span class="comment">// c1 is 4 bytes.</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c2[] = <span class="string">&quot;Hank&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c2 is %ld bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(c2)); <span class="comment">// c2 is 5 bytes.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>造成<code>c1</code>和<code>c2</code>的长度各不相同的原因在于，Linux C
当中以双引号"..."直接声明字符串的时候，系统默认会在字符串最后添加一个<code>'\0'</code>字符作为<strong>结束标志</strong>。<code>'\0'</code>的
ASCII
编码十进制形式为<code>0</code>，二进制形式为<code>0000 0000</code>，系统当中用来表示一个不可显示的<strong>空操作符</strong>。</p>
<p><img src="/C&C++/C/storage-structure/array-char-2.png"></p>
<p>由上图可以看出，字符串<code>"Hank"</code>等效于字符数组<code>&#123;'H', 'a', 'n', 'k', '\0'&#125;</code>。使用<code>printf()</code>函数打印字符串或字符数组时，格式符<code>%c</code>表示输出一个字符，<code>%s</code>表示输出的是一个字符串，具体使用可以参数下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> c1[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符数组%s的是第1个字符是%c。\n&quot;</span>, c1, c1[<span class="number">0</span>]); <span class="comment">// 字符数组Hank的是第1个字符是H。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c2[] = <span class="string">&quot;Hank&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符串%s的是第1个字符同样是%c。\n&quot;</span>, c2, c2[<span class="number">0</span>]); <span class="comment">// 字符串Hank的是第1个字符同样是H。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组">二维数组</h3>
<p>二维数组也称为<strong>矩阵</strong>（<em>matrix</em>），可以将其形象的理解为一个具有<strong>行</strong>和<strong>列</strong>的表格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1991</span>, <span class="number">1992</span>, <span class="number">1993</span>, <span class="number">1994</span>, <span class="number">1995</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>, <span class="number">2004</span>, <span class="number">2005</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2011</span>, <span class="number">2012</span>&#125;</span><br><span class="line">  &#125;; <span class="comment">// 声明并定义一个具有3行3列元素的整型二维数组</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;第2行第1列保存的整数值为：%d\n&quot;</span>, matrix[<span class="number">1</span>][<span class="number">0</span>]);  <span class="comment">// 第2行第1列保存的整数值为：2001</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;第3行第5列保存的整数值为：%d\n&quot;</span>, matrix[<span class="number">2</span>][<span class="number">4</span>]);  <span class="comment">// 第3行第5列保存的整数值为：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义二维乃至多维数组时，对于没有显式进行赋值的数组元素，Linux C
将默认其值为该数组对应数据类型的缺省值，例如上面代码中，第 3 行第 5
列并未显式进行赋值定义，所以其值默认为整型数据的缺省值<code>0</code>，该二维数组在内存中的实际存储结构如下：</p>
<p><img src="/C&C++/C/storage-structure/double-dimensional-array.png"></p>
<blockquote>
<p>注意：由于数组每个元素都拥有连续的存储地址，其实际展现出存储结构也应是线性形态。但是上图为了形象体现二维数组矩阵的存储结构，所以将其抽象为了表格形态，但是图中的每一行元素都通过箭头与下一行首尾相连，以体现其真实存储地址的连续性。</p>
</blockquote>
<h2 id="结构体-struct">结构体 struct</h2>
<p>由于数组只能存放相同数据类型的数据，而结构体是一种由<strong>不同类型数据</strong>组成的组合型数据结构。使用时需要先声明结构体类型，再建立结构体变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名称 &#123;</span></span><br><span class="line">  成员数据类型 成员数据名称;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体类型定义完成之后，就可以定义该结构体类型的变量，具体定义格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名称 结构体变量名称;</span></span><br></pre></td></tr></table></figure>
<p>下面的代码定义了一个<code>Date</code>和<code>Student</code>结构体类型以及名为<code>hank</code>的结构体变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明Date结构体类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明Student结构体类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span> address[<span class="number">20</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span> <span class="comment">// 声明Date结构体变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">hank</span>;</span> <span class="comment">// 声明Student结构体变量</span></span><br></pre></td></tr></table></figure>
<p>定义结构体变量以后，系统会对其分配内存单元。结构体变量占用的内存长度是各数据类型成员所占用的长度之和，每个成员都拥有自己独立的内存单元。例如对于上面代码中定义的<code>Data</code>和<code>Student</code>结构体，声明并定义之后的内存布局如下图所示：</p>
<p><img src="/C&C++/C/storage-structure/struct.png"></p>
<p>Linux C
当中可以不指定结构体类型的名称，而直接定义一个结构体变量，就像下面代码所展示的那样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span> address[<span class="number">20</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">&#125; hank;</span><br></pre></td></tr></table></figure>
<p>结构体变量定义完成之后，就可以开始对结构体成员进行初始化赋值，然后以<strong><code>结构体变量名称.成员名称</code></strong>的方式访问，接下来看一个从结构体类型定义、结构体变量声明、结构体初始化、引用并输出结构体成员值的完整例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date</span> =</span> &#123;<span class="number">2019</span>, <span class="number">3</span>, <span class="number">1</span>&#125;; <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d年%d月%d日\n&quot;</span>, date.year, date.month, date.day); <span class="comment">// 2019年3月1日</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论 GCC
采取哪种标准的编译选项，都可以在初始化结构体变量时，以<code>.结构体成员名称 = 成员初始值</code>的方式赋值给指定成员，其它未赋值成员的值将会是该成员数据类型所对应的缺省值（<em>整型默认为<code>0</code>，浮点型默认为<code>0.000000</code>，字符型默认为<code>\0</code>，指针类型默认为<code>NULL</code></em>），修改一下上面例子代码，只对结构体成员<code>year</code>进行显式赋值操作，由于<code>month</code>和<code>day</code>都是整型数据，因此其默认值为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date</span> =</span> &#123;.year = <span class="number">2019</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d年%d月%d日\n&quot;</span>, date.year, date.month, date.day); <span class="comment">// 2019年0月0日</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同类型的结构体变量可以相互赋值</strong>，修改一下上面例子程序的代码并执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date1</span> =</span> &#123;.year = <span class="number">2018</span>, .month = <span class="number">8</span>, .day = <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date2</span> =</span> date1; <span class="comment">// 将结构体date1的成员值直接赋值给date2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d年%d月%d日\n&quot;</span>, date2.year, date2.month, date2.day);  <span class="comment">// 2018年8月1日</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结构体数组</strong>与普通数组一样，只是每个元素都是结构体类型的数据，下面的代码定义并初始化了一个结构体数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">calendar</span>[6] =</span> &#123;</span><br><span class="line">  &#123;<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2020</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2020</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;.year = <span class="number">2020</span>, .month = <span class="number">1</span>, .day = <span class="number">4</span>&#125;</span><br><span class="line">  &#123;.year = <span class="number">2020</span>, .month = <span class="number">1</span>, .day = <span class="number">5</span>&#125;</span><br><span class="line">  &#123;.year = <span class="number">2020</span>, .month = <span class="number">1</span>, .day = <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="共用体-union">共用体 union</h2>
<p>共用体可以在同一个地址开始的内存单元中存放几种不同的数据类型，正是由于占用内存的起始地址相同，所以<strong>共用体某一时刻只能存放一个数据，而不能同时存放多个</strong>；下面展示了共用体定义的基本格式，可以看到语法上与结构体非常类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体类型名称 &#123;</span></span><br><span class="line">  成员数据类型 成员数据名称;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>共用体拥有让一个变量同时具备多种数据类型的能力</strong>，接下来，我们声明一个称为<code>Variable</code>的结构体变量，该变量拥有存放字符型、整型、浮点型数据的能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Variable</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> character;  <span class="comment">// 有符号字符型，占用1个字节空间。</span></span><br><span class="line">  <span class="type">int</span> integer;     <span class="comment">// 基本整型，占用2个字节空间。</span></span><br><span class="line">  <span class="type">float</span> real;      <span class="comment">// 单精度浮点型，占用4个字节空间。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Variable.integer = <span class="number">100</span>; <span class="comment">// 将整数100存储在Variable结构体变量。</span></span><br></pre></td></tr></table></figure>
<p><strong>共用体变量所占用的内存长度，等于内存占用最长的那个数据类型的变量长度</strong>。因此，上面定义的<code>Variable</code>结构体变量占用的存储空间为<code>4</code>个字节，即占用内存空间最大的浮点型数据<code>real</code>的长度。</p>
<p><img src="/C&C++/C/storage-structure/union.png"></p>
<p>共用体也可以不指定共用体类型的名称，而直接定义一个共用体变量；但是需要注意，由于共用体内成员占据的都是同一块存储空间，因此定义共用体变量以后，只能初始化其中的一个成员，比如像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> character;</span><br><span class="line">  <span class="type">int</span> integer;</span><br><span class="line">  <span class="type">float</span> real;</span><br><span class="line">&#125; character = &#123;<span class="string">&#x27;H&#x27;</span>&#125;; <span class="comment">// 初始化第1个成员character</span></span><br></pre></td></tr></table></figure>
<p>共用体变量定义完成之后，在代码当中并不能直接引用，只能通过<code>共用体变量名称.成员名称</code>引用或初始化共用体中的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Variable</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">    <span class="type">int</span> integer;</span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Variable</span> <span class="title">demo</span>;</span></span><br><span class="line">  demo.integer = <span class="number">2012</span>; <span class="comment">// 初始化成员integer</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, demo.integer); <span class="comment">// 2012</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC 也支持显式的初始化共用体的指定成员，请接着阅读下面示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Variable</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> character;</span><br><span class="line">  <span class="type">int</span> integer;</span><br><span class="line">  <span class="type">float</span> real;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Variable</span> <span class="title">demo</span> =</span> &#123;.integer = <span class="string">&#x27;U&#x27;</span>&#125;; <span class="comment">// 仅初始化指定成员</span></span><br></pre></td></tr></table></figure>
<p>由于共用体变量中保存的成员总是最后一次赋值的成员，所以每次赋值操作都会覆盖之前保存的成员状态。此外，因为共用体成员之间都共享着一个起始地址，所以共用体变量的地址与其成员的地址都是相同的，这是与结构体非常不同的一点，接下来的示例代码将会非常好的展示这一点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Variable</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">    <span class="type">int</span> integer;</span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Variable</span> <span class="title">demo</span>;</span></span><br><span class="line"></span><br><span class="line">  demo.integer = <span class="number">2012</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前共用体装载的是成员integer的值%d地址为%p\n&quot;</span>, demo.integer, &amp;demo.integer); <span class="comment">// 当前共用体装载的是成员integer的值2012地址为0x7ffd99356564</span></span><br><span class="line"></span><br><span class="line">  demo.real = <span class="number">3.14</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前共用体装载的是成员real的值%f地址为%p\n&quot;</span>, demo.real, &amp;demo.real); <span class="comment">// 当前共用体装载的是成员real的值3.140000地址为0x7ffd99356564</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Linux C
允许相同类型的共用体变量相互进行赋值，也可以定义一个共用体数组，甚至出现在结构体类型的定义当中。</p>
</blockquote>
<h2 id="枚举类型-enum">枚举类型 enum</h2>
<p>如果变量拥有几种可能的值，那么就可以考虑将该变量定义为枚举类型，枚举类型变量的取值范围仅限于枚举类型定义的范围。枚举类型的声明格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名称 &#123;</span>枚举元素列表&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的声明格式，我们将在下面代码中声明一个枚举类型<code>Week</code>，然后初始化一个枚举变量<code>today</code>，并将其结果打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Week</span> &#123;</span></span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    Wednesday = <span class="number">3</span>,</span><br><span class="line">    Thursday = <span class="number">4</span>,</span><br><span class="line">    Friday = <span class="number">5</span>,</span><br><span class="line">    Saturday = <span class="number">6</span>,</span><br><span class="line">    Sunday = <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Week</span> <span class="title">today</span> =</span> Friday;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;今天是星期%d\n&quot;</span>, today); <span class="comment">// 今天是星期5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC
编译器对于枚举类型元素会按照常量进行处理，因此这些元素也被称为<strong>枚举常量</strong>，而既然是常量就不能对其直接进行赋值操作，否则编译器将会提示错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    youth = <span class="number">18</span>,</span><br><span class="line">    midlife = <span class="number">30</span>,</span><br><span class="line">    elder = <span class="number">50</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  midlife = <span class="number">20</span>; <span class="comment">// 不能对枚举常量进行赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">// main.c:12:11: error: lvalue required as left operand of assignment</span></span><br><span class="line"><span class="comment">//    midlife = 20;</span></span><br><span class="line"><span class="comment">//            ^</span></span><br></pre></td></tr></table></figure>
<p>枚举类型每个元素的值默认为一个整型数据，GCC
编译器会按照<code>1</code>，<code>2</code>，<code>3</code>...的序数顺序为枚举类型的每个元素赋值，如果将枚举类型元素赋值为一个非整型数据，那么
GCC 编译器将会提示<code>枚举值不是一个整型常量</code>的错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Circular</span> &#123;</span></span><br><span class="line">    pi = <span class="number">3.14</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Circular</span> <span class="title">value</span> =</span> pi;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;圆周率PI的值为%d\n&quot;</span>, pi); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">// main.c:5:10: error: enumerator value for ‘pi’ is not an integer constant</span></span><br><span class="line"><span class="comment">//      pi = 3.14,</span></span><br><span class="line"><span class="comment">//           ^~~~</span></span><br></pre></td></tr></table></figure>
<p>正是由于枚举值是一个整型(<em>int</em>)的常量，因此其占用的存储空间总是整型数据所占用的存储空间，接着看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Ordinal</span> &#123;</span></span><br><span class="line">    first = <span class="number">1</span>,</span><br><span class="line">    second = <span class="number">2</span>,</span><br><span class="line">    third = <span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Ordinal</span> <span class="title">two</span> =</span> second;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  // Ordinal枚举类型变量two的枚举值为2，它占用了4个字节存储空间!</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ordinal枚举类型变量two的枚举值为%d，它占用了%ld个字节存储空间!\n&quot;</span>, two, <span class="keyword">sizeof</span>(two));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举与其它的复合数据类型一样，可以<strong>不用声明枚举类型名称，而直接定义枚举类型变量</strong>，因此上面的例子也可以改写为下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    first = <span class="number">1</span>,</span><br><span class="line">    second = <span class="number">2</span>,</span><br><span class="line">    third = <span class="number">3</span></span><br><span class="line">  &#125; two = second;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ordinal枚举类型变量two的枚举值为2！</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Ordinal枚举类型变量two的枚举值为%d！\n&quot;</span>, two);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运算符">运算符</h1>
<p>运算符用于执行程序程序代码当中的运算操作，使用时需要注意<strong>优先级</strong>、<strong>结合性</strong>、<strong>运算目数</strong>方面的事项，Linux
C 支持的运算符主要有如下几种类型：</p>
<h2 id="赋值运算符">赋值运算符</h2>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 54%">
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">运算目数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>=</strong></td>
<td style="text-align: left;"><strong>赋值</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a = 0</code></td>
</tr>
<tr>
<td style="text-align: left;">+=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a + b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a += b</code></td>
</tr>
<tr>
<td style="text-align: left;">-=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a - b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a -= b</code></td>
</tr>
<tr>
<td style="text-align: left;">*=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a * b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a *= b</code></td>
</tr>
<tr>
<td style="text-align: left;">/=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a / b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a /= b</code></td>
</tr>
<tr>
<td style="text-align: left;">%=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a % b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a %= b</code></td>
</tr>
<tr>
<td style="text-align: left;">&gt;&gt;=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a &gt;&gt; b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a &gt;&gt;= b</code></td>
</tr>
<tr>
<td style="text-align: left;">&lt;&lt;=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a &lt;&lt; b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a &lt;&lt;= b</code></td>
</tr>
<tr>
<td style="text-align: left;">&amp;=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a &amp; b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a &amp;= b</code></td>
</tr>
<tr>
<td style="text-align: left;">^=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a ^ b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a ^= b</code></td>
</tr>
<tr>
<td style="text-align: left;">│=</td>
<td style="text-align: left;">复合赋值运算符，等效于<code>a = a │ b</code>。</td>
<td style="text-align: left;">双目运算符</td>
<td style="text-align: left;"><code>a │= b</code></td>
</tr>
</tbody>
</table>
<h2 id="算术运算符">算术运算符</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">运算目数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>+</strong></td>
<td style="text-align: left;"><strong>加法</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a + b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>-</strong></td>
<td style="text-align: left;"><strong>减法</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a - b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>*</strong></td>
<td style="text-align: left;"><strong>乘法</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a * b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>/</strong></td>
<td style="text-align: left;"><strong>除法</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a / b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>%</strong></td>
<td style="text-align: left;"><strong>取余</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a % b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>++</strong></td>
<td style="text-align: left;"><strong>自增</strong> 运算符</td>
<td style="text-align: left;"><strong>单目</strong> 运算符</td>
<td style="text-align: left;"><code>a++</code>或<code>++a</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>--</strong></td>
<td style="text-align: left;"><strong>自减</strong> 运算符</td>
<td style="text-align: left;"><strong>单目</strong> 运算符</td>
<td style="text-align: left;"><code>a--</code>或<code>--a</code></td>
</tr>
</tbody>
</table>
<h2 id="关系运算符">关系运算符</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">运算目数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>&gt;</strong></td>
<td style="text-align: left;"><strong>大于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &gt; b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>&lt;</strong></td>
<td style="text-align: left;"><strong>小于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &lt; b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>==</strong></td>
<td style="text-align: left;"><strong>等于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a == b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>&gt;=</strong></td>
<td style="text-align: left;"><strong>大于等于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &gt;= b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>&lt;=</strong></td>
<td style="text-align: left;"><strong>小于等于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &lt;= b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>!=</strong></td>
<td style="text-align: left;"><strong>不等于</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a != b</code></td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">运算目数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>&amp;&amp;</strong></td>
<td style="text-align: left;"><strong>逻辑与</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &amp;&amp; b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>‖</strong></td>
<td style="text-align: left;"><strong>逻辑或</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a ‖ b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>!</strong></td>
<td style="text-align: left;"><strong>逻辑非</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a ! b</code></td>
</tr>
</tbody>
</table>
<h2 id="位运算符">位运算符</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">运算目数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>&amp;</strong></td>
<td style="text-align: left;"><strong>按位与</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &amp; b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>│</strong></td>
<td style="text-align: left;"><strong>按位或</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a │ b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>^</strong></td>
<td style="text-align: left;"><strong>接位异或</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a ^ b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>~</strong></td>
<td style="text-align: left;"><strong>按位取反</strong> 运算符</td>
<td style="text-align: left;"><strong>单目</strong> 运算符</td>
<td style="text-align: left;"><code>~a</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>&lt;&lt;</strong></td>
<td style="text-align: left;"><strong>左移</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &lt;&lt; b</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>&gt;&gt;</strong></td>
<td style="text-align: left;"><strong>右移</strong> 运算符</td>
<td style="text-align: left;"><strong>双目</strong> 运算符</td>
<td style="text-align: left;"><code>a &gt;&gt; b</code></td>
</tr>
</tbody>
</table>
<h1 id="选择结构">选择结构</h1>
<p><strong>GCC
编译器表达逻辑运算结果时，数值<code>0</code>等效于<code>false</code>数值<code>1</code>等效于<code>true</code>，包括其它任何非<code>0</code>值也都会被认为等效于<code>true</code></strong>，当程序在执行选择结构的判断时，尤为需要注意这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非零数值皆为真!\n&quot;</span>); <span class="comment">// 非零数值皆为真!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if-结构">if 结构</h2>
<p>如果<code>表达式</code>结果为<code>true</code>，那么执行<code>语句</code>；如果<code>表达式</code>结果为<code>false</code>，那么跳过该选择结构并执行后面语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>表达式</code>结果为<code>true</code>执行<code>语句1</code>；如果<code>表达式</code>结果为<code>false</code>执行<code>语句2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>表达式1</code>结果为<code>true</code>就执行<code>语句1</code>并跳过该选择结构；如果<code>表达式1</code>结果为<code>false</code>就继续判断<code>表达式2</code>，如果<code>表达式2</code>结果为<code>true</code>就执行<code>语句2</code>并跳过该选择结构，如果<code>表达式2</code>结果为<code>false</code>，那么就直接执行<code>语句3</code>，最后跳出该选择结构并执行后续代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>) &#123;</span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if
语句中的表达式，可以是关系表达式、逻辑表达式、甚至数值表达式，实际开发过程当中注意灵活进行使用；接下来编写一个关于<code>if</code>结构的完整
Linux C 程序示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> alphabet = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alphabet == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是true条件下的语句！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (alphabet == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是false条件下的语句！\n&quot;</span>); <span class="comment">// 执行结果：这是false条件下的语句！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;都错了！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC
当中，只要包含了<code>&lt;stdbool.h&gt;</code>头文件，就可以方便的在逻辑运算和选择结构当中使用<code>bool</code>类型以及<code>true</code>、<code>false</code>关键字，修改一下上面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是true条件下的语句！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是false条件下的语句！\n&quot;</span>);  <span class="comment">// 执行结果：这是false条件下的语句！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;都错了！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch-结构">switch 结构</h2>
<p>下面的伪代码当中，<strong><code>switch</code>语句上<code>表达式</code>的结果必须是整型或者字符型</strong>，否则
GCC
编译器会提示<code>error: switch quantity not an integer</code>错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，在接下来的代码当中，我们将会编写一个关于<code>switch</code>语句的完整例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> alphabet = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (alphabet) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;这是字母H！\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;这是字母U！\n&quot;</span>); <span class="comment">// 执行结果：这是字母U！</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;都错了！\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环结构">循环结构</h1>
<p>面向过程的程序开发当中，通常拥有<strong>顺序结构</strong>、<strong>选择结构</strong>、<strong>循环结构</strong>三种基本结构，本节内容将会来介绍相对更为繁琐一些的循环结构。</p>
<h2 id="while-结构">while 结构</h2>
<p><code>表达式</code>结果为<code>true</code>时执行循环体中的<code>语句</code>，为<code>false</code>时跳出循环体执行后续其它语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前执行了第%d次\n&quot;</span>, index);</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-while-结构">do while 结构</h2>
<p>首先无条件执行循环体中的<code>语句</code>，然后检查<code>表达式</code>内的条件，如果<code>表达式</code>结果为<code>true</code>就继续执行循环体，如果<code>表达式</code>结果为<code>false</code>就跳出循环体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前执行了第%d次\n&quot;</span>, index);</span><br><span class="line">    index++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (index &lt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-结构">for 结构</h2>
<p>首先执行<code>表达式1</code>，主要用于设置初始条件，只执行一次;
然后执行<code>表达式2</code>，主要用于判断循环是否继续进行;
最后执行<code>表达式3</code>，主要用于循环变量进行自增操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前执行了第%d次\n&quot;</span>, index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>while</code>、<code>do while</code>、<code>for</code>三个例子程序，都是在循环索引小于<code>6</code>的条件之下打印当前执行的索引值，因而执行的结果都是相同的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前执行了第0次</span><br><span class="line">当前执行了第1次</span><br><span class="line">当前执行了第2次</span><br><span class="line">当前执行了第3次</span><br><span class="line">当前执行了第4次</span><br><span class="line">当前执行了第5次</span><br></pre></td></tr></table></figure>
<h2 id="continue-关键字">continue 关键字</h2>
<p><code>continue</code>用于跳出当前循环，仅能作用于循环结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;当前for循环的第%d次就将会被continue\n&quot;</span>, index);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前for循环的第3次就将会被continue</span></span><br></pre></td></tr></table></figure>
<h2 id="break-关键字">break 关键字</h2>
<p><code>break</code>用于终止整个循环，可用于循环结构以及<code>switch</code>选择结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前for循环仅执行至第%d次就将被break\n&quot;</span>, index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前for循环仅执行至第0次就将被break</span></span><br><span class="line"><span class="comment">// 当前for循环仅执行至第1次就将被break</span></span><br><span class="line"><span class="comment">// 当前for循环仅执行至第2次就将被break</span></span><br></pre></td></tr></table></figure>
<h1 id="使用函数">使用函数</h1>
<p>一个 Linux C 程序通常由一个主函数和若干的其它函数组成，Linux C
当中的函数遵循<strong>先定义后使用</strong>的原则，对于 GCC
编译系统提供的库函数，需要先使用<code>#include</code>指令将头文件包含至源码文件当中，下面伪代码展示了定义一个带参函数的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值数据类型 函数名称( 形式参数类型 形式参数名称, ... ) &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  函数体;</span><br><span class="line">  ... ...</span><br><span class="line">  return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数定义完成之后，就可以通过下面的格式进行函数的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名称(实际参数值);</span><br></pre></td></tr></table></figure>
<p>函数调用后返回结果的数据类型与函数定义中的返回值数据类型一致，如果函数不需要接收<strong>返回值</strong>和<strong>参数</strong>，则必须使用<code>void</code>关键字显式进行定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void 函数名称( void ) &#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其它编程语言不同，Linux C
当中无任何参数的函数<code>function()</code>是指<strong>当前函数的参数个数不确定</strong>，而显式定义了<code>void</code>关键字参数的<code>function(void)</code>才是指<strong>当前函数没有任何参数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125; <span class="comment">// 定义void参数表示该函数不接受任何参数。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  function(<span class="string">&quot;Hank&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">// main.c:5:3: error: too many arguments to function ‘function’</span></span><br><span class="line"><span class="comment">//    function(&quot;Hank&quot;);</span></span><br><span class="line"><span class="comment">//    ^~~~~~~~</span></span><br><span class="line"><span class="comment">// main.c:1:5: note: declared here</span></span><br><span class="line"><span class="comment">//  int function(void) &#123;&#125;</span></span><br><span class="line"><span class="comment">//      ^~~~~~~~</span></span><br></pre></td></tr></table></figure>
<p>因而上面例子中，函数<code>function(void)</code>由于显式定义了<code>void</code>参数，因此
GCC
编译器会报出参数个数过多的错误信息，如果移除函数定义中的<code>void</code>关键字，<code>function()</code>就可以正常通过编译。</p>
<p>同样的，当函数没有返回值时，函数定义中除了返回值类型使用<code>void</code>以外，函数内部也不需要再使用<code>return</code>语句，下面的例子代码定义了一个返回值类型为<code>void</code>并且不具有<code>return</code>语句的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这是一个没有返回值的函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数必须遵循先定义后使用原则，当主函数位于其它函数前面时，必须将其它函数的声明语句放置到主函数之前，确保代码顺序执行时主函数能识别后面声明的函数内容。函数声明有时也被称为<strong>函数原型</strong>，如下两种函数声明方法在
GCC 中都有效：</p>
<ul>
<li><code>返回值数据类型 函数名称( 形式参数类型 );</code></li>
<li><code>返回值数据类型 函数名称( 形式参数类型 形式参数名称 );</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(<span class="type">char</span>[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">(<span class="type">char</span> <span class="built_in">string</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  function1(<span class="string">&quot;这是函数1&quot;</span>);</span><br><span class="line">  function2(<span class="string">&quot;这是函数2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(<span class="type">char</span> <span class="built_in">string</span>[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">string</span>); <span class="comment">// 这是函数1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">(<span class="type">char</span> <span class="built_in">string</span>[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">string</span>); <span class="comment">// 这是函数2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子当中，使用了字符数组作为函数的参数，<strong>Linux C
当中规定使用数组作为函数的实际参数时，函数形式参数得到的将会是该数组首元素的地址</strong>，请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 0x7ffc0c4f6060</span></span><br><span class="line">  function(<span class="built_in">array</span>);           <span class="comment">// 0x7ffc0c4f6060</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正是由于数组作为函数参数时，传递的是数组的首地址；当在接收数组参数的函数内部，对数组进行修改操作之后，将会改变所有引用该数组名称的数组元素内容，这一点需要特别注意。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span>[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  traversal(<span class="built_in">array</span>); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">  function(<span class="built_in">array</span>);</span><br><span class="line">  traversal(<span class="built_in">array</span>); <span class="comment">// 1 2 3 4 100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[])</span> &#123;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">4</span>] = <span class="number">100</span>;</span><br><span class="line">  traversal(<span class="built_in">array</span>); <span class="comment">// 1 2 3 4 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历打印数组内容 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">array</span>[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，使用<strong>数组元素</strong>作为实际参数时，向形式参数变量传递的是数组元素的值。而用<strong>数组名称</strong>作为函数实际参数时，向形式参数(<em>数组名、指针变量</em>)传递的是数组首元素的地址。</p>
<blockquote>
<p>GCC 当中无论编译规范选择 C89/C90 或者 C99 乃至
C11，主函数返回类型是否为<code>int</code>或<code>void</code>以及函数最后是否有<code>return</code>语句，编译都能够正常通过并且没有任何警告信息。</p>
</blockquote>
<h1 id="变量作用域与函数">变量作用域与函数</h1>
<p>函数内定义的变量称为<strong>局部变量</strong>，函数外定义的变量称为<strong>全局变量</strong>，习惯上会将全局变量的<strong>首字母</strong>进行大写处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test = <span class="number">2019</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> test = <span class="number">2006</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;局部变量test的值为%d\n&quot;</span>, test); <span class="comment">// 局部变量test的值为2006</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;全局变量Test的值为%d\n&quot;</span>, Test); <span class="comment">// 全局变量Test的值为2019</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个函数共享一个全局变量，很容易造成数据操作的结果相互污染，因此使用全局变量时需要格外谨慎。</p>
</blockquote>
<p>函数的定义和声明通常都是全局的，但是 Linux C
允许在函数内部再嵌套定义一个函数，类似于局部变量，该函数只能在定义它的那个函数内部有效，因此也可以称为<strong>局部函数</strong>。下面代码当中，主函数<code>main()</code>内部定义了一个<code>inner()</code>并正常调用，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> Test = <span class="number">2019</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是一个引用了局部变量%d的嵌套函数！\n&quot;</span>, Test); <span class="comment">// 这是一个引用了局部变量2019的嵌套函数！</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>局部函数仅在主函数内可见，当在主函数外进行调用时 GCC
编译器会提示语法错误。</p>
</blockquote>
<h1 id="变量存储类型">变量存储类型</h1>
<p>变量的存储方式分为动态（<em>程序运行期间按需动态的进行分配</em>）和静态（<em>程序运行期间由系统固定分配</em>）两种，现代操作系统当中，用户的内存空间一般会分为<strong>程序存储区</strong>、<strong>静态存储区</strong>、<strong>动态存储区</strong>三块区域。</p>
<p><img src="/C&C++/C/variable-storage-structure.png"></p>
<p>用户数据主要放置在动态和静态存储区当中，<strong>静态存储区</strong>主要保存全局变量以及<code>static</code>声明的静态局部变量，程序执行时为其分配存储空间，执行完毕后释放这些空间。程序运行过程中，全局变量占据固定存储单元，无须动态分配与释放。</p>
<p><strong>动态存储区</strong>会在函数开始调用时动态分配存储空间，调用完毕后释放这些存储空间，分配与释放都是伴随函数调用动态进行的。动态存储区存放的数据主要分为以下
3 类：</p>
<ol type="1">
<li>函数的形式参数，调用函数时会为其动态分配存储空间；</li>
<li>函数内声明的自动变量，即未使用<code>static</code>关键字声明的非静态变量。</li>
<li>函数调用时的现场保护和返回地址。</li>
</ol>
<p>GCC
当中的每个<strong>变量</strong>与<strong>函数</strong>都拥有数据类型与存储类型（<em>数据在内存中的存储方式，即静态和动态存储</em>）两个属性，
因此在声明变量与函数时，应当同时声明其数据与存储类型。目前 GCC
支持的存储类型主要包括自动（<em>auto</em>）、静态（<em>static</em>）、寄存器（<em>register</em>）、外部（<em>extern</em>），接下来将会逐一进行介绍。</p>
<h2 id="自动-auto">自动 auto</h2>
<p>Linux C
函数中的局部变量默认为自动存储类型，函数中定义的局部变量和形式参数都属于这个类型，如果需要显式进行声明，可以使用<code>auto</code>关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;显式声明了一个自动变量：%f\n&quot;</span>, pi); <span class="comment">// 显式声明了一个自动变量：3.140000</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态-static">静态 static</h2>
<p>静态局部变量使用<code>static</code>关键字声明，保存在用户内存的静态存储区当中，其值在函数调用结束后并不会释放存储单元；下一次函数调用时，该静态局部变量依然继续保留原值。因为静态局部变量在程序运行过程中占据固定的存储单元，所以缺省赋值的情况下，GCC
编译器会默认赋予相应数据类型的初值（<em>整形变量缺省为<code>0</code>，字符型变量缺省为<code>\0</code>空操作符</em>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  method(); <span class="comment">// method()中静态局部变量index的值为：1</span></span><br><span class="line">  method(); <span class="comment">// method()中静态局部变量index的值为：2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> index = <span class="number">0</span>; <span class="comment">// 程序执行过程中，静态局部变量index的状态将会得到保留</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;method()中静态局部变量index的值为：%d\n&quot;</span>, ++index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>静态局部变量不能被其它函数引用，而只能被变量声明所在的函数使用</strong>。</p>
</blockquote>
<h2 id="寄存器-register">寄存器 register</h2>
<p>传统计算机体系结构里，静态/动态变量都存储在计算机<strong>内存单元</strong>当中，CPU
通过指令集与内存进行交互。为了提高执行效率，可以将一些存取较为频繁的变量放置到
CPU 寄存器当中，GCC
当中可以使用<code>register</code>关键字声明这样的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> tmall = <span class="number">1111</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;声明了一个寄存器变量：%d\n&quot;</span>, tmall); <span class="comment">// 声明了一个寄存器变量：1111</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现代计算机体系结构，CPU
已经可以智能的将常用变量调度至寄存器，而毋需手动再进行声明配置。</p>
</blockquote>
<h2 id="外部-extern">外部 extern</h2>
<p>这里简单总结一下，<code>auto</code>关键字声明的自动变量保存在用户内存的<strong>动态存储区</strong>，<code>static</code>关键字声明的静态局部变量保存在用户内存的<strong>静态存储区</strong>，<code>register</code>关键字声明的寄存器变量保存在
CPU 的<strong>寄存器区</strong>，它们都是<strong>局部变量</strong>。</p>
<p>接下来将要介绍的<code>extern</code>关键字，则主要作用于<strong>全局变量</strong>。一般情况下，全局变量存放在静态存储区的，通常其作用域是从变量定义处至程序文件末尾，在此作用域内的代码都可以引用该全局变量。而通过使用<code>extern</code>关键字，可以方便的扩展全局变量的作用域。</p>
<p>（1）<code>extern</code>可以在一个源码文件内部扩展全局变量的作用域：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">char</span> A, B;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  method(); <span class="comment">// A的小写是a，B的小写是b！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A, B;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A的小写是%c，B的小写是%c！\n&quot;</span>, A, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中，<code>extern</code>关键字扩展了全局变量<code>char A, B;</code>的作用域到<code>main()</code>函数。但是事实上，GCC
已经自带了<strong>全局变量作用域</strong>提升的特性，即使此处不向<code>main()</code>函数当中添加<code>extern</code>关键字，依然能正常编译运行，运行结果与添加<code>extern</code>关键字的情况相同。</p>
<p>（2）<code>extern</code>也可以将一个源码文件内部全局变量的作用域扩展至其它源文件当中：</p>
<p>首先，按照如下目录结构建立源文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  tree</span><br><span class="line">.</span><br><span class="line">├── main.c</span><br><span class="line">└── utils</span><br><span class="line">    └── method.h</span><br></pre></td></tr></table></figure>
<p>向<code>method.h</code>添加如下代码，其中定义了字符类型的全局变量<code>A</code>和<code>B</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="type">char</span> B = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A的小写仍然是%c，B的小写仍然是%c！\n&quot;</span>, A, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面<code>method.h</code>源文件当中定义的变量作用域通过<code>extern</code>关键字扩展至<code>main.c</code>的主函数当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">char</span> A, B;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  method(); <span class="comment">// A的小写仍然是x，B的小写仍然是b！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gcc main.c utils/method.c</code>命令将两个源文件编译为一个可执行文件，输出结果为：<code>A的小写仍然是x，B的小写仍然是b！</code>。</p>
<blockquote>
<p>本源文件中的<code>extern</code>变量优先级高于外部源文件中的<code>extern</code>变量优先级。</p>
</blockquote>
<p>（3）如果需要限制该全局变量仅在本源码文件中使用，那么可以通过<code>static</code>关键字将该<strong>全局变量</strong>声明为<strong>静态</strong>的，这样其它文件中就无法使用<code>extern</code>关键字扩展其作用域，现在将<code>method.c</code>内的全局变量<code>A</code>、<code>B</code>声明为<code>static</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> A = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> B = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A的小写仍然是%c，B的小写仍然是%c！\n&quot;</span>, A, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件<code>main.c</code>保持对全局变量<code>A</code>和<code>B</code>的声明不变，执行后
GCC 报出以下错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">char</span> A, B;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  method(); <span class="comment">// A的小写仍然是a，B的小写仍然是b！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /tmp/cczIQZ43.o：在函数‘main’中：</span></span><br><span class="line"><span class="comment">// main.c:(.text+0x11)：对‘A’未定义的引用</span></span><br><span class="line"><span class="comment">// main.c:(.text+0x18)：对‘B’未定义的引用</span></span><br><span class="line"><span class="comment">// collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是：<strong>局部变量声明<code>static</code>存储类型是为了指定存储区域，而全局变量本身就分配在静态存储区，添加<code>static</code>存储类型只是为了控制其作用域的扩展</strong>。</p>
</blockquote>
<h1 id="函数存储类型">函数存储类型</h1>
<p>函数编写的目的是为了让其它函数调用，因而函数本质上是全局的。但是<strong>根据函数能否被其它源文件中的代码调用</strong>，将函数分为<strong>内部函数</strong>和<strong>外部函数</strong>。</p>
<h2 id="内部函数-static">内部函数 static</h2>
<p>内部函数只能被本源文件当中的代码调用，定义时只需要在函数返回类型之前添加<code>static</code>关键字，因此也称为<strong>静态函数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 返回值数据类型 函数名称(参数列表) &#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部函数在多人协作开发时，可以有效的防止多个源文件中定义的函数名称相互污染。现在将变量存储类型小节的例子程序稍作修改，向<code>utils</code>目录下<code>method.c</code>当中的<code>method()</code>函数添加<code>static</code>关键字，使其成为一个不能被其它源文件中代码调用的内部函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这是一个内部函数，也称为静态函数!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在<code>main.c</code>源文件中声明<code>method()</code>并调用该函数，此时执行<code>gcc main.c utils/method.c</code>编译控制台报出错误信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  method();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /tmp/ccCcRM70.o：在函数‘main’中：</span></span><br><span class="line"><span class="comment">// main.c:(.text+0x15)：对‘method’未定义的引用</span></span><br><span class="line"><span class="comment">// collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<h2 id="外部函数-extern">外部函数 extern</h2>
<p>外部函数可以方便的被其它源文件中的代码调用，Linuc C
当中<strong>函数默认为外部函数</strong>，也可以显式的使用<code>extern</code>关键字进行定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> 返回值数据类型 函数名称(参数列表) &#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在将前面例子中的<code>method()</code>函数显式添加上<code>extern</code>关键字，使其成为一个外部函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这是一个使用extern关键字声明的外部函数!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在<code>main.c</code>中调用该<code>method()</code>外部函数，并执行<code>gcc main.c utils/method.c</code>成功编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  method();  <span class="comment">// 这是一个内部函数，也称为静态函数!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剖析指针">剖析指针</h1>
<p>变量的地址（通过取地址运算符<code>&amp;</code>获得）称为该变量的<strong>指针</strong>，存放地址/指针的变量（使用指针运算符<code>*</code>声明）称为<strong>指针变量</strong>，其声明格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *指针变量名称</span><br></pre></td></tr></table></figure>
<p>指针变量由 Linux C
基本数据类型派生而来，由于每种数据类型的存放方式与占用空间不同，为了确保指针运算能够正确的得到执行，指针变量声明时必须指定其所属数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">short</span> number = <span class="number">2019</span>;                                            <span class="comment">// 定义一个短整型变量，占据2个字节存储空间</span></span><br><span class="line">  <span class="type">short</span> *pointer = &amp;number;                                       <span class="comment">// 声明一个指针类型变量，占据8个字节存储空间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;短整型变量number当前的存储地址是：%p\n&quot;</span>, &amp;number);      <span class="comment">// 短整型变量number当前的存储地址是：0x7ffdba5e89fe</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指定变量pointer存放的指针地址是：%p\n&quot;</span>, pointer);       <span class="comment">// 指定变量pointer存放的指针地址是：0x7ffdba5e89fe</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指定变量pointer自身的存储地址是：%p\n&quot;</span>, &amp;pointer);      <span class="comment">// 指定变量pointer自身的存储地址是：0x7ffdba5e8a00</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指定变量pointer指向地址保存的数据是：%d\n&quot;</span>, *pointer);  <span class="comment">// 指定变量pointer指向地址保存的数据是：2019</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指针类型总是占据%ld个字节存储空间\n&quot;</span>, <span class="keyword">sizeof</span>(pointer)); <span class="comment">// 指针类型总是占据8个字节存储空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于一个已经声明并定义完成的指针变量，使用地址运算符<code>&amp;指针变量名称</code>只能得到该指针变量的地址，而通过指针运算符<code>*指针变量名称</code>则可以获取其保存的真实数据。</p>
</blockquote>
<p>将指针变量作为函数的参数时，传入的实质上是变量的存储地址，因此函数中对该指针变量进行的任何操作，其结果都会反映至该指针实际指向变量的状态，请仔细理解接下面的示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *param)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="type">char</span> symbol = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">  <span class="type">char</span> *pointer = &amp;symbol;</span><br><span class="line">  method(pointer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数指针变量pointer指向的值依然是%c\n&quot;</span>, *pointer); <span class="comment">// 主函数指针变量pointer指向的值依然是U</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *param)</span> &#123;</span><br><span class="line">  *param = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;method()函数参数传入的指针变量被修改为%c\n&quot;</span>, *param); <span class="comment">// method()函数参数传入的指针变量被修改为U</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指向数组的指针">指向数组的指针</h2>
<p>一个数组包含有若干个元素，每个元素都占据着相应存储单元并拥有各自的地址。指针变量即可以指向基本数据类型变量，也可以指向数组中的元素。Linux
C
语言当中，<strong>数组名称就代表数组当中首元素的地址</strong>，请参考下面的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="built_in">array</span>);     <span class="comment">// 0x7fff1d270770</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 0x7fff1d270770</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;<span class="built_in">array</span>[<span class="number">0</span>] == <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组名称array就代表数组当中首元素array[0]的地址\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组指针的运算">数组指针的运算</h3>
<p>当指针指向数组元素时，可以对指针进行加<code>+</code>减<code>-</code>运算（包括自增<code>++</code>自减<code>--</code>运算），此时指针会基于所属数据类型占用的字节数进行前后移动，进而达到通过移动指针来访问数组各个元素的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *pointer = &amp;<span class="built_in">array</span>[<span class="number">3</span>] + <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指针pointer当前指向的数组元素是%d\n&quot;</span>, *pointer); <span class="comment">// 指针pointer当前指向的数组元素是5</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过指针访问数组元素">通过指针访问数组元素</h3>
<p>除了使用传统的下标<code>数组名称[元素位置]</code>访问数组以外，Linux
C 还支持使用指针以<code>*(数组名+元素位置)</code>的形式来进行访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;以下标方式访问数组%d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">5</span>]);     <span class="comment">// 以下标方式访问数组5</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;以指针方式访问数组%d\n&quot;</span>, *(<span class="built_in">array</span> + <span class="number">5</span>)); <span class="comment">// 以指针方式访问数组5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用指针方式访问数组元素，通常会获得更优的执行效率。</p>
</blockquote>
<h3 id="使用数组名称作为函数参数">使用数组名称作为函数参数</h3>
<p>使用数组名称作为函数参数时，由于实际向函数传递的是数组首元素地址，因此函数中对于该数组进行的任何修改，同样也将会反映到原始声明的数组上，这一特性与前面提到的向函数传递基本数据类型指针相似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *param)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;I love this land!&quot;</span>;</span><br><span class="line">  method(<span class="built_in">string</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数中字符类型指针所指向的字符串内容依然为：%s\n&quot;</span>, <span class="built_in">string</span>); <span class="comment">// 主函数中字符类型指针所指向的字符串内容依然为：I love this land!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *pointer = param; <span class="comment">// GCC当中，此处必须显式将指向字符串的字符指针类型形式参数赋值给一个局部变量。</span></span><br><span class="line">  pointer = <span class="string">&quot;I also love this ocean!&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;method()函数将参数传入的字符类型指针变量值修改为：%s\n&quot;</span>, pointer); <span class="comment">// method()函数将参数传入的字符类型指针变量值修改为：I love this land!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指向字符串的指针">指向字符串的指针</h2>
<p><strong>Linux C
语言没有字符串数据类型，字符串都是以字符数组形式保存。</strong>可以通过数组名和下标引用字符串中的字符，或者使用格式字符串<code>%s</code>和数组名称输出整个字符串，也可以通过<strong>字符类型的指针变量</strong>引用一个字符串常量，此时<strong>指针变量保存的是字符串首个字符的地址</strong>，就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> name1[] = <span class="string">&quot;uinika&quot;</span>;                               <span class="comment">// 声明一个字符数组</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;通过数组名打印字符串：%s\n&quot;</span>, name1);              <span class="comment">// 通过数组名打印字符串：uinika</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;通过数组名打印字符串中的一个元素：%c\n&quot;</span>, name1[<span class="number">0</span>]); <span class="comment">// 通过数组名打印字符串中的一个元素：u</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *name2 = <span class="string">&quot;hank&quot;</span>;                                   <span class="comment">// 声明一个字符指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用字符指针打印字符串：%s\n&quot;</span>, name2);              <span class="comment">// 使用字符指针打印字符串：hank</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用字符指针打印字符串中的一个元素：%c\n&quot;</span>, name2[<span class="number">0</span>]); <span class="comment">// 使用字符指针打印字符串中的一个元素：h</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以通过下标<code>[]</code>方便的修改字符串数组中指定元素的值，但是字符指针变量所指向字符串当中的元素值是不可修改的，否则
GCC
编译器将会提示错误信息：<code>[1] 25465 segmentation fault(core dumped)./ a.out</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *pointer = <span class="string">&quot;uinika&quot;</span>;</span><br><span class="line">  pointer[<span class="number">5</span>] = <span class="string">&#x27;H&#x27;</span>;  <span class="comment">// [1] 25465 segmentation fault(core dumped)./ a.out</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pointer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于字符指针变量实际保存的是字符串首元素的地址，因此可以像字符数组一样，通过与整数进行加减运算来完成<strong>字符串截取</strong>功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *pointer = <span class="string">&quot;uinika&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;截取后的字符串结果：%s\n&quot;</span>, pointer + <span class="number">3</span>); <span class="comment">// 截取后的字符串结果：ika</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改进一下上面的代码，让<code>printf()</code>成为一个可变格式输出的函数，也就是将格式字符串声明并定义为一个字符数组，提升代码可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *pointer = <span class="string">&quot;uinika&quot;</span>;</span><br><span class="line">  <span class="type">char</span> format[] = <span class="string">&quot;截取后的字符串结果：%s\n&quot;</span>; <span class="comment">// 这是一个格式字符串变量</span></span><br><span class="line">  <span class="built_in">printf</span>(format, pointer + <span class="number">3</span>); <span class="comment">// 截取后的字符串结果：ika</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符指针与字符数组使用上最显著的区别在于：<strong>字符数组当中元素的值是可以进行修改的，而字符指针变量所指向字符串常量中的元素不可被修改</strong>，否则
GCC
编译时将会提示错误信息<code>[1] 18548 segmentation fault (core dumped) ./a.out</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="built_in">array</span>[] = <span class="string">&quot;uinika&quot;</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">0</span>] = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;将首字母替换为大写：%s\n&quot;</span>, <span class="built_in">array</span>); <span class="comment">// 将首字母替换为大写：Uinika</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pointer = <span class="string">&quot;uinika&quot;</span>;</span><br><span class="line">  pointer[<span class="number">0</span>] = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;截取后的字符串结果：%s\n&quot;</span>, pointer); <span class="comment">// [1]    18548 segmentation fault (core dumped)  ./a.out</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于字符指针变量指向的字符串常量里的元素不能修改，所以当字符指针作为参数传递至其它函数进行处理时，如果重新将一个字符串常量赋值给该字符指针，那么该字符指针将仅仅被作为一个普通的函数局部变量进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *pointer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;I love this land!&quot;</span>;</span><br><span class="line">  method(<span class="built_in">string</span>);</span><br><span class="line">  <span class="comment">// 主函数中字符类型指针所指向的字符串内容依然为：I love this land!</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数中字符类型指针所指向的字符串内容依然为：%s\n&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">(<span class="type">char</span> *pointer)</span> &#123;</span><br><span class="line">  pointer = <span class="string">&quot;I also love this ocean!&quot;</span>;</span><br><span class="line">  <span class="comment">// method()函数将参数传入的字符类型指针变量值修改为：I also love this ocean!</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;method()函数将参数传入的字符类型指针变量值修改为：%s\n&quot;</span>, pointer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子当中，<code>method()</code>函数对传入的字符指针参数<code>pointer</code>重新进行了赋值，但是主函数中<code>string</code>指针所指向的字符串常量并未发生改变。这是由于字符指针总是占有
8
个字节存储空间，保存的总是字符串常量在内存中首个元素的地址。因此，当在<code>method()</code>函数内声明一个字符串常量并赋值给<code>pointer</code>指针的时候，仅仅是改变了形式参数<code>pointer</code>所指向的字符串常量首地址值，而并不会影响主函数中字符指针<code>string</code>所指向的字符串常量地址，因而<code>pointer</code>仅仅被视为一个普通的局部函数。</p>
<h2 id="函数与指针">函数与指针</h2>
<p>GCC 编译器会为 Linux C
函数分配一段存储空间，这段存储空间的起始地址称为<strong>函数的指针</strong>，用来保存函数指针地址的变量称为<strong>函数的指针变量</strong>，声明一个函数指针的具体格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*函数指针名称)(形式参数...)</span><br></pre></td></tr></table></figure>
<p><strong>函数指针变量只能指向其声明时所指定类型的函数</strong>，Linux
C
当中除使用函数名调用函数以外，还可以通过函数指针来进行调用,具体调用格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*函数指针名称)(实际参数...)</span><br></pre></td></tr></table></figure>
<p>通过函数指针调用函数时，必须先让声明的函数指针变量指向该函数，来看下面这个函数指针实际应用的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> integer)</span>;                   <span class="comment">// 函数声明</span></span><br><span class="line">  <span class="type">int</span> (*function)(<span class="type">int</span> integer);              <span class="comment">// 函数指针声明</span></span><br><span class="line">  function = method;                         <span class="comment">// 让函数指针去指向method函数</span></span><br><span class="line">  <span class="type">int</span> value = (*function)(<span class="number">2018</span>);             <span class="comment">// 通过指针变量调用函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;函数method返回结果：%d\n&quot;</span>, value); <span class="comment">// 函数method返回结果：2018</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> integer)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>声明函数指针时，可以缺省函数的参数名称，而只需要保留数据类型，即<code>int (*function)(int integer);</code>亦可以写作<code>int (*function)(int);</code>。</p>
</blockquote>
<p>与前面小节内容提到的数组指针、指向字符串的字符指针不同，函数的指针变量不能进行算术运算，否则
GCC
编译器将提示<code>[1] 23924 segmentation fault (core dumped) ./a.out</code>错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> integer)</span>; <span class="comment">// 函数声明</span></span><br><span class="line">  <span class="type">int</span> (*function)(<span class="type">int</span>);    <span class="comment">// 定义函数指针</span></span><br><span class="line">  function = method;       <span class="comment">// 让函数指针去指向method函数</span></span><br><span class="line">  function += <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> value = (*function)(<span class="number">2018</span>); <span class="comment">// [1]    24115 segmentation fault (core dumped)  ./a.out</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> integer)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针作为参数">函数指针作为参数</h3>
<p>指向函数的指针可以作为其它函数的参数，即将函数的入口地址传递给其它函数的形式参数，以便于在该函数中方便的调用参数指针所指向的那个函数。这样做的好处在于不需要修改主调函数中的任何代码，就可以通过方便的更换传递给它的函数指针参数，替换相应的功能，具体请参考下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">/* 声明函数 */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">addition</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">subtraction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> (*counter)(<span class="type">int</span>, <span class="type">int</span>))</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定义指向函数的指针 */</span></span><br><span class="line">  <span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>) = addition;</span><br><span class="line">  <span class="type">int</span> (*sub)(<span class="type">int</span>, <span class="type">int</span>) = subtraction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用函数并传入函数指针作为参数 */</span></span><br><span class="line">  <span class="type">int</span> result = calculator(add);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;执行加法函数addition的结果：%d\n&quot;</span>, result); <span class="comment">// 执行加法函数addition的结果：4004</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 再次调用函数并传入函数指针作为参数 */</span></span><br><span class="line">  result = calculator(sub);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;执行减法函数subtraction的结果：%d\n&quot;</span>, result); <span class="comment">// 执行减法函数subtraction的结果：-34</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 加法函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addition</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 减法函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtraction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主调函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> (*counter)(<span class="type">int</span>, <span class="type">int</span>))</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> counter(<span class="number">1985</span>, <span class="number">2019</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 Linux
内核源代码当中，大量使用了指向函数的指针作为函数的参数，因而本小节内容是
Linux C 编程开发当中一个较为重要的知识点。</p>
</blockquote>
<h3 id="返回指针值的函数">返回指针值的函数</h3>
<p>Linux C
函数除了返回整型、字符型、浮点类型等基本数据类型以外，还能够返回指针数据类型，即返回一个存储地址值。一个返回指针值的函数定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 *函数名称(形式参数...) &#123;</span><br><span class="line">  <span class="keyword">return</span> 指针类型数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，结合前面章节中提到的指向字符串的字符指针、以及指针作为函数参数的内容，编写一个返回字符类型指针的示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">function</span><span class="params">(<span class="type">char</span> *parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指向字符串的字符指针变量string的地址为：%p\n&quot;</span>, <span class="built_in">string</span>);           <span class="comment">// 指向字符串的字符指针变量string的地址为：0x55869dde8778</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function()函数返回的字符型指针变量地址：%p\n&quot;</span>, function(<span class="built_in">string</span>)); <span class="comment">// function()函数返回的字符型指针变量地址：0x55869dde8778</span></span><br><span class="line"></span><br><span class="line">  (<span class="built_in">string</span> == function(<span class="built_in">string</span>)) ? <span class="built_in">printf</span>(<span class="string">&quot;它们地址相等！\n&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;它们地址不相等！\n&quot;</span>); <span class="comment">// 它们地址相等！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">function</span><span class="params">(<span class="type">char</span> *parameter)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *result = parameter;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针数组">指针数组</h2>
<p><strong>数组元素全部为指针类型</strong>的数组称为<strong>指针数组</strong>，即数组中每个元素都存放的是一个内存地址值，指针数组的定义格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *数组名称[数组长度]</span><br></pre></td></tr></table></figure>
<p>指针数组常用于方便灵活的处理多个字符串，由于字符串本身就是一个字符数组，因此存放有多个字符串的数组本质就是一个二维数组。由于二维数组定义时需要指定列数，每一列包含的元素个数都是相同的，一旦某个字符串的长度过长，就会以该字符串的长度作为每行的长度，从而造成大量内存空间的浪费。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">  <span class="type">char</span> *cities[] = &#123;<span class="string">&quot;guizhou&quot;</span>, <span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;chongqing&quot;</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;指针数组cities占用的存储空间大小为%ld个字节\n&quot;</span>, <span class="keyword">sizeof</span>(cities));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符串%s的指针地址为%p\n&quot;</span>, cities[<span class="number">0</span>], cities[<span class="number">0</span>]); <span class="comment">// 字符串guizhou的指针地址为0x55ff28f727f8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符串%s的指针地址为%p\n&quot;</span>, cities[<span class="number">1</span>], cities[<span class="number">1</span>]); <span class="comment">// 字符串chengdu的指针地址为0x55ff28f72800</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符串%s指针地址为%p\n&quot;</span>, cities[<span class="number">2</span>], cities[<span class="number">2</span>]);   <span class="comment">// 字符串chongqing指针地址为0x55ff28f72808</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中，声明并定义一个字符指针数组，并保存了 3
个字符串常量的首地址。由于指针变量的长度总是为 8
个字节，而且数组本身是连续存储的，因此上面打印的字符串数组内存地址总是按照
8 个字节间隔进行排列。</p>
<h2 id="指针类型数据的指针">指针类型数据的指针</h2>
<p>指向指针的指针，顾名思义就是<strong>指向指针数据类型的指针变量</strong>，可以通过如下格式进行声明和定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 **指针名称;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *cities[] = &#123;<span class="string">&quot;guizhou&quot;</span>, <span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;chongqing&quot;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> **pointer; <span class="comment">// 指向指针数据类型的指针变量</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">3</span>; index++) &#123;</span><br><span class="line">    pointer = cities + index; <span class="comment">// 根据循环索引index逐步移动指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pointer); <span class="comment">// 遍历字符类型指针数组cities当中存储的常量字符串</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到的指针数组的元素不仅可以指向字符串，也可以指向整型或者浮点型等其它数据类型，来看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> numbers[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;                                                                <span class="comment">// 整型数组</span></span><br><span class="line">  <span class="type">int</span> *addresses[<span class="number">10</span>] = &#123;&amp;numbers[<span class="number">0</span>], &amp;numbers[<span class="number">1</span>], &amp;numbers[<span class="number">2</span>], &amp;numbers[<span class="number">3</span>], &amp;numbers[<span class="number">4</span>], &amp;numbers[<span class="number">5</span>]&#125;; <span class="comment">// 基于numbers的元素构建整型指针数组addresses</span></span><br><span class="line">  <span class="type">int</span> **pointer, index;</span><br><span class="line">  pointer = addresses; <span class="comment">// 使pinter指向指针数组address首地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **pointer); <span class="comment">// 打印pointer指向的指针里所保存指针地址所指向的数据</span></span><br><span class="line">    pointer += <span class="number">1</span>;              <span class="comment">// 移动指针到下一个数组元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码由于整型指针数组<code>addresses</code>不像上一个例子中的字符串常量那样，可以自动获取首地址值，因此必须通过取地址运算符<code>&amp;</code>显式的获取地址来构建这个指针数组。</p>
</blockquote>
<h2 id="main-函数的指针参数">main 函数的指针参数</h2>
<p><code>main()</code>函数携带的形式参数<code>(int argc, char *argv[])</code>也称为
Linux C 程序的<strong>命令行参数</strong>，其中第 1
个参数<code>argc</code>是单词<em>argument
count</em>的缩写，表示参数的个数；，第 2
个参数<code>argv</code>是单词<em>argument
vector</em>的缩写，表示参数向量，这是一个字符类型的指针数组，数组中每个元素都指向命令行输入的字符串，即<code>命令 参数1 参数2...</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前参数的个数为%d\n&quot;</span>, argc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前命令行传递的参数值为%s、%s、%s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果，Linux
控制台下编译为默认的<code>a.out</code>文件后执行结果如下，注意打印时将运行<code>a.out</code>文件的命令也作为了输入参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ./a.out hank uinika</span><br><span class="line"></span><br><span class="line">当前参数的个数为3</span><br><span class="line">当前命令行传递的参数值为./a.out、hank、uinika</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实，形式参数<code>argc</code>和<code>argv</code>也可以命名为其它名字，但是出于约定成俗的习惯，建议继续沿用这样的命名方式。</p>
</blockquote>
<h2 id="void-无类型指针">void 无类型指针</h2>
<p>C99
标准提供了<code>void</code>类型的指针，用于定义一个基类型为<code>void</code>的指针变量，即<code>void *变量名</code>。该指针并不指向任何确定的数据类型，只会在使用其它数据类型的指针变量对其进行赋值时，由
GCC
编译系统自动对其进行类型转换。转换后的指针只能得到其它数据类型的纯地址值，并不能自动指向该类型指针之前所引用的数据，任何尝试打印自动类型转换后<code>void</code>指针所引用数据的行为，都将会引发
GCC 的编译警告信息，就如同下面代码这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> number = <span class="number">1985</span>;</span><br><span class="line">  <span class="type">void</span> *pointer = &amp;number;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pointer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main.c: In function ‘main’:</span></span><br><span class="line"><span class="comment">main.c:7:18: warning: dereferencing ‘void *’ pointer</span></span><br><span class="line"><span class="comment">   printf(&quot;%d\n&quot;, *pointer);</span></span><br><span class="line"><span class="comment">                  ^~~~~~~~</span></span><br><span class="line"><span class="comment">main.c:7:18: error: invalid use of void expression</span></span><br><span class="line"><span class="comment">   printf(&quot;%d\n&quot;, *pointer);</span></span><br><span class="line"><span class="comment">                  ^</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>简单修改一下上面的代码，只获取自动类型转换后<code>void</code>指针变量<code>pointer</code>内保存的地址值，代码就可以正常得到执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> number = <span class="number">1985</span>;</span><br><span class="line">  <span class="type">void</span> *pointer = &amp;number;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pointer); <span class="comment">// 0x7fff3988204c</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="null-空类型指针">NULL 空类型指针</h2>
<p>GCC
提供的<code>stdio.h</code>头文件里通过预定义指令<code>#define NULL 0</code>定义了符号常量<code>NULL</code>，如果将其赋值给指针变量，那么就认为该指针变量为<strong>空指针</strong>，保存的变量地址值为<code>00000000</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> number = <span class="number">1985</span>;</span><br><span class="line">  <span class="type">int</span> *pointer = &amp;number;</span><br><span class="line">  pointer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pointer); <span class="comment">// 00000000</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>指针变量值为<code>NULL</code></strong>和<strong>未赋值的指针变量</strong>属于两类概念，前者保存的地址值为<code>00000000</code>，后者则可能指向一个无法预料的值，也就是江湖传说中的<strong>野指针</strong>。</p>
</blockquote>
<h2 id="指针运算">指针运算</h2>
<p>指针变量与整型数据进行加减运算，即将该指针变量值与其所指向变量类型占用的存储单元字节数进行加减运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> universities[<span class="number">2</span>] = &#123;<span class="number">211</span>, <span class="number">985</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *goal = &amp;universities[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(goal + <span class="number">1</span>)); <span class="comment">// 985</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将变量的地址赋值给一个指针，注意不能将一个整数赋值给指针变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> integer = <span class="number">985</span>;</span><br><span class="line">  <span class="type">int</span> *number = &amp;integer; <span class="comment">// 工作正常</span></span><br><span class="line">  <span class="type">int</span> *pointer = <span class="number">0x7fff3967308c</span>; <span class="comment">// 引发GCC编译器警告</span></span><br><span class="line">  <span class="comment">// main.c: In function ‘main’:</span></span><br><span class="line">  <span class="comment">// main.c:6:18: warning: initialization makes pointer from integer without a cast [-Wint-conversion]</span></span><br><span class="line">  <span class="comment">//    int *pointer = 0x7fff3967308c; // 引发GCC编译器警告</span></span><br><span class="line">  <span class="comment">//                   ^~~~~~~~~~~~~~</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变量之间可以相减，得到的差是两个指针变量之间的元素个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *zero = &amp;numbers[<span class="number">0</span>];</span><br><span class="line">  <span class="type">int</span> *four = &amp;numbers[<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *four - *zero); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个指针变量都指向同一个数组的不同元素，则可以进行比较运算，即前面数组元素的指针将会<strong>小于</strong>后面的数组元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *cities[<span class="number">3</span>] = &#123;<span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;zunyi&quot;</span>, <span class="string">&quot;guiyang&quot;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> *chengdu = cities[<span class="number">0</span>];</span><br><span class="line">  <span class="type">char</span> *guiyang = cities[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;贵阳比成都更远吗？%s！\n&quot;</span>, (*chengdu &lt; *guiyang) ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>); <span class="comment">// 贵阳比成都更远吗？是的！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归纳总结">归纳总结</h2>
<ul>
<li>首先需要<strong>明确指针的概念</strong>，指针就是变量的内存地址，凡是出现<strong>指针</strong>的地方都可以使用<strong>地址</strong>进行代替。<strong>变量的指针就是变量的地址，指针变量就是地址变量</strong>。</li>
<li>区别<strong>指针</strong>与<strong>指针变量</strong>，<strong>指针</strong>是指地址值本身，<strong>指针变量</strong>是用来存放这个地址的变量。</li>
<li>明确<strong>指针的指向</strong>所表达的概念，对于指针变量而言，保存的是哪个变量的地址，就认为指针变量指向了这个变量。</li>
<li><code>void</code>是一种特殊类型的指针，并不指向任何特定的数据类型。如果要保存特定数据类型的数据，那么首先要对指针地址进行类型转换（<em>由
GCC 编译器自动转换或由代码强制进行转换</em>）。</li>
<li><strong>指向数组的指针变量</strong>，其保存的实质是该数组的首元素地址，而<strong>指针数组</strong>则是指数组元素全部为指针类型的数组，注意区分这两个不同的概念。</li>
<li>注意分辨<strong>字符数组</strong>与<strong>字符串指针</strong>，字符数组中元素的值可以修改，而字符指针变量所指向字符串常量中的元素不可修改。</li>
<li><strong>无类型指针</strong><code>void</code>不指向任何确定的数据类型，<strong>空指针</strong><code>NULL</code>保存的地址值为<code>00000000</code>，未进行初始化赋值的指针，由于指向不确定的存储区域，因此被称为<strong>野指针</strong>。</li>
</ul>
<h1 id="动态内存分配">动态内存分配</h1>
<p>前面章节介绍过，Linux C
当中的<strong>全局变量</strong>分配在内存中的静态存储区，非静态局部变量（包括形式参数）分配在内存中的动态存储区，这个存储区是一个称为<strong>栈</strong>（<em>stack</em>）的区域。此外，Linux
C
还允许建立一个称为<strong>堆</strong>（<em>heap</em>）的自由动态存储区，用于存放一些临时数据，这些数据毋须在程序声明部分定义，也毋须在函数结束时释放，而是随时按需去申请开辟指定大小的空间，然后再随时手动进行释放。<strong>因为不会在代码中声明和定义相关的变量，所以也就不能通过变量或数组名称引用这些数据，而只能通过指针进行引用</strong>。</p>
<p>内存的动态分配是通过 Linux C
提供的头文件<code>stdlib.h</code>内置的四个标准库函数实现：<code>malloc()</code>、<code>calloc()</code>、<code>free()</code>、<code>realloc()</code>，C99
标准将它们的返回类型定义为<code>void</code>类型，即不指向具体的数据类型，只表示指向一个抽象的纯地址。</p>
<h2 id="void-mallocunsigned-int-size">void *malloc(unsigned int
size)</h2>
<p>用于在内存的动态存储区中分配一个长度为<code>size</code>的连续空间，返回值是所分配存储空间的首字节地址。如果函数由于内存空间不足等原因未能执行成功，那么将会返回一个空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">void</span> *address = <span class="built_in">malloc</span>(<span class="number">16</span>); <span class="comment">// 在动态存储区开辟16字节的存储区域，并返回首地址。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, address);    <span class="comment">// 0x55c638ba7260</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-callocunsigned-n-unsigned-size">void *calloc(unsigned n,
unsigned size)</h2>
<p>用于在内存的动态存储区分配<code>n</code>个长度为<code>size</code>的连续空间，可以用于保存一个<strong>动态数组</strong>。函数返回值同样指向所分配区域的首地址，执行不成功同样返回空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">void</span> *address = <span class="built_in">calloc</span>(<span class="number">4</span>, <span class="number">16</span>); <span class="comment">// 在动态存储区开辟4个16字节的连续存储空间，并返回首地址。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, address); <span class="comment">// 0x55ffbb6b9260</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-freevoid-p">void free(void *p)</h2>
<p>释放<code>void</code>类型指针变量<code>p</code>所指向的动态存储空间，以便于
Linux
操作系统进行回收复用。通常情况下，参数<code>p</code>是<code>malloc()</code>或<code>calloc()</code>函数调用后的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">void</span> *address = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">  <span class="type">void</span> *addresses = <span class="built_in">calloc</span>(<span class="number">8</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(address);</span><br><span class="line">  <span class="built_in">free</span>(addresses);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-reallocvoid-p-unsigned-int-size">void *realloc(void *p,
unsigned int size)</h2>
<p>如果已经通过<code>malloc()</code>或<code>calloc()</code>函数获取动态存储空间，那么可以使用<code>realloc()</code>重新进行存储空间<code>size</code>的分配，执行成功后返回重新分配的地址，如果分配不成功则返回空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">/* 分配一个32字节动态存储空间，并将首地址赋值给void类型指针变量address。 */</span></span><br><span class="line">  <span class="type">void</span> *address = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, address); <span class="comment">// 0x55a5481c7260</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重新分配address占用的动态存储空间，并将重新分配后的存储空间首地址赋予void类型指针变量update。*/</span></span><br><span class="line">  <span class="type">void</span> *update = <span class="built_in">realloc</span>(address, <span class="number">64</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, update); <span class="comment">// 0x55a5481c76a0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realloc()</code>调用后的返回值必须通过声明<code>void</code>类型的指针变量进行接收，否则
GCC
编译器将提示警告信息：<code>warning: ignoring return value of ‘realloc’, declared with attribute warn_unused_result [-Wunused-result]</code>。</p>
<h1 id="typedef-声明">typedef 声明</h1>
<p>除了直接使用各种原生数据类型，Linux C
还支持<code>typedef</code>关键字自定义数据类型，具体使用格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原生数据类型 自定义数据类型</span><br></pre></td></tr></table></figure>
<p>下面的例子当中，我们将通过<code>typedef</code>对原生的数据类型进行重命名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Age; <span class="comment">// 声明整型数据为代表年纪的Date</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125; Date; <span class="comment">// 声明结构体类型为Date</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Array[<span class="number">10</span>]; <span class="comment">// 声明整型数组类型为Array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *Pointer; <span class="comment">//声明字符指针类型为String</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  Age student = <span class="number">33</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, student); <span class="comment">// 33</span></span><br><span class="line"></span><br><span class="line">  Date birthday = &#123;<span class="number">1985</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, birthday.year); <span class="comment">// 1985</span></span><br><span class="line"></span><br><span class="line">  Array ordinal = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ordinal[<span class="number">9</span>]); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">  Pointer input = &amp;c;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *input); <span class="comment">// V</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="预处理指令">预处理指令</h1>
<p>GCC 编译器可以在<strong>预处理阶段</strong>对 Linux C
源代码进行一系列预处理操作，首先会清除代码中的注释，然后对预处理指令（<em>Preprocessing
Directive</em>）进行处理，预处理指令通常以<code>#</code>开头，指令语句后面<strong>没有分号</strong>。经过预处理之后的代码将不再包含相关指令。例如：将<code>#include</code>指令替换为头文件指定的内容，用<code>#define</code>指令指定的值替换代码中引用的位置。</p>
<h2 id="宏定义-define-undef">宏定义 #define #undef</h2>
<p>宏定义主要用于减少代码中一些重复出现常量的书写工作量，宏名称习惯上使用大写字母表示，具体定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名称 宏值</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们编写一个完整的宏定义示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTENCE <span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> regards[] = SENTENCE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, regards); <span class="comment">// Hello World!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，<code>#define</code>指令位于源代码文件开头，有效范围从该指令位置一直覆盖到源文件结束。如果需要，也可以采用另外一个宏定义指令<code>#undef</code>手动终止该宏定义的作用域，其具体使用格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> 待终止作用域范围的宏定义名称</span></span><br></pre></td></tr></table></figure>
<p>修改一下前面的代码，通过添加<code>#undef</code>指令来控制<code>SENTENCE</code>的作用域范围：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTENCE <span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> regards[] = SENTENCE;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> SENTENCE</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, regards); <span class="comment">// Hello World!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：宏定义并非变量，GCC
也不会为其分配存储空间，仅仅是对源代码字符串进行的简单替换。</p>
</blockquote>
<p>上面的宏定义只是定义了一个常量值，如果需要对一个表达式进行宏定义，那么就需要使用到<strong>带参数的宏定义</strong>，具体定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏定义名称(参数列表) 参数的表达式</span></span><br></pre></td></tr></table></figure>
<p>接下来一份完整的示例代码继续走起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDITION(x, y) (x + y)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> result = ADDITION(<span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result); <span class="comment">// 125</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件包含-include">文件包含 #include</h2>
<p>文件包含指令<code>#include</code>用于将其它源代码文件包含至指令所在位置，<strong>一条<code>#include</code>指令只能包含一个源文件，包含多个源文件需要多条<code>#include</code>指令</strong>，其具体使用格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span>  <span class="comment">// 标准方式，在系统目录中查找依赖文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span>  <span class="comment">// 首先在代码所在目录查找，如果未找到再按照标准方式查找。</span></span></span><br></pre></td></tr></table></figure>
<p>现在，在测试代码目录里新建一个<code>utils</code>子文件夹，然后添加一份如下所示的<code>method.c</code>源码文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is a method!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着在上级目录编写<code>main.c</code>主函数，并在其中调用<code>method.c</code>提供的<code>method()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./utils/method.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  method(); <span class="comment">// This is a method!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种书写在源码头部的文件通常被称为<strong>头文件</strong>，里边通常用于放置函数定义、结构体定义、宏定义；头文件后缀名例行使用<code>.h</code>结尾，因此出于规范方面的考量，需要将上面的<code>method.c</code>后缀名修改为<code>method.h</code>，下面展示一份完整的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结构体定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125; date = &#123;<span class="number">1985</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tool</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在<code>main.c</code>主函数当中调用头文件<code>method.h</code>定义的各种值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./utils/method.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">float</span> pi = PI;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, pi); <span class="comment">// 3.140000</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> year = date.year;</span><br><span class="line">  <span class="type">int</span> month = date.month;</span><br><span class="line">  <span class="type">int</span> day = date.day;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d年%d月%d日\n&quot;</span>, year, month, day); <span class="comment">// 1985年8月6日</span></span><br><span class="line"></span><br><span class="line">  tool(); <span class="comment">// Function!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件编译-ifdef-ifndef-if">条件编译 #ifdef #ifndef #if</h2>
<p>正常情况下，一份源代码文件当中的所有代码都会参予编译，但是某些时刻只希望编译代码文件当中的部分内容，此时就需要使用到<strong>条件编译</strong>相关的预定义指令。</p>
<p>（1）如果<code>标识符</code><strong>已经被</strong><code>#define</code>预处理指令定义，那么
GCC
将会预处理<code>代码段 1</code>，否则就会预处理<code>代码段 2</code>。前面有提到：条件编译本质上是一系列宏替换操作，因此预处理后的源文件将只会根据条件保留<code>代码段 1</code>和<code>代码段 2</code>中之一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">  代码段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  代码段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AGE 18 <span class="comment">// 宏定义AGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AGE       <span class="comment">// 如果宏定义AGE存在，</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> AUTH 0 <span class="comment">// 那么宏定义 AUTH = 0 将被预处理并参予编译。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> AUTH 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> permission = AUTH;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前编译的宏定义值：%d\n&quot;</span>, permission); <span class="comment">// 当前编译的宏定义值：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）如果<code>标识符</code><strong>没有被</strong><code>#define</code>预处理指令定义，那么
GCC
将会预处理<code>代码段 1</code>，否则就会预处理<code>代码段 2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">  代码段</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  代码段</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AGE 18 <span class="comment">// 宏定义AGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AGE       <span class="comment">// 如果宏定义AGE不存在，</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> AUTH 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> AUTH 1  <span class="comment">// 那么宏定义 AUTH = 0 将被预处理并参予编译。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> permission = AUTH;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前编译的宏定义值：%d\n&quot;</span>, permission); <span class="comment">// 当前编译的宏定义值：1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）当<code>表达式</code>为真（<em>非零值</em>）时就预处理<code>代码段 1</code>，否则预处理<code>代码段 2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line">  代码段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  代码段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT Linux <span class="comment">// or Windows</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> CURRENT != Windowns <span class="comment">// 如果当前操作系统为Windows</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current OS is Windows\n&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行结果：Current OS is Linux\n&quot;</span>); <span class="comment">// 执行结果：Current OS is Linux</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="位运算">位运算</h1>
<p>位运算是以二进制为对象的运算，<strong>参加位运算的只能为整型或字符型数据，浮点类型数据不能参与位运算</strong>。位运算是嵌入式系统开发当中的常用计算操作，下表列出了
Linux C 当中可以使用的位运算。</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 43%">
<col style="width: 8%">
<col style="width: 38%">
</colgroup>
<thead>
<tr>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">释义</th>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>&amp;</strong></td>
<td style="text-align: left;"><strong>按位与</strong>，例如：<code>a &amp; b</code>。</td>
<td style="text-align: left;"><strong>~</strong></td>
<td style="text-align: left;"><strong>按位取反</strong>，例如：<code>~a</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>│</strong></td>
<td style="text-align: left;"><strong>按位或</strong>，例如：<code>a │ b</code>。</td>
<td style="text-align: left;"><strong>&lt;&lt;</strong></td>
<td style="text-align: left;"><strong>左移</strong>，例如：<code>a &lt;&lt; b</code>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>^</strong></td>
<td style="text-align: left;"><strong>接位异或</strong>，例如：<code>a ^ b</code>。</td>
<td style="text-align: left;"><strong>&gt;&gt;</strong></td>
<td style="text-align: left;"><strong>右移</strong>，例如：<code>a &gt;&gt; b</code>。</td>
</tr>
</tbody>
</table>
<h2 id="按位与">按位与 &amp;</h2>
<p>参予运算的两个数据，按二进制位进行<strong>与</strong>运算，真值表如下：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>0 &amp; 0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1 &amp; 0</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>0 &amp; 1</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1 &amp; 1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
</tbody>
</table>
<p>Linux C 程序当中，前缀<code>0b</code>代表 2
进制数值，前缀<code>0x</code>代表 16 进制数值，无任何前缀的数值默认为 10
进制数值。由于字符类型占用一个字节（<em>1 个 Byte 等于 8 个
bit</em>）空间，因此后面关于位运算的示例代码当中，一律使用<code>unsigned char</code>数据类型来声明二进制数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b00101011</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a); <span class="comment">// 输出16进制结果：0X2B</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）<strong>清零，即将一个字节单元的八位全部置为二进制<code>0</code></strong>。操作方法是将操作数<code>a</code>二进制值当中的<code>1</code>替换为<code>0</code>作为操作数<code>b</code>来参予<strong>与</strong>运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b00101011</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">0b10010100</span>;</span><br><span class="line">  <span class="comment">/*              &amp;   00000000 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a &amp; b); <span class="comment">// 输出16进制结果：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）<strong>获取二进制的指定位</strong>，方法是将操作数<code>a</code>的二进制值当中，<strong>需要获取的位</strong>都置为<code>1</code>，<strong>除需要获取位之外</strong>的所有位都置为<code>0</code>，然后让其参予同操作数的<strong>与</strong>运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">/* 获取操作数 a1 的低 4 位 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a1 = <span class="number">0b00110011</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b1 = <span class="number">0b00001111</span>;</span><br><span class="line">  <span class="comment">/*               &amp;   00000011 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a1 &amp; b1); <span class="comment">// 输出16进制结果：0X3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取操作数 12 的高 4 位 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a2 = <span class="number">0b00110011</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b2 = <span class="number">0b11110000</span>;</span><br><span class="line">  <span class="comment">/*               &amp;   00110000 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a2 &amp; b2); <span class="comment">// 输出16进制结果：0X30</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按位或">按位或 |</h2>
<p>两个操作数对应的二进制位当中，<strong>只要有一个的状态为<code>1</code>，那么运算的结果就是<code>1</code></strong>。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>0 \| 0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1 \| 0</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>0 \| 1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1 \| 1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
</tbody>
</table>
<p>接位或运算通常用来<strong>将操作数的指定位置设为<code>1</code></strong>，方法是将操作数当中需要保持原样的位置设为<code>0</code>，需要指定为<code>1</code>的位置保持<code>1</code>，然后参予同操作数的<strong>或</strong>运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b10101010</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">0b00001111</span>;</span><br><span class="line">  <span class="comment">/*              |   10101111 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a &amp; b); <span class="comment">// 输出16进制结果：0XA</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按位异或">按位异或 ^</h2>
<p>如果参予运算的两个二进制操作数的<strong>对应位异号，那么结果为<code>1</code>；如果对应位同号则结果为<code>0</code></strong>。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>0 ^ 0</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1 ^ 0</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>0 ^ 1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1 ^ 1</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
</tbody>
</table>
<p>（1）<strong>翻转指定的位，即<code>1</code>转换为<code>0</code>，<code>0</code>转换为<code>1</code></strong>。方法是将操作数二进制位当中需要翻转的位置设置为<code>1</code>，其它位置设置为<code>0</code>，然后参予与操作数的<strong>异或</strong>运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b11111001</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">0b00001111</span>;</span><br><span class="line">  <span class="comment">/*            ^   11110110 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a &amp; b); <span class="comment">// 输出16进制结果：0X9</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）
<strong>交换两个变量的取值</strong>，即将操作数<code>a</code>和<code>b</code>进行交叉赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1985</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2019</span>;</span><br><span class="line"></span><br><span class="line">  a = a ^ b;</span><br><span class="line">  b = b ^ a;</span><br><span class="line">  a = a ^ b;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;当前a的值为%d，b的值为%d！\n&quot;</span>, a, b); <span class="comment">// 当前a的值为2019，b的值为1985！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按位取反">按位取反 ~</h2>
<p>按位取反运算符<code>~</code>是一个单目运算符，用来对二进制操作数的每一位进行取反，即<code>1</code>变为<code>0</code>然后<code>0</code>变为<code>1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b11111111</span>;</span><br><span class="line">  <span class="comment">/*              ~   00000000 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = ~a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, b); <span class="comment">// 输出16进制结果：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按位取反可以与其它位运算符结合使用，比如通过和按位与运算符<code>&amp;</code>一起结合使用，可以方便的将操作数的指定位置为<code>0</code>;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b00001111</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = ~<span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*            1     00000011 */</span></span><br><span class="line">  <span class="comment">/*            ~     11111110 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c = a &amp; b;</span><br><span class="line">  <span class="comment">/*            a     00001111 */</span></span><br><span class="line">  <span class="comment">/*            b     11111110 */</span></span><br><span class="line">  <span class="comment">/*            c &amp;   00001110 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出16进制结果：%#X\n&quot;</span>, a &amp; b); <span class="comment">// 输出16进制结果：0XE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按位左移">按位左移 &lt;&lt;</h2>
<p>将操作数的二进制位左移指定位数之后补<code>0</code>。<strong>左移 1
位相当于该数值乘以<code>2</code>，左移 n
位则相当于乘以<code>2ᐢ</code></strong>。按位左移运算比乘法更快，日常开发中需要强调性能的场合，可以考虑将乘以<code>2ᐢ</code>的幂运算替换为左移<code>n</code>位，但是特别注意当操作数二进制所有位都被左移出去之后，最终的结果将会等于<code>0</code>，这并非最终期望的乘法结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b00100000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = a &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*           &lt;&lt; 1   01000000 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*           &lt;&lt; 2   10000000 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> d = a &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/*           &lt;&lt; 3   00000000 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;待操作10进制值：%d，待操作16进制值：%#X\n&quot;</span>, a, a); <span class="comment">// 待操作10进制值：32，待操作16进制值：0X20</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, b, b); <span class="comment">// 输出10进制结果：64，输出16进制结果：0X40</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, c, c); <span class="comment">// 输出10进制结果：128，输出16进制结果：0X80</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, d, d); <span class="comment">// 输出10进制结果：0，输出16进制结果：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按位右移">按位右移 &gt;&gt;</h2>
<p>同样的，按位右移操作符<code>&gt;&gt;</code>是将操作数的二进制位左移指定位数之后补<code>0</code>。<strong>左移
1 位相当于该数值除以<code>2</code>，左移 n
位则相当于除以<code>2ᐢ</code></strong>。当试图使用右移运算代替除法计算时，依然需要注意当操作数所有位都被右移出去之后结果为<code>0</code>的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0b00010000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*           &gt;&gt; 1   00001000 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*           &gt;&gt; 2   00000100 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> d = a &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/*           &gt;&gt; 3   00000010 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e = a &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/*           &gt;&gt; 4   00000001 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> f = a &gt;&gt; <span class="number">5</span>;</span><br><span class="line">  <span class="comment">/*           &gt;&gt; 5   00000000 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;待操作10进制值：%d，待操作16进制值：%#X\n&quot;</span>, a, a); <span class="comment">// 待操作10进制值：16，待操作16进制值：0X10</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, b, b); <span class="comment">// 输出10进制结果：8，输出16进制结果：0X8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, c, c); <span class="comment">// 输出10进制结果：4，输出16进制结果：0X4</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, d, d); <span class="comment">// 输出10进制结果：2，输出16进制结果：0X2</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, e, e); <span class="comment">// 输出10进制结果：1，输出16进制结果：0X1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出10进制结果：%d，输出16进制结果：%#X\n&quot;</span>, f, f); <span class="comment">// 输出10进制结果：0，输出16进制结果：0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>Linux C 标准程序设计语言</p><p><a href="http://www.uinio.com/C&amp;C++/C/">http://www.uinio.com/C&amp;C++/C/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2014-03-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2017-05-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Web/Nodejs/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">NodeJS 快速上手指南</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Web/Scss/"><span class="level-item">SCSS 3.5.5 简明上手指南</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#hello-world"><span class="level-left"><span class="level-item">1</span><span class="level-item">Hello World</span></span></a></li><li><a class="level is-mobile" href="#变量常量常变量"><span class="level-left"><span class="level-item">2</span><span class="level-item">变量、常量、常变量</span></span></a></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">3</span><span class="level-item">数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#整型-int"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">整型 int</span></span></a></li><li><a class="level is-mobile" href="#字符型-char"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">字符型 char</span></span></a></li><li><a class="level is-mobile" href="#浮点型-float"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">浮点型 float</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型转换"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">基本数据类型转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#自动类型转换"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">自动类型转换</span></span></a></li><li><a class="level is-mobile" href="#强制类型转换"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">强制类型转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#布尔类型-bool"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">布尔类型 bool</span></span></a></li><li><a class="level is-mobile" href="#复数类型-complex"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">复数类型 complex</span></span></a></li><li><a class="level is-mobile" href="#数组-array"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">数组 array</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#初始化"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">初始化</span></span></a></li><li><a class="level is-mobile" href="#字符数组"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">字符数组</span></span></a></li><li><a class="level is-mobile" href="#二维数组"><span class="level-left"><span class="level-item">3.7.3</span><span class="level-item">二维数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#结构体-struct"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">结构体 struct</span></span></a></li><li><a class="level is-mobile" href="#共用体-union"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">共用体 union</span></span></a></li><li><a class="level is-mobile" href="#枚举类型-enum"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">枚举类型 enum</span></span></a></li></ul></li><li><a class="level is-mobile" href="#运算符"><span class="level-left"><span class="level-item">4</span><span class="level-item">运算符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#赋值运算符"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">赋值运算符</span></span></a></li><li><a class="level is-mobile" href="#算术运算符"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">算术运算符</span></span></a></li><li><a class="level is-mobile" href="#关系运算符"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">关系运算符</span></span></a></li><li><a class="level is-mobile" href="#逻辑运算符"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">逻辑运算符</span></span></a></li><li><a class="level is-mobile" href="#位运算符"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">位运算符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#选择结构"><span class="level-left"><span class="level-item">5</span><span class="level-item">选择结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#if-结构"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">if 结构</span></span></a></li><li><a class="level is-mobile" href="#switch-结构"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">switch 结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#循环结构"><span class="level-left"><span class="level-item">6</span><span class="level-item">循环结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#while-结构"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">while 结构</span></span></a></li><li><a class="level is-mobile" href="#do-while-结构"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">do while 结构</span></span></a></li><li><a class="level is-mobile" href="#for-结构"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">for 结构</span></span></a></li><li><a class="level is-mobile" href="#continue-关键字"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">continue 关键字</span></span></a></li><li><a class="level is-mobile" href="#break-关键字"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">break 关键字</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用函数"><span class="level-left"><span class="level-item">7</span><span class="level-item">使用函数</span></span></a></li><li><a class="level is-mobile" href="#变量作用域与函数"><span class="level-left"><span class="level-item">8</span><span class="level-item">变量作用域与函数</span></span></a></li><li><a class="level is-mobile" href="#变量存储类型"><span class="level-left"><span class="level-item">9</span><span class="level-item">变量存储类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#自动-auto"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">自动 auto</span></span></a></li><li><a class="level is-mobile" href="#静态-static"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">静态 static</span></span></a></li><li><a class="level is-mobile" href="#寄存器-register"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">寄存器 register</span></span></a></li><li><a class="level is-mobile" href="#外部-extern"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">外部 extern</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数存储类型"><span class="level-left"><span class="level-item">10</span><span class="level-item">函数存储类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内部函数-static"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">内部函数 static</span></span></a></li><li><a class="level is-mobile" href="#外部函数-extern"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">外部函数 extern</span></span></a></li></ul></li><li><a class="level is-mobile" href="#剖析指针"><span class="level-left"><span class="level-item">11</span><span class="level-item">剖析指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#指向数组的指针"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">指向数组的指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数组指针的运算"><span class="level-left"><span class="level-item">11.1.1</span><span class="level-item">数组指针的运算</span></span></a></li><li><a class="level is-mobile" href="#通过指针访问数组元素"><span class="level-left"><span class="level-item">11.1.2</span><span class="level-item">通过指针访问数组元素</span></span></a></li><li><a class="level is-mobile" href="#使用数组名称作为函数参数"><span class="level-left"><span class="level-item">11.1.3</span><span class="level-item">使用数组名称作为函数参数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#指向字符串的指针"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">指向字符串的指针</span></span></a></li><li><a class="level is-mobile" href="#函数与指针"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">函数与指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数指针作为参数"><span class="level-left"><span class="level-item">11.3.1</span><span class="level-item">函数指针作为参数</span></span></a></li><li><a class="level is-mobile" href="#返回指针值的函数"><span class="level-left"><span class="level-item">11.3.2</span><span class="level-item">返回指针值的函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#指针数组"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">指针数组</span></span></a></li><li><a class="level is-mobile" href="#指针类型数据的指针"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">指针类型数据的指针</span></span></a></li><li><a class="level is-mobile" href="#main-函数的指针参数"><span class="level-left"><span class="level-item">11.6</span><span class="level-item">main 函数的指针参数</span></span></a></li><li><a class="level is-mobile" href="#void-无类型指针"><span class="level-left"><span class="level-item">11.7</span><span class="level-item">void 无类型指针</span></span></a></li><li><a class="level is-mobile" href="#null-空类型指针"><span class="level-left"><span class="level-item">11.8</span><span class="level-item">NULL 空类型指针</span></span></a></li><li><a class="level is-mobile" href="#指针运算"><span class="level-left"><span class="level-item">11.9</span><span class="level-item">指针运算</span></span></a></li><li><a class="level is-mobile" href="#归纳总结"><span class="level-left"><span class="level-item">11.10</span><span class="level-item">归纳总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态内存分配"><span class="level-left"><span class="level-item">12</span><span class="level-item">动态内存分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#void-mallocunsigned-int-size"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">void *malloc(unsigned int
size)</span></span></a></li><li><a class="level is-mobile" href="#void-callocunsigned-n-unsigned-size"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">void *calloc(unsigned n,
unsigned size)</span></span></a></li><li><a class="level is-mobile" href="#void-freevoid-p"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">void free(void *p)</span></span></a></li><li><a class="level is-mobile" href="#void-reallocvoid-p-unsigned-int-size"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">void *realloc(void *p,
unsigned int size)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#typedef-声明"><span class="level-left"><span class="level-item">13</span><span class="level-item">typedef 声明</span></span></a></li><li><a class="level is-mobile" href="#预处理指令"><span class="level-left"><span class="level-item">14</span><span class="level-item">预处理指令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#宏定义-define-undef"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">宏定义 #define #undef</span></span></a></li><li><a class="level is-mobile" href="#文件包含-include"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">文件包含 #include</span></span></a></li><li><a class="level is-mobile" href="#条件编译-ifdef-ifndef-if"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">条件编译 #ifdef #ifndef #if</span></span></a></li></ul></li><li><a class="level is-mobile" href="#位运算"><span class="level-left"><span class="level-item">15</span><span class="level-item">位运算</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按位与"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">按位与 &amp;</span></span></a></li><li><a class="level is-mobile" href="#按位或"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">按位或 |</span></span></a></li><li><a class="level is-mobile" href="#按位异或"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">按位异或 ^</span></span></a></li><li><a class="level is-mobile" href="#按位取反"><span class="level-left"><span class="level-item">15.4</span><span class="level-item">按位取反 ~</span></span></a></li><li><a class="level is-mobile" href="#按位左移"><span class="level-left"><span class="level-item">15.5</span><span class="level-item">按位左移 &lt;&lt;</span></span></a></li><li><a class="level is-mobile" href="#按位右移"><span class="level-left"><span class="level-item">15.6</span><span class="level-item">按位右移 &gt;&gt;</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Amplifier/"><img src="/Electronics/Amplifier/logo.png" alt="运算放大器 Op-Amp 基本应用与参数选型"></a></figure><div class="media-content"><p class="date"><time dateTime="2026-02-02T16:00:00.000Z">2026-02-03</time></p><p class="title"><a href="/Electronics/Amplifier/">运算放大器 Op-Amp 基本应用与参数选型</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Math/Decible/"><img src="/Math/Decible/logo.png" alt="电子学单位分贝 dB 数学推导与速查表"></a></figure><div class="media-content"><p class="date"><time dateTime="2026-01-17T16:00:00.000Z">2026-01-18</time></p><p class="title"><a href="/Math/Decible/">电子学单位分贝 dB 数学推导与速查表</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/IEEE1394/"><img src="/Electronics/IEEE1394/logo.png" alt="IEEE1394 FireWire 火线通信协议与 PHY 硬件设计"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-11-21T16:00:00.000Z">2025-11-22</time></p><p class="title"><a href="/Electronics/IEEE1394/">IEEE1394 FireWire 火线通信协议与 PHY 硬件设计</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Cadence-Skill/"><img src="/Electronics/Cadence-Skill/logo.png" alt="Cadence SPB OrCAD/Allegro 设计技巧合集"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-09-27T16:00:00.000Z">2025-09-28</time></p><p class="title"><a href="/Electronics/Cadence-Skill/">Cadence SPB OrCAD/Allegro 设计技巧合集</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/I2C/"><img src="/Electronics/I2C/logo.png" alt="内置集成电路总线协议 I²C 简明指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-09-05T16:00:00.000Z">2025-09-06</time></p><p class="title"><a href="/Electronics/I2C/">内置集成电路总线协议 I²C 简明指南</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8A%AF%E7%89%87/"><span class="tag">芯片</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/"><span class="tag">通信总线</span><span class="tag">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>