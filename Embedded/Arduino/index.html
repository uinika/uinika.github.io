<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>玩转 Arduino Uno Mega 与 UINIO-MCU-ESP32 开源硬件 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Arduino 是一款非常流行与成熟的电子原型评估套件，其 PCB 硬件、IDE 集成开发环境、板级支持包 全部基于开源共享协议，其中，Eagle 原理图以及 PCB 布线遵循 CC BY-SA 共享协议，而 IDE 集成开发环境的源代码基于 GPL 开源协议，微控制器 MCU 的 C&amp;#x2F;C++ 板级支持包则是基于 LGPL 开源协议。自从 2005 年第一款 Arduino 开发板"><meta property="og:type" content="blog"><meta property="og:title" content="玩转 Arduino Uno Mega 与 UINIO-MCU-ESP32 开源硬件"><meta property="og:url" content="http://www.uinio.com/Embedded/Arduino/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="Arduino 是一款非常流行与成熟的电子原型评估套件，其 PCB 硬件、IDE 集成开发环境、板级支持包 全部基于开源共享协议，其中，Eagle 原理图以及 PCB 布线遵循 CC BY-SA 共享协议，而 IDE 集成开发环境的源代码基于 GPL 开源协议，微控制器 MCU 的 C&amp;#x2F;C++ 板级支持包则是基于 LGPL 开源协议。自从 2005 年第一款 Arduino 开发板"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2016-02-15T16:00:00.000Z"><meta property="article:modified_time" content="2021-11-14T16:00:00.000Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Embedded/Arduino/"},"headline":"玩转 Arduino Uno Mega 与 UINIO-MCU-ESP32 开源硬件","image":["http://www.uinio.com/Embedded/Arduino/logo.png"],"datePublished":"2016-02-15T16:00:00.000Z","dateModified":"2021-11-14T16:00:00.000Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO Lab"}}},"description":"Arduino\r 是一款非常流行与成熟的电子原型评估套件，其\r PCB 硬件、IDE 集成开发环境、板级支持包\r 全部基于开源共享协议，其中，Eagle 原理图以及\r PCB 布线遵循 CC BY-SA 共享协议，而 IDE\r 集成开发环境的源代码基于 GPL 开源协议，微控制器 MCU 的\r C&#x2F;C++ 板级支持包则是基于 LGPL\r 开源协议。自从 2005 年第一款 Arduino\r 开发板"}</script><link rel="canonical" href="http://www.uinio.com/Embedded/Arduino/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO Lab</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/my/works.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-02-15T16:00:00.000Z" title="2016/2/16 00:00:00">2016-02-16</time>发表</span><span class="level-item"><time dateTime="2021-11-14T16:00:00.000Z" title="2021/11/15 00:00:00">2021-11-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/">嵌入式固件</a></span><span class="level-item">3 小时读完 (大约28932个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">玩转 Arduino Uno Mega 与 UINIO-MCU-ESP32 开源硬件</h1><div class="content"><p><a target="_blank" rel="noopener" href="https:https://www.arduino.cc/"><strong>Arduino</strong></a>
是一款非常流行与成熟的电子原型评估套件，其
<code>PCB 硬件</code>、<code>IDE 集成开发环境</code>、<code>板级支持包</code>
全部基于开源共享协议，其中，<strong>Eagle</strong> 原理图以及
<strong>PCB</strong> 布线遵循 <strong>CC BY-SA</strong> 共享协议，而 IDE
集成开发环境的源代码基于 <strong>GPL</strong> 开源协议，微控制器 MCU 的
<strong>C/C++</strong> 板级支持包则是基于 <strong>LGPL</strong>
开源协议。自从 2005 年第一款 Arduino
开发板面世以来，官方已经推出了琳琅满目的各类硬件以及软件包，叠加各大芯片厂商的助力，整个开源社区的氛围日趋活跃与丰富。</p>
<p><img src="/Embedded/Arduino/logo.png"></p>
<p>本文首先从入门级的 <strong>Arduino Uno</strong>
入手，然后逐步过渡至片上资源更为丰富的 <strong>Mega
2560</strong>，两款都是由 Arduino 官方所推出的 <code>5V</code>
供电电压的开发板。最后引入了携带有 Wifi/Bluetooth 无线接入能力的
<strong>ESP8266</strong> 和 <strong>ESP32</strong>，而它们则是采用了国产
<code>3.3V</code>
芯片的开发板，由于<code>开源社区</code>或者<code>芯片原厂</code>提供了兼容
Arduino API
的板级支持包，在较为丰富功能的基础上提供了相对低廉的价格，叠加 Arduino
较为成熟的开发环境，更是加速了 Arduino 的应用与普及。</p>
<span id="more"></span>
<h2 id="uno-r3">UNO R3</h2>
<p><strong>Arduino Uno</strong> 是整个 Arduino
家族当中应用最为广泛、文档最为齐全的一款硬件产品，基于 Microchip
微芯公司的 <strong>8</strong> 位 <strong>AVR</strong> 单片机 <a target="_blank" rel="noopener" href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf"><strong>ATmega328P</strong></a>，工作电压为<code>5V</code>，采用<code>16MHz</code>的无源谐振器，并拥有<code>32 KB</code>的
<strong>Flash</strong>
存储器（其中<code>0.5KB</code>用于<code>Bootloader</code>程序），以及<code>2KB</code>的
<strong>SRAM</strong> 和<code>1KB</code>的
<strong>EEPROM</strong>，同时还具备 <strong>14</strong>
个数字输入/输出引脚（其中 <strong>6</strong> 个可以用作 PWM 输出）和
<strong>6</strong> 个模拟输入接口，本文采用的是 2011 年发布的 <a target="_blank" rel="noopener" href="https://store.arduino.cc/usa/arduino-uno-rev3"><strong>Arduino Uno
R3</strong></a> 版本开发板。</p>
<p><img src="/Embedded/Arduino/Uno/0.png"></p>
<p>通常情况下，所有基于 <a target="_blank" rel="noopener" href="https://www.microchip.com/"><strong>Atmel</strong></a>
公司（现已被 Microchip 收购）的 <strong>AVR</strong>
架构的微控制器，都具备有如下 3
种类型的<strong>片上存储空间</strong>：</p>
<ol type="1">
<li><strong>Flash</strong>：程序存储空间，即保存 Arduino Sketch
程序的位置；</li>
<li><strong>SRAM</strong>：静态随机读取存储器，Arduino Sketch
程序运行时建立和操作变量的地方；</li>
<li><strong>EEPROM</strong>：供开发人员通过调用<a target="_blank" rel="noopener" href="https:https://www.arduino.cc/en/Reference/EEPROM">EEPROM
库</a>，从而持久保存数据的空间。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：Flash 和 EEPROM 存储器中的数据可以断电保存，而
SRAM 内的数据则是掉电丢失的。</p>
</blockquote>
<p><strong>Arduino Uno</strong>板载的<a target="_blank" rel="noopener" href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf">ATmega328P</a>微控制器拥有<code>32k Bytes</code>的
<strong>Flash</strong>
存储器（其中<code>0.5k Bytes</code>用于<code>Bootloader</code>），以及<code>2k Bytes</code>的
<strong>SRAM</strong> 和<code>1k Bytes</code>的
<strong>EEPROM</strong>。相比于<strong>Arduino Mega
2560</strong>板载<strong>ATmega2560</strong>微控制器拥有的<code>256k Bytes</code>的
<strong>Flash</strong>
存储器（其中<code>8KB</code>用于<code>Bootloader</code>），以及<code>8k Bytes</code>的
<strong>SRAM</strong> 与<code>4k Bytes</code>的
<strong>EEPROM</strong>。<strong>Arduino Uno</strong>
的存储资源相对要逊色不少，特别是 SRAM
过低将会引发程序执行错误，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;I am Hank&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码执行时，由 9 个字母组成的字符数组将会被放入
SRAM，由于每个字母的 ASCII
码会占用一个<code>Byte</code>，加上最后的<code>\0</code>结束符，那么<code>name[]</code>总共会占用<code>9 + 1 = 10</code>个字节，貌似看起来不多，但是在需要大量显示文本或者进行查表操作的时候，虽然程序能够正常的编译并且上传，但是执行的时候
SRAM 空间将会很快发生溢出，从而导致程序以不可预料的方式执行失败。</p>
<p>综上所述，为了节约宝贵的存储空间，除了尽量采用较小的数据类型以外，还可以将代码中不需要频繁修改的数据通过<a target="_blank" rel="noopener" href="https:https://www.arduino.cc/reference/en/language/variables/utilities/progmem/"><code>PROGMEM</code></a>关键字存放至
Flash 存储器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> PROGMEM dataType variableName[] = &#123;&#125;; <span class="comment">// 优先使用这种格式</span></span><br><span class="line"><span class="type">const</span> dataType variableName[] PROGMEM = &#123;&#125;; <span class="comment">// 或者使用这种格式</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> dataType PROGMEM variableName[] = &#123;&#125;; <span class="comment">// 但是这种格式不被允许</span></span><br></pre></td></tr></table></figure>
<p>将上面字符数组<code>name[]</code>的定义修改为如下格式，就可以确保数据保存至<code>Flash</code>存储器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> PROGMEM <span class="type">char</span> name[] = <span class="string">&quot;I am Hank&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Arduino Uno R3</strong>
开发板的推荐输出电压为<code>7-12V</code>，极限输出电压为<code>6-20V</code>。每个
IO
引脚的输出电流为<code>20mA</code>，而<code>3.3V</code>引脚的输出电流为<code>50mA</code>，其详细的
IO 引脚资源分配示意图如下图所示：</p>
<p><img src="/Embedded/Arduino/Uno/1.png"></p>
<p>Arduino 开发板的 ISCP（电路内串行编程，In-Circuit Serial
Programming）引脚，它们直接与 <strong>ATmega328P</strong>
微控制器连接，分别用于<code>VCC</code>、<code>MISO</code>、<code>MOSI</code>、<code>SCK</code>、<code>GND</code>、<code>RESET</code>功能，其主要用途是通过串行接口向微控制器烧写程序。</p>
<p><img src="/Embedded/Arduino/Uno/2.png"></p>
<blockquote>
<p>注意：由于 Arduino Uno R3 已经内置<code>CH340</code>串口 USB
转换芯片，所以通常直接通过 USB 接口完成烧录，因而 ICSP
引脚较少被使用。</p>
</blockquote>
<p>上述示意图当中各种颜色和图案所表达的意义如下表所示：</p>
<p><img src="/Embedded/Arduino/Uno/3.png"></p>
<h2 id="安装串口驱动">安装串口驱动</h2>
<p>笔者手中的 <a target="_blank" rel="noopener" href="https://store.arduino.cc/usa/arduino-uno-rev3">Arduino Uno R3</a>
属于国产版本，将官方电路设计中用作 USB
转串口用途的<code>ATMEGA16U2</code>芯片替换为了江苏沁恒的<code>CH340G</code>芯片。因而不能再使用
Arduino 官方推荐的驱动程序，而应当安装<a href="http:https://www.wch.cn/products/CH340.html">CH340G
驱动程序</a>，从而确保计算机与开发板的正确连接。</p>
<p><img src="/Embedded/Arduino/Driver/CH340G.png"></p>
<p>安装完成之后，用<code>USB cable type A/B</code>数据线连接开发板与计算机，如果计算机的【设备管理器】当中显示<code>USB-SERIAL CH340 (COMx)</code>，就表示
Arduino 开发板已经连接成功。</p>
<p><img src="/Embedded/Arduino/Driver/Success.png"></p>
<h2 id="arduino-ide">Arduino IDE</h2>
<p>从官方网站下载<a target="_blank" rel="noopener" href="https:https://www.arduino.cc/en/Main/Software">Arduino
IDE</a>并且安装，打开后依次选择<code>【文件 &gt; 示例 &gt; 01.Basics &gt; Blink】</code>：</p>
<p><img src="/Embedded/Arduino/IDE/Step-1.png"></p>
<p>然后再依次点击<code>【工具 &gt; 开发板 &gt; Arduino UNO】</code>选择当前所使用的
Arduino 开发板型号：</p>
<p><img src="/Embedded/Arduino/IDE/Step-2.png"></p>
<p>最后点击<code>【工具 &gt; 端口 &gt; COMx】</code>选择当前开发板所使用的串行端口，由于<code>COM1</code>和<code>COM2</code>通常被计算机保留给内部硬件串行设备值使用，因此外接串行设备的端口号通常会大于或等于<code>COM3</code>：</p>
<p><img src="/Embedded/Arduino/IDE/Step-3.png"></p>
<blockquote>
<p><strong>注意</strong>：如果无法确定当前 Arduino
硬件占用的串行端口号码，可以先拔出 USB 连接线，然后再重新插入，此时 IDE
端口设置中新增加的就是 Arduino 硬件的串口号码。</p>
</blockquote>
<p>接下来，验证当前程序是否存在语法错误，鼠标点击 Arduino IDE
右上角的<code>✔</code>编译验证按钮，或者依次选择菜单栏上的<code>【项目 &gt; 验证/编译】</code>，当然也可以直接按下快捷键<code>【Ctrl + R】</code>：</p>
<p><img src="/Embedded/Arduino/IDE/Step-4.png"></p>
<p>最后，编译并且上传程序至 Arduino 开发板，鼠标点击 Arduino IDE
右上角的<code>➨</code>上传按钮，或者依次选择菜单栏上的<code>【项目 &gt; 上传】</code>，当然也可以直接按下快捷键<code>【Ctrl + U】</code>：</p>
<p><img src="/Embedded/Arduino/IDE/Step-5.png"></p>
<blockquote>
<p><strong>注意</strong>：使用快捷键<code>【Ctrl + U】</code>编译和下载程序，有时候会导致
Arduino IDE 报出 Java
空指针异常，所以建议尽量采用鼠标点击按钮进行编译上传。</p>
</blockquote>
<p>程序上传完成之后将会被 Arduino
开发板自动运行，此时网络标号为<code>L</code>的 LED
将会间隔<code>1</code>秒钟不断闪烁，下面就是本示例里所运行的
<strong>Blink</strong> 的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置函数，只在按下重置或者电源按钮以后被运行一次。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);      <span class="comment">// 初始化数字引脚 LED_BUILTIN 为输出模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环函数，永远循环执行里面的功能代码。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED_BUILTIN, HIGH);   <span class="comment">// 打开 LED，其中的 HIGH 表示高电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 等待 1 秒钟</span></span><br><span class="line">  digitalWrite(LED_BUILTIN, LOW);    <span class="comment">// 关闭 LED，其中的 LOW 表示低电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 等待 1 秒钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：由于 Arduno 官方提供的 IDE
开发体验并不友好，所以可以尝试使用安装有 <a target="_blank" rel="noopener" href="https://platformio.org/">PlatformIO</a> 插件的
<strong>VSCode</strong>，PlatformIO
是一款可以方便应用于各类嵌入式、物联网产品开发的插件，具备跨平台的构建系统和库管理器，并提供了对
<code>Arduino</code>、<code>ARM mbed</code>、<code>ESP8266/ESP32</code>、<code>AVR</code>、<code>RISC-V</code>、<code>STM32</code>、<code>PIC32</code>、<code>nRF51/nRF52</code>、<code>MSP430</code>、<code>MCS-51(8051)</code>、<code>FPGA</code>、<code>FreeRTOS</code>、<code>ESP-IDF</code>、<code>CMSIS</code>、<code>SPL</code>
等众多微控制器的支持。</p>
</blockquote>
<p><img src="/Embedded/Arduino/IDE/PlatformIO.png"></p>
<h2 id="安装第三方类库">安装第三方类库</h2>
<p>Arduino 提供了大量由工程师或者爱好者编写的<a target="_blank" rel="noopener" href="https:https://www.arduino.cc/en/Reference/Libraries">第三方库</a>，选择
Arduino IDE
菜单栏上的<code>【项目 &gt; 加载库 &gt; 管理库...】</code>或是按下【Ctrl
+ Shift + I】快捷键：</p>
<p><img src="/Embedded/Arduino/Installation/0.png"></p>
<p>打开<code>【库管理器】</code>界面，搜索并且选择指定的第三库点击<code>【安装】</code>按钮即可：</p>
<p><img src="/Embedded/Arduino/Installation/1.png"></p>
<p>此外，还可以离线直接安装<code>ZIP</code>格式的第三方库，压缩包的名称即为库的名称，压缩包当中包含
1 份<code>.cpp</code>源文件和 1
份<code>.h</code>头文件，以及一些其它的相关文件。此时选择菜单栏上的<code>【项目 &gt; 加载库 &gt; 添加.zip库...】</code>，然后在弹出的对话框中选择<code>.zip</code>文件即可完成安装：</p>
<p><img src="/Embedded/Arduino/Installation/2.png"></p>
<h2 id="安装板级支持包">安装板级支持包</h2>
<p>自从 Arduino IDE 1.6.2 版本开始，默认会安装所有 AVR
微控制器的核心板级支持包。但是某些第三方厂商生产的 Arduino
开发板需要额外进行安装，此时可以选择菜单栏上的【工具 &gt; 开发板 &gt;
开发板管理器...】：</p>
<p><img src="/Embedded/Arduino/Installation/3.png"></p>
<p>打开【开发板管理器】界面以后，检索需要的板级支持包名称就可以进行添加操作：</p>
<p><img src="/Embedded/Arduino/Installation/4.png"></p>
<p>如果第三方厂商的开发板不在 Arduino
官方的支持列表里面，则再需要选择菜单栏上的<code>【文件 &gt; 首选项 &gt; 附加开发板管理器网址】</code>，然后输入一个指向
JSON 格式配置文件的 URL
地址（如果存在多个可以用逗号<code>,</code>进行分隔），再重新进入<code>【开发板管理器】</code>更新安装所需的支持包即可。</p>
<p><img src="/Embedded/Arduino/Installation/5.png"></p>
<p>如果输入框当中存在多款板级支持包的 URL
地址，那么就可以使用<strong>逗号</strong><code>,</code>进行分隔；或者输入框右侧的按钮，在弹出的文本框当中通过<strong>换行</strong>进行添加：</p>
<p><img src="/Embedded/Arduino/Installation/6.png"></p>
<h2 id="引脚工作模式">引脚工作模式</h2>
<h3 id="数字引脚-digital">数字引脚 Digital</h3>
<p>Arduino
的引脚可以分别配置为<strong>输入</strong>或者<strong>输出</strong>，采用
Atmega 芯片的数字、模拟引脚都可以采用基本相同的方式进行配置。</p>
<h4 id="input-输入">INPUT 输入</h4>
<p>Atmega
芯片的引脚<strong>默认为输入模式</strong>，此时引脚处于<code>high-impedance state</code>高阻抗状态，类似于输入引脚前面串联了一枚<code>100MΩ</code>电阻。这意味着当引脚入处于默认状态或者被配置为<code>pinMode(pin, INPUT)</code>的时候，极易遭到外部干扰。因此
Arduino
官方建议将没有使用的引脚，通过<code>上拉电阻</code>（连接+5V）或者<code>下拉电阻</code>（连接
GND），设置为一个已知的确定状态，这里的电阻建议选取<code>10KΩ</code>阻值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pin_test = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);                   <span class="comment">// 初始化串口，设置波特率为 9600</span></span><br><span class="line">  pinMode(pin_test, INPUT);             <span class="comment">// 初始化引脚为输入 INPUT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> status = digitalRead(pin_test);   <span class="comment">// 读取目标引脚的状态</span></span><br><span class="line">  Serial.println(status);               <span class="comment">// 串口打印状态值</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 循环读取引脚状态的间隔时间为 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将数字引脚 <strong>D5</strong>
设置为<code>INPUT</code>输入模式，然后将 <strong>D5</strong>
用杜邦线分别短接至 Arduino Uno
的<code>3.3V</code>、<code>5V</code>、<code>GND</code>引脚，然后观察串口打印的
<strong>D5</strong>
引脚电平状态，会发现短接至<code>3.3V</code>、<code>5V</code>接口的时候输入状态皆为高电平<code>1</code>，而短接至<code>GND</code>引脚的时候则输入状态为低电平<code>0</code>。</p>
<p><img src="/Embedded/Arduino/Pin/serial-print.png"></p>
<h4 id="input_pullup-上拉输入">INPUT_PULLUP 上拉输入</h4>
<p>Atmega
芯片引脚上内置有<code>20KΩ</code>上拉电阻，调用<code>pinMode(pin, INPUT_PULLUP)</code>函数即可以设置为使能。一旦使能则该引脚行为就会与普通<code>INPUT</code>模式相反，例如：当外接有传感器时，将传感器连接到配置为<code>INPUT_PULLUP</code>模式的引脚，而另一端接入<code>GND</code>，那么当开关断开时该引脚会读取到高电平（由内部上拉电阻拉高），而当开关按下时引脚则会读取到低电平（由于另一端接入了<code>GND</code>），即高电平<code>HIGH</code>关闭传感器，低电平<code>LOW</code>打开传感器。</p>
<blockquote>
<p><strong>注意</strong>：由于上拉电阻的存在，Arduino 引脚可能无法为点亮
LED 提供足够的电流。</p>
</blockquote>
<p>无论当前引脚状态为<code>HIGH</code>或者<code>LOW</code>，上拉电阻的控制都是由微控制器内部的相同寄存器来完成的。因此，如果某个引脚被配置为<code>INPUT_PULLUP</code>上拉电阻接通，如果该引脚随后通过<code>pinMode()</code>切换至<code>OUTPUT</code>，此时该引脚的状态将被设置为<code>HIGH</code>，而再通过<code>pinMode()</code>切换至<code>INPUT</code>，则处于<code>HIGH</code>状态的<code>OUTPUT</code>引脚同样将会使能上拉电阻。这也正是
<strong>Arduino 1.0.1</strong>
之前版本里，可以通过如下代码使能上拉电阻的原因：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pinMode(pin, INPUT);           <span class="comment">// 设置引脚为输入模式</span></span><br><span class="line">digitalWrite(pin, HIGH);       <span class="comment">// 开启上拉电阻</span></span><br></pre></td></tr></table></figure>
<p>下面来编写一段测试代码，将数字引脚 <strong>D13</strong>
设置为上拉输入模式<code>INPUT_PULLUP</code>，此时由于内部上拉电阻的作用，串口打印出的该引脚状态将会总是高电平<code>1</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pin_test = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);                   <span class="comment">// 初始化串口，设置波特率为 9600</span></span><br><span class="line">  pinMode(pin_test, INPUT_PULLUP);      <span class="comment">// 初始化引脚为上拉输入 INPUT_PULLUP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> status = digitalRead(pin_test);   <span class="comment">// 读取目标引脚的状态</span></span><br><span class="line">  Serial.println(status);               <span class="comment">// 串口打印状态值</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 循环读取引脚状态的间隔时间为 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：谨慎考虑将数字引脚 <strong>D13</strong>
用作输入模式，由于该引脚还连接了电阻和 LED
元件，如果使能内置<code>20KΩ</code>上拉电阻，则其电压将会徘徊在<code>1.7V</code>左右，而非预期的<code>5V</code>，这意味着该引脚会始终返回状态<code>LOW</code>。如果必须将该引脚用作数字输入，则需要将其<code>pinMode()</code>设置为<code>INPUT</code>然后再使用一个外置的下拉电阻。</p>
</blockquote>
<h4 id="output-输出">OUTPUT 输出</h4>
<p>Arduino Uno 可以通过<code>pinMode()</code>将 Atmega
芯片的引脚配置为<code>OUTPUT</code>模式，此时引脚处于低阻抗状态（low-impedance
state），这意味着引脚可以为外置电路提供较大的电流（最高可达<code>40mA</code>）。下面的测试代码，用于循环间隔
1 秒输出数字引脚 <strong>D2</strong> 的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pin_test = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);                   <span class="comment">// 初始化串口，设置波特率为 9600</span></span><br><span class="line">  pinMode(pin_test, OUTPUT);            <span class="comment">// 初始化引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(pin_test, HIGH);         <span class="comment">// 输出高电平 HIGH</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 延时 1 秒</span></span><br><span class="line">  printSerial();                        <span class="comment">// 调用串口打印函数</span></span><br><span class="line">  digitalWrite(pin_test, LOW);          <span class="comment">// 输出低电平 LOW</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 等待 1 秒</span></span><br><span class="line">  printSerial();                        <span class="comment">// 调用串口打印函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口打印函数，用于输出当前引脚状态 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSerial</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> status = digitalRead(pin_test);   <span class="comment">// 读取目标引脚的状态</span></span><br><span class="line">  Serial.println(status);               <span class="comment">// 串口打印状态值</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 循环读取状态的间隔时间为 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：将 Arduino
的引脚进行短路或者试图通过其负载大电流设备，都有可能会损坏引脚上的晶体管，甚至烧毁整个
Atmega
芯片。因此为了避免不必要的损失，最好将输出引脚连接至具备<code>470Ω</code>或<code>1kΩ</code>电阻的设备上面。</p>
</blockquote>
<h3 id="模拟引脚-analog">模拟引脚 Analog</h3>
<p>Arduino 板载的 ATmega 微控制器包含 1 个 6 通道<strong>模数转换器
ADC</strong>，该转换器具备 10
位分辨率，可以返回<code>0 ~ 1023</code>之间的整数。除此之外，模拟引脚还具备数字
GPIO
引脚的所有功能，其用作数字用途时功能与数字引脚<code>D0 ~ D13</code>一致。代码当中可以通过别名<code>A0 ~ A5</code>引用模拟引脚，当然也可以将模拟引脚作为数字引脚那样使用。例如，下面代码将模拟引脚<code>A0</code>设置为输出模式<code>OUTPUT</code>，并间隔
1 秒切换其电平状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pin_test = A0;                      <span class="comment">// 模拟引脚 A0 ~ A5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);                   <span class="comment">// 初始化串口，设置波特率为 9600</span></span><br><span class="line">  pinMode(pin_test, OUTPUT);            <span class="comment">// 初始化引脚</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(pin_test, HIGH);         <span class="comment">// 输出高电平 HIGH</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 延时 1 秒</span></span><br><span class="line">  printSerial();                        <span class="comment">// 调用串口打印函数</span></span><br><span class="line">  digitalWrite(pin_test, LOW);          <span class="comment">// 输出低电平 LOW</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 等待 1 秒</span></span><br><span class="line">  printSerial();                        <span class="comment">// 调用串口打印函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口打印函数，用于输出当前引脚状态 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSerial</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> status = digitalRead(pin_test);   <span class="comment">// 读取目标引脚的状态</span></span><br><span class="line">  Serial.println(status);               <span class="comment">// 串口打印状态值</span></span><br><span class="line">  delay(<span class="number">1000</span>);                          <span class="comment">// 循环读取状态的间隔时间为 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟引脚也具有上拉电阻特性，其作用与数字引脚的上拉电阻相同，可以通过如下代码进行启用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pinMode(A0，INPUT_PULLUP); <span class="comment">// 将模拟引脚 0 设置为输入上拉</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：打开上拉电阻会影响<code>analogRead()</code>函数的返回值。</p>
</blockquote>
<p>如果之前已经将引脚设置为<code>OUTPUT</code>输出模式，那么<code>AnalogRead()</code>函数将会无法正常工作，因此，调用该函数之前需要将其设置回<code>INPUT</code>输入模式。同样的，如果该引脚已经被设置为高电平作为输出状态，那么当切换回输入状态时，则需要使能上拉电阻。</p>
<p>ATmega 数据手册警告不要在相近的时间内，让 A/D
通过<code>analogRead()</code>函数访问其它的模拟引脚，否则可能会引起信号的抖动与噪声。正确的做法是在操作模拟引脚（数字模式下）之后，调用<code>analogRead()</code>读取模拟引脚之前，进行一次短暂的延时操作。</p>
<h3 id="脉冲宽度调制-pwm">脉冲宽度调制 PWM</h3>
<p>Arduino IDE 上附带的
<code>文件 &gt; 示例 &gt; 03.Analog &gt; Fade</code>
示例，展示了如何通过<code>analogWrite()</code>函数，以 PWM
模拟输出的方式控制 LED 的淡入淡出（渐亮与渐暗）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ledPin = <span class="number">9</span>;    <span class="comment">// LED 正极连接至数字 D9 引脚，而负极连接到 GND</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 不需要进行任何设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* 淡入，从最暗到最亮，每次增加 5 点亮度 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> fadeValue = <span class="number">0</span> ; fadeValue &lt;= <span class="number">255</span>; fadeValue += <span class="number">5</span>) &#123;</span><br><span class="line">    analogWrite(ledPin, fadeValue);   <span class="comment">// 设置值，范围从 0 ~ 255</span></span><br><span class="line">    delay(<span class="number">30</span>);                        <span class="comment">// 延时 30 毫秒以展示效果</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 淡出，从最亮到最暗，每次减少 5 点亮度 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> fadeValue = <span class="number">255</span> ; fadeValue &gt;= <span class="number">0</span>; fadeValue -= <span class="number">5</span>) &#123;</span><br><span class="line">    analogWrite(ledPin, fadeValue);   <span class="comment">// 设置值，范围从 0 ~ 255</span></span><br><span class="line">    delay(<span class="number">30</span>);                        <span class="comment">// 延时 30 毫秒以展示效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PWM 是指脉冲宽度调制（Pulse Width
Modulation），是一种通过<strong>数字方式</strong>获得<strong>模拟结果</strong>的技术。通过创建数字方波，控制（调制）信号开关状态（<code>5V</code>或者<code>0V</code>）的持续时间（即脉冲宽度），从而获得近似的模拟值，实现
LED 淡入淡出的效果。</p>
<p><img src="/Embedded/Arduino/Pin/PWM.gif"></p>
<p>上面是<code>Fade</code>示例代码的波形示意图，其中<strong>绿线</strong>代表固定的时间间隔，这个时间是
PWM 频率的倒数。换而言之，当 PWM
频率为<code>500Hz</code>的时候，每格绿线间隔就代表<code>2ms</code>毫秒。调用<code>analogWrite()</code>的时间范围为<code>0 ~ 255</code>，那么<code>analogWrite(255)</code>表示占空比为<code>100%</code>（<code>2ms</code>时间内始终打开），而<code>analogWrite(127)</code>则表示占空比为<code>50％</code>（打开约一半时间）。</p>
<p><img src="/Embedded/Arduino/Pin/DSO.gif"></p>
<p>上图为笔者采用数字示波器对<code>Fade</code>示例中的
<strong>D9</strong> 和 <strong>GND</strong>
引脚采样所获得的动态波形图，从动图当中可以看到电平信号的宽度始终处于线性的变化之中。</p>
<h2 id="arduino-c">Arduino C++</h2>
<h3 id="草图">草图</h3>
<p>Arduino IDE 采用 <strong>C++</strong>
作为开发语言，但是裁剪了面向对象以及一些较为复杂的语法特性，然后增加了一些特性关键字，所有源代码都通过称为<code>Sketch [sketʃ] 草图</code>的工程项目进行管理，每份
<strong>Sketch</strong> 包含的代码主要由如下 2 部分组成：</p>
<ul>
<li><code>setup()</code>：主要用于初始化变量与第三方库以及引脚的工作模式，仅会在
Sketch 程序启动的时候执行一次；</li>
<li><code>loop()</code>：放置在<code>setup()</code>函数之后，主要用于放置实际控制
Arduino 开发板的代码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 用于放置设置代码，仅运行一次。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 放置功能代码，无限循环执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<h4 id="整型常量">整型常量</h4>
<p>整型常量就是<code>Sketch</code>代码中直接声明的各种整型数据，默认情况下为
10
进制，但是通过特殊的标识符与格式，可以分别转换为二、八、十六进制。</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 12%">
<col style="width: 20%">
<col style="width: 32%">
</colgroup>
<thead>
<tr>
<th>基数</th>
<th>示例</th>
<th>格式</th>
<th>可用字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>10</code>进制（<strong>D</strong>ecimal）</td>
<td><code>123</code></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td><code>2</code>进制（<strong>B</strong>inary）</td>
<td><code>B1111011</code></td>
<td>字母<code>B</code>前缀</td>
<td><code>0</code>和<code>1</code></td>
</tr>
<tr>
<td><code>8</code>进制（<strong>O</strong>ctal）</td>
<td><code>0173</code></td>
<td>数字<code>0</code>前缀</td>
<td><code>0 - 7</code></td>
</tr>
<tr>
<td><code>16</code>进制（<strong>H</strong>exadecimal）</td>
<td><code>0x7B</code></td>
<td>字母数字<code>0x</code>前缀</td>
<td><code>0 ~ 9</code>、<code>A ~ F</code>、<code>a ~ f</code></td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：<strong>ATmega328P</strong> 属于 8 位 AVR
单片机，所以最多只能表达 8
位二进制数据，即<code>0 ~ 255</code>范围的整型二进制形式。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>后缀<code>u</code>或<code>U</code></td>
<td>将常量强制转换为<code>unsigned</code>数据格式</td>
<td><code>33u</code></td>
</tr>
<tr>
<td>后缀<code>l</code>或<code>L</code></td>
<td>将常量强制转换为<code>long</code>数据格式</td>
<td><code>100000L</code></td>
</tr>
<tr>
<td>后缀<code>ul</code>或<code>UL</code></td>
<td>将常量强制转换为<code>unsigned long</code>数据格式</td>
<td><code>32767ul</code></td>
</tr>
</tbody>
</table>
<h4 id="浮点常量">浮点常量</h4>
<p>浮点常量除了使用小数点<code>.</code>表示以外，还可以采用科学计数法<code>E</code>或<code>e</code>进行表达。</p>
<table>
<thead>
<tr>
<th>整型常量</th>
<th>渲染结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>10.0</code></td>
<td><span class="math inline">\(10\)</span></td>
</tr>
<tr>
<td><code>2.34E5</code></td>
<td><span class="math inline">\(2.34 \times 10^5 = 234000\)</span></td>
</tr>
<tr>
<td><code>67e-12</code></td>
<td><span class="math inline">\(67.0 \times 10^{-12} =
0.000000000067\)</span></td>
</tr>
</tbody>
</table>
<h4 id="布尔常量-true-与-false">布尔常量 true 与 false</h4>
<p>Arduino
分别采用<code>true</code>和<code>false</code>来表达<strong>真</strong>和<strong>假</strong>。</p>
<ul>
<li><code>false</code>：通常被定义为<code>0</code>。</li>
<li><code>true</code>：通常被定义为<code>1</code>，但是任意非零的整数（包括负数）也被认为等效于<code>true</code>。</li>
</ul>
<h4 id="电平状态-high-low">电平状态 HIGH LOW</h4>
<p>常量<code>HIGH</code>和<code>LOW</code>分别用于设置数字引脚的电平状态，其作用与当前引脚的输入<code>INPUT</code>输出<code>OUTPUT</code>状态密切相关：</p>
<ul>
<li><code>HIGH</code>：当引脚处于<code>INPUT</code>模式，调用<code>digitalRead()</code>读取到<code>HIGH</code>意味着当前电平状态高于<code>3.0V</code>，即处于高电平状态。如果调用<code>digitalWrite()</code>将设置为<code>INPUT</code>模式的引脚置为高电平<code>HIGH</code>，这将会使能内部的<code>20KΩ</code>上拉电阻，从而持续向引脚输入高电平状态。当然，使能引脚内部上拉电阻的正确做法是将引用的工作模式设置为<code>INPUT_PULLUP</code>。当引脚处于<code>OUTPUT</code>模式时，调用<code>digitalWrite()</code>将引脚状态置为<code>HIGH</code>，此时引脚向外输出的电压为<code>5V</code>。</li>
<li><code>LOW</code>：当引脚处于<code>INPUT</code>模式，如果此时引脚通过<code>digitalRead()</code>读取的电压低于<code>1.5V</code>就会认为处于低电平<code>LOW</code>。当引脚处于<code>OUTPUT</code>模式，调用<code>digitalWrite()</code>将其状态置为<code>LOW</code>，此时引脚输出电压为<code>0V</code>，同时输出的电流也会变得极小。</li>
</ul>
<h4 id="输入状态-input-output-input_pullup">输入状态 INPUT OUTPUT
INPUT_PULLUP</h4>
<p>如前所述，常量<code>INPUT</code>、<code>OUTPUT</code>、<code>INPUT_PULLUP</code>用于<code>pinMode()</code>函数设置引脚的工作模式。</p>
<h4 id="板载-led_builtin">板载 LED_BUILTIN</h4>
<p>大部份 Arduino 开发板都会存在一个引脚通过一个电阻连接到一枚板载
LED，常量<code>LED_BUILTIN</code>就表示这枚 LED 所连接的引脚编号，大部分
LED 都会连接到第 <strong>13</strong>
号数字引脚，所以通过串口打印该常量将会输出<code>13</code>。</p>
<h3 id="数据类型">数据类型</h3>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 14%">
<col style="width: 47%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">占用存储空间</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/array/">array</a></td>
<td style="text-align: center;"><span class="math inline">\(\frac{sizeof(array)}{sizeof(*array)}\)</span></td>
<td><strong>数组</strong>，包含一系列相同数据类型的元素，可以采用索引进行访问。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/bool/">bool</a></td>
<td style="text-align: center;"><strong>1 Byte</strong>（8bit）</td>
<td><strong>布尔型</strong>，拥有<code>true</code>或<code>false</code>两个值。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/boolean/">boolean</a></td>
<td style="text-align: center;"><strong>1 Byte</strong>（8bit）</td>
<td><strong>布尔型别名</strong>，官方建议代码中使用<code>bool</code>关键字作为数据类型。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/byte/">byte</a></td>
<td style="text-align: center;"><strong>1 Byte</strong>（8bit）</td>
<td><strong>字节型</strong>，用于存储<code>0 ~ 255</code>的 8
位<strong>无符号整数</strong>。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/word/">word</a></td>
<td style="text-align: center;"><strong>2 Byte</strong>（16bit）</td>
<td><strong>单词型</strong>，用于存储 <code>0 ~ 65535</code>
的<strong>无符号整数</strong>。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/char/">char</a></td>
<td style="text-align: center;"><strong>1 Byte</strong>（8bit）</td>
<td><strong>字符型</strong>，用于存储单引号<code>'h'</code>字符，实际保存是其
<strong>ASCII</strong> 编码。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/unsignedchar/">unsigned
char</a></td>
<td style="text-align: center;"><strong>1 Byte</strong>（8bit）</td>
<td><strong>无符号字符型</strong>，其编码为<code>0 ~ 255</code>的数字。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/">char
string[]</a></td>
<td style="text-align: center;"><code>sizeof()</code></td>
<td><strong>字符串</strong>，本质是字符数组，可以使用双引号进行表示<code>char myString[] = "Hank"</code>，结尾会自动添加
ASCII 编码为 <code>\0</code> 的空字符。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/stringobject/">String
类</a></td>
<td style="text-align: center;"><code>length()</code></td>
<td><strong>字符串对象</strong>，可以通过 <code>String()</code>
构造函数创建一个 <code>String</code>
类，该类拥有诸多便捷的字符串处理函数。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/float/">float</a></td>
<td style="text-align: center;"><strong>4 Byte</strong>（32bit）</td>
<td><strong>浮点型</strong>，用于保存小数，注意数据类型转换时会损失精度。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/double/">double</a></td>
<td style="text-align: center;"><strong>4 Byte</strong>（32bit）</td>
<td><strong>双精度浮点型</strong>，在 Arduino Due 上面占用 <strong>8
Byte</strong>（64bit）。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/int/">int</a></td>
<td style="text-align: center;"><strong>2 Byte</strong>（16bit）</td>
<td><strong>整型</strong>，在 Arduino Due 上面占用 <strong>4
Byte</strong>（32bit）。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/unsignedint/">unsigned
int</a></td>
<td style="text-align: center;"><strong>2 Byte</strong>（16bit）</td>
<td><strong>无符号整型</strong>，只存储正整数，与普通整型区别在于符号位的处理，在
Arduino Due 上占用 <strong>4 Byte</strong>（32bit）。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/short/">short</a></td>
<td style="text-align: center;"><strong>2 Byte</strong>（16bit）</td>
<td><strong>短整型</strong>。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/long/">long</a></td>
<td style="text-align: center;"><strong>4 Byte</strong>（32bit）</td>
<td><strong>长整型</strong>。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/unsignedlong/">unsigned
long</a></td>
<td style="text-align: center;"><strong>4 Byte</strong>（32bit）</td>
<td><strong>无符号长整型</strong>，用于存储范围更大的正整数。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/size_t/">size_t</a></td>
<td style="text-align: center;">-</td>
<td>一种以字节（Byte）来表示任意对象大小的数据类型，也是<code>sizeof()</code>和<code>Serial.print()</code>的返回值类型。</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/void/">void</a></td>
<td style="text-align: center;">-</td>
<td>仅仅用于函数声明，表示当前函数没有任何返回信息。</td>
</tr>
</tbody>
</table>
<h3 id="数据类型转换">数据类型转换</h3>
<p>可以对下面表格当中指定的数据类型，执行<strong>强制数据类型转换</strong>操作：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 9%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th>Arduino 风格</th>
<th>标准 C 风格</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(unsigned int)x</code></td>
<td>-</td>
<td>强制转换为<strong>无符号普通整型</strong>。</td>
</tr>
<tr>
<td><code>(unsigned long)x</code></td>
<td>-</td>
<td>强制转换为<strong>无符号长整型</strong>。</td>
</tr>
<tr>
<td><code>byte(x)</code></td>
<td><code>(byte)x</code></td>
<td>强制转换为<strong>字节型</strong>。</td>
</tr>
<tr>
<td><code>char(x)</code></td>
<td><code>(char)x</code></td>
<td>强制转换为<strong>字符型</strong>。</td>
</tr>
<tr>
<td><code>float(x)</code></td>
<td><code>(float)x</code></td>
<td>强制转换为<strong>浮点型</strong>。</td>
</tr>
<tr>
<td><code>int(x)</code></td>
<td><code>(int)x</code></td>
<td>强制转换为<strong>普通整型</strong>。</td>
</tr>
<tr>
<td><code>long(x)</code></td>
<td><code>(long)x</code></td>
<td>强制转换为<strong>长整型</strong>。</td>
</tr>
<tr>
<td><code>word(x, h/l)</code></td>
<td><code>(word)x</code></td>
<td>当第 2
个参数为<code>h</code>表示取<code>word</code>的最<strong>左</strong>侧<strong>高</strong>位字节，为<code>l</code>则是取最<strong>右</strong>侧的<strong>低</strong>位字节。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：通过原生的<code>String()</code>函数还能够将不同类型的数据构造为一个<code>String</code>类实例，具体请参考本文【核心库函数】章节下的<a href="#字符串">【<strong>字符串</strong>】</a>小节：</p>
</blockquote>
<p>下面总结了一下 Arduino 开发实践当中一些常用的数据类型转换技巧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 String 对象转换为字符 Char 数组 */</span></span><br><span class="line">String object = <span class="string">&quot;www.uinika.com&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];         <span class="comment">// 防止局部变量被销毁</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, object.c_str());  <span class="comment">// 将转换之后的字符数组拷贝至 buffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将参数 2022 按照 format 转换成格式为 %ld 长度为 SIZE 的字符数组 string */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (100)</span></span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[SIZE];</span><br><span class="line"><span class="built_in">snprintf</span>(<span class="built_in">string</span>, SIZE, <span class="string">&quot;%ld&quot;</span>, <span class="number">2022</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先将字符串转换为字符数组 characters，然后再将其强制转换为无符号字符数组 result */</span></span><br><span class="line"><span class="type">char</span> characters[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(characters, String(<span class="string">&quot;www.uinika.cn&quot;</span>).c_str());</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *result = (<span class="type">unsigned</span> <span class="type">char</span> *)characters;</span><br></pre></td></tr></table></figure>
<h3 id="运算符-操作符">运算符 &amp; 操作符</h3>
<h4 id="sizeof">sizeof()</h4>
<p><code>sizeof(variable)</code>
操作符用于返回参数变量所占据的字节数，返回值的数据类型为
<code>size_t</code>。由于可以方便的调整数组大小，该操作符在处理数组或者字符串时非常有用，下面的示例程序将会逐次向串口打印一个字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> myString[] = <span class="string">&quot;www.uinika.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (byte i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(myString) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(i, DEC);</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">write</span>(myString[i]);</span><br><span class="line">    Serial.<span class="built_in">println</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>);  <span class="comment">// 放慢程序的运行速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>sizeof()</code> 返回的是数组或者字符串的总字节数，对于诸如
<code>int</code> 这样更大数据类型的数组，可以采用下面这种方式来处理
<code>for</code> 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int years[] = &#123;2019, 2020, 2021&#125;;</span><br><span class="line"></span><br><span class="line">/* 对于任何类型或大小的数组，这个for循环都可以正常工作 */</span><br><span class="line">for (byte i = 0; i &lt; (sizeof(years) / sizeof(years[0])); i++) &#123;</span><br><span class="line">  // 针对 years[i] 进行一些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注释">注释</h4>
<table>
<colgroup>
<col style="width: 45%">
<col style="width: 3%">
<col style="width: 45%">
<col style="width: 4%">
</colgroup>
<thead>
<tr>
<th>注释</th>
<th>功能描述</th>
<th>注释</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/further-syntax/blockcomment/">/*
... */</a></td>
<td>块注释；</td>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/further-syntax/singlelinecomment/">//
...</a></td>
<td>单行注释；</td>
</tr>
</tbody>
</table>
<h4 id="流程控制">流程控制</h4>
<table>
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr>
<th>流程控制</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/while/">while</a></td>
<td>连续进行循环，直至参数当中的表达式执行结果变为 <code>false</code>
为止。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/dowhile/">do...while</a></td>
<td>工作方式与 <code>while</code>
循环相同，但会在循环结束的时候进行一次判断，所以这种循环至少会被执行一次。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/if/">if</a></td>
<td>检查判断条件，如果为 <code>true</code>
就执行内部的语句，否则就会绕开这些语句。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/else/">else</a></td>
<td>通常与 <code>if</code> 语句搭配使用，如果 <code>if</code>
语句的条件为 <code>false</code>，就会执行 <code>else</code>
子句，从而实现对多个判断条件的分组；</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/for/">for</a></td>
<td>用于循环执行花括号 <code>&#123;&#125;</code> 当中的循环体语句。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/switchcase/">switch...case</a></td>
<td>将 <code>switch</code> 语句的变量值与 <code>case</code>
语句中指定的值进行比较，如果匹配就会执行这个 <code>case</code>
语句当中的代码。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/break/">break</a></td>
<td>退出 <code>for</code> 和 <code>while</code>、<code>do…while</code>
循环， 以及 <code>switch case</code> 语句。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/continue/">continue</a></td>
<td>跳出本次 <code>for</code> 和
<code>while</code>、<code>do…while</code> 循环。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/return/">return</a></td>
<td>终止函数的执行，并且返回函数的执行结果。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/control-structure/goto/">goto</a></td>
<td>跳转程序的运行流程到指定的标记点。</td>
</tr>
</tbody>
</table>
<h4 id="预编译">预编译</h4>
<table>
<colgroup>
<col style="width: 57%">
<col style="width: 42%">
</colgroup>
<thead>
<tr>
<th>预编译</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/further-syntax/define/">#define()</a></td>
<td>在编译之前赋予常量一个引用，编译器会在编译时用常量值替换对这些引用。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/further-syntax/include/">#include()</a></td>
<td>用于在 Arduino 草图当中包含外部的库文件。</td>
</tr>
</tbody>
</table>
<h4 id="数学运算符">数学运算符</h4>
<table>
<colgroup>
<col style="width: 47%">
<col style="width: 3%">
<col style="width: 45%">
<col style="width: 3%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">数学运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">数学运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/remainder/">A
% B</a></td>
<td style="text-align: center;">取余</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/subtraction/">A
- B</a></td>
<td style="text-align: center;">减法</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/multiplication/">A
* B</a></td>
<td style="text-align: center;">乘法</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/division/">A
/ B</a></td>
<td style="text-align: center;">除法</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/addition/">A
+ B</a></td>
<td style="text-align: center;">加法</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/arithmetic-operators/assignment/">A
= B</a></td>
<td style="text-align: center;">赋值</td>
</tr>
</tbody>
</table>
<h4 id="比较运算符">比较运算符</h4>
<table>
<colgroup>
<col style="width: 45%">
<col style="width: 4%">
<col style="width: 46%">
<col style="width: 4%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">比较运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">比较运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/notequalto/">A
!= B</a></td>
<td style="text-align: center;">不等于</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/equalto/">A
== B</a></td>
<td style="text-align: center;">等于</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/lessthan/">A
&lt; B</a></td>
<td style="text-align: center;">小于</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/greaterthan/">A
&gt; B</a></td>
<td style="text-align: center;">大于</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/lessthanorequalto/">A
&lt;= B</a></td>
<td style="text-align: center;">小于或等于</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/comparison-operators/greaterthanorequalto/">A
&gt;= B</a></td>
<td style="text-align: center;">大于或等于</td>
</tr>
</tbody>
</table>
<h4 id="布尔运算符">布尔运算符</h4>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 14%">
<col style="width: 18%">
<col style="width: 14%">
<col style="width: 18%">
<col style="width: 14%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">布尔运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">布尔运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">布尔运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a href>! A</a></td>
<td style="text-align: center;">逻辑非</td>
<td style="text-align: center;"><a href>A &amp;&amp; B</a></td>
<td style="text-align: center;">逻辑与</td>
<td style="text-align: center;"><a href>A ∥ B</a></td>
<td style="text-align: center;">逻辑或</td>
</tr>
</tbody>
</table>
<h4 id="指针运算符">指针运算符</h4>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 7%">
<col style="width: 38%">
<col style="width: 15%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">指针运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">指针运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/pointer-access-operators/reference/">&amp;
A</a></td>
<td style="text-align: center;">获取变量 <code>A</code> 的地址</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/pointer-access-operators/dereference/">*
A</a></td>
<td style="text-align: center;">获取指针变量 <code>A</code>
所指向的地址当中包含的值</td>
</tr>
</tbody>
</table>
<h4 id="位运算符">位运算符</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 41%">
<col style="width: 14%">
<col style="width: 40%">
<col style="width: 3%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">位运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">位运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwiseand/">A
&amp; B</a></td>
<td style="text-align: center;">按位与</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwisexor/">A
^ B</a></td>
<td style="text-align: center;">按位异或</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitshiftleft/">A
&lt;&lt; n</a></td>
<td style="text-align: center;">左移 <code>n</code> 位，空位用二进制
<code>0</code> 填充</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwiseor/">A
〡 B</a></td>
<td style="text-align: center;">按位或</td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitshiftright/">A
&gt;&gt; n</a></td>
<td style="text-align: center;">右移 <code>n</code> 位，空位用二进制
<code>0</code> 填充</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/bitwise-operators/bitwisenot/">~
A</a></td>
<td style="text-align: center;">按位取反</td>
</tr>
</tbody>
</table>
<h4 id="复合运算符">复合运算符</h4>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 13%">
<col style="width: 36%">
<col style="width: 14%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">复合运算符</th>
<th style="text-align: center;">功能描述</th>
<th style="text-align: center;">复合运算符</th>
<th style="text-align: center;">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/increment/">A++</a></td>
<td style="text-align: center;">对 <code>A</code> 进行递增</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundmultiplication/">A
*= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
相乘，然后再赋值给 <code>A</code></td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/decrement/">A--</a></td>
<td style="text-align: center;">对 <code>A</code> 进行递减</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundsubtraction/">A
-= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
相减，然后再赋值给 <code>A</code></td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundremainder/">A
%= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
取余，然后再赋值给 <code>A</code></td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compounddivision/">A
/= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
相除，然后再赋值给 <code>A</code></td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundbitwiseand/">A
&amp;= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
按位与，然后再赋值给 <code>A</code></td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundbitwisexor/">A
^= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
按位异或，然后再赋值给 <code>A</code></td>
</tr>
<tr>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundaddition/">A
+= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
相加，然后再赋值给 <code>A</code></td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/structure/compound-operators/compoundbitwiseor/">A
〡= B</a></td>
<td style="text-align: center;">首先 <code>A</code> 与 <code>B</code>
按位或，然后再赋值给 <code>A</code></td>
</tr>
</tbody>
</table>
<h3 id="变量限定符">变量限定符</h3>
<p>Arduino C++
依然允许声明<strong>全局变量</strong>（代码文件全局可见）或者<strong>局部变量</strong>（仅在声明它们的函数中可见）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global = <span class="number">2020</span>;                 <span class="comment">// 全局变量，对于所有函数可见</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 初始化串口，设置波特率为 9600</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> local = <span class="number">2019</span>;                <span class="comment">// 局部变量，仅在函数内部可见</span></span><br><span class="line">  Serial.println(global);          <span class="comment">// 串口输出全局变量</span></span><br><span class="line">  Serial.println(local);           <span class="comment">// 串口输出局部变量</span></span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const">const</h4>
<p>关键字<code>const</code>用于声明一个<strong>只读</strong>的常量，修改其值将会引发编译器错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">pi = <span class="number">7</span>;     <span class="comment">// 非法，不能修改一个常量</span></span><br></pre></td></tr></table></figure>
<h4 id="static">static</h4>
<p>关键字<code>static</code>用于声明一个<strong>静态局部变量</strong>，其值在函数调用结束后并不会释放存储单元；下一次函数调用时，该静态局部变量依然继续保留原来的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  test();   <span class="comment">// 静态局部变量index的值为 1</span></span><br><span class="line">  test();   <span class="comment">// 静态局部变量index的值为 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  Serial.println(++index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Embedded/Arduino/Data-Type/static.png"></p>
<h4 id="volatile">volatile</h4>
<p>关键字<code>volatile [ˈvɒlətaɪl] 不稳定物质</code>用于指示 Arduino
编译器从 <strong>RAM</strong>
加载变量，而非从存储寄存器（存储与操作程序变量的临时内存区域）当中。因为在某些情况下，存储在寄存器中的变量值可能不准确。当一个变量可以被其所处代码块之外的代码修改时，就应该将其声明为<code>volatile</code>，Arduino
里出现这种情况的地方，主要是在<strong>中断服务程序</strong>当中。</p>
<p>如果声明为<code>volatile</code>的变量超过一个字节（例如是一个 16
位的整型或者 32 位的长整型数据），那么 Arduino Uno 的 8
位微控制器将无法一次性完成读取。所以程序的主代码（例如<code>loop()</code>函数）读取<code>volatile</code>变量的<strong>第一个</strong>
8 位的时候，此时中断服务函数可能已经对<strong>第二个</strong> 8
位进行了修改，从而产生一个错误的结果。解决这个问题，需要在主代码读取<code>volatile</code>变量时，通过<code>noInterrupts()</code>函数或者<code>ATOMIC_BLOCK</code>宏禁用中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当中断引脚状态改变的时候切换 LED 的亮灭 */</span></span><br><span class="line"><span class="type">int</span> pin = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">volatile</span> byte state = LOW;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(pin, OUTPUT);      <span class="comment">// 设置第 13 引脚为输出模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 添加数字引脚 2 的中断事件，设置 blink 为中断服务函数，引脚状态发生改变时触发 */</span></span><br><span class="line">  attachInterrupt(digitalPinToInterrupt(<span class="number">2</span>), blink, CHANGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(pin, state);  <span class="comment">// 向第 13 引脚写入状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blink</span><span class="params">()</span> &#123;</span><br><span class="line">  state = !state;            <span class="comment">// 状态值取反</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个库包含了 ATOMIC_BLOCK 宏 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;util/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> input_from_interrupt;     <span class="comment">// 声明 volatile 变量</span></span><br><span class="line"></span><br><span class="line">ATOMIC_BLOCK(ATOMIC_RESTORESTATE) &#123;</span><br><span class="line">  <span class="type">int</span> result = input_from_interrupt;   <span class="comment">// 中断被阻塞的代码，连续的原子操作不会发生中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="progmem">PROGMEM</h4>
<p>如前所述，关键字<code>PROGMEM</code>用于将变量保存在
<strong>Flash</strong> 存储器，而非 <strong>SRAM</strong>
存储器当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  <span class="type">const</span> PROGMEM <span class="type">char</span> name[] = <span class="string">&quot;I am Hank&quot;</span>;   <span class="comment">// 将字符串保存至 Flash 存储器</span></span><br><span class="line">  Serial.println(name);                      <span class="comment">// 串口输出保存在 Flash 里的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Embedded/Arduino/Data-Type/PROGMEM.png"></p>
<h3 id="数组处理">数组处理</h3>
<p>Arduino C++ 的数组语法与标准 C 语言完全相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> test[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> test[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">-8</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">char</span> test[<span class="number">7</span>] = <span class="string">&quot;uinika&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：声明数组长度时，需要增加 1 个结束符。</p>
</blockquote>
<p>数组的遍历与标准 C
语言也是一样的，下面代码将会循环向串口输出<code>"uinika"</code>字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  <span class="type">char</span> name[<span class="number">7</span>] = <span class="string">&quot;uinika&quot;</span>;         <span class="comment">// 声明字符串或字符数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    Serial.println(name[i]);       <span class="comment">// 串口遍历输出字符串上的每个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意，采用双引号<code>""</code>声明字符数组时，系统会自动在最后为其分配一个空操作符<code>\0</code>作为结束标志。</p>
<p><img src="/Embedded/Arduino/Data-Type/array-traversal.png"></p>
<p>此外，数组的长度可以调用原生提供的<code>sizeof()</code>函数进行返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  <span class="type">char</span> name[] = <span class="string">&quot;uinika&quot;</span>;          <span class="comment">// 声明字符串或者字符数组</span></span><br><span class="line">  Serial.println(<span class="keyword">sizeof</span>(name));   <span class="comment">// 串口输出字符数组长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Embedded/Arduino/Data-Type/length.png"></p>
<h2 id="核心库函数">核心库函数</h2>
<h3 id="数字-io">数字 I/O</h3>
<table>
<thead>
<tr>
<th>
数字 I/O
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/digital-io/pinmode/">pinMode(pin,
mode)</a>
</td>
<td>
配置引脚的工作模式。参数<code>pin</code>是引脚数。 <br> ▶
参数<code>mode</code>：可以选择<code>INPUT</code>（输入）、<code>OUTPUT</code>（输出）、<code>INPUT_PULLUP</code>（输入上拉）；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/digital-io/digitalread/">digitalRead(pin)</a>
</td>
<td>
从指定数字引脚读取当前的电平状态，可以是<code>HIGH</code>或者<code>LOW</code>。
<br> ▶ 参数<code>pin</code>：需要读取状态的引脚编号； <br> ▶
返回值：<code>HIGH</code>或者<code>LOW</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/digital-io/digitalwrite/">digitalWrite(pin,
value)</a>
</td>
<td>
将<code>HIGH</code>或<code>LOW</code>状态写入指定的数字引脚。 <br> ▶
参数<code>pin</code>：需要写入的引脚编号； <br> ▶
参数<code>value</code>：<code>HIGH</code>或者<code>LOW</code>； <br> ▶
返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="模拟-io">模拟 I/O</h3>
<table>
<thead>
<tr>
<th>
模拟 I/O
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/analog-io/analogread/">analogRead(pin)</a>
</td>
<td>
从指定的模拟引脚读取数值，Arduino Uno 包含一个多通道的 10
位模数转换器，能够将<code>0V ~ 5V</code>映射为<code>0 ~ 1023</code>的整数值，其中每个单元所表示的电压为
<span class="math inline">\(\frac{5V}{1024} \approx 0.0049V = 4.9
mV\)</span>；读取一次模拟输入需要消耗<code>100</code>微秒（即<code>0.0001</code>秒），因此读取模拟输入的最大频率为<code>10000</code>次/秒。
<br> ▶ 参数<code>pin</code>：需要进行读取操作的模拟引脚编号； <br> ▶
返回值：<code>0 ~ 1023</code>之间的整数值； <br> ▶
当模拟输入引脚没有任何连接时，调用<code>analogRead()</code>获得的返回值是一个随机数值，该数值受到多种因素影响，例如将手指靠近该引脚也会引发变化。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/">analogWrite(pin,
value)</a>
</td>
<td>
向指定引脚写入模拟数值，以产生固定频率的 PWM 波形。Arduino Uno
提供<code>3</code>、<code>5</code>、<code>6</code>、<code>9</code>、<code>10</code>、<code>11</code>为
PWM 引脚，可输出频率为<code>490 Hz</code>（其中 5 和 6 引脚为
<code>980Hz</code>）的 PWM 波形。 <br> ▶
参数<code>pin</code>：需要进行读取操作的模拟引脚编号； <br> ▶
参数<code>value</code>：为<code>0</code>（关断）到<code>255</code>（打开）之间的
整型占空比； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/analog-io/analogreference/">analogReference(type)</a>
</td>
<td>
配置模拟输入参考电压的范围与解析度，对于 Arduino Uno 可以选择如下参数：
<br> ▶
参数<code>type</code>：<code>DEFAULT</code>（默认模拟参考电压为<code>5V</code>），<code>INTERNAL</code>（<strong>ATmega328P</strong>
内建参考电压<code>1.1V</code>）； <br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="高级-io">高级 I/O</h3>
<table>
<thead>
<tr>
<th>
高级 I/O
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/tone/">tone(pin,
frequency, <br>duration)</a>
</td>
<td>
用于生成指定频率（以及<code>50%</code>占空比）的方波信号，可以驱动压电式蜂鸣器或者扬声器播放指定频率音调。注意，Arduino
Uno
只能同时通过<code>tone()</code>从一个引脚产生信号，此时其它引脚无法通过调用<code>tone()</code>输出信号。
<br> ▶ 参数<code>pin</code>：需要输出信号的引脚编号； <br> ▶
参数<code>frequency</code>：输出信号的频率，数据类型为<code>unsigned int</code>；
<br> ▶
参数<code>duration</code>：信号持续时间，以毫秒作为单位，数据类型为<code>unsigned long</code>；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/notone/">noTone(pin)</a>
</td>
<td>
停止生成由<code>tone()</code>函数触发的方波信号，如果需要使用多个引脚输出信号，必须在每个引脚输出信号前调用<code>noTone()</code>函数停止其它引脚输出信号。
<br> ▶ 参数<code>pin</code>：需要停止信号输出的引脚编号； <br> ▶
返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/pulsein/">pulseIn(pin,
value, <br>timeout)</a>
</td>
<td>
获取指定引脚的脉冲状态持续时间,
例如当前想检测脉冲信号<code>HIGH</code>，那么 Arduino
会在引脚变为<code>HIGH</code>时开始计时，引脚变为<code>LOW</code>之后停止记时，最后返回以毫秒为单位的脉冲持续时间，如果在超时时间内没有读取到脉冲信号，那么就会返回<code>0</code>。
<br> ▶ 参数<code>pin</code>：需要获取脉冲状态的引脚编号； <br> ▶
参数<code>value</code>：需要读取的脉冲类型，值为<code>HIGH</code>或者<code>LOW</code>两者之一，数据类型为<code>unsigned int</code>；
<br> ▶
参数<code>timeout</code>：可选，超时时间，以毫秒为单位，默认为<code>1</code>秒，数据类型为<code>unsigned long</code>；
<br> ▶
返回值：脉冲持续的时间长度，如果在超时时间内没有读到脉冲信号则返回<code>0</code>，数据类型为<code>unsigned long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/pulseinlong">pulseInLong(pin,
value, <br>timeout)</a>
</td>
<td>
<code>pulseIn()</code>的替代方法，更适合处理长脉冲和受中断影响的场景，其功能和参数与<code>pulseIn()</code>基本一致。但是由于该函数依赖于<code>micros()</code>，因此不能被用于<code>noInterrupts()</code>函数的上下文。
<br> ▶ 参数<code>pin</code>：需要获取脉冲状态的引脚编号； <br> ▶
参数<code>value</code>：需要读取的脉冲类型，值为<code>HIGH</code>或者<code>LOW</code>两者之一，数据类型为<code>unsigned int</code>；
<br> ▶
参数<code>timeout</code>：可选，超时时间，以毫秒为单位，默认为<code>1</code>秒，数据类型为<code>unsigned long</code>；
<br> ▶
返回值：脉冲持续的时间长度，如果在超时时间内没有读到脉冲信号则返回<code>0</code>，数据类型为<code>unsigned long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/shiftin/">shiftIn(dataPin,
clockPin, <br>bitOrder)</a>
</td>
<td>
将 1
个字节的数据通过移位方式逐位进行<strong>输入</strong>，数据可以从最高位（最左侧）或者最低位（最右侧）输入。Arduino
会首先在时钟引脚输出<code>HIGH</code>，然后通过数据引脚读取 1
位数据，读取完成之后时钟引脚会被设置为<code>LOW</code>。 <br> ▶
参数<code>dataPin</code>：输入位数据的引脚编号，允许的数据类型为<code>int</code>；
<br> ▶
参数<code>clockPin</code>：时钟信号引脚编号，允许的数据类型为<code>int</code>；
<br> ▶
参数<code>bitOrder</code>：位传送的顺序，<code>MSBFIRST</code>（最高有效位优先）或者<code>LSBFIRST</code>（最低有效位优先）二选一；
<br> ▶ 返回值：读取到的数据，允许的数据类型为<code>byte</code>； <br>
✸ 如果与 Arduino
通信的设备是在时钟引脚脉冲信号的上升沿发送数据，那么需要确保在调用<code>shiftIn()</code>之前，首先调用<code>digitalWrite(clockPin, LOW)</code>将时钟引脚设置为<code>LOW</code>，从而确保数据读取准确无误。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/advanced-io/shiftout/">shiftOut(dataPin,
<br>clockPin, bitOrder, <br>value)</a>
</td>
<td>
将 1
个字节的数据通过移位方式逐位进行<strong>输出</strong>，数据可以从最高位（最左侧）或者最低位（最右侧）输出。Arduino
会首先在时钟引脚输出<code>HIGH</code>，然后通过数据引脚读取 1
位数据，读取完成之后时钟引脚会被设置为<code>LOW</code>。 <br> ▶
参数<code>dataPin</code>：输出位数据的引脚编号，允许的数据类型为<code>int</code>；
<br> ▶
参数<code>clockPin</code>：时钟信号引脚编号，允许的数据类型为<code>int</code>；
<br> ▶
参数<code>bitOrder</code>：位传送的顺序，<code>MSBFIRST</code>（最高有效位优先）或者<code>LSBFIRST</code>（最低有效位优先）二选一；
<br> ▶
参数<code>value</code>：需要传送出的数据，允许的数据类型为<code>byte</code>；
<br> ▶ 返回值：无； <br> ✸
如果目标设备是在时钟引脚脉冲信号的上升沿读取 Arduino
上的数据，那么就需要确保调用<code>shiftOut()</code>之前，首先调用<code>digitalWrite(clockPin, LOW)</code>将时钟引脚设置为<code>LOW</code>，从而确保数据读取准确无误。
</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：下面表格当中的两个函数是 Zero、Due、MKR 的专属
I/O 函数：</p>
</blockquote>
<table>
<thead>
<tr>
<th>
Zero、Due、MKR 专属 I/O
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/zero-due-mkr-family/analogreadresolution/">analogReadResolution(bits)</a>
</td>
<td>
以位<code>bit</code>为单位设置<code>analogRead()</code>返回值大小，由于
Zero、Due、MKR 系列开发板拥有 12 位 ADC
功能，其分辨率最高可以调整至<code>12</code>，可以让<code>analogRead()</code>函数的返回值介于<code>0 ~ 4095</code>之间。所以为了向后兼容
AVR
开发板，其默认值限定为<code>10</code>个<code>bit</code>，返回值介于<code>0 ~ 1023</code>之间。
<br> ▶
参数<code>bits</code>：决定<code>analogRead()</code>函数返回值的位分辨率，取值范围介于<code>1 ~ 32</code>之间，如果取值超出开发板提供的范围，则按照该开发板能够处理的最高分辨率处理。
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/zero-due-mkr-family/analogwriteresolution/">analogWriteResolution(bits)</a>
</td>
<td>
以位<code>bit</code>为单位设置<code>analogWrite()</code>函数的输出分辨率，同样为了向后兼容
AVR
开发板，其默认值被限定为<code>8</code>个<code>bit</code>，返回值介于<code>0 ~ 255</code>之间。
<br> ▶
参数<code>bits</code>：决定<code>analogWrite()</code>函数所使用的位分辨率，取值范围介于<code>1 ~ 32</code>之间，如果取值超出了开发板提供的范围，则按照该开发板能够处理的最高分辨率处理。
<br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="定时">定时</h3>
<table>
<thead>
<tr>
<th>
定时
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/time/delay/">delay(ms)</a>
<a href></a>
</td>
<td>
让程序的运行停顿参数指定的时间（以<strong>毫秒</strong>为单位），<code>1000</code>毫秒
= <code>1</code>秒。 <br> ▶
参数<code>ms</code>：延时时间，单位为<strong>毫秒</strong>，允许的数据类型为<code>unsigned long</code>；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/time/delaymicroseconds/">delayMicroseconds(us)</a>
</td>
<td>
让程序的运行停顿参数指定的时间（以<strong>微秒</strong>为单位），<code>1000</code>微秒
= <code>1</code>毫秒。 <br> ▶
参数<code>ms</code>：延时时间，单位为<strong>微秒</strong>，允许的数据类型为<code>unsigned long</code>；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/time/micros/">micros()</a>
</td>
<td>
记录 Arduino
启动后运行当前程序的时间（单位为微秒），最长可以记录接近<strong>70</strong>分钟。如果超出记录时间上限，记录将会从<code>0</code>重新开始。在<code>16MHz</code>的
Arduino Uno
开发板上，该函数的分辨率为<code>4</code>微秒，因此每次返回的时间值总是<code>4</code>的倍数。
<br> ▶ 返回值：Arduino
启动后运行当前程序的时间，以<strong>微秒</strong>作为单位
，允许的数据类型为<code>unsigned long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/time/millis/">millis()</a>
</td>
<td>
记录 Arduino
启动后运行当前程序的<strong>毫秒</strong>数，最长可以记录至50天，然后归<code>0</code>。
<br> ▶ 返回值：Arduino 启动后运行当前程序的<strong>毫秒</strong>数
，允许的数据类型为<code>unsigned long</code>；
</td>
</tr>
</tbody>
</table>
<h3 id="数学">数学</h3>
<table>
<thead>
<tr>
<th>
数学
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/abs/">abs(x)</a>
</td>
<td>
计算一个数值的绝对值。 <br> ▶ 参数<code>x</code>：待计算绝对值的数值；
<br> ▶ 返回值：如果参数 <code>x</code> 大于或者等于 <code>0</code> 返回
<code>+x</code>；如果参数 <code>x</code> 小于 <code>0</code> 则返回
<code>-x</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/constrain/">constrain(x,
a, b)</a>
</td>
<td>
将一个数值限制在一个特定范围以内。 <br> ▶
参数<code>x</code>：需要约束范围的数值，允许所有数据类型； <br> ▶
参数<code>a</code>：范围的下限，允许所有数据类型； <br> ▶
参数<code>b</code>：范围的上限，允许所有数据类型； <br> ▶ 返回值：如果
<code>a&lt;x&lt;b</code> 返回 <code>x</code>；如果 <code>x&lt;a</code>
返回 <code>a</code>；如果 <code>x&gt;b</code> 返回 <code>b</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/map/">map(value,
fromLow, <br>fromHigh, toLow, <br>toHigh)</a>
</td>
<td>
将一个数值从一个区间等比例的映射至另外一个区间，即将
<code>fromLow</code> 的值映射至
<code>toLow</code>，<code>fromHigh</code> 的值映射至
<code>toHigh</code>，中间值映射至中间值。 <br> ▶
参数<code>value</code>：需要进行映射的数值； <br> ▶
参数<code>fromLow</code>：映射之前，区间的最小边界值； <br> ▶
参数<code>fromHigh</code>：映射之前，区间的最大边界值； <br> ▶
参数<code>toLow</code>：映射之后，区间的最小边界值； <br> ▶
参数<code>toHigh</code>：映射之后，区间的最大边界值； <br> ▶
返回值：被映射后的值；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/max/">max(x,
y)</a>
</td>
<td>
计算两个数值的最大值。 <br> ▶ 参数<code>x</code>：待比较的第 1 个值；
<br> ▶ 参数<code>y</code>：待比较的第 2 个值； <br> ▶
返回值：两个值当中的最大值；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/min/">min(x,
y)</a>
</td>
<td>
计算两个数值的最小值。 <br> ▶ 参数<code>x</code>：待比较的第 1 个值；
<br> ▶ 参数<code>y</code>：待比较的第 2 个值； <br> ▶
返回值：两个值当中的最小值；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/pow/">pow(base,
exponent)</a>
</td>
<td>
计算一个幂函数的值。 <br> ▶
参数<code>base</code>：底数，允许的数据类型为 <code>float</code>； <br>
▶ 参数<code>exponent</code>：指数，允许的数据类型为 <code>float</code>；
<br> ▶ 返回值：求幂运算的结果，允许的数据类型为 <code>double</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/sq/">sq(x)</a>
</td>
<td>
计算数值的平方结果，即数字乘以自身的值。 <br> ▶
参数<code>x</code>：待计算的数值，允许为任意数据类型； <br> ▶
返回值：数值的乘方结果，允许的数据类型为 <code>double</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/math/sqrt/">sqrt(x)</a>
</td>
<td>
计算数字的<code>√￣</code>平方根结果，即开方运算。 <br> ▶
参数<code>x</code>：待计算的数值，允许为任意数据类型； <br> ▶
返回值：数值的平方根，允许的数据类型为 <code>double</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/trigonometry/cos/">cos(rad)</a>
</td>
<td>
以弧度为单位，计算角度的<strong>余弦值</strong>。 <br> ▶
参数<code>rad</code>：角度的弧度值，允许的数据类型为
<code>float</code>； <br> ▶
返回值：角度的<strong>余弦值</strong>，允许的数据类型为
<code>double</code>；
</td>
</tr>
<tr>
<td>
<a href></a>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/trigonometry/sin/">sin(rad)</a>
</td>
<td>
以弧度为单位，计算角度的<strong>正弦值</strong>。 <br> ▶
参数<code>rad</code>：角度的弧度值，允许的数据类型为
<code>float</code>； <br> ▶
返回值：角度的<strong>正弦值</strong>，允许的数据类型为
<code>double</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/trigonometry/tan/">tan(rad)</a>
</td>
<td>
以弧度为单位，计算角度的<strong>正切值</strong>。 <br> ▶
参数<code>rad</code>：角度的弧度值，允许的数据类型为
<code>float</code>； <br> ▶
返回值：角度的<strong>正切值</strong>，允许的数据类型为
<code>double</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/random-numbers/random/">random(min,
max)</a>
</td>
<td>
用于生成伪随机数。 <br> ▶ 参数<code>max</code>：随机值的上界； <br> ▶
参数<code>min</code>：可选，随机值的下界； <br> ▶ 返回值：一个介于
<code>min ~ max-1</code> 之间的伪随机数，允许的数据类型为
<code>long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/random-numbers/randomseed/">randomSeed(seed)</a>
</td>
<td>
用于初始化一个伪随机数生成器，虽然伪随机数会从一个随机序列的任意一点开始生成，但是这个序列总是相同的。采用<code>analogRead()</code>这样随机的输入结果作为该函数参数，就可以确保该序列总是不同的。
<br> ▶
参数<code>seed</code>：用于初始化伪随机数序列的种子值，允许的数据类型为
<code>unsigned long</code>； <br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="字符">字符</h3>
<table>
<thead>
<tr>
<th>
字符
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isalpha/">isAlpha(thisChar)</a>
</td>
<td>
判断一个字符是否是<strong>字母</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isalphanumeric/">isAlphaNumeric(thisChar)</a>
</td>
<td>
判断一个字符是否为<strong>字母</strong>或者<strong>数字</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isascii/">isAscii(thisChar)</a>
</td>
<td>
判断一个字符是否为 <strong>ASCII</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/iscontrol/">isControl(thisChar)</a>
</td>
<td>
判断一个字符是否为<strong>控制字符</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isdigit/">isDigit(thisChar)</a>
</td>
<td>
判断一个字符是否为<strong>数字</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isgraph/">isGraph(thisChar)</a>
</td>
<td>
判断一个字符是否<strong>可以打印内容</strong>（包含能够产生输出的任意字符，但是不包含无内容的空格），如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/ishexadecimaldigit/">isHexadecimalDigit(thisChar)</a>
</td>
<td>
判断一个字符是否是<strong>十六进制字符</strong>（<code>0 ~ 9</code> 和
<code>a ~ f</code>），如果是则返回 <code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/islowercase/">isLowerCase(thisChar)</a>
</td>
<td>
判断一个字符是否为<strong>小写格式</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isprintable/">isPrintable(thisChar)</a>
</td>
<td>
判断一个字符是否可以<strong>打印</strong>（能够产生输出的任意字符，也包含空格），如果是则返回<code>true</code>。
<br> ▶ 参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/ispunct/">isPunct(thisChar)</a>
</td>
<td>
判断一个字符是否是<strong>标点符号</strong>（即逗号、分号、感叹号等），如果是则返回<code>true</code>。
<br> ▶ 参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isspace/">isSpace(thisChar)</a>
</td>
<td>
判断一个字符是否是<strong>空白字符</strong>（包括空格<code></code>、分页符<code>\f</code>、换行符<code>\n</code>、回车<code>\r</code>、水平制表符<code>\t</code>、垂直制表符<code>\v</code>），如果是则返回<code>true</code>。
<br> ▶ 参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/isuppercase/">isUpperCase(thisChar)</a>
</td>
<td>
判断一个字符是否为<strong>大写格式</strong>，如果是则返回
<code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/characters/iswhitespace/">isWhitespace(thisChar)</a>
</td>
<td>
判断一个字符是否是<strong>空格</strong>或者<strong>水平制表符</strong>
<code>\t</code>，如果是则返回 <code>true</code>。 <br> ▶
参数<code>thisChar</code>：字符变量，允许的数据类型为
<code>char</code>； <br> ▶ 返回值：<code>true</code>；
</td>
</tr>
</tbody>
</table>
<h3 id="字符串">字符串</h3>
<p>通过 <code>String()</code> 构造函数，可以构造出一个 <a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/stringobject/"><strong>String
类型</strong></a>的实例，该构造函数具有如下 3
种<strong>重载</strong>形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String(val)</span><br><span class="line">String(val, base)</span><br><span class="line">String(val, decimalPlaces)</span><br></pre></td></tr></table></figure>
<p>构造函数 <code>String()</code> 当中的
<code>val</code>、<code>base</code>、<code>decimalPlaces</code>
三个参数分别具有如下意义：</p>
<ul>
<li><code>val</code>：需要转换为 String 实例的数据，可以是
<code>string</code>、<code>char</code>、<code>byte</code>、<code>int</code>、<code>long</code>、<code>unsigned int</code>、<code>unsigned long</code>、<code>float</code>、<code>double</code>
类型。</li>
<li><code>base</code>：用于格式化整数值的基数（进制）。</li>
<li><code>decimalPlaces</code>：指定小数点之后有几位，仅用于参数
<code>val</code> 为浮点类型 <code>float</code> 或 <code>double</code>
的时候。</li>
</ul>
<p>下面的代码是一个关于 <code>String()</code>
构造函数应用的综合实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字符与字符串处理 */</span></span><br><span class="line">String demo = <span class="string">&quot;Hello String&quot;</span>;                    <span class="comment">// 使用常量字符串</span></span><br><span class="line">String demo = String(<span class="string">&#x27;a&#x27;</span>);                       <span class="comment">// 常量字符 char</span></span><br><span class="line">String demo = String(<span class="string">&quot;This is a string&quot;</span>);        <span class="comment">// 常量字符串 sting</span></span><br><span class="line">String demo = String(stringTwo + <span class="string">&quot; with more&quot;</span>);  <span class="comment">// 连接两个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数值处理 */</span></span><br><span class="line">String demo = String(<span class="number">13</span>);                        <span class="comment">// 整型常量</span></span><br><span class="line">String demo = String(analogRead(<span class="number">0</span>), DEC);        <span class="comment">// 十进制整型</span></span><br><span class="line">String demo = String(<span class="number">45</span>, HEX);                   <span class="comment">// 十六进制整型</span></span><br><span class="line">String demo = String(<span class="number">255</span>, BIN);                  <span class="comment">// 二进制整型</span></span><br><span class="line">String demo = String(millis(), DEC);             <span class="comment">// 十进制长整型</span></span><br><span class="line">String demo = String(<span class="number">5.698</span>, <span class="number">3</span>);                  <span class="comment">// 使用浮点数，并且指定小数点的位置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：使用 <code>String()</code>
构造函数将整型转换为字符串时，其结果总是为该整型数据的 ASCII 形式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>
字符串
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/charat/">charAt(n)</a>
</td>
<td>
访问字符串的特定字符。 <br> ▶ 参数<code>n</code>：一个数据类型为
<code>unsigned int</code> 的变量。 <br> ▶ 返回值：字符串的第
<code>n</code> 个字符；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/compareto/">compareTo(myString)</a>
</td>
<td>
逐个比较两个字符串当中字符的 <strong>ASCII</strong> 编码，这意味着
<code>a</code> 在 <code>b</code> 之前，但是在大写字母 <code>A</code>
之后，而数字会在字母之前； <br> ▶ 参数<code>myString</code>：另一个
<code>String</code> 类型的变量。 <br> ▶
返回值：返回<strong>负数</strong>表示调用 <code>String</code> 出现在参数
<code>String</code> 之前，而返回<strong>正数</strong>则表示调用
<code>String</code> 出现在参数 <code>String</code>
之后，返回<strong>零</strong>表示两个字符串相等；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/concat/">concat(parameter)</a>
</td>
<td>
将一个参数附加到 String 对象上面。 <br> ▶
参数<code>parameter</code>：允许的数据类型有
<code>String</code>、<code>string</code>、<code>char</code>、<code>byte</code>、<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>float</code>、<code>double</code>。
<br> ▶ 返回值：成功返回 <code>true</code>，失败返回
<code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/c_str/">c_str()</a>
</td>
<td>
将字符串的内容转换为 C 语言风格的以<strong>空字符</strong>结尾的字符串。
<br> ▶ 返回值：转换之后的 C 语言风格字符串指针；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/endswith/">endsWith(myString)</a>
</td>
<td>
判断 <code>String</code> 类型字符串是否以指定的 <code>String</code>
类型字符串结尾。 <br> ▶ 参数<code>myString</code>：另一个
<code>String</code> 类型的变量； <br> ▶ 返回值：如果调用 String 以参数
String 结尾返回 <code>true</code>，否则返回 <code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/equals/">equals(myString)</a>
</td>
<td>
比较两个字符串是否相等，这种比较是区分大小写的，这意味着
<code>hello</code> 不等于 <code>HELLO</code>。 <br> ▶
参数<code>myString</code>：另一个 <code>String</code> 类型的变量； <br>
▶ 返回值：如果调用 String 与参数 String 相等返回
<code>true</code>，否则返回 <code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/equalsignorecase/">equalsIgnoreCase(myString)</a>
</td>
<td>
比较两个字符串是否相等，但是这种比较并不会区分大小写的，因此
<code>hello</code> 就会等于 <code>HELLO</code>。 <br> ▶
参数<code>myString</code>：另一个 <code>String</code> 类型的变量； <br>
▶ 返回值：如果调用 String 与参数 String 在忽略大小写的情况下相等返回
<code>true</code>，否则返回 <code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/getbytes/">getBytes(buf,
len)</a>
</td>
<td>
将调用 String 的<strong>字符</strong>复制到指定大小 <code>len</code>
的缓冲区 <code>buf</code>。 <br> ▶
参数<code>buf</code>：目标缓冲区，允许数据类型是 <code>byte</code>
类型的数组； <br> ▶ 参数<code>len</code>：缓冲区大小，允许
<code>unsigned int</code> 类型的数据； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/indexof/">indexOf(val,
from)</a>
</td>
<td>
从调用 String
的<strong>开始位置</strong>查找一个指定的<strong>字符</strong>或者<strong>字符串</strong>。
<br> ▶ 参数<code>val</code>：数据类型为 <code>char</code> 或
<code>String</code>，待搜索的字符或者字符串； <br> ▶
参数<code>from</code>：开始搜索的字符串索引位置； <br> ▶ 返回值：参数
<code>val</code> 在字符串当中的索引，没有如果找到则返回
<code>-1</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/lastindexof/">lastIndexOf(val,
from)</a>
</td>
<td>
从调用 String
的<strong>结束位置</strong>查找一个指定的<strong>字符</strong>或者<strong>字符串</strong>。
<br> ▶ 参数<code>val</code>：数据类型为 <code>char</code> 或
<code>String</code>，待搜索的字符或者字符串； <br> ▶
参数<code>from</code>：开始搜索的字符串索引位置； <br> ▶ 返回值：参数
<code>val</code> 在字符串当中的索引，没有如果找到则返回
<code>-1</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/length/">length()</a>
</td>
<td>
以字符作为单位，返回字符串的长度，注意返回结果不会包含字符串末尾的<strong>结束字符</strong>。
<br> ▶ 参数<code>buf</code>：目标缓冲区，允许数据类型是
<code>byte</code> 类型的数组； <br> ▶
参数<code>len</code>：缓冲区大小，允许 <code>unsigned int</code>
类型的数据； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/remove">remove(index,
count)</a>
</td>
<td>
删除调用字符串当中，指定索引位置 <code>index</code> 的指定数量字符
<code>count</code>。 <br> ▶ 参数<code>index</code>：数据类型为
<code>unsigned int</code>，开始进行删除操作的字符索引； <br> ▶
参数<code>count</code>：数据类型为
<code>unsigned int</code>，需要删除的字符数量； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/replace/">replace(substring1,
substring2)</a>
</td>
<td>
将字符串当中的指定部分 <code>substring1</code> 替换为
<code>substring2</code>。 <br> ▶
参数<code>substring1</code>：数据类型为
<code>String</code>，希望替换的字符串； <br> ▶
参数<code>substring2</code>：数据类型为
<code>String</code>，替换之后的字符串； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/reserve/">reserve(size)</a>
</td>
<td>
在内存当中分配一个缓冲区来处理 <code>String</code> 对象。 <br> ▶
参数<code>size</code>：数据类型为
<code>unsigned int</code>，内存缓冲区占用的字节数； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/setcharat/">setCharAt(index,
c)</a>
</td>
<td>
设置字符串指定索引位置 <code>index</code> 为字符
<code>c</code>，如果索引超出字符串长度，则不会产生任何影响。 <br> ▶
参数<code>index</code>：设置字符的索引； <br> ▶
参数<code>c</code>：等待设置的字符； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/startswith/">startsWith(myString)</a>
</td>
<td>
测试调用 <code>String</code> 是否以参数 <code>String</code> 作为开始。
<br> ▶ 参数<code>myString</code>：数据类型为 <code>String</code>
的变量； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/substring/">substring(from,
to)</a>
</td>
<td>
从调用字符串截取子字符串，如果省略结束索引
<code>to</code>，该子字符串将会截取至调用字符串的末尾。 <br> ▶
参数<code>from</code>：待截取子字符串的起始索引； <br> ▶
参数<code>to</code>：可选参数，待截取子字符串的结束索引； <br> ▶
返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tochararray/">toCharArray(buf,
len)</a>
</td>
<td>
将调用 String 当中的字符复制到指定长度为 <code>len</code> 的缓冲区
<code>buf</code>。 <br> ▶ 参数<code>buf</code>：数据类型为
<code>char</code> 字符数组，复制操作的目标缓冲区； <br> ▶
参数<code>len</code>：数据类型为
<code>unsigned int</code>，缓冲区的大小； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/todouble/">toDouble()</a>
</td>
<td>
将调用字符串 <code>String</code> 转换为<strong>双精度浮点数</strong>。
<br> ▶ 返回值：转换后的 <code>double</code>
数据类型，如果调用字符串不是以数值开头，导致转换不能有效进行，则返回
<code>0</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/toint/">toInt()</a>
</td>
<td>
将调用字符串 <code>String</code> 转换为<strong>整型数</strong>。 <br> ▶
返回值：转换后的 <code>long</code>
数据类型，如果调用字符串并非整型数据，致使转换不能有效进行，则返回
<code>0</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tofloat/">toFloat()</a>
</td>
<td>
将调用字符串 <code>String</code> 转换为<strong>浮点数</strong>。 <br> ▶
返回值：转换后的 <code>float</code>
数据类型，如果调用字符串不是以数值开头，致使转换不能有效进行，则返回
<code>0</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/tolowercase/">toLowerCase()</a>
</td>
<td>
将调用字符串 <code>String</code>
全部就地转换为<strong>小写格式</strong>。 <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/touppercase/">toUpperCase()</a>
</td>
<td>
将调用字符串 <code>String</code>
全部就地转换为<strong>大写格式</strong>。 <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/variables/data-types/string/functions/trim/">trim()</a>
</td>
<td>
就地去除调用字符串 <code>String</code> 前后的空格。 <br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="位操作">位操作</h3>
<table>
<thead>
<tr>
<th>
位操作
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/bit/">bit(n)</a>
</td>
<td>
<strong>计算</strong>指定位的值（第 0 位是 1，第 1 位是 2，第 2 位是 4
等等）。 <br> ▶ 参数<code>n</code>：需要计算的位； <br> ▶
返回值：位的值；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/bitclear/">bitClear(x,
n)</a>
</td>
<td>
<strong>清除</strong>一个数值变量的指定位。 <br> ▶
参数<code>x</code>：待进行位清除操作的数字变量； <br> ▶
参数<code>n</code>：待清除的位； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/bitread/">bitRead(x,
n)</a>
</td>
<td>
<strong>读取</strong>指定数值变量的 1 位。 <br> ▶
参数<code>x</code>：待进行位读取操作的数值； <br> ▶
参数<code>n</code>：需要读取哪一位，对于最右侧的最低有效位，从第
<code>0</code> 位开始； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/bitset/">bitSet(x,
n)</a>
</td>
<td>
将某个数值变量的指定位设置为 <code>1</code>。 <br> ▶
参数<code>x</code>：待进行位设置的数值； <br> ▶
参数<code>n</code>：需要设置的位，对于最右侧的最低有效位，从第
<code>0</code> 位开始； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/bitwrite/">bitWrite(x,
n, b)</a>
</td>
<td>
对数值变量的指定位进行<strong>写入</strong>操作。 <br> ▶
参数<code>x</code>：待进行位写入操作的数值； <br> ▶
参数<code>n</code>：需要写入的位，对于最右侧的最低有效位，从第<code>0</code>位开始；
<br> ▶
参数<code>b</code>：需要写入的二进制值（<code>0</code>或者<code>1</code>）；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/highbyte/">highByte(x)</a>
</td>
<td>
提取 1 个 <code>word</code>
字的<strong>最左侧高位字节</strong>（或者对于较大的数据类型是第 2
个最低字节）。 <br> ▶ 参数<code>x</code>：一个任意类型的值； <br> ▶
返回值：提取的字节，允许的数据类型为<code>byte</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/bits-and-bytes/lowbyte/">lowByte(x)</a>
</td>
<td>
提取 1 个 <code>word</code> 字的<strong>最右侧低位字节</strong>。 <br>
▶ 参数<code>x</code>：一个任意类型的值； <br> ▶
返回值：提取的字节，允许的数据类型为 <code>byte</code>；
</td>
</tr>
</tbody>
</table>
<h3 id="中断">中断</h3>
<table>
<thead>
<tr>
<th>
中断
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt/">attachInterrupt(digitalPinToInterrupt(pin),
ISR, mode)</a>
</td>
<td>
用于添加<strong>外部中断</strong>，可用于中断的数字引脚：<strong>Uno</strong>
的 <code>2</code>、<code>3</code> 号引脚，<strong>Mega2560</strong> 的
<code>2</code>、<code>3</code>、<code>18</code>、<code>19</code>、<code>20</code>、<code>21</code>
号引脚，以及 <strong>Due</strong> 的所有数字引脚； <br> ▶
参数<code>interrupt</code>：中断编号，通常使用
<code>digitalPinToInterrupt(pin)</code>
函数将实际数字引脚转换为特定中断编号，允许的数据类型为
<code>int</code>； <br> ▶ 参数<code>pin</code>：发生中断的引脚编号；
<br> ▶
参数<code>ISR</code>：中断服务函数，中断发生时自动调用，该函数必须没有参数与返回值；
<br> ▶
参数<code>mode</code>：<code>LOW</code>：引脚为<strong>低电平</strong>时触发中断；<code>CHANGE</code>：引脚电平发生<strong>变化</strong>时触发中断；<code>RISING</code>：引脚电平由<strong>低电平</strong>变为<strong>高电平</strong>时触发中断；<code>FALLING</code>：引脚电平由<strong>高电平</strong>变为<strong>低电平</strong>时触发中断；此外，Arduino
Due、Zero 和 MKR1000 还允许为
<code>HIGH</code>，即引脚为<strong>高电平</strong>时触发中断; <br> ▶
返回值：无； <br> ✸ 中断服务程序（ISR，Interrupt Service
Routine）应当尽可能短小快速。如果当前 <strong>Sketch</strong>
设置有多个中断服务，那么每次只能运行 1
个中断，其它中断将会在当前中断执行完成以后，按照优先级顺序进行执行。由
<code>millis()</code> 依赖于中断进行计数，而 <code>delay()</code>
需要中断才能生效，因此在中断服务程序内部调用它们将会失效；<code>micros()</code>
最初可以正常工作，但是在 <code>1 ~ 2</code> 毫秒以后发生异常；最后，由于
<code>delayMicroseconds()</code>
不使用任何计数器，因此将会得到正常运行。 <br> ✸ 通常采用声明为
<code>volatile</code>
的全局变量在主程序与中断服务程序之间传递数据，从而确保变量在它们之间得到正确的更新；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/external-interrupts/detachinterrupt/">
detachInterrupt(digitalPinToInterrupt(pin)) </a>
</td>
<td>
关闭指定的<strong>外部中断</strong>。 <br> ▶
参数<code>interrupt</code>：需要禁用的中断编号； <br> ▶
参数<code>pin</code>：待禁用外部中断的引脚编号； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/interrupts/interrupts/">
interrupts() </a>
</td>
<td>
重新使能中断（在 <code>nointerrupts()</code>
禁用中断之后），中断用于让某些任务运行在后台，其默认情况下是使能的，禁用中断以后会导致一些内置函数无法正常工作。
<br> ▶ 参数：无； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/interrupts/nointerrupts/">
noInterrupts() </a>
</td>
<td>
禁用中断（可以调用 <code>interrupts()</code>
重新使能中断），禁用以后会影响到一些内置函数的工作。 <br> ▶ 参数：无；
<br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h2 id="io-工具类">I/O 工具类</h2>
<h3 id="stream">stream</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/">stream
类</a>
是所有<strong>字符流</strong>和<strong>二进制流</strong>的基类，通常不会直接进行调用，主要在继承于它的
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/">Serial</a>、<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/Wire">Wire</a>、<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/Ethernet">Ethernet</a>、<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SD/">SD</a>
等相关工具函数当中使用。</p>
<table>
<thead>
<tr>
<th>
stream 字符与二进制流
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamavailable">stream.available()</a>
</td>
<td>
获取已经接收到的数据流当中可用的字节数，该函数是 <code>Stream</code>
类的一部分，可以被继承它的类（<code>Wire</code>、<code>Serial</code>
等）调用；<br> ▶ 参数：无；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamread">stream.read()</a>
</td>
<td>
将输入流当中的字符读取至缓冲区。<br> ▶ 参数：无；<br> ▶
返回值：输入数据的第 1 个有效字节，如果没有数据，则返回
<code>-1</code>。；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamflush">stream.flush()</a>
</td>
<td>
在所有字符发送完毕之后，清除缓冲区。<br> ▶ 参数：无；<br> ▶
返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamfind">stream.find(target,
length)</a>
</td>
<td>
从流当中读取数据，直至查询到目标；。<br> ▶
参数<code>target</code>：待检索的字符串，数据类型为
<code>char</code>；<br> ▶
参数<code>length</code>：目标的长度，数据类型为
<code>size_t</code>；<br> ▶ 返回值：如果找到目标返回
<code>true</code>，如果超时则返回 <code>false</code>，数据类型为
<code>bool</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamfinduntil">stream.findUntil(target,
terminal)</a>
</td>
<td>
从流当中读取数据，直至找到指定长度的目标字符串/结束符，或者发生超时退出。<br>
▶ 参数<code>target</code>：待检索的字符串，数据类型为
<code>char</code>；<br> ▶
参数<code>terminal</code>：搜索当中的结束字符串，数据类型
<code>char</code>；<br> ▶ 返回值：如果检索到目标字符串返回
<code>true</code>，如果超时则返回 <code>false</code>，数据类型为
<code>bool</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streampeek">stream.peek()</a>
</td>
<td>
从文件中读取 1 个字节，但是并不跳转至下 1
个字节，连续调用该函数会返回与下一次调用 <code>read()</code>
相同的值。<br> ▶ 参数：无；<br> ▶
返回值：下一个字节或者字符，如果没有则返回 <code>-1</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamreadbytes">stream.readBytes(buffer,
length)</a>
</td>
<td>
将数据流当中的字符读入缓冲区，读取完成或者超时就会终止。<br> ▶
参数<code>buffer</code>：用来存储字节的缓冲区，数据类型为
<code>char</code> 或者 <code>byte</code> 数组；<br> ▶
参数<code>length</code>：待读取的字节数，数据类型为
<code>int</code>；<br> ▶ 返回值：缓冲区中的字节数，数据类型为
<code>size_t</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamreadbytesuntil">stream.readBytesUntil(character,
<br>buffer, length)</a>
</td>
<td>
从流中读取字符到缓冲区，如果检测到终止符字符，或者读取完成以及超时的时候，就会终止。<br>
▶ 参数<code>character</code>：待检索的字符，数据类型为
<code>char</code>；<br> ▶
参数<code>buffer</code>：用来存储字节的缓冲区，数据类型为
<code>char</code> 或者 <code>byte</code>数组；<br> ▶
参数<code>length</code>：待读取的字节数，数据类型为
<code>int</code>；<br> ▶ 返回值：放置在缓冲区当中的字节数；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamreadstring">stream.readString()</a>
</td>
<td>
将数据流当中的字符读取到字符串，如果超时则函数终止。<br> ▶
参数：无；<br> ▶ 返回值：继承自 <code>Stream</code> 类的实例；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamreadstringuntil">stream.readStringUntil(terminator)</a>
</td>
<td>
从流中读取字符到字符串，如果检测到终止符或者超时则函数就会终止。<br> ▶
参数<code>terminator</code>：待检索的字符，数据类型为
<code>char</code>；<br> ▶
返回值：从数据流当中读取到的全部字符串（以结束符为止）；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamparseint">stream.parseInt(lookahead,
ignore)</a>
</td>
<td>
返回当前位置第 1 个有效的整型 <code>int</code> 或者长整型
<code>long</code> 数据；<br> ▶
参数<code>lookahead</code>：设定在数据流当中查找整型数据的模式，可以选择
<code>SKIP_ALL</code>（默认模式，忽略除负号、小数点或数字之外的所有字符），<code>SKIP_NONE</code>（没有任何内容被忽略），<code>SKIP_WHITESPACE</code>（忽略制表符、空格、换行符、回车符）当中的一种模式；<br>
▶ 参数<code>ignore</code>：数据类型为
<code>char</code>，用于在搜索当中跳过指定的字符；<br> ▶
返回值：返回的数据类型为 <code>long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamparsefloat">stream.parseFloat(lookahead,
ignore)</a>
</td>
<td>
返回当前位置的第 1 个有效的浮点型数据，然后以第 1
个非浮点数的字符结束，如果发生超时则函数将会终止；<br> ▶
参数<code>lookahead</code>：设定在数据流当中查找浮点数的模式，可以选择
<code>SKIP_ALL</code>（默认模式，忽略除负号、小数点或数字之外的所有字符），<code>SKIP_NONE</code>（没有任何内容被忽略），<code>SKIP_WHITESPACE</code>（忽略制表符、空格、换行符、回车符）当中的一种模式；<br>
▶ 参数<code>ignore</code>：数据类型为
<code>char</code>，用于在搜索当中跳过指定的字符；<br> ▶
返回值：返回的数据类型为 <code>float</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/stream/streamsettimeout">stream.setTimeout(time)</a>
</td>
<td>
设置数据流等待的最大毫秒数，默认值为 <code>1000</code> 毫秒。<br> ▶
参数<code>time</code>：单位为毫秒的超时时间，数据类型为
<code>long</code>；<br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="serial">Serial</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/">Serial
类</a>用于 Arduino 开发板与其它设备进行串行通信，所有 Arduino
开发板都至少拥有一组 <strong>UART</strong>（通用异步收发器）或者
<strong>USART</strong>（通用同步/异步收发器）串行通讯接口。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%">
<col style="width: 17%">
<col style="width: 27%">
<col style="width: 19%">
<col style="width: 19%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Arduino 型号</th>
<th style="text-align: center;">SERIAL 引脚</th>
<th style="text-align: center;">SERIAL1 引脚</th>
<th style="text-align: center;">SERIAL2 引脚</th>
<th style="text-align: center;">SERIAL3 引脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Uno</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">0(RX) / 1(TX)</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mega</strong></td>
<td style="text-align: center;">0(RX) / 1(TX)</td>
<td style="text-align: center;">19(RX) / 18(TX)</td>
<td style="text-align: center;">17(RX) / 16(TX)</td>
<td style="text-align: center;">15(RX) / 14(TX)</td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP8266</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GPIO1(TX) / GPIO3(RX)</td>
<td style="text-align: center;">GPIO2 (TX)</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP32</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GPIO1(TX) / GPIO3(RX)</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Arduino 与 Uno 和 Mega 与计算机通信的引脚分别为 <code>0</code> 和
<code>1</code>，连接到这些引脚会干扰通信，导致固件上传失败。</p>
<table>
<thead>
<tr>
<th>
串行通信
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/ifserial">Serial.if(Serial)</a>
</td>
<td>
判断串行通信接口是否已经就绪。<br> ▶ 参数：无；<br> ▶
返回值：如果指定的串行端口可用就返回 <code>true</code>，否则返回
<code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/available">Serial.available()</a>
</td>
<td>
获取当前可以从串口读取的字节或者字符数量，即已经接收到并且保存在<strong>串行接收缓冲区</strong>当中的数据。<br>
▶ 参数：无；<br> ▶ 返回值：可供读取的字节数量；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/availableforwrite">Serial.availableForWrite()</a>
</td>
<td>
非阻塞写入操作的情况下，获取当前串行缓冲区写入的字节或者字符数。<br> ▶
参数：无；<br> ▶ 返回值：可供写入的字节数量；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/begin">Serial.begin(speed,
config)</a>
</td>
<td>
设置串行数据传输的速率（以<code>比特/秒</code>作为单位），以及<code>数据位</code>、<code>奇偶校验位</code>、<code>停止位</code>（默认为
8 个数据位，1 个停止位，无奇偶校验位）。<br> ▶
参数<code>speed</code>：串行通信的波特率，数据类型为长整型
<code>long</code>；<br> ▶
参数<code>config</code>：设置<code>数据位</code>、<code>奇偶校验位</code>、<code>停止位</code>，可选择的值有
<code>SERIAL_5N1</code>、<code>SERIAL_6N1</code>、<code>SERIAL_7N1</code>、<code>SERIAL_8N1</code>(默认)、<code>SERIAL_5N2</code>、<code>SERIAL_6N2</code>、<code>SERIAL_7N2</code>、<code>SERIAL_8N2</code>、<code>SERIAL_5E1</code>(偶数校验)、<code>SERIAL_6E1</code>、<code>SERIAL_7E1</code>、<code>SERIAL_8E1</code>、<code>SERIAL_5E2</code>、<code>SERIAL_6E2</code>、<code>SERIAL_7E2</code>、<code>SERIAL_8E2</code>、<code>SERIAL_5O1</code>(奇数校验)、<code>SERIAL_6O1</code>、<code>SERIAL_7O1</code>、<code>SERIAL_8O1</code>、<code>SERIAL_5O2</code>、<code>SERIAL_6O2</code>、<code>SERIAL_7O2</code>、<code>SERIAL_8O2</code>；<br>
▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/end">Serial.end()</a>
</td>
<td>
关闭串行通信，让<code>RX</code>和<code>TX</code>引脚可以用作通用的输入输出（GPIO），调用<code>Serial.begin()</code>以后可以重新打开串行通信。<br>
▶ 参数：无；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/find">Serial.find(target,
length)</a>
</td>
<td>
从串行缓冲区检索数据，如果找到目标数据，函数返回
<code>true</code>，如果超时则返回 <code>false</code>。<br> ▶
参数<code>target</code>：待检索的字符串，数据类型为字符型
<code>char</code>；<br> ▶
参数<code>length</code>：检索到的目标长度，数据类型为字符型
<code>size_t</code>；<br> ▶ 返回值：<code>true</code> 或者
<code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/finduntil">Serial.findUntil(target,
terminal)</a>
</td>
<td>
从串行缓冲区读取数据，直至查询到指定长度的目标字符串或者终止符字符串（检索到目标返回
<code>true</code>，超时则返回 <code>false</code>）。<br> ▶
参数<code>target</code>：待检索的字符串，数据类型为字符型
<code>char</code>；<br> ▶
参数<code>terminal</code>：检索过程当中的结束字符，数据类型为字符型
<code>char</code>；<br> ▶ 返回值：<code>true</code> 或者
<code>false</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/flush">Serial.flush()</a>
</td>
<td>
等待发送出去的串行数据传输完成。<br> ▶ 参数：无<br> ▶ 返回值：无
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/parsefloat">Serial.parseFloat(lookahead,
ignore)</a>
</td>
<td>
从串行缓冲区返回第 1 个有效的浮点数据，超时以后将会自动退出。<br> ▶
参数<code>lookahead</code>：设定在数据流当中查找浮点数的模式，可以选择
<code>SKIP_ALL</code>（默认模式，忽略除负号、小数点或数字之外的所有字符），<code>SKIP_NONE</code>（没有任何内容被忽略），<code>SKIP_WHITESPACE</code>（忽略制表符、空格、换行符、回车符）当中的一种模式；<br>
▶ 参数<code>ignore</code>：数据类型为
<code>char</code>，用于在搜索当中跳过指定的字符；<br> ▶
返回值：返回的数据类型为 <code>float</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/parseint">Serial.parseInt(lookahead,
ignore)</a>
</td>
<td>
从输入的串行数据当中查找一个有效的整型数据，超时以后将会自动退出。<br>
▶
参数<code>lookahead</code>：设定在数据流当中查找整型数据的模式，可以选择
<code>SKIP_ALL</code>（默认模式，忽略除负号、小数点或数字之外的所有字符），<code>SKIP_NONE</code>（没有任何内容被忽略），<code>SKIP_WHITESPACE</code>（忽略制表符、空格、换行符、回车符）当中的一种模式；<br>
▶ 参数<code>ignore</code>：数据类型为
<code>char</code>，用于在搜索当中跳过指定的字符；<br> ▶
返回值：返回的数据类型为 <code>long</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/peek">Serial.peek()</a>
</td>
<td>
返回输入串行数据的下一个字节或者字符，而不将其从内部串行缓冲区移除，连续调用<code>peek()</code>将会返回相同的字符。<br>
▶ 参数：无；<br> ▶ 返回值：当前串行数据可用的第 1 个字节，返回
<code>-1</code> 则表示没有数据可用，数据类型为整型 <code>int</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/print">Serial.print(val,
format)</a>
</td>
<td>
将数据以人类可读的 ASCII 文本打印至串行通信端口。<br> ▶
参数<code>val</code>：等待打印的值，可以是任意数据类型；<br> ▶
参数<code>format</code>：打印格式，可以设置为
<code>BIN</code>(二进制)、<code>OCT</code>(八进制)、<code>DEC</code>(十进制)、<code>HEX</code>(十六进制)，对于浮点数，该参数用
于设定需要使用到的小数位数；<br> ▶ 返回值：返回写入的字节数，数据类型为
<code>size_t</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/println">Serial.println(val,
format)</a>
</td>
<td>
将数据以 ASCII 文本格式打印至串行端口，并且添加返回字符（ASCII
码<code>13</code>或者<code>'\r'</code>）和换行字符 （ASCII
码<code>10</code>或者<code>'\n'</code>）。<br> ▶
参数<code>val</code>：等待打印的值，可以是任意数据类型；<br> ▶
参数<code>format</code>：打印格式，可以设置为
<code>BIN</code>(二进制)、<code>OCT</code>(八进制)、<code>DEC</code>(十进制)、<code>HEX</code>(十六进制)，对于浮点数，该参数用于设定需要使用到的小数位数；<br>
▶ 返回值：返回写入的字节数，数据类型为 <code>size_t</code>；<br>

</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/read">Serial.read()</a>
</td>
<td>
读取输入的串行数据；<br> ▶ 参数：无；<br> ▶
返回值：当前串行数据可用的第 1 个字节，返回 <code>-1</code>
则表示没有数据可用，数据类型为整型 <code>int</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/readbytes">Serial.readBytes(buffer,
length)</a>
</td>
<td>
从串行端口读取字符到缓冲区，如果读取完成或者超时则函数终止。<br> ▶
参数<code>buffer</code>：用来存储字节的缓冲区，可以使用
<code>char</code> 或 <code>byte</code> 数组数据类型；<br> ▶
参数<code>length</code>：需要读取的字节数，数据类型为
<code>int</code>；<br> ▶ 返回值：放置在缓冲区当中的字节数，数据类型为
<code>size_t</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/readbytesuntil">Serial.readBytesUntil(character,
<br>buffer, length)</a>
</td>
<td>
将串行缓冲区的字符读取到数组里，如果检测到终止字符或者读取完成以及超时则函数终止。<br>
▶ 参数<code>character</code>：待读取的字符串，数据类型为
<code>char</code>；<br> ▶
参数<code>buffer</code>：用来存储字节的缓冲区，数据类型为
<code>char</code> 或者 <code>byte</code> 数组；<br> ▶
参数<code>length</code>：待读取的字节长度，数据类型为
<code>int</code>；<br> ▶ 返回值：数据类型为 <code>size_t</code>；<br>
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/readstring">Serial.readString()</a>
</td>
<td>
将串行缓冲区的字符读取到一个字符串当中，如果超时则函数中止。<br> ▶
参数：无；<br> ▶ 返回值：从串行缓冲区读取的字符串；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil">Serial.readStringUntil(terminator)</a>
</td>
<td>
将串行缓冲区中的字符读取为字符串，如果检测到终止字符或者超时则函数终止。<br>
▶ 参数<code>terminator</code>：待搜索的字符，数据类型为
<code>char</code>；<br> ▶
返回值：从串行缓冲区读取的字符串（以结束符为止）；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/settimeout">Serial.setTimeout(time)</a>
</td>
<td>
设置串行数据等待的最大毫秒数，默认为<code>1000</code>毫秒。<br> ▶
参数<code>time</code>：单位为<strong>毫秒</strong>的超时时间，数据类型为
<code>long</code>；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/write">
Serial.write(val)<br> Serial.write(str)<br> Serial.write(buf, len)
</a>
</td>
<td>
将二进制数据写入串口，这些数据将会以<code>字节</code>或<code>字节序列</code>的形式发送;要发送代表数字的字符，请使用print()函数。<br>
▶ 参数<code>val</code>：希望以单个字节发送的值；<br> ▶
参数<code>str</code>：希望以字节序列形式发送的字符串；<br> ▶
参数<code>buf</code>：希望以字节序列形式发送的数组；<br> ▶
参数<code>len</code>：需要从上面 buf 数组发送的字节长度；<br> ▶
返回值：写入的字节长度，数据类型为 <code>size_t</code>；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/communication/serial/serialevent">Serial.serialEvent()</a>
</td>
<td>
当串行数据可用时调用该事件函数，然后就可以使用<code>Serial.read()</code>来读取这些数据。<br>
▶ 参数<code>statements</code>：任意有效的 Arduino C++ 语句；<br> ▶
返回值：无；
</td>
</tr>
</tbody>
</table>
<h3 id="wire">Wire</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/Wire">Wire 库</a>
用于设备之前的 <strong>I²C/TWI</strong> 协议通信，下面表格展示了 I²C
引脚在各种 Arduino 开发板上的默认位置：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Arduino 型号</th>
<th>I²C/TWI 功能引脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Uno</strong></td>
<td><code>A4</code>（SDA）、<code>A5</code>（SCL）</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mega2560</strong></td>
<td><code>20</code>（SDA）、<code>21</code>（SCL）</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Due</strong></td>
<td><code>20</code>（SDA）、<code>21</code>（SCL）、<code>SDA1</code>、<code>SCL1</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP8266</strong></td>
<td><code>GPIO4/D2</code>（SDA）、<code>GPIO5/D1</code>（SCL）</td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP32</strong></td>
<td><code>GPIO21</code>（SDA）、<code>GPIO22</code>（SCL）</td>
</tr>
</tbody>
</table>
<p>使用该 Wire 库时，需要在代码当中包含
<code>#include &lt;Wire.h&gt;</code>
头文件，此外还需要注意如下两点：</p>
<ul>
<li>I²C/TWI 地址拥有 <code>7</code> 位和 <code>8</code> 位两种格式，其中
<code>7</code> 位用于标识设备，而第 <code>8</code>
位则用于确定其读写状态，Wire 库至始至终使用 <code>7</code>
位地址。如果参考代码当中存在 <code>8</code>
位地址，那么就需要删除其最低位，即将值向右移动一位，从而变成一个位于
<code>0 ~ 127</code> 范围的地址。但是，其中 <code>0 ~ 7</code>
范围的地址为系统保留使用，因而可供开发人员使用的地址从 <code>8</code>
开始；</li>
<li>Wire 库的实现当中使用 <code>32</code>
<strong>字节</strong>的缓冲区，所有的通信操作都应当位于该范围以内，单次传输当中超出的字节都将会被丢弃；</li>
</ul>
<table>
<thead>
<tr>
<th>
I²C 总线通信
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireBegin">Wire.begin(address)</a>
</td>
<td>
初始化 Wire 库，以<strong>主</strong>或者<strong>从</strong>方式加入 I²C
总线，该函数通常只会被调用一次。 <br> ▶ 参数<code>address</code>：7
位<strong>从机</strong>（Slave）地址，如果不指定，则表明当前设备为<strong>主机</strong>（Master）；
<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireRequestFrom">Wire.requestFrom(address,
quantity, stop)</a>
</td>
<td>
<strong>主设备</strong>向<strong>从设备</strong>请求字节数据，然后就可以调用
<code>available()</code> 和 <code>read()</code> 读取这些字节数据。 <br>
▶ 参数<code>address</code>：被请求字节数据的<strong>从设备</strong> 7
位地址； ▶ 参数<code>quantity</code>：请求的字节（Bytes）数； ▶
参数<code>stop</code>：布尔类型，如果为 <code>true</code>
就会在请求完成之后发送一个停止信息，从而释放总线资源；如果为
<code>false</code>，则会在请求完成之后，不断的重复发送请求，持续进行连接；
<br> ▶ 返回值：<strong>从设备</strong>返回的字节（Bytes）数据；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireBeginTransmission">Wire.beginTransmission(address)</a>
</td>
<td>
开始使用指定的地址向 I²C <strong>从设备</strong>传输数据。 <br> ▶
参数<code>address</code>：被传输字节数据的<strong>从设备</strong> 7
位地址； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireEndTransmission">Wire.endTransmission(stop)</a>
</td>
<td>
结束指定地址的 I²C <strong>从设备</strong>数据传输。 <br> ▶
参数<code>stop</code>：布尔类型，设置为 <code>true</code>
将发送一个停止消息，在传输结束之后释放 I²C 总线；设置为
<code>false</code> 将会重复进行发送，保持连接一直处于活动状态； <br> ▶
返回值：传输状态标识，<code>0</code> 表示成功，<code>1</code>
表示数据对于传输缓冲区而言过长，<code>2</code>
接收来自传输地址的否定应答，<code>3</code>
接收来自传输地址的否定数据，<code>4</code> 表示其它错误；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireAvailable">Wire.available()</a>
</td>
<td>
返回可以使用 <code>read()</code>
进行读取的字节数量，可以在<strong>主设备</strong>执行
<code>requestFrom()</code> 之后调用，或者在<strong>从设备</strong>执行完
<code>onReceive()</code> 回调函数以后调用； <br> ▶ 参数：无； <br> ▶
返回值：可用于进行读取的字节数量；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireRead">Wire.read()</a>
</td>
<td>
读取执行 <code>requestFrom()</code>
之后，<strong>从设备</strong>传输到<strong>主设备</strong>的字节数据，或者从<strong>主设备</strong>传递给<strong>从设备</strong>的字节数据。
<br> ▶ 参数：无； <br> ▶ 返回值：当前接收到的下一个字节数据；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireWrite">
Wire.write(value) <br> Wire.write(string) <br> Wire.write(data,
length) <br> </a>
</td>
<td>
读取执行 <code>requestFrom()</code>
之后，<strong>从设备</strong>传输到<strong>主设备</strong>的字节数据，或者从<strong>主设备</strong>传递给<strong>从设备</strong>的字节数据。
<br> ▶ 参数 <code>value</code>：作为单个字节数据发送的值；<br> ▶ 参数
<code>string</code>：作为一系列字节数据发送的字符串；<br> ▶ 参数
<code>data</code>：将以字节形式发送的数据数组；<br> ▶ 参数
<code>length</code>：需要传输的字节数量； <br> ▶
返回值：写入的字节数量；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireSetClock">Wire.setClock()</a>
</td>
<td>
设置 I²C 总线工作的时钟频率。 <br> ▶
参数：需要设置的时钟频率，单位为<strong>赫兹</strong>； <br> ▶
返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireOnReceive">Wire.onReceive(handler)</a>
</td>
<td>
注册一个回调函数，在<strong>从设备</strong>接收到<strong>主设备</strong>传输的数据时被调用。
<br> ▶ 参数：回调函数（参数为从主设备读取到的字节数量，无返回值），例如
<code>void myHandler(int numBytes)</code>； <br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/WireOnRequest">Wire.onRequest(handler)</a>
</td>
<td>
注册一个回调函数，在<strong>主设备</strong>向<strong>从设备</strong>请求数据时被自动调用。
<br> ▶ 参数：回调函数（即没有参数，也没有返回值），例如
<code>void myHandler()</code>; <br> ▶ 返回值：无；
</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：从 Arduino 1.0 开始，<code>Wire</code>
库继承自 <code>Stream</code> 函数，因此其读写函数 <code>send()</code> 和
<code>receive()</code> 已经被最新的 <code>read()</code> 与
<code>write()</code> 代替。</p>
</blockquote>
<p>使用一个 I²C 外围设备之前，通常需要查询该设备对应的 I²C 总线地址，在
<strong>ESP32</strong> 和 <strong>ESP8266</strong>
当中执行如下代码，就可以在 Arduino 的串口监视器当中（波特率为
<code>9600</code>），查询当前连接到开发板上的设备 I²C 地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">begin</span>();</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>); <span class="comment">// 设置串口监视器的波特率为 9600</span></span><br><span class="line">  <span class="keyword">while</span> (!Serial)</span><br><span class="line">    ; <span class="comment">// 等待串口监视器准备完成</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;\n===============优雅的分隔线===============&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;【正在运行 Hank 的 I²C 地址扫描程序】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  byte error, address; <span class="comment">// 错误以及 I²C 地址变量</span></span><br><span class="line">  <span class="type">int</span> devicecount;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;开始扫描...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  devicecount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (address = <span class="number">1</span>; address &lt; <span class="number">127</span>; address++) &#123;</span><br><span class="line">    <span class="comment">/* I²C 地址扫描程序通过 Wire.endTransmission() 的返回值来查询设备地址 */</span></span><br><span class="line">    Wire.<span class="built_in">beginTransmission</span>(address);</span><br><span class="line">    error = Wire.<span class="built_in">endTransmission</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">0</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;发现 I²C 设备的地址 0x&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (address &lt; <span class="number">16</span>)</span><br><span class="line">        Serial.<span class="built_in">print</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(address, HEX);</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot; !&quot;</span>);</span><br><span class="line">      devicecount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == <span class="number">4</span>) &#123;</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;未知错误发生在 I²C 地址 0x&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (address &lt; <span class="number">16</span>)</span><br><span class="line">        Serial.<span class="built_in">print</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(address, HEX);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (devicecount == <span class="number">0</span>)</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;没有找到 I²C 设备！\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;完成！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">5000</span>); <span class="comment">// 5 秒之后开始下一次扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spi">SPI</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPI">SPI 库</a> 用于让
Arduino 以<strong>主机身份</strong>（Master）实现 SPI
总线通信，使用时需要在代码当中包含如下头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SPI.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>串行外设接口</strong>（SPI，Serial Peripheral
Interface）用于微控制器与一个或多个外围设备，以同步串行方式进行短距离快速通信，该协议包含有
<strong>4</strong> 条数据线：</p>
<ol type="1">
<li><strong>MISO</strong> (Master In Slave
Out)：主机输入，从机输出；</li>
<li><strong>MOSI</strong> (Master Out Slave
In)：主机输出，从机输入；</li>
<li><strong>SCK</strong> (Serial Clock)：同步主机时钟；</li>
<li><strong>SS</strong> (Slave
Select)：从机片选，即指定<strong>主机</strong>需要调用的<strong>从机</strong>；</li>
</ol>
<blockquote>
<p><strong>注意</strong>：当一个设备的<strong>从机</strong>片选引脚为<strong>低电平</strong>时，该设备就可以与<strong>主机</strong>进行通信；而为高电平时，则会忽略<strong>主机</strong>；这样就可以使得多个
SPI 设备共享相同的
<code>MISO</code>、<code>MOSI</code>、<code>CLK</code> 网络。</p>
</blockquote>
<p>在 Arduino 当中为 SPI 设备编写代码时，需要注意如下一些事项：</p>
<ul>
<li>设备最大可用的 SPI 速度，其值可以通过 <code>SPISettings()</code>
函数的第 1 个参数进行控制，例如额定频率为
<code>15 MHz</code>，则该参数就填写 <code>15000000</code>；</li>
<li>数据以<strong>最高有效位</strong>（MSB，Most Significant
Bit）先移动，还是<strong>最低有效位</strong>（LSB，Least Significant
Bit）先移动，由 <code>SPISettings()</code> 第 2 个参数设置；</li>
<li>数据时钟空闲时的电平状态，在时钟脉冲信号的<code>上升沿</code>还是<code>下降沿</code>取样，该项由
<code>SPISettings()</code> 的第 3 个参数进行控制；</li>
</ul>
<blockquote>
<p><strong>注意</strong>：SPI
协议相对比较松散，每一种设备的实现细节都会有所区别，所以编写代码时必须注意阅读芯片的数据手册。</p>
</blockquote>
<p>通常情况下，SPI 总线可以划分为 4
种传输模式，这些模式控制着数据是在时钟信号的上升沿还是下降沿进行移入移出，称为<strong>时钟相位</strong>（CPOL，Clock
Polarity）；以及时钟是在<code>高电平</code>还是<code>低电平</code>时空闲，称为<strong>时钟极性</strong>（CPHA，Clock
Phase），这 4 种模式的相位与极性如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">模式</th>
<th style="text-align: center;">时钟相位</th>
<th style="text-align: center;">时钟极性</th>
<th style="text-align: center;">输出沿</th>
<th style="text-align: center;">数据采集</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>SPI_MODE0</code></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">下降沿</td>
<td style="text-align: center;">上升沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>SPI_MODE1</code></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">上升沿</td>
<td style="text-align: center;">下降沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>SPI_MODE2</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">上升沿</td>
<td style="text-align: center;">下降沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>SPI_MODE3</code></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">下降沿</td>
<td style="text-align: center;">上升沿</td>
</tr>
</tbody>
</table>
<p>当选定好参数之后，就可以调用 <code>SPI.beginTransaction()</code> 启动
SPI 端口，并且直接将 <code>SPI.SPISettings()</code>
作为函数参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPI.<span class="built_in">beginTransaction</span>(<span class="built_in">SPISettings</span>(<span class="number">14000000</span>, MSBFIRST, SPI_MODE0));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：如果其它库想要在<strong>中断</strong>当中使用
SPI，则必须调用 <code>SPI.endtransaction()</code> 结束当前连接。</p>
</blockquote>
<p>对于大多数 SPI 设备而言，会在调用 <code>SPI.begintransaction()</code>
之后，输出<strong>低电平</strong>片选<strong>从设备</strong>；接着再调用
<code>SPI.transfer()</code> 开始传输数据，结束之后调用
<code>SPI. endtransaction()</code>，让片选端输出<strong>高电平</strong>，下面的表格，展示了
Arduino 开发板 SPI 引脚的默认分布情况：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Arduino 型号</th>
<th style="text-align: center;">MOSI</th>
<th style="text-align: center;">MISO</th>
<th style="text-align: center;">SCK</th>
<th style="text-align: center;">SS</th>
<th style="text-align: center;">工作电平</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Uno</strong></td>
<td style="text-align: center;"><code>GPIO11</code> 或
<code>ICSP4</code></td>
<td style="text-align: center;"><code>GPIO12</code> 或
<code>ICSP1</code></td>
<td style="text-align: center;"><code>GPIO13</code> 或
<code>ICSP3</code></td>
<td style="text-align: center;"><code>GPIO10</code></td>
<td style="text-align: center;">5V</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Mega2560</strong></td>
<td style="text-align: center;"><code>GPIO51</code> 或
<code>ICSP4</code></td>
<td style="text-align: center;"><code>GPIO50</code> 或
<code>ICSP1</code></td>
<td style="text-align: center;"><code>GPIO52</code> 或
<code>ICSP3</code></td>
<td style="text-align: center;"><code>GPIO53</code></td>
<td style="text-align: center;">5V</td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP8266</strong></td>
<td style="text-align: center;"><code>GPIO13</code></td>
<td style="text-align: center;"><code>GPIO12</code></td>
<td style="text-align: center;"><code>GPIO14</code></td>
<td style="text-align: center;"><code>GPIO15</code></td>
<td style="text-align: center;">3.3V</td>
</tr>
<tr>
<td style="text-align: center;"><strong>ESP32</strong></td>
<td style="text-align: center;"><code>GPIO23</code></td>
<td style="text-align: center;"><code>GPIO19</code></td>
<td style="text-align: center;"><code>GPIO18</code></td>
<td style="text-align: center;"><code>GPIO5</code></td>
<td style="text-align: center;">3.3V</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>
SPI 总线通信
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPISettings">SPISettings(speedMaximum,
dataOrder, dataMode)</a>
</td>
<td>
该对象用于配置设备的 SPI 通信端口。 <br> ▶ 参数
<code>speedMaximum</code>: 设置 SPI 通信的最大速度，例如
<code>20 MHz</code> 就设置为 <code>20000000</code>；<br> ▶ 参数
<code>dataOrder</code>: 最高有效位优先
<code>MSBFIRST</code>，最低有效位优先 <code>LSBFIRST</code>；<br> ▶
参数 <code>dataMode</code>: 一共拥有
<code>SPI_MODE0</code>、<code>SPI_MODE1</code>、<code>SPI_MODE2</code>、<code>SPI_MODE3</code>
四种模式；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPIBegin">SPI.begin()</a>
</td>
<td>
初始化 SPI 总线，即设置
<code>SCK</code>、<code>MOSI</code>、<code>SS</code>
引脚为输出模式，并且将 <code>SCK</code>、<code>MOSI</code>
的电平拉低，而 <code>SS</code> 的电平拉高。 <br> ▶ 参数: 无；<br> ▶
返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPIEnd">SPI.end()</a>
</td>
<td>
关闭 SPI 总线，注意此时引脚的工作模式不会发生改变。 <br> ▶ 参数:
无；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPIbeginTransaction">SPI.beginTransaction(mySettings)</a>
</td>
<td>
使用 <code>SPISettings</code> 对象初始化 SPI 总线。 <br> ▶ 参数
<code>mySettings</code>: 已经配置好的 <code>SPISettings</code> 对象<br>
▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPIendTransaction">SPI.endTransaction()</a>
</td>
<td>
停止使用 SPI 总线，通常在取消<strong>片选</strong>之后再进行调用，以释放
SPI 总线资源。 <br> ▶ 参数: 无；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPISetBitOrder">SPI.setBitOrder(order)</a>
</td>
<td>
该函数已经废弃，请使用 <code>SPISettings</code> 和
<code>SPI.beginTransaction()</code> 来配置 SPI 参数。 <br> ▶ 参数
<code>order</code>: 最高有效位优先 <code>MSBFIRST</code>，最低有效位优先
<code>LSBFIRST</code>；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPISetClockDivider">SPI.setClockDivider(divider)</a>
</td>
<td>
该函数已经废弃，请使用 <code>SPISettings</code> 和
<code>SPI.beginTransaction()</code> 来配置 SPI 参数。 <br> ▶ 参数
<code>divider</code>: 仅可用于采用 AVR 微控制器的
Arduino，可以选择将其设置为
<code>SPI_CLOCK_DIV2</code>、<code>SPI_CLOCK_DIV4</code>、<code>SPI_CLOCK_DIV8</code>、<code>SPI_CLOCK_DIV16</code>、<code>SPI_CLOCK_DIV32</code>、<code>SPI_CLOCK_DIV64</code>、<code>SPI_CLOCK_DIV128</code>
当中的一项；<br> ▶ 参数 <code>slaveSelectPin</code>: 仅用于 Arduino
Due，从设备选择引脚；<br> ▶ 参数 <code>divider</code>: 仅用于 Arduino
Due，取值范围为 <code>1 ~ 255</code>；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPISetDataMode">SPI.setDataMode(mode)</a>
</td>
<td>
该函数已经废弃，请使用 <code>SPISettings</code> 和
<code>SPI.beginTransaction()</code> 来配置 SPI 参数。 <br> ▶ 参数
<code>mode</code>: 选择 SPI 总线的工作模式，可以设置为
<code>SPI_MODE0</code>、<code>SPI_MODE1</code>、<code>SPI_MODE2</code>、<code>SPI_MODE3</code>；<br>
▶ 参数 <code>slaveSelectPin</code>: 仅用于 Arduino
Due，从设备选择引脚；<br> ▶ 返回值：无；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPITransfer"> receivedVal =
SPI.transfer(val)<br> receivedVal16 = SPI.transfer16(val16)<br>
SPI.transfer(buffer, size) </a>
</td>
<td>
SPI 总线可以同时收发数据，其中接收到的数据以 <code>receivedVal</code>
或者 <code>receivedVal16</code>
形式返回；如果接收到的数据被存储在一个缓冲区当中，那么旧的数据会被新接收到的数据替换掉。
<br> ▶ 参数 <code>val</code>: 需要通过 SPI
总线发送出去的字节数据；<br> ▶ 参数 <code>val16</code>: 需要使用 SPI
总线发送的两字节变量；<br> ▶ 参数 <code>buffer</code>:
待传输的数据的数组；<br> ▶ 返回值：Arduino 主设备在 SPI
总线上接收到的数据；
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/en/Reference/SPIusingInterrupt">SPI.usingInterrupt(interruptNumber)</a>
</td>
<td>
如果 Arduino 程序需要在中断当中执行 SPI
操作，那么可以调用这个函数注册该<strong>中断编码</strong>，从而使得
<code>SPI.beginTransaction()</code>
能够防止冲突的发生，即在调用该函数时指定的<strong>中断</strong>会在调用
<code>beginTransaction()</code> 时被禁用，然后在执行
<code>endTransaction()</code> 以后被重新启用。 <br> ▶ 参数
<code>interruptNumber</code>: 关联的<strong>中断编号</strong>；<br> ▶
返回值：无；
</td>
</tr>
</tbody>
</table>
<h2 id="外设工具类">外设工具类</h2>
<h3 id="mouse">Mouse</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/">Mouse
类</a>可以让基于<code>32u4</code>或<code>SAMD</code>微控制器的开发板（Leonardo、Esplora、Zero、Due、MKR）通过其
Micro USB 接口控制其所连接计算机上的鼠标。</p>
<table>
<thead>
<tr>
<th>
Mouse 鼠标控制
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mousebegin">Mouse.begin()</a>
</td>
<td>
用于模拟连接到计算机的鼠标，结束控制可以调用<code>Mouse.end()</code>。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mouseclick">Mouse.click(button)</a>
</td>
<td>
在当前鼠标所在的位置向计算机发送瞬时单击，作用与按下并立即释放鼠标按键相同。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mouseend">Mouse.end()</a>
</td>
<td>
用于停止模拟连接至计算机的鼠标。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mousemove">Mouse.move(xVal,
yVal, wheel)</a>
</td>
<td>
移动当前连接计算机上的鼠标位置，屏幕上的运动始终相对于光标当前的位置，使用之前必须首先调用<code>Mouse.begin()</code>。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mousepress">Mouse.press(button)</a>
</td>
<td>
将按下鼠标按键的操作发送至当前连接的计算机，类似于单击并且连续按住鼠标按键，可以调用<code>Mouse.release()</code>取消该操作。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mouserelease">Mouse.release(button)</a>
</td>
<td>
松开之前按下的鼠标按键。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/mouseispressed">Mouse.isPressed(button)</a>
</td>
<td>
检查当前指定鼠标按键的状态。
</td>
</tr>
</tbody>
</table>
<h3 id="keyboard">Keyboard</h3>
<p><a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/">Keyboard
类</a>可以让基于<code>32u4</code>或<code>SAMD</code>微控制器的开发板（Leonardo、Esplora、Zero、Due、MKR）通过
Micro USB 控制其所连接计算机上的键盘。</p>
<table>
<thead>
<tr>
<th>
Keyboard 键盘控制
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardbegin">Keyboard.begin()</a>
</td>
<td>
使用 Due
开发板时，表示开始模拟连接到计算机的键盘，调用<code>Keyboard.end()</code>可以结束控制。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardend">Keyboard.end()</a>
</td>
<td>
停止 Arduino 对当前连接计算机的键盘的仿真。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardpress">Keyboard.press(key)</a>
</td>
<td>
模拟按下并且按住键盘的操作，主要用于组合按键，可以调用<code>Keyboard.release</code>或者<code>Keyboard.releaseAll</code>结束操作，使用前必须首先调用<code>Keyboard.begin()</code>。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardprint">Keyboard.print(characters)</a>
</td>
<td>
将击键操作发送至当前连接的计算机。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardprintln">Keyboard.println(characters)</a>
</td>
<td>
将击键操作发送至当前连接的计算机，然后发送换行符和回车符。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardrelease">Keyboard.release(key)</a>
</td>
<td>
松开指定的键盘按键。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardreleaseall">Keyboard.releaseAll()</a>
</td>
<td>
松开当前按下的所有按键。
</td>
</tr>
<tr>
<td>
<a target="_blank" rel="noopener" href="https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardwrite">Keyboard.write(character)</a>
</td>
<td>
模拟按下并且释放键盘上的按键，可以直接用于发送 ASCII
字符或者其它的修饰符以及特殊按键。
</td>
</tr>
</tbody>
</table>
<h2 id="mega-2560">MEGA 2560</h2>
<p><a target="_blank" rel="noopener" href="https://store.arduino.cc/usa/mega-2560-r3">Arduino Mega
2560</a>开发板基于<a target="_blank" rel="noopener" href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf">ATmega2560</a>微控制器，与
Uno 上采用的 ATmega328P 同属 8 位 AVR
微控制器，其工作电压同为<code>5V</code>，采用的时钟频率为<code>16MHz</code>，拥有<code>256KB</code>容量的
Flash 存储器（其中<code>8KB</code>用于
Bootloader），<code>8KB</code>大小的 SRAM，<code>4KB</code>容量的
EEPROM。</p>
<p><img src="/Embedded/Arduino/Mega/0.png"></p>
<p>板载 54 个数字输入/输出引脚（其中 15 个可用作 PWM 输出），16
个模拟输入引脚，4 个
UART（硬件串行端口）。推荐的输入电压在<code>7 ~ 12V</code>范围以内，而极限输入电压则在<code>6 ~ 20V</code>之间，每个
I/O
引脚可以输出<code>20mA</code>直流电流，其中<code>3.3V</code>引脚可以输出<code>50mA</code>直流电流。</p>
<p><img src="/Embedded/Arduino/Mega/1.png"></p>
<p><img src="/Embedded/Arduino/Mega/2.png"></p>
<p><img src="/Embedded/Arduino/Mega/3.png"></p>
<p><img src="/Embedded/Arduino/Mega/4.png"></p>
<p>而 <a target="_blank" rel="noopener" href="https://store.arduino.cc/usa/due">Arduino Due</a>
作为首款基于 32 位 ARM 内核微控制器的 Arduino 开发板，其引脚分布与
Arduino Mega 2560 基本保持一致，但是微控制器采用了 <a href="http:https://www.atmel.com/Images/Atmel-11057-32-bit-Cortex-M3-Microcontroller-SAM3X-SAM3A_Datasheet.pdf">Atmel
SAM3X8E ARM Cortex-M3
CPU</a>，其工作电压为<code>3.3V</code>，时钟晶振频率为<code>84 MHz</code>，拥有<code>512KB</code>的
Flash 存储器，以及<code>96KB</code>的
SRAM（分为<code>64KB</code>和<code>32KB</code>两个<strong>Bank</strong>），并且板载
54 个数字输入/输出引脚（其中 12 个可用于 PWM 输出），12 个模拟输出，4
个硬件串行接口。</p>
<p><img src="/Embedded/Arduino/Mega/5.png"></p>
<h2 id="esp-8266">ESP 8266</h2>
<p><strong>深圳安信可科技</strong>推出的<a target="_blank" rel="noopener" href="https:https://www.wemos.cc/">NodeMCU</a>是一款以<strong>上海乐鑫科技</strong>
<a target="_blank" rel="noopener" href="https:https://www.espressif.com/zh-hans/products/hardware/esp8266ex/overview">ESP8266</a>
模组作为核心的开发板，早期主要支持 Lua 脚本化编程，后经开源社区推出的<a target="_blank" rel="noopener" href="https://arduino-esp8266.readthedocs.io/en/latest/">《ESP8266
Arduino Core》</a>整合了对于 Arduino
环境的支持，作为一款低成本的物联网开发板风靡于全球电子爱好者。</p>
<p><img src="/Embedded/Arduino/ESP8266/0.png"></p>
<p><strong>NodeMCU</strong> 开发板支持频率范围在
<code>2400 ~ 2483.5MHz</code> 之间的 802.11b/g/n 无线协议 WIFI，板载
<code>32Mbit</code> 的 Flash 外置存储空间，并且拥有 30 个接口引脚：</p>
<p><img src="/Embedded/Arduino/ESP8266/5.png"></p>
<h3 id="安装板级支持包-1">安装板级支持包</h3>
<p>将开源社区提供的 <strong>ESP8266 Arduino Core</strong> 板级支持包 URL
地址添加至 Arduino
IDE，鼠标依次选择<code>【文件 &gt; 首选项 &gt; 附加开发板管理器网址】</code>，然后填写如下地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://arduino.esp8266.com/stable/package_esp8266com_index.json</span><br></pre></td></tr></table></figure>
<p><img src="/Embedded/Arduino/ESP8266/1.png"></p>
<p>然后，选择菜单栏的<code>【工具 &gt; 开发板 &gt; 开发板管理器...】</code>打开<strong>开发板管理器</strong>，安装
<strong>ESP8266</strong> 板级支持包：</p>
<p><img src="/Embedded/Arduino/ESP8266/2.png"></p>
<p>最后，不要忘记回到 Arduino IDE
的工具栏当中，重新选择<code>【工具 &gt; 开发板 &gt; ESP 8266 Boards】</code>里面的开发板型号：</p>
<p><img src="/Embedded/Arduino/ESP8266/3.png"></p>
<p>选择完成以后，Arduino IDE 的<code>【工具】</code>菜单栏下面会展示
ESP8266
支持包提供的一些配置选项，这里还需要勾选当前开发板连接的串行端口号：</p>
<p><img src="/Embedded/Arduino/ESP8266/4.png"></p>
<h3 id="硬件串口-hardwareserial">硬件串口 HardwareSerial</h3>
<p>ESP8266 当中 <code>Serial</code> 串行总线对象的工作方式与普通 Arduino
基本相同，除了硬件上针对 <code>TX</code> 和 <code>RX</code>
的<code>128</code> 字节 <strong>FIFO</strong> 之外，还拥有额外的
<code>256</code> 字节 <code>TX</code> 和 <code>RX</code>
<strong>缓冲区</strong>。<strong>发送</strong>与<strong>接收</strong>都是由中断驱动，当
FIFO/缓冲区发生溢出之后，读写函数将会阻塞程序的执行。用于操作 ESP8266
串行通信接口的 <code>Serial</code> 和 <code>Serial1</code>对象，两者都是
<code>HardwareSerial</code> 类的实例，它们仅适用于采用 ESP8266
的核心板：</p>
<ul>
<li><code>Serial</code> 对象默认使用硬件 <strong>UART0</strong>
接口，它被映射到 <code>GPIO1/TX</code> 和 <code>GPIO3/RX</code>
引脚，执行 <code>Serial.begin()</code> 之后再调用
<code>Serial.swap()</code> 就可以将 <code>Serial</code> 对象映射至
<code>GPIO15/TX</code> 和 <code>GPIO13/RX</code>，然后再次调用
<code>Serial.swap()</code>，就可以将 <strong>UART0</strong> 恢复为默认的
<code>GPIO1</code> 和 <code>GPIO3</code>。</li>
<li><code>Serial1</code> 对象使用硬件 <strong>UART1</strong> 接口, 其中
<code>TX</code> 引脚为 <code>GPIO2</code>，而 <code>RX</code>
引脚连接到了 Flash 芯片，因而不能再用于接收数据，通过调用
<code>Serial1.begin(baudrate)</code>，即可开始使用
<code>Serial1</code>。如果 <code>Serial1</code> 没有被使用，并且
<code>Serial</code> 对象没有调用过 <code>swap()</code>，那么在调用
<code>Serial.begin()</code> 之后再执行
<code>Serial.set_tx(2)</code>，或者直接调用
<code>Serial.begin(baud, config, mode, 2)</code>，就可以将
<strong>UART0</strong> 的 <code>TX</code> 映射至
<strong>GPIO2</strong>。</li>
</ul>
<p><code>Serial</code> 与 <code>Serial1</code> 在 Arduino 标准 API
的基础之上，新增加了下面的工具方法：</p>
<table>
<thead>
<tr>
<th>
函数名称
</th>
<th>
功能描述
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>setdebugoutput(true)</code>
</td>
<td>
调用 <code>Serial.begin()</code> 时内置 WiFi
库的<strong>调试输出</strong>默认禁用，如果需要启用<strong>调试输出</strong>，就需要手动调用该函数，例如：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serial.<span class="built_in">setDebugOutput</span>(<span class="literal">true</span>)；  <span class="comment">// 开启 Serial 的调试输出</span></span><br><span class="line">Serial<span class="number">1.</span><span class="built_in">setdebugoutput</span>(<span class="literal">true</span>)； <span class="comment">// 将调试输出重定向至 Serial1</span></span><br></pre></td></tr></table></figure>
</td>
</tr>
<tr>
<td>
<code>begin(baudrate, config)</code>
</td>
<td>
在 <code>Serial</code> 与 <code>Serial1</code>
对象上调用该方法可以配置串行通信相关属性，例如<strong>数据位</strong>（<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>）、<strong>奇偶校验</strong>方式（奇校验
<code>O</code>、偶校验 <code>E</code>、无校验
<code>N</code>）、<strong>停止位</strong>（<code>1</code>、<code>2</code>），例如：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serial.<span class="built_in">begin</span>(baudrate, SERIAL_8N1);</span><br><span class="line">Serial.<span class="built_in">begin</span>(baudrate, SERIAL_<span class="number">6E2</span>);</span><br></pre></td></tr></table></figure>
</td>
</tr>
<tr>
<td>
<code>baudRate()</code>
</td>
<td>
调用 <code>Serial</code> 和 <code>Serial1</code> 对象上的
<code>baudRate()</code>
可以获取当前的波特率设置，返回一个表示当前波特率的整型数据，例如：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);                  <span class="comment">// 设置波特率为 115200</span></span><br><span class="line"><span class="type">int</span> br = Serial.<span class="built_in">baudRate</span>();            <span class="comment">// 获取当前的波特率</span></span><br><span class="line">Serial.<span class="built_in">printf</span>(<span class="string">&quot;Serial is %d bps&quot;</span>, br); <span class="comment">// 串口 1 将会打印 &quot;Serial is 115200 bps&quot;</span></span><br></pre></td></tr></table></figure>
</td>
</tr>
<tr>
<td>
<code>Serial.begin(detectedBaudrate)</code>
</td>
<td>
检测输入至 <code>Serial</code>
串行通信接口的未知波特率，返回值为当前检测到的波特率，返回
<code>0</code> 表示没有检测到有效的波特率。
</td>
</tr>
<tr>
<td>
<code>setRxBufferSize(size_t size)</code>
</td>
<td>
该函数用于设置接收缓冲区的大小，默认值为 <code>256</code>；
</td>
</tr>
</tbody>
</table>
<h3 id="软件串口-softwareserial">软件串口 SoftwareSerial</h3>
<p>通过使用第三方提供的 <a target="_blank" rel="noopener" href="https://github.com/plerup/espsoftwareserial">EspSoftwareSerial</a>
库，可以让 ESP8266 支持高达 <code>115200</code> 波特率的多个
<code>SoftwareSerial</code> 实例。下面的例子当中，首先将一块 ESP
开发板的 <code>16</code> 和 <code>17</code>
引脚分别作为串行数据的接收与发送引脚，并且发送一个字符数据
<code>5</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">16</span>, <span class="number">17</span>)</span></span>;     <span class="comment">// (接收引脚 RX, 发送引脚 TX)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);              <span class="comment">// 初始化硬件串口，用于 Arduino 串口监视器</span></span><br><span class="line">  mySerial.<span class="built_in">begin</span>(<span class="number">9600</span>);              <span class="comment">// 初始化软件串口，用于两块 ESP 开发板之前通信</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> bytesSent = mySerial.<span class="built_in">write</span>(<span class="number">5</span>); <span class="comment">// 发送字节数据</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Begins writing...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，把另一块 ESP 开发板的 <code>16</code> 和 <code>17</code>
引脚也分别用于串行数据的收发，然后接收上面那块 ESP
开发板发送过来的串行数据，并且将其显示到 Arduino IDE
的串口监视器当中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">16</span>, <span class="number">17</span>)</span></span>;     <span class="comment">// (接收引脚 RX, 发送引脚 TX)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);              <span class="comment">// 初始化硬件串口，用于 Arduino 串口监视器</span></span><br><span class="line">  mySerial.<span class="built_in">begin</span>(<span class="number">9600</span>);              <span class="comment">// 初始化软件串口，用于两块 ESP 开发板之前通信</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mySerial.<span class="built_in">available</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(mySerial.<span class="built_in">read</span>()); <span class="comment">// 接收字节数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="i²c-总线配置">I²C 总线配置</h3>
<p><strong>ESP8266 Arduino Core</strong> 板级支持包所实现的
<code>Wire</code> 库，支持 <strong>ESP8266</strong>
在<strong>主设备</strong>模式下高达 <code>450KHz</code> 的 I²C
总线时钟频率，使用时可以通过调用如下函数来配置
<code>SDA</code>（串行数据）和 <code>SCL</code>（串行时钟）引脚：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wire.begin(<span class="type">int</span> sda, <span class="type">int</span> scl)</span><br></pre></td></tr></table></figure>
<p>例如 <code>Wire.begin(0, 2)</code>，在常见的 <strong>ESP-01</strong>
模组当中 <strong>SDA</strong> 默认为第 <code>4</code>
引脚，<strong>SCL</strong> 默认为第 <code>5</code> 引脚。</p>
<blockquote>
<p><strong>注意</strong>：需要特别注意
<strong>ESP32</strong>（<code>Wire.begin(int sda, int scl)</code>）与
<strong>ESP8266</strong>（<code>Wire.setPins(sda_pin, scl_pin)</code>）在设置
I²C 引脚方面的区别。</p>
</blockquote>
<h3 id="spi-总线配置">SPI 总线配置</h3>
<p><strong>ESP8266 Arduino Core</strong> 比较完整的实现了 Arduino 的 SPI
总线 API，支持设置<strong>时钟极性</strong>（CPHA，Clock
Phase），但是并不支持<strong>时钟相位</strong>（CPOL，Clock
Polarity）的设置，并且 <code>SPI_MODE2</code> 和 <code>SPI_MODE3</code>
也暂时还无法工作。</p>
<p>通常情况下，默认的 SPI 引脚为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOSI = GPIO13</span><br><span class="line">MISO = GPIO12</span><br><span class="line">SCLK = GPIO14</span><br><span class="line">SS   = GPIO15</span><br></pre></td></tr></table></figure>
<p>但是通过扩展模式，可以将普通引脚切换为 <strong>SPI0</strong>
的硬件引脚，例如在执行 <code>SPI.begin()</code> 之前调用
<code>SPI.pins(6, 7, 8, 0)</code>，SPI 引脚的映射状态就会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOSI = SD1</span><br><span class="line">MISO = SD0</span><br><span class="line">SCLK = CLK</span><br><span class="line">HWCS = GPIO0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：这种模式通过微控制器读取
<strong>Flash</strong> 当中的程序代码来控制 SPI
引脚，这种控制由微控制器上的<strong>硬件仲裁单元</strong>来完成（Flash
总是拥有更高的优先级），这种情况下<strong>片选</strong>操作总是由硬件来进行控制，开发人员不能通过
GPIO 来操作片选线
（因为永远不会知道仲裁单元何时会访问总线，所以必须让其自动进行片选操作）。</p>
</blockquote>
<h2 id="esp-32">ESP 32</h2>
<p><strong>上海乐鑫科技</strong>推出的<a target="_blank" rel="noopener" href="https://www.espressif.com/sites/default/files/documentation/esp32-wroom-32_datasheet_cn.pdf"><strong>ESP32-WROOM-32</strong></a>
是一款通用型
<code>Wi-Fi 802.11 b/g/n</code>、<code>Bluetooth v4.2 BR/EDR BLE</code>
微控制器模组，其核心为 <strong>ESP32-D0WDQ6</strong>
芯片，拥有两个可以单独控制的 MCU 内核，时钟频率调节范围为
<code>80 MHz ~ 240 MHz</code>。集成了<strong>电容式触摸</strong>、<strong>霍尔</strong>、<strong>低噪声放大</strong>等传感器，以及
<strong>SD 卡</strong>、<strong>以太网</strong>、<strong>高速
SDIO/SPI</strong>、<strong>UART</strong>、<strong>I2S</strong>、<strong>I2C</strong>
等接口。</p>
<p><img src="/Embedded/Arduino/ESP32/DevKitC.png"></p>
<p><strong>深圳果云科技</strong>推出的 <strong>Goouuu-ESP32</strong>
则是一款基于 <strong>ESP32-WROOM-32</strong> 模组的 <code>39Pin</code>
开发板，由于乐鑫官方在 Github 上提供了兼容 Arduino 的板级支持包
<strong>arduino-esp32</strong>，因此该开发板可以良好工作于 Ardunio IDE
环境下，下面示意图展示了该开发板 GPIO 引脚的功能映射情况：</p>
<p><img src="/Embedded/Arduino/ESP32/pinmap.png"></p>
<h3 id="安装板级支持包-2">安装板级支持包</h3>
<p>按照前面 <a href="#添加板级支持包">添加板级支持包</a>
小节介绍的方法，将乐鑫官方提供的<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/arduino-esp32/en/latest/">《《ESP32
Arduino Core》》</a>板级支持包地址添加至 <strong>Ardunio IDE</strong>
的【附加开发板管理器网址】当中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure>
<p>接下来就可以依次选择【工具 -&gt; 开发板管理器】检索并且安装 ESP32
开发板兼容的 Ardunio
板级支持包了，如果觉得安装速度过慢，那么还可以选择下面的方式离线进行安装：</p>
<ol type="1">
<li>将 <a target="_blank" rel="noopener" href="https://github.com/espressif/arduino-esp32">arduino-esp32</a>
从官方乐鑫官方的 GitHub 仓库地址
<code>https://github.com/espressif/arduino-esp32.git</code>
克隆下来，或者直接下载仓库的 <code>.zip</code>
格式包。然后，拷贝或者解压至被称为 <strong>Sketchbook</strong> 的
Ardunio 默认代码工作区的目录 <code>\hardware\espressif\esp32</code>
下面，例如
<code>C:\Users\hank\Documents\Arduino\hardware\espressif\esp32</code>；</li>
<li>通过命令行进入 <code>\hardware\espressif\esp32</code> 目录然后执行
<code>git submodule update --init --recursive</code> 初始化 Git
子仓库；接下来进入 <code>\hardware\espressif\esp32\tools</code>
文件夹，鼠标双击执行 <code>get.exe</code> 安全依赖包；</li>
<li>完成上述步骤之后，安装 <strong>ESP32 Ardunio</strong>
兼容开发板对应的 USB 转串口驱动，然后打开 <strong>Ardunio IDE</strong>
并插入开发板，选择相应的<strong>开发板</strong>与<strong>端口</strong>，就可以编译并且上传
<strong>Ardunio Sketch</strong> 程序到板子上了；</li>
</ol>
<p>如果需要更新 <code>arduino-esp32</code>
板级支持包，则可以按照如下步骤进行操作：</p>
<ol type="1">
<li>首先，命令进入 <code>\hardware\espressif\esp32</code> 目录执行
<code>git pull</code> 更新代码；</li>
<li>然后，执行 <code>\hardware\espressif\esp32\tools\get.exe</code>
更新依赖包；</li>
</ol>
<h3 id="gpio-矩阵与复用">GPIO 矩阵与复用</h3>
<p>一些微控制器架构会将外设功能绑定到指定引脚，并且不能通过固件重新进行定义。而
ESP32 架构可以通过 <strong>IO MUX</strong> 与 <strong>GPIO
Matrix</strong> 管理和配置某些外设到不同的物理引脚，例如可以将任意的
GPIO 路由成为 <strong>I²C</strong> 的 <code>SDA</code> 和
<code>SCL</code>：</p>
<p><img src="/Embedded/Arduino/ESP32/peripheral.png"></p>
<p>使用 <strong>IO MUX</strong> 与 <strong>GPIO Matrix</strong>
相关功能的时候，需要注意如下 3 条事项：</p>
<ol type="1">
<li>某些引脚只允许设置为
<code>INPUT</code>，这类引脚不能用于需要配置输入/输出信号的外设；</li>
<li>由于一些外围设备存在输出信号，所以必须将 GPIO 配置为
<code>OUTPUT</code>；</li>
<li>某些高速外围设备，例如
<code>ADC</code>、<code>DAC</code>、<code>Touch</code>、<code>JTAG</code>
必须使用指定的 GPIO 引脚；</li>
</ol>
<blockquote>
<p><strong>注意</strong>：该功能优点在于无需完全依赖物理引脚，避免在硬件设计阶段出现的一些引脚功能定义错误。</p>
</blockquote>
<p>下面的表格展示了 ESP32 基本外设的 GPIO 功能映射情况：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">外设类型</th>
<th style="text-align: center;">GPIO 功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>ADC</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>DAC</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>触摸传感器</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>JTAG</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>SD/SDIO/MMC</strong>
主控制器</td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>Motor PWM</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>SDIO/SPI</strong> 从控制器</td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>UART</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>I²C</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>I²S</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>LED PWM</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>RMT</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>GPIO</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>Parallel QSPI</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>EMAC</strong></td>
<td style="text-align: center;"><code>指定 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>脉冲计数器</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong>TWAI</strong></td>
<td style="text-align: center;"><code>全部 GPIO</code></td>
</tr>
</tbody>
</table>
<h3 id="i²c-总线配置-1">I²C 总线配置</h3>
<p>前面关于 Arduino Uno 的内容当中，提到过其在硬件上将 <code>A4</code>
和 <code>A4</code> 引脚定义为 <strong>I²C</strong> 总线的
<code>SDA</code> 和 <code>SCL</code>，而在接下来的 ESP32
实例当中，我们不再需要手动将这些引脚设置到 <code>Wire.begin()</code>
函数的参数当中，因为这些配置（<code>SDA/GPIO 21</code> 和
<code>SCL/GPIO 22</code>），已经提前预置到了 ES32 的 Arduino
板级支持包当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    Wire.begin(); <span class="comment">// 开启 I²C 总线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然开发人员也可以根据需要，通过在调用 <code>Wire.begin()</code>
之前执行 <code>Wire.setPins(int sda, int scl)</code>
来改变这些引脚的默认设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sda_pin = <span class="number">16</span>; <span class="comment">// 将 GPIO 16 指定为 I²C 总线的 SDA</span></span><br><span class="line"><span class="type">int</span> scl_pin = <span class="number">17</span>; <span class="comment">// 将 GPIO 17 指定为 I²C 总线的 SCL</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    Wire.setPins(sda_pin, scl_pin); <span class="comment">// 首先，设置好 I²C 引脚</span></span><br><span class="line">    Wire.begin();                   <span class="comment">// 然后，再打开 I²C 总线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：类似的方法也适用于其它的外围设备。</p>
</blockquote>
<h2 id="外设运用实例">外设运用实例</h2>
<h3 id="pcf8574t-驱动-1602-液晶">PCF8574T 驱动 1602 液晶</h3>
<p>ESP32 通过使用 I²C 地址为 <code>0x27</code> 的
<strong>PCF8574T</strong> 液晶屏驱动模块，可以方便的驱动拥有
<code>16</code> 列 <code>2</code> 行显示范围的 <strong>1602</strong>
液晶屏幕。</p>
<p><img src="/Embedded/Arduino/Peripheral/PCF8574T.png"></p>
<blockquote>
<p><strong>注意</strong>：通过前面 <a href="#wire">Wire</a> 小节提供的
<strong>I²C 地址扫描程序</strong>，可以通过串口监视器，获得连接到 ESP
开发板默认 I²C 引脚的设备地址。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LiquidCrystal_I2C.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 PCF8574T 液晶屏驱动模块的 I²C 地址建立一个 16 列 2 行的液晶对象 */</span></span><br><span class="line"><span class="function">LiquidCrystal_I2C <span class="title">lcd</span> <span class="params">(<span class="number">0x27</span>, <span class="number">16</span>, <span class="number">2</span>)</span></span>;  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">setup</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  lcd. <span class="built_in">init</span> ();          <span class="comment">// 初始化 1602 液晶连接</span></span><br><span class="line">  lcd. <span class="built_in">backlight</span> ();     <span class="comment">// 开启 1602 液晶的背光</span></span><br><span class="line">  lcd. <span class="built_in">print</span> ( <span class="string">&quot;==[Our Status]==&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">loop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  lcd. <span class="built_in">setCursor</span> (<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 将光标放置到第 1 行的第 0 列</span></span><br><span class="line">  <span class="comment">/* 动态显示当前秒数 */</span></span><br><span class="line">  lcd. <span class="built_in">print</span> ( <span class="built_in">millis</span> () / <span class="number">1000</span>);</span><br><span class="line">  lcd. <span class="built_in">print</span> ( <span class="string">&quot; Seconds&quot;</span> );</span><br><span class="line">  <span class="built_in">delay</span> (<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mfrc-522-读写卡">MFRC 522 读写卡</h3>
<p><a target="_blank" rel="noopener" href="https://www.mifare.net/en/"><strong>MIFARE</strong></a>
是<strong>恩智浦</strong>（NXP）半导体公司推出的<code>接触/非接触式</code>智能卡技术的商标，其中
<a target="_blank" rel="noopener" href="https://www.nxp.com/docs/en/data-sheet/MFRC522.pdf"><strong>RC522</strong></a>
是应用 <code>13.56MHz</code> 频率的非接触式读写卡芯片，支持 <a target="_blank" rel="noopener" href="https://nfc-tools.github.io/resources/standards/iso14443/"><strong>14443A</strong></a>
协议。而 <strong>RFID-RC522</strong> 模组则是一款采用了
<code>MIFARE RC522</code> 芯片的读写卡模组，采用 <code>3.3V</code>
电压进行供电，支持 SPI 总线与主控制芯片进行连接通信。</p>
<p><img src="/Embedded/Arduino/Peripheral/RC522.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/miguelbalboa/rfid"><strong>RFID</strong></a>是一款支持
RFID-RC522 模组的 Arduino
第三方开源库，其对应的引脚功能映射如下面的表格所示：</p>
<table>
<thead>
<tr>
<th>SPI 引脚</th>
<th>MFRC522</th>
<th>Uno</th>
<th>Mega</th>
<th>ESP8266</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RST/Reset</strong></td>
<td>RST</td>
<td>9</td>
<td>5</td>
<td>D3</td>
</tr>
<tr>
<td><strong>SPI SS</strong></td>
<td>SDA</td>
<td>10</td>
<td>53</td>
<td>D8</td>
</tr>
<tr>
<td><strong>SPI MOSI</strong></td>
<td>MOSI</td>
<td>11/ICSP-4</td>
<td>51</td>
<td>D7</td>
</tr>
<tr>
<td><strong>SPI MISO</strong></td>
<td>MISO</td>
<td>12/ICSP-1</td>
<td>50</td>
<td>D6</td>
</tr>
<tr>
<td><strong>SPI SCK</strong></td>
<td>SCK</td>
<td>13/ICSP-3</td>
<td>52</td>
<td>D5</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：可供 RC522
读写操作的<strong>接触式集成电路卡</strong>（PICC，Proximity Integrated
Circuit Card）是一种使用 ISO/IEC 14443A 接口的射频卡/标签，其与
<strong>RFID-RC522</strong> 读写卡器之间涉及的通信协议，定义在《ISO/IEC
14443-3:2011 Part 3 Type A》规范的第 6 小节
<code>Type A – Initialization and anticollision</code>
当中，除此之外，具体的功能描述还可以参考 <a target="_blank" rel="noopener" href="https://www.nxp.com/docs/en/data-sheet/MFRC522.pdf">RC522
数据手册</a>。</p>
</blockquote>
<h2 id="安装-esp-板级支持包的新方法">安装 ESP 板级支持包的新方法</h2>
<p>首先，向 <strong>Arduino IDE</strong> 添加如下的开发板 URL 地址：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//www.arduino.cn/package_esp32_index.json</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//www.arduino.cn/package_esp8266com_index.json</span></span><br></pre></td></tr></table></figure>
<p>然后，前往
<code>https://cloud.codess-nas.top:5213/s/2Ocn?path=%2F</code>
直接下载板级支持包文件进行安装即可。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>玩转 Arduino Uno Mega 与 UINIO-MCU-ESP32 开源硬件</p><p><a href="http://www.uinio.com/Embedded/Arduino/">http://www.uinio.com/Embedded/Arduino/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2016-02-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Web/Webpack/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Webpack 4 核心配置剖析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Software/Data-Structure/"><span class="level-item">常用数据结构 &amp; 算法分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#uno-r3"><span class="level-left"><span class="level-item">1</span><span class="level-item">UNO R3</span></span></a></li><li><a class="level is-mobile" href="#安装串口驱动"><span class="level-left"><span class="level-item">2</span><span class="level-item">安装串口驱动</span></span></a></li><li><a class="level is-mobile" href="#arduino-ide"><span class="level-left"><span class="level-item">3</span><span class="level-item">Arduino IDE</span></span></a></li><li><a class="level is-mobile" href="#安装第三方类库"><span class="level-left"><span class="level-item">4</span><span class="level-item">安装第三方类库</span></span></a></li><li><a class="level is-mobile" href="#安装板级支持包"><span class="level-left"><span class="level-item">5</span><span class="level-item">安装板级支持包</span></span></a></li><li><a class="level is-mobile" href="#引脚工作模式"><span class="level-left"><span class="level-item">6</span><span class="level-item">引脚工作模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数字引脚-digital"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">数字引脚 Digital</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#input-输入"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">INPUT 输入</span></span></a></li><li><a class="level is-mobile" href="#input_pullup-上拉输入"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">INPUT_PULLUP 上拉输入</span></span></a></li><li><a class="level is-mobile" href="#output-输出"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">OUTPUT 输出</span></span></a></li></ul></li><li><a class="level is-mobile" href="#模拟引脚-analog"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">模拟引脚 Analog</span></span></a></li><li><a class="level is-mobile" href="#脉冲宽度调制-pwm"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">脉冲宽度调制 PWM</span></span></a></li></ul></li><li><a class="level is-mobile" href="#arduino-c"><span class="level-left"><span class="level-item">7</span><span class="level-item">Arduino C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#草图"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">草图</span></span></a></li><li><a class="level is-mobile" href="#常量"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">常量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#整型常量"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">整型常量</span></span></a></li><li><a class="level is-mobile" href="#浮点常量"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">浮点常量</span></span></a></li><li><a class="level is-mobile" href="#布尔常量-true-与-false"><span class="level-left"><span class="level-item">7.2.3</span><span class="level-item">布尔常量 true 与 false</span></span></a></li><li><a class="level is-mobile" href="#电平状态-high-low"><span class="level-left"><span class="level-item">7.2.4</span><span class="level-item">电平状态 HIGH LOW</span></span></a></li><li><a class="level is-mobile" href="#输入状态-input-output-input_pullup"><span class="level-left"><span class="level-item">7.2.5</span><span class="level-item">输入状态 INPUT OUTPUT
INPUT_PULLUP</span></span></a></li><li><a class="level is-mobile" href="#板载-led_builtin"><span class="level-left"><span class="level-item">7.2.6</span><span class="level-item">板载 LED_BUILTIN</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">数据类型</span></span></a></li><li><a class="level is-mobile" href="#数据类型转换"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">数据类型转换</span></span></a></li><li><a class="level is-mobile" href="#运算符-操作符"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">运算符 &amp; 操作符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sizeof"><span class="level-left"><span class="level-item">7.5.1</span><span class="level-item">sizeof()</span></span></a></li><li><a class="level is-mobile" href="#注释"><span class="level-left"><span class="level-item">7.5.2</span><span class="level-item">注释</span></span></a></li><li><a class="level is-mobile" href="#流程控制"><span class="level-left"><span class="level-item">7.5.3</span><span class="level-item">流程控制</span></span></a></li><li><a class="level is-mobile" href="#预编译"><span class="level-left"><span class="level-item">7.5.4</span><span class="level-item">预编译</span></span></a></li><li><a class="level is-mobile" href="#数学运算符"><span class="level-left"><span class="level-item">7.5.5</span><span class="level-item">数学运算符</span></span></a></li><li><a class="level is-mobile" href="#比较运算符"><span class="level-left"><span class="level-item">7.5.6</span><span class="level-item">比较运算符</span></span></a></li><li><a class="level is-mobile" href="#布尔运算符"><span class="level-left"><span class="level-item">7.5.7</span><span class="level-item">布尔运算符</span></span></a></li><li><a class="level is-mobile" href="#指针运算符"><span class="level-left"><span class="level-item">7.5.8</span><span class="level-item">指针运算符</span></span></a></li><li><a class="level is-mobile" href="#位运算符"><span class="level-left"><span class="level-item">7.5.9</span><span class="level-item">位运算符</span></span></a></li><li><a class="level is-mobile" href="#复合运算符"><span class="level-left"><span class="level-item">7.5.10</span><span class="level-item">复合运算符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变量限定符"><span class="level-left"><span class="level-item">7.6</span><span class="level-item">变量限定符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#const"><span class="level-left"><span class="level-item">7.6.1</span><span class="level-item">const</span></span></a></li><li><a class="level is-mobile" href="#static"><span class="level-left"><span class="level-item">7.6.2</span><span class="level-item">static</span></span></a></li><li><a class="level is-mobile" href="#volatile"><span class="level-left"><span class="level-item">7.6.3</span><span class="level-item">volatile</span></span></a></li><li><a class="level is-mobile" href="#progmem"><span class="level-left"><span class="level-item">7.6.4</span><span class="level-item">PROGMEM</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组处理"><span class="level-left"><span class="level-item">7.7</span><span class="level-item">数组处理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#核心库函数"><span class="level-left"><span class="level-item">8</span><span class="level-item">核心库函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数字-io"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">数字 I/O</span></span></a></li><li><a class="level is-mobile" href="#模拟-io"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">模拟 I/O</span></span></a></li><li><a class="level is-mobile" href="#高级-io"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">高级 I/O</span></span></a></li><li><a class="level is-mobile" href="#定时"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">定时</span></span></a></li><li><a class="level is-mobile" href="#数学"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">数学</span></span></a></li><li><a class="level is-mobile" href="#字符"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">字符</span></span></a></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">字符串</span></span></a></li><li><a class="level is-mobile" href="#位操作"><span class="level-left"><span class="level-item">8.8</span><span class="level-item">位操作</span></span></a></li><li><a class="level is-mobile" href="#中断"><span class="level-left"><span class="level-item">8.9</span><span class="level-item">中断</span></span></a></li></ul></li><li><a class="level is-mobile" href="#io-工具类"><span class="level-left"><span class="level-item">9</span><span class="level-item">I/O 工具类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#stream"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">stream</span></span></a></li><li><a class="level is-mobile" href="#serial"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">Serial</span></span></a></li><li><a class="level is-mobile" href="#wire"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">Wire</span></span></a></li><li><a class="level is-mobile" href="#spi"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">SPI</span></span></a></li></ul></li><li><a class="level is-mobile" href="#外设工具类"><span class="level-left"><span class="level-item">10</span><span class="level-item">外设工具类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mouse"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">Mouse</span></span></a></li><li><a class="level is-mobile" href="#keyboard"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">Keyboard</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mega-2560"><span class="level-left"><span class="level-item">11</span><span class="level-item">MEGA 2560</span></span></a></li><li><a class="level is-mobile" href="#esp-8266"><span class="level-left"><span class="level-item">12</span><span class="level-item">ESP 8266</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装板级支持包-1"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">安装板级支持包</span></span></a></li><li><a class="level is-mobile" href="#硬件串口-hardwareserial"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">硬件串口 HardwareSerial</span></span></a></li><li><a class="level is-mobile" href="#软件串口-softwareserial"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">软件串口 SoftwareSerial</span></span></a></li><li><a class="level is-mobile" href="#i²c-总线配置"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">I²C 总线配置</span></span></a></li><li><a class="level is-mobile" href="#spi-总线配置"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">SPI 总线配置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#esp-32"><span class="level-left"><span class="level-item">13</span><span class="level-item">ESP 32</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装板级支持包-2"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">安装板级支持包</span></span></a></li><li><a class="level is-mobile" href="#gpio-矩阵与复用"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">GPIO 矩阵与复用</span></span></a></li><li><a class="level is-mobile" href="#i²c-总线配置-1"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">I²C 总线配置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#外设运用实例"><span class="level-left"><span class="level-item">14</span><span class="level-item">外设运用实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#pcf8574t-驱动-1602-液晶"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">PCF8574T 驱动 1602 液晶</span></span></a></li><li><a class="level is-mobile" href="#mfrc-522-读写卡"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">MFRC 522 读写卡</span></span></a></li></ul></li><li><a class="level is-mobile" href="#安装-esp-板级支持包的新方法"><span class="level-left"><span class="level-item">15</span><span class="level-item">安装 ESP 板级支持包的新方法</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C/C++ 语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Linux 操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Python-%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">Python 语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/UINIO-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">UINIO 开源项目资料</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Web-%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web 开发</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%BA%A7%E4%B8%9A%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">产业经济</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%96%E8%A7%82%E4%B8%8E%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">外观与结构设计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6/"><span class="level-start"><span class="level-item">嵌入式固件</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">开发环境配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">版本管理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"><span class="level-start"><span class="level-item">生活日常</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">硬件电子技术</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">软件工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Motor-PWM/"><img src="/Electronics/Motor-PWM/logo.png" alt="直流无刷电机的 PWM 驱动控制原理简述"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-06T16:00:00.000Z">2024-11-07</time></p><p class="title"><a href="/Electronics/Motor-PWM/">直流无刷电机的 PWM 驱动控制原理简述</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/E-Series/"><img src="/Electronics/E-Series/logo.png" alt="美国电子工业联盟 E 系列标准参数值速查手册"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-05T16:00:00.000Z">2024-11-06</time></p><p class="title"><a href="/Electronics/E-Series/">美国电子工业联盟 E 系列标准参数值速查手册</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/TVS/"><img src="/Electronics/TVS/logo.png" alt="瞬态电压抑制二极管 TVS 选型简述"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-05T16:00:00.000Z">2024-09-06</time></p><p class="title"><a href="/Electronics/TVS/">瞬态电压抑制二极管 TVS 选型简述</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Battery/"><img src="/Electronics/Battery/logo.png" alt="锂离子电池技术参数简明选型指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-08-28T16:00:00.000Z">2024-08-29</time></p><p class="title"><a href="/Electronics/Battery/">锂离子电池技术参数简明选型指南</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/LTspice/"><img src="/Electronics/LTspice/logo.png" alt="如何使用新版本的 LTspice 进行模拟电路仿真"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-05-21T16:00:00.000Z">2024-05-22</time></p><p class="title"><a href="/Electronics/LTspice/">如何使用新版本的 LTspice 进行模拟电路仿真</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/">硬件电子技术</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E6%95%B0/"><span class="tag">代数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%BF%E7%9C%9F/"><span class="tag">仿真</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%99%A8%E4%BB%B6/"><span class="tag">元器件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"><span class="tag">命令行</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%84%E9%A2%91/"><span class="tag">射频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"><span class="tag">嵌入式 Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><span class="tag">开发规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"><span class="tag">微积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%8B%E6%9C%BA/"><span class="tag">手机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/"><span class="tag">数学结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD/"><span class="tag">新概念英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%BD%E8%BD%A6/"><span class="tag">汽车</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90%E4%BB%AA%E5%99%A8/"><span class="tag">电子仪器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%9C%BA/"><span class="tag">电机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"><span class="tag">电路理论</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="tag">网络协议</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv" style="display:inline-block;margin:auto 0.5rem;">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2025 <span>UinIO 电子技术实验室</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>