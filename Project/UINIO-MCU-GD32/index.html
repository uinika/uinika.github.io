<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>兆易创新 UINIO-MCU-GD32F350 固件库开发指南 - UinIO.com 电子技术实验室</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UinIO.com 电子技术实验室"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UinIO.com 电子技术实验室"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="早在新冠疫情爆发前的 2019 年，就曾经撰写过一篇关于 ARM 标准库的技术长文 《意法半导体 STM32F103 标准库典型实例》 ，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4 年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于兆易创新 推出的国产 ARM 微控制器，设计和制作了 UINIO-MCU-GD32F350RBT6 这款开源核心板，同时撰写"><meta property="og:type" content="blog"><meta property="og:title" content="兆易创新 UINIO-MCU-GD32F350 固件库开发指南"><meta property="og:url" content="http://www.uinio.com/Project/UINIO-MCU-GD32/"><meta property="og:site_name" content="UinIO.com 电子技术实验室"><meta property="og:description" content="早在新冠疫情爆发前的 2019 年，就曾经撰写过一篇关于 ARM 标准库的技术长文 《意法半导体 STM32F103 标准库典型实例》 ，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4 年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于兆易创新 推出的国产 ARM 微控制器，设计和制作了 UINIO-MCU-GD32F350RBT6 这款开源核心板，同时撰写"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.uinio.com/images/favicon.png"><meta property="article:published_time" content="2024-03-17T16:00:00.000Z"><meta property="article:modified_time" content="2024-07-03T18:28:39.696Z"><meta property="article:author" content="Hank"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.uinio.com/images/favicon.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.uinio.com/Project/UINIO-MCU-GD32/"},"headline":"兆易创新 UINIO-MCU-GD32F350 固件库开发指南","image":["http://www.uinio.com/Project/UINIO-MCU-GD32/logo.png"],"datePublished":"2024-03-17T16:00:00.000Z","dateModified":"2024-07-03T18:28:39.696Z","author":{"@type":"Person","name":"Hank"},"publisher":{"@type":"Organization","name":"UinIO.com 电子技术实验室","logo":{"@type":"ImageObject","url":{"text":"UinIO.com"}}},"description":"早在新冠疫情爆发前的 2019 年，就曾经撰写过一篇关于\r ARM 标准库的技术长文 《意法半导体\r STM32F103 标准库典型实例》\r ，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4\r 年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于兆易创新\r 推出的国产 ARM 微控制器，设计和制作了 UINIO-MCU-GD32F350RBT6\r 这款开源核心板，同时撰写"}</script><link rel="canonical" href="http://www.uinio.com/Project/UINIO-MCU-GD32/"><link rel="alternate" href="/atom.xml" title="UinIO.com 电子技术实验室" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.font.im/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">UinIO.com</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://space.bilibili.com/1514341594">Bilibili</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.zhihu.com/people/uinika">知乎</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/uinika">Github</a><a class="navbar-item" target="_blank" rel="noopener" href="https://gitee.com/uinika">Gitee</a><a class="navbar-item" href="/archives/index.html">开源硬件</a><a class="navbar-item" href="/my/about.html">关于我</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-17T16:00:00.000Z" title="2024/3/18 00:00:00">2024-03-18</time>发表</span><span class="level-item"><time dateTime="2024-07-03T18:28:39.696Z" title="2024/7/4 02:28:39">2024-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Project/">Project</a></span><span class="level-item">4 小时读完 (大约32622个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">兆易创新 UINIO-MCU-GD32F350 固件库开发指南</h1><div class="content"><p>早在新冠疫情爆发前的 <strong>2019</strong> 年，就曾经撰写过一篇关于
<strong>ARM</strong> 标准库的技术长文 <a target="_blank" rel="noopener" href="http://uinio.com/Embedded/STM32F103/"><strong>《意法半导体
STM32F103 标准库典型实例》</strong></a>
，文章非常详尽的介绍了各种常见片上外设资源的应用。时至 4
年以后的今天，国产微控制器在工程实践领域已经得到了广泛运用，因而基于<a target="_blank" rel="noopener" href="https://www.gigadevice.com.cn/product/mcu"><strong>兆易创新</strong></a>
推出的国产 ARM 微控制器，设计和制作了 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>
这款开源核心板，同时撰写了本篇文章作为配套的资料教程，希冀为国产芯片的商业化普及尽自己一份绵薄之力。</p>
<p><img src="/Project/UINIO-MCU-GD32/logo.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>
是一款采用 LQFP64 封装的 <strong>GD32F350RBT6</strong>
微控制器核心板，基于 <strong>ARM Cortex-M4</strong> 内核架构，主频高达
<code>108MHz</code>，拥有 <code>128K</code> 容量 Flash，以及
<code>16K</code> 的 SRAM。而 <a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-GD32F103C"><strong>UINIO-MCU-GD32F103C</strong></a>
采用 LQFP48 封装的 <strong>GD32F103Cxxx</strong> 系列微控制器（包括
<code>GD32F103CBT6</code>、<code>GD32F103C8T6</code>、<code>GD32F103C6T6</code>、<code>GD32F103C4T6</code>），基于
<strong>ARM Cortex-M3</strong> 内核架构，主频达到
<code>108MHz</code>，拥有 <code>16K ~ 128K</code> 容量 Flash，以及
<code>6K ~ 20K</code> 的 SRAM。</p>
<span id="more"></span>
<h1 id="准备-gd32-支持包-固件库">准备 GD32 支持包 &amp; 固件库</h1>
<p>这里以 <strong>UINIO-MCU-GD32F350RBT6</strong>
核心板作为例子，首先需要前往兆易创新的 <a target="_blank" rel="noopener" href="https://www.gd32mcu.com/cn/download/7?kw=GD32F3x0"><strong>GD32
MCU 微控制器</strong></a>
官方网站，把如下两个开发资源下载到本地计算机：</p>
<ol type="1">
<li><strong>GD32F350RBT6</strong> 固件库
<code>GD32F3x0_Firmware_Library_V2.2.1</code>。</li>
<li><strong>Keil uVision5</strong> 开发环境的支持包
<code>GigaDevice.GD32F3x0_DFP.3.0.2.pack</code>。</li>
</ol>
<p>然后，启动 <strong>Keil uVision5</strong>
开发环境，开始导入或者在线安装
<code>GigaDevice.GD32F3x0_DFP.3.0.2.pack</code> 支持包：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/0.png"></p>
<p>接下来，解压 <code>GD32F3x0_Firmware_Library_V2.2.1</code>
固件库，此时会得到如下一系列目录：</p>
<ul>
<li><strong>Docs</strong>：包含有官方评估板的<strong>原理图</strong>和固件库的<strong>使用指南</strong>。</li>
<li><strong>Examples</strong>：各种 <strong>GD32F350RBT6</strong>
片上外设的官方示例源程序。</li>
<li><strong>Firmware</strong>：包含有<strong>内核库</strong>
<code>CMSIS</code>、<strong>标准外设库</strong>
<code>GD32F3x0_standard_peripheral</code>、<strong>USB
文件系统库</strong> <code>GD32F3x0_usbfs_library</code>
三个子目录。</li>
<li><strong>Template</strong>：集成开发环境 <strong>IAR</strong> 和
<strong>Keil uVision4</strong> 的工程模板，包含有 LED 闪烁、USART
打印、按键控制的简单示例程序。</li>
<li><strong>Utilities</strong>：一些第三方组件和 GD32
配套的评估板测试文件。</li>
</ul>
<p>其中 <strong>Examples</strong>
下面的每一个子目录，都对应着一种片上外设的示例程序，里面通常会包含有如下的源文件：</p>
<ul>
<li><code>main.c</code>：主程序源文件。</li>
<li><code>systick.h</code>：SysTick 精准延时头文件；</li>
<li><code>systick.c</code>：SysTick 精准延时源文件；</li>
<li><code>GD32f3x0.it.h</code>：中断处理程序头文件；</li>
<li><code>GD32f3x0_it.c</code>：中断处理程序源文件（未使用中断，所有函数体为空）；</li>
<li><code>GD32f3x0_libopt.h</code>：通过预处理语句 <code>#include</code>
包含指定的外设库 <code>.h</code> 头文件（默认导入全部外设）；</li>
</ul>
<p>而 <strong>Firmware</strong> 目录下面包含有
<strong>GD32F350RBT6</strong> 固件库的核心源文件：</p>
<ul>
<li><code>CMSIS</code> 子目录包含有 <strong>ARM Cortex-M4</strong>
内核的支持文件、启动代码、库引导文件，以及 <code>GD32F3x0</code>
的全局头文件和系统配置文件。</li>
<li><code>GD32F3x0_standard_peripheral</code> 子目录下的
<code>Include</code> 包含了固件库所需要的头文件，而 <code>Source</code>
则包含有固件库所需的源文件。</li>
</ul>
<h1 id="测试-uinio-mcu-gd32-核心板">测试 UINIO-MCU-GD32 核心板</h1>
<p>打开 <code>GD32F3x0_Firmware_Library_V2.2.1</code> 固件库下面的
<code>Template</code> 目录，删掉除开 <code>Keil_project</code>
目录之外的其它文件与目录，然后将 <code>Examples\GPIO\Running_led</code>
内的全部源文件，拷贝至 <code>Template</code>
目录当中，从而获得如下的文件目录结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Template</span><br><span class="line">├── Keil_project</span><br><span class="line">│   ├── Project.uvopt</span><br><span class="line">│   └── Project.uvproj</span><br><span class="line">├── gd32f3x0_it.c</span><br><span class="line">├── gd32f3x0_it.h</span><br><span class="line">├── gd32f3x0_libopt.h</span><br><span class="line">├── main.c</span><br><span class="line">├── readme.txt</span><br><span class="line">├── systick.c</span><br><span class="line">└── systick.h</span><br></pre></td></tr></table></figure>
<p>鼠标双击 <code>Template</code> 目录下面的工程描述文件
<code>Project.uvproj</code>，启动 <strong>Keil uVision5</strong>。由于
<code>GD32F3x0_Firmware_Library_V2.2.1</code> 当中的示例工程采用的是
<strong>Keil uVision4</strong>
建立和编译，因而此时会弹出下面的错误信息：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/1.png"></p>
<p>按下【确定】按钮忽略这些错误信息，依次选择顶部菜单栏上面的【Project
-&gt; Manage -&gt; Migrate to Version 5 Format...】，把工程迁移成为
<strong>Keil uVision5</strong> 兼容的格式：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/2.png"></p>
<p>此时会提示工程描述文件需要从 <strong>Keil uVision4</strong> 的
<code>Project.uvproj</code> 保存为 <strong>Keil uVision5</strong> 的
<code>Project.uvprojx</code>，直接按下【确定】按钮即可：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/3.png"></p>
<p>在开始接下来的操作之前，需要先将 <strong>Keil uVision5</strong>
工程的编译目标切换为 <strong>UINIO-MCU-GD32F350RBT6</strong>
核心板所使用的型号【GD32F350】：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/4.png"></p>
<p>点击顶部工具栏上的【Options for
Target...】按钮，指定<strong>目标选项对话框</strong>里的【ARM
Compiler】版本为 <code>compiler version 5</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/5.png"></p>
<blockquote>
<p><strong>注意</strong>：这里必须修改 <strong>Keil uVision5</strong>
当中 ARM 编译器版本，否则会导致后续的编译操作出现错误，具体请参考 <a target="_blank" rel="noopener" href="http://uinio.com/Project/UINIO-DAP-Link">《ARM 调试工具
UINIO-DAP-Link 应用详解》</a> 一文的 <a target="_blank" rel="noopener" href="http://uinio.com/Project/UINIO-DAP-Link/#%E6%B7%BB%E5%8A%A0-arm-compiler-version-5">添加
ARM Compiler version 5</a> 小节内容。</p>
</blockquote>
<p>切换至对话框的【Output】选项卡，在勾选【Create HEX
File】的同时，把【Name of Executable】修改为
<code>Project.hex</code>（务必添加 <code>.hex</code>
后缀，否则默认烧录的是 <code>.axf</code> 文件）：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/6.png"></p>
<p>再切换至对话框当中的【Debug】选项卡，此时需要将 <a target="_blank" rel="noopener" href="http://uinio.com/Project/UINIO-DAP-Link/"><strong>UINIO-DAP-Link</strong></a>
插入至计算机的 USB 接口，然后在下拉选择【CMSIS-DAP
Debugger】之后，再按下右侧的【Settings】按钮：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/7.png"></p>
<p>此时会弹出<strong>调试器设置对话框</strong>，这里我们选择【UINIO-CMSIS-DAP】，并且将【Max
Clock】配置为 <code>10MHz</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/8.png"></p>
<p>最后再切换至【Flash Download】选项卡，勾选【Reset and
Run】，并且点击【Add】按钮添加片上 Flash 的编程算法：</p>
<p><img src="/Project/UINIO-MCU-GD32/1-Keil/9.png"></p>
<p>完成上述配置步骤之后点击【OK】，回到 <strong>Keil uVision5</strong>
的主界面，此时按下快捷键【F7】或者顶部工具栏上的【Build】按钮编译示例工程，再按下快捷键【F8】或者【Download】按钮将编译后得到的
<code>.hex</code> 程序下载至 <strong>UINIO-MCU-GD32F350RBT6</strong>
核心板运行，此时整个工程的目录文件结构如下所示，其中的 <code>Out</code>
目录保存着编译后产生的十六进制 <code>.hex</code> 文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Template</span><br><span class="line">├── Keil_project</span><br><span class="line">│   ├── Project.uvguix.hank</span><br><span class="line">│   ├── Project.uvopt</span><br><span class="line">│   ├── Project.uvoptx</span><br><span class="line">│   ├── Project.uvproj.saved_uv4</span><br><span class="line">│   ├── Project.uvprojx</span><br><span class="line">│   ├── RTE</span><br><span class="line">│   │   ├── _GD32F310</span><br><span class="line">│   │   │   └── RTE_Components.h</span><br><span class="line">│   │   ├── _GD32F330</span><br><span class="line">│   │   │   └── RTE_Components.h</span><br><span class="line">│   │   └── _GD32F350</span><br><span class="line">│   │       └── RTE_Components.h</span><br><span class="line">│   ├── list</span><br><span class="line">│   │   ├── Project.map</span><br><span class="line">│   │   └── startup_gd32f3x<span class="number">0.l</span>st</span><br><span class="line">│   └── output</span><br><span class="line">├── gd32f3x0_it.c</span><br><span class="line">├── gd32f3x0_it.h</span><br><span class="line">├── gd32f3x0_libopt.h</span><br><span class="line">├── main.c</span><br><span class="line">├── readme.txt</span><br><span class="line">├── systick.c</span><br><span class="line">└── systick.h</span><br></pre></td></tr></table></figure>
<p>该示例程序会每间隔 4 秒的时间，循环切换
<strong>UINIO-MCU-GD32F350RBT6</strong> 的四个 GPIO 引脚
<code>C2</code>、<code>C10</code>、<code>C11</code>、<code>C12</code>
的高低电平状态，此时通过万用表就可以测量出运行结果，从而方便的判断出程序是否下载成功，以及核心板运行是否存在有故障。</p>
<blockquote>
<p><strong>注意</strong>：<strong>DAPLink</strong> 是 ARM
系列微控制器开发过程当中，程序下载与调试不可少的工具，相关资料和设计资源可以参考笔者之前撰写的<a target="_blank" rel="noopener" href="http://uinio.com/Project/UINIO-DAP-Link/">《ARM 调试工具
UINIO-DAP-Link 应用详解》</a> 一文。</p>
</blockquote>
<h1 id="搭建-keil-uvision5-自定义工程">搭建 Keil uVision5
自定义工程</h1>
<h2 id="新建目录与拷贝源文件">新建目录与拷贝源文件</h2>
<p>本节内容开始尝试自己动手搭建 <strong>Keil uVision5</strong>
工程，首先新建一个名称为 <code>Keil-GD32F350RBT6</code> 的 <strong>Keil
uVision5</strong>
工程，并将其保存至同名的目录下面，然后再新建如下一系列子目录，并且将固件库里的源文件拷贝至对应的子目录：</p>
<ul>
<li><strong>Applications</strong>：保存应用层相关的源文件。</li>
<li><strong>Documents</strong>：用于存放 Markdown
说明文档，可以预先放置一个 <code>README.md</code> 文件。</li>
<li><strong>Drivers</strong>：存放针对
<strong>UINIO-MCU-GD32F350RBT6</strong> 定制的板级驱动程序。</li>
<li><strong>Firmware</strong>：用于放置
<code>GD32F3x0_Firmware_Library_V2.2.1</code> 当中 <code>Firmware</code>
目录下的全部内容（即
<code>CMSIS</code>、<code>GD32F3x0_standard_peripheral</code>、<code>GD32F3x0_usbfs_library</code>
三个子目录）。</li>
<li><strong>Sources</strong>：用于保存
<code>GD32F3x0_Firmware_Library_V2.2.1</code> 下面的
<code>Template</code> 目录当中，除
<code>IAR_project</code>、<code>Keil_project</code>、<code>readme.txt</code>
之外的文件（即<code>main.c/h</code>、<code>systick.c/h</code>、<code>gd32f3x0_it.c/h</code>、<code>gd32f3x0_libopt.h</code>
七个源文件）。</li>
</ul>
<h2 id="创建分组与添加源文件">创建分组与添加源文件</h2>
<p>鼠标点击 <strong>Keil uVision5</strong> 顶部菜单栏上面的【File
Extensions, Books and Environment...】按钮：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/0.png"></p>
<p>在弹出的<strong>工程管理项</strong>对话框当中，分别将左侧的【Project
Targets】命名为
<code>Keil-GD32F350RBT6</code>，而中间的【Groups】则分别建立如下几个分组，并且通过右侧的
<code>Files</code> 向指定分组添加相应的源文件：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/1.png"></p>
<ul>
<li><strong>CMSIS 分组</strong>：分别添加
<code>Keil-GD32F350RBT6\Firmware\CMSIS\GD\GD32F3x0\Source</code>
目录下的 <code>system_gd32f3x0.c</code> 外设接入层源文件，以及
<code>Keil-GD32F350RBT6\Firmware\CMSIS\GD\GD32F3x0\Source\ARM</code>
目录下的 <code>startup_gd32f3x0.s</code>
启动文件（添加对话框的文件类型要修改为 <code>.s</code>）。</li>
<li><strong>Drivers 分组</strong>：暂时不需要添加任何源文件。</li>
<li><strong>Firmware 分组</strong>：按需添加
<code>Keil-GD32F350RBT6\Firmware\GD32F3x0_standard_peripheral\Source</code>
目录下的 <code>.c</code> 源文件（其中的 <code>gd32f3x0_rcu.c</code> 和
<code>gd32f3x0_gpio.c</code> 属于必须添加）。</li>
<li><strong>Documents 分组</strong>：将
<code>Keil-GD32F350RBT6\Documents</code> 目录下新建的
<code>README.md</code> 文件添加进去。</li>
<li><strong>Applications</strong> 分组：添加
<code>Keil-GD32F350RBT6\Sources</code> 目录下的
<code>main.c</code>、<code>systick.c</code>、<code>gd32f3x0_it.c</code>
三个源文件。</li>
<li><strong>Sources 分组</strong>：暂时不需要添加任何源文件。</li>
</ul>
<p>完成上述操作之后，在<strong>工程管理项</strong>对话框当中，各个分组下面的源文件情况如下图所示：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/2.png"></p>
<p>点击【OK】按钮关闭<strong>工程管理项</strong>对话框，此时
<strong>Keil uVision5</strong> 左侧呈现的工程目录结构如下面所示：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/3.png"></p>
<h2 id="移除-source-目录下的冗余代码">移除 Source 目录下的冗余代码</h2>
<p>为了避免工程搭建过程当中，直接拷贝官方固件库 <code>Template</code>
目录下的源文件，出现冗余代码导致编译错误的情况，接下来还需要对
<code>Source</code> 目录进行一些清理工作。首先需要删除掉该目录下
<code>main.c</code> 源文件里多余的内容，只需要保留如下所示的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* configure systick */</span></span><br><span class="line">    <span class="built_in">systick_config</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还需要再移除掉 <code>Source</code> 目录下
<code>gd32f3x0_it.c</code> 源文件里面，如下所示的无效代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      this function handles SysTick exception</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">led_spark</span>();</span><br><span class="line">    <span class="built_in">delay_decrement</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置编译器路径与选项">配置编译器路径与选项</h2>
<p>点击 <strong>Keil uVision5</strong> 工具栏顶部的【Options for
target】，在弹出的<strong>目标选项对话框</strong>当中，首先切换至【C/C++】选项卡，将【Define】输入框设置为
<code>USE_STDPERIPH_DRIVER,GD32F3X0,GD32F350</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/4.png"></p>
<p>然后再点击对话框当中【Include Paths】输入框右侧的按钮，配置 ARM
编译器分别包含 <strong>Keil-GD32F350RBT6</strong>
工程目录下的如下路径：</p>
<ul>
<li><code>.\Sources</code></li>
<li><code>.\Firmware\CMSIS</code></li>
<li><code>.\Firmware\CMSIS\GD\GD32F3x0\Include</code></li>
<li><code>.\Firmware\GD32F3x0_standard_peripheral\Include</code></li>
</ul>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/5.png"></p>
<p>接下来切换至【Target】选项卡，选择 ARM 编译器的版本为
<strong>5</strong>，并勾选界面上 <strong>Keil uVision5</strong>
自带的用于串口重定向的【Use MicroLIB】工具库：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/6.png"></p>
<p>最后切换到【Output】选项卡，将【Name of Executable】输入框设置为
<code>Keil-GD32F350RBT6.hex</code>，并且勾选 <strong>Create HEX
File</strong> 使得编译结果为十六进制 <code>.hex</code> 格式：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/7.png"></p>
<h2 id="测试工程的编译下载">测试工程的编译下载</h2>
<p>完成上述配置工作之后，关闭 <strong>Keil uVision5</strong>
界面上的全部对话框，然后按下快捷键【F7】或者顶部工具栏上的【Build】按钮，将新建工程里的相关源文件编译为一个
<code>Keil-GD32F350RBT6.hex</code> 文件：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Build started: Project: Keil-GD32F350RBT6</span><br><span class="line">*** Using Compiler &#x27;V5.<span class="number">06</span> update <span class="number">7</span> (build <span class="number">960</span>)&#x27;, folder: &#x27;D:\Software\Tech\Keil\ARM\ARMCC\Bin&#x27;</span><br><span class="line">Build target &#x27;Keil-GD32F350RBT6&#x27;</span><br><span class="line">assembling startup_gd32f3x0.s...</span><br><span class="line">compiling gd32f3x0_dma.c...</span><br><span class="line">compiling gd32f3x0_dbg.c...</span><br><span class="line">compiling gd32f3x0_crc.c...</span><br><span class="line">compiling gd32f3x0_ctc.c...</span><br><span class="line">compiling gd32f3x0_cec.c...</span><br><span class="line">compiling gd32f3x0_dac.c...</span><br><span class="line">compiling gd32f3x0_exti.c...</span><br><span class="line">compiling gd32f3x0_adc.c...</span><br><span class="line">compiling gd32f3x0_cmp.c...</span><br><span class="line">compiling system_gd32f3x0.c...</span><br><span class="line">compiling gd32f3x0_fmc.c...</span><br><span class="line">compiling gd32f3x0_fwdgt.c...</span><br><span class="line">compiling gd32f3x0_i2c.c...</span><br><span class="line">compiling gd32f3x0_misc.c...</span><br><span class="line">compiling gd32f3x0_gpio.c...</span><br><span class="line">compiling gd32f3x0_pmu.c...</span><br><span class="line">compiling gd32f3x0_spi.c...</span><br><span class="line">compiling gd32f3x0_syscfg.c...</span><br><span class="line">compiling gd32f3x0_rcu.c...</span><br><span class="line">compiling gd32f3x0_rtc.c...</span><br><span class="line">compiling gd32f3x0_tsi.c...</span><br><span class="line">compiling gd32f3x0_timer.c...</span><br><span class="line">compiling gd32f3x0_wwdgt.c...</span><br><span class="line">compiling gd32f3x0_usart.c...</span><br><span class="line">compiling gd32f3x0_it.c...</span><br><span class="line">compiling main.c...</span><br><span class="line">compiling systick.c...</span><br><span class="line">linking...</span><br><span class="line">Program Size: Code=<span class="number">1104</span> RO-data=<span class="number">368</span> RW-data=<span class="number">4</span> ZI-data=<span class="number">1028</span></span><br><span class="line"><span class="function">FromELF: <span class="title">creating</span> <span class="title">hex</span> <span class="title">file</span>...</span></span><br><span class="line"><span class="function">&quot;.\<span class="title">Objects</span>\<span class="title">Keil</span>-<span class="title">GD32F350RBT6.hex</span>&quot; - 0 <span class="title">Error</span>(<span class="title">s</span>), 0 <span class="title">Warning</span>(<span class="title">s</span>).</span></span><br><span class="line"><span class="function"><span class="title">Build</span> <span class="title">Time</span> <span class="title">Elapsed</span>:  00:00:03</span></span><br></pre></td></tr></table></figure>
<p>如果编译结果显示 <code>0 Error(s), 0 Warning(s)</code>，说明这个
<strong>Keil uVision5</strong>
工程已经搭建成功。接下来，就可以按下快捷键【F8】或者顶部工具栏上的【Download】按钮，把编译后得到的十六进制文件
<code>Keil-GD32F350RBT6.hex</code>，通过 <strong>UINIO-DAP-Link</strong>
下载至 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板上面运行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Load &quot;D:\\Workspace\\UINIO-MCU-GD32F350RBT6\\Keil-GD32F350RBT6\\Objects\\Keil-GD32F350RBT6.hex&quot;</span><br><span class="line"><span class="built_in">Erase</span> Done.</span><br><span class="line">Programming Done.</span><br><span class="line"><span class="built_in">Verify</span> OK.</span><br><span class="line">Flash Load finished <span class="built_in">at</span> <span class="number">18</span>:<span class="number">22</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：为了大家能够方便快速的搭建测试项目，该自定义工程已被保存到开源硬件项目
<a target="_blank" rel="noopener" href="https://github.com/uinika/UINIO-MCU-GD32F350RBT6"><strong>UINIO-MCU-GD32F350RBT6</strong></a>
的 <code>Keil-GD32F350RBT6</code> 目录里面。</p>
</blockquote>
<h2 id="让-keil-uvision5-支持中文注释">让 Keil uVision5
支持中文注释</h2>
<p>鼠标依次选择 <strong>Keil uVision5</strong> 菜单栏上的 【Edit -&gt;
Configration... -&gt; 】，将弹出窗口【Editor】选项卡下的
<code>Encoding</code> 选择为 <code>Chinese GB2312 (Simplified)</code>
就可以支持中文注释：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/8.png"></p>
<blockquote>
<p><strong>注意</strong>：这种方式会导致 Keil uVision
显示的源代码字体非常不美观，更佳的处理办法是利用
<strong>Sublime</strong> 等文本编辑器提供的 <a target="_blank" rel="noopener" href="https://github.com/seanliang/ConvertToUTF8">ConvertToUTF8</a>
插件，将源代码文件全部转换为 <strong>UTF-8</strong> 格式的编码。</p>
</blockquote>
<h2 id="使用-astyle-格式化源代码">使用 AStyle 格式化源代码</h2>
<p><a target="_blank" rel="noopener" href="https://astyle.sourceforge.net/">AStyle</a> 是一款用于对
C/C++ 源代码进行格式化的开源插件，鼠标点击 <strong>Keil
uVision5</strong> 菜单栏上的【Tools -&gt; Customize Tools Menu】：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/9.png"></p>
<p>在弹出的对话框当中进行如下的设置，其中的 <strong>Command</strong>
就是 <code>astyle.exe</code> 可执行文件所在的路径：</p>
<ul>
<li><strong>Command</strong>:
<code>D:\Software\Tech\AStyle\astyle.exe</code></li>
<li><strong>AStyle
All</strong>：<code>"$E*.c" "$E*.h" --style=google --indent=spaces=2</code>。</li>
<li><strong>AStyle
File</strong>：<code>!E --style=google --indent=spaces=2</code>。</li>
</ul>
<p>完成上述步骤之后，就可以在 <strong>Keil uVision5</strong>
的菜单栏上发现【Tools -&gt; AStyle All】和【Tools -&gt; AStyle
File】两条自定义菜单项：</p>
<p><img src="/Project/UINIO-MCU-GD32/2-Project/10.png"></p>
<h1 id="mcu-微控制器系统结构概览">MCU 微控制器系统结构概览</h1>
<h2 id="芯片资源简介">芯片资源简介</h2>
<p><strong>GD32F350RBT6</strong> 是一款采用 Arm Cortex-M4 内核架构的 32
位微控制器，工作频率为 <code>108MHz</code>，工作电压范围在
<code>2.6V ~ 3.6V</code> 之间，工作温度介于 <code>-40°C ~ +85°C</code>
范围。提供高达 <code>128KB</code> 的片上 <strong>Flash</strong> 闪存和
<code>16KB</code> 的 <strong>SRAM</strong>
内存，其它的片上资源情况可以参考下面表格：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">资源名称</th>
<th style="text-align: left;">数量</th>
<th style="text-align: left;">资源名称</th>
<th style="text-align: left;">数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>12 位 ADC</strong></td>
<td style="text-align: left;">1 个</td>
<td style="text-align: left;"><strong>SPI</strong></td>
<td style="text-align: left;">2 个</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>12 位 DAC</strong></td>
<td style="text-align: left;">1 个</td>
<td style="text-align: left;"><strong>I2C</strong></td>
<td style="text-align: left;">2 个</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>通用比较器 CMP</strong></td>
<td style="text-align: left;">2 个</td>
<td style="text-align: left;"><strong>USART</strong></td>
<td style="text-align: left;">2 个</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>通用 16 位定时器</strong></td>
<td style="text-align: left;">5 个</td>
<td style="text-align: left;"><strong>I2S</strong></td>
<td style="text-align: left;">1 个</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>通用 32 位定时器</strong></td>
<td style="text-align: left;">1 个</td>
<td style="text-align: left;"><strong>HDMI-CEC</strong></td>
<td style="text-align: left;">1 个</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>基本定时器</strong></td>
<td style="text-align: left;">1 个</td>
<td style="text-align: left;"><strong>TSI</strong></td>
<td style="text-align: left;">1 个</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>PWM 高级定时器</strong></td>
<td style="text-align: left;">1 个</td>
<td style="text-align: left;"><strong>USBFS 全速 USB</strong></td>
<td style="text-align: left;">1 个</td>
</tr>
</tbody>
</table>
<p><strong>UINIO-MCU-GD32F350RBT6</strong> 采用的
<strong>GD32F350RBT6</strong> 微控制器使用的是 <code>LQFP64</code>
封装形式，其具体 <strong>64</strong> 个引脚的功能分配可以参见下图：</p>
<p><img src="/Project/UINIO-MCU-GD32/3-ARM/0.png"></p>
<h2 id="arm-cortex-m4-内核架构">ARM Cortex-M4 内核架构</h2>
<p><strong>ARM Cortex-M4</strong> 系列微控制器基于
<strong>ARMv7</strong> 架构，其内核主要由下面一系列的功能单元构成：</p>
<p><img src="/Project/UINIO-MCU-GD32/3-ARM/1.png"></p>
<ul>
<li><strong>嵌套式向量型中断控制器</strong>（<strong>NVIC</strong>，Nested
Vectored Interrupt Controller）。</li>
<li><strong>浮点运算单元</strong>（<strong>FPU</strong>，Floating Point
Unit）。</li>
<li><strong>闪存地址重载及断点单元</strong>（<strong>FPB</strong>，Flash
Patch Breakpoint）。</li>
<li><strong>串行线调试接口</strong>（<strong>SW-DP</strong>，Serial-Wire
Debug Port）。</li>
<li><strong>数据观测点及跟踪单元</strong>（<strong>DWT</strong>，Data
Watchpoint And Trace）。</li>
<li><strong>指令跟踪宏单元</strong>（<strong>ITM</strong>，Instrumentation
Trace Macrocell）。</li>
<li><strong>跟踪端口接口单元</strong>（<strong>TPIU</strong>，Trace Port
Interface Unit）。</li>
<li><strong>内部总线矩阵</strong>（<strong>Bus Matrix</strong>，用于实现
<strong>I-Code</strong> 指令总线、<strong>D-Code</strong>
数据总线、<strong>System</strong> 系统总线、<strong>PPB</strong>
专用总线、<strong>AHB-AP</strong> 调试专用总线的相互联接）。</li>
</ul>
<h2 id="gd32f350rbt6-外设架构">GD32F350RBT6 外设架构</h2>
<p><strong>GD32F350RBT6</strong>
微控制器的整体系统架构如下面的框图所示，其中
<strong>AHB</strong>（Advanced High performance
Bus）高级高性能总线矩阵采用的是多层总线结构，支持多个主从设备之间实现并行通信，其中<strong>主设备</strong>包含有来自
<strong>ARM Cortex-M4</strong> 内核架构的
<code>I-Code 指令总线</code>、<code>D-Code 数据总线</code>、<code>System 系统总线</code>，以及来自于内核外部的
<code>DMA 总线</code>：</p>
<ul>
<li><strong>I-Code 总线</strong>：即 Instruction Code，用于从
<code>0x 0000 0000 ~ 0x 1FFF FFFF</code>
<strong>代码区域</strong>获取向量。</li>
<li><strong>D-Code 总线</strong>：即 Data
Code，用于加载和存储数据，以及调试访问<strong>代码区域</strong>。</li>
<li><strong>System
系统总线</strong>：用于获取指令和向量、加载与存储数据、调试访问<strong>系统区域</strong>（包括内部
SRAM 和外设区域）。</li>
<li><strong>DMA
总线</strong>：用于直接内存访问（<strong>DMA</strong>，Direct Memory
Access）的传输总线。</li>
</ul>
<p><img src="/Project/UINIO-MCU-GD32/3-ARM/2.png"></p>
<p>除此之外，<strong>AHB
总线矩阵</strong>的<strong>从设备</strong>包含有来自 Flash 存储控制器的
<strong>IBUS</strong> 和 <strong>DBUS</strong> 总线、<strong>SRM
控制器</strong>总线，以及 <strong>AHB1</strong> 和 <strong>AHB2</strong>
总线：</p>
<ul>
<li><strong>AHB2</strong> 总线连接了
<strong>A</strong>、<strong>B</strong>、<strong>C</strong>、<strong>D</strong>、<strong>F</strong>
一共五组 GPIO 端口。</li>
<li><strong>AHB1</strong> 总线连接的是其它片上外设资源，其通过两组
<strong>AHB-APB 总线桥</strong>（AHB to APB Bridge 1/2）分别提供了
<strong>AHB1</strong>
总线与<strong>高级外设总线</strong>（<strong>APB</strong>，Advanced
Peripheral Bus）之间的同步连接。</li>
</ul>
<h2 id="地址空间映射">地址空间映射</h2>
<p><strong>ARM Cortex M4</strong>
内核采用了<strong>哈佛结构</strong>，使用相互独立的总线来读取<strong>指令</strong>和操作<strong>数据</strong>。这些指令和数据都存储在一个大小为
<code>4GB</code> 的相同<strong>地址空间</strong>（因为 <strong>ARM
Cortex M4</strong> 的地址总线宽度为 <strong>32
位</strong>，所以其对应的地址范围为 <code>2</code> 的 <code>32</code>
次方等于
<strong>4GB</strong>），但是处于不同的<strong>地址范围</strong>：</p>
<p><img src="/Project/UINIO-MCU-GD32/3-ARM/3.png"></p>
<p>观察上面的表格可以发现 <strong>GD32F350RBT6</strong> 
的片上外设地址空间被划分为 <strong>AHB1</strong> 和
<strong>AHB2</strong> 总线、<strong>APB1</strong> 和
<strong>APB2</strong>
总线共四个部分，这些总线的最低地址被称为<strong>总线基地址</strong>，也就是挂载在该总线上第
1
个外设的地址，而每个外设的最低地址则被称为<strong>外设基地址</strong>，每个外设的地址范围内都分布着该外设所对应的<strong>寄存器</strong>，通过<strong>操作这些寄存器就可以达到控制外设的目的</strong>。</p>
<h1 id="操作寄存器-运用固件库">操作寄存器 → 运用固件库</h1>
<h2 id="操作寄存器">操作寄存器</h2>
<p>如果需要将 <strong>AHB</strong> 总线上的 <strong>GPIOA</strong>
外设对应的 16 个引脚全部置为
<code>1</code>，那么就需要去配置<strong>端口输出控制寄存器</strong>
<code>GPIOx_OCTL</code>，通过查询用户手册可以知道其地址偏移量为
<code>0x14</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/4-Register/1.png"></p>
<p>由于 <strong>GPIOA</strong> 的外设基地址为
<code>0x4800 0000</code>，所以寄存器 <code>GPIOA_OCTL</code>
的地址计算方式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x4800</span> <span class="number">0000</span> + <span class="number">0x0000</span> <span class="number">0014</span> = <span class="number">0x4800</span> <span class="number">0014</span></span><br></pre></td></tr></table></figure>
<p>换而言之，将寄存器 <code>OCTL(0~15)</code>
相应的<strong>位</strong>设置为 <code>1</code>，就可以把对应的
<code>GPIOA(0~15)</code> 控制为高电平。如果要让全部 16
个引脚输出高电平，那么相应的 <code>GPIOA_OCTL</code> 寄存器的高 16
位可以置为 <code>0</code> 而低 16 位置为 <code>1</code>，即
<code>0000 0000 0000 0000 1111 1111 1111 1111</code>，转换为十六进制就是
<code>0x0000FFFF</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x48000014</span>) = <span class="number">0x0000FFFF</span>;      <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure>
<p>像上面这样直接对寄存器地址进行操作会比较麻烦，下面可以通过宏定义
<code>#define</code>，为每一个寄存器地址都分配一个名称：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL (unsigned int*)(0x48000014)  <span class="comment">// 将寄存器地址 0x48000014 定义为指针类型的 GPIOA_OCTL</span></span></span><br><span class="line">*GPIOA_OCTL = <span class="number">0x0000FFFF</span>;                       <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure>
<p>为了进一步简化代码，可以将指针类型 <code>*</code> 的声明合并到
<code>GPIOA_OCTL</code> 的宏定义当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL *(unsigned int*)(0x48000014) <span class="comment">// 将寄存器地址 0x48000014 定义为 GPIOA_OCTL</span></span></span><br><span class="line">GPIOA_OCTL = <span class="number">0x0000FFFF</span>;                        <span class="comment">// 将 GPIOA 外设对应的 16 个引脚全部输出高电平</span></span><br></pre></td></tr></table></figure>
<h2 id="运用库函数">运用库函数</h2>
<p><strong>兆易创新</strong>官方固件库
<code>GD32F3x0_Firmware_Library_V2.2.1</code>
当中<strong>标准外设库</strong>
<code>Firmware\GD32F3x0_standard_peripheral</code> 目录下的
<code>Include\gd32f3x0_gpio.h</code> 和
<code>Source\gd32f3x0_gpio.c</code> 两个源文件，提供有一系列用于操作
GPIO 的库函数：</p>
<p><img src="/Project/UINIO-MCU-GD32/4-Register/2.png"></p>
<p>其中的
<code>void gpio_port_write(uint32_t gpio_periph, uint16_t data)</code>
函数可以用于向特定的 GPIO 端口写入状态值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_port_write(GPIOB, <span class="number">0xFFFF</span>);</span><br></pre></td></tr></table></figure>
<p>该函数被定义在 <code>Source\gd32f3x0_gpio.c</code>
源文件当中，可以看到其函数体内调用了 <code>GPIO_OCTL(gpio_periph)</code>
函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      write data to the specified GPIO port</span></span><br><span class="line"><span class="comment">    \param[in]  gpio_periph: GPIOx(x = A,B,C,D,F)</span></span><br><span class="line"><span class="comment">                only one parameter can be selected which is shown as below:</span></span><br><span class="line"><span class="comment">      \arg        GPIOx(x = A,B,C,D,F)</span></span><br><span class="line"><span class="comment">    \param[in]  data: specify the value to be written to the port output control register</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_port_write</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint16_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_OCTL(gpio_periph) = (<span class="type">uint32_t</span>)data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>GPIO_OCTL(gpio_periph)</code> 函数又被预定义在了
<code>Include\gd32f3x0_gpio.h</code> 头文件里面，其最终调用的是
<code>REG32(addr)</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OCTL(gpiox)           REG32((gpiox) + 0x00000014U)    <span class="comment">/*!&lt; GPIO port output control register */</span></span></span><br></pre></td></tr></table></figure>
<p><code>REG32(addr)</code> 函数的定义位于官方固件库
<code>Firmware\CMSIS\GD\GD32F3x0\Include</code> 目录下的
<code>gd32f3x0.h</code> 头文件当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG32(addr)                  (*(volatile uint32_t *)(uint32_t)(addr))</span></span><br></pre></td></tr></table></figure>
<p>把前面寄存器 <code>GPIOA_OCTL</code> 的地址计算式
<code>0x4800 0000 + 0x0000 0014</code> 作为 <code>addr</code>
参数代入之后，就会发现标准外设库底层也是在操作寄存器，只是在使用的时候更加直观简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG32(addr) (*(volatile uint32_t *)(uint32_t)(0x4800 0000 + 0x0000 0014))</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：通过<strong>寄存器</strong>直接控制外设，性能开销更少，运行更加迅速，适用于片上资源有限，且对于实时性要求较高的场景。而使用<strong>标准外设库</strong>来操控外设，其优势主要体现在提升代码的开发效率以及可读性与可维护性。</p>
</blockquote>
<h1 id="通过-gpio-寄存器控制-led">通过 GPIO 寄存器控制 LED</h1>
<p>使用 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板来控制 GPIO
端口的输出，整体需要经历下面几个步骤：</p>
<ol type="1">
<li>开启指定 GPIO 的<strong>端口时钟</strong>；</li>
<li>配置指定 GPIO 的<strong>工作模式</strong>；</li>
<li>配置指定 GPIO 的<strong>输出类型</strong>；</li>
</ol>
<p>开始编写代码之前，首先需要将一枚 <code>4.7K</code> 的电阻
<code>R1</code> 与一枚 LED 发光二极管串联，然后再连接到
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOB8</code>
引脚，当该引脚输出<strong>高电平</strong>的时候 LED
发光二极管就会点亮，而输出<strong>低电平</strong>的时候 LED
发光二极管就会熄灭，具体的电路连接关系请参考下面的示意图：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/0.png"></p>
<h2 id="开启-gpio-的端口时钟">开启 GPIO 的端口时钟</h2>
<p>由于 <strong>GD32F350RBT6</strong>
的外设时钟资源默认情况下都是<strong>关闭</strong>的，所以在配置外设之前需要先<strong>开启其对应的时钟</strong>。</p>
<h3 id="ahb-总线使能寄存器-rcu_ahben">AHB 总线使能寄存器 RCU_AHBEN</h3>
<p><code>GPIOB</code> 引脚分组被挂载到了 <strong>GD32F350RBT6</strong>
微控制器的 <strong>AHB</strong> 总线下面，在用户手册的
<code>复位和时钟单元(RCU)</code> 章节里，描述了 <strong>AHB
总线使能寄存器</strong> <code>RCU_AHBEN</code> 的地址偏移量为
<code>0x14</code>、复位值为 <code>0x0000 0014</code>，可以按照 8
位的<strong>字节</strong>、16 位的<strong>半字</strong>以及 32
位的<strong>字</strong>进行访问：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/1.png"></p>
<p>而 <strong>AHB 总线使能寄存器</strong>
<code>RCU_AHBEN</code>位于<strong>复位和时钟单元 RCU</strong>
外设的地址范围之内，由于 RCU 的外设基地址为
<code>0x4002 1000</code>，所以 <code>RCU_AHB1EN</code>
寄存器的实际地址计算过程如下面等式所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">RCU_AHBEN</span> = <span class="variable constant_">RCU</span> 的外设基地址 + <span class="variable constant_">AHB</span> 总线使能寄存器偏移量 = <span class="number">0x4002</span> <span class="number">1000</span> + <span class="number">0x14</span> = <span class="number">0x4002</span> <span class="number">1014</span></span><br></pre></td></tr></table></figure>
<p>根据用户手册当中接下来的内容，可以发现 <code>RCU_AHB1EN</code>
寄存器的第 <code>18</code> 位 <code>PBEN</code> 就是 GPIOB
时钟的<strong>使能位</strong>：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/2.png"></p>
<p>所以只需要往 <code>RCU_AHB1EN</code> 寄存器的第 18 位写入
<code>1</code>，其它位保持不变，就可以实现对 <strong>GPIOB</strong>
外设时钟的使能，这里我们可以通过一个<strong>或运算</strong>和<strong>移位运算</strong>来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCU_AHBEN |= (<span class="number">1</span> &lt;&lt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面等式要使能的是第几位，就向右移多少位。例如上面等式向第
18 位写入 <code>1</code>，所以就右移 <code>18</code> 位。</p>
</blockquote>
<h2 id="配置-gpio-的工作模式">配置 GPIO 的工作模式</h2>
<p>接下来，着手配置 <strong>GD32F350RBT6</strong> 的 GPIO
工作模式，这里具体可以划分为下面两个步骤：</p>
<ol type="1">
<li>将<strong>端口控制寄存器</strong> <code>GPIOx_CTL</code>
配置为<code>输入模式(默认)</code> / <code>输出模式</code> /
<code>备用功能模式</code> / <code>模拟模式</code>；</li>
<li>将<strong>端口上下拉寄存器</strong> <code>GPIOx_PUD</code>
配置为<code>上拉模式</code> / <code>下拉模式</code> /
<code>悬空模式(默认)</code>；</li>
</ol>
<h3 id="配置端口控制寄存器-gpiob_ctl">配置端口控制寄存器 GPIOB_CTL</h3>
<p>已知 <strong>GPIOB</strong> 寄存器的基地址为
<code>0x4800 0400</code>，而端口控制寄存器 <code>GPIOB_CTL</code>
的地址偏移量为 <code>0x00</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/3.png"></p>
<p>从而就可以计算出 <strong>GPIOB</strong> 端口控制寄存器
<code>GPIOB_CTL</code> 的实际地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x00</span> = <span class="number">0x4800</span> <span class="number">0400</span></span><br></pre></td></tr></table></figure>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/4.png"></p>
<p>该寄存器通过两个位来进行控制，例如这里需要操作的是 <code>Pin8</code>
引脚，就是需要控制 <code>GPIOB_CTL</code> 寄存器的第 17 和 16
位。通过将这两位配置为 <code>01</code>，就可以将 <strong>GPIOB8</strong>
端口配置为输出模式。此时向 <code>GPIOB_CTL</code>
寄存器写入的二进制数据为
<code>0000 0000 0000 0001 0000 0000 0000 0000</code>，转换为十六进制就是
<code>00010000</code>。为了确保其它位不会被修改，需要先将第 15 和第 14
两位置零，然后再将其配置为 <code>0</code> 和 <code>1</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL &amp;= <span class="number">0xFFFCFFFF</span>;  <span class="comment">// 把第 17 和 16 位置为 00</span></span><br><span class="line">GPIOB_CTL |= <span class="number">0x00004000</span>;  <span class="comment">// 配置第 17 和 16 位为 01</span></span><br></pre></td></tr></table></figure>
<p>除此之外，还可以采用下面的计算方式进行配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_CTL &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 把第 17 和 16 位置为 00</span></span><br><span class="line">GPIOB_CTL |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 配置第 17 和 16 位为 01</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面代码当中的数值 <code>8</code> 对应的是
<code>GPIOB8</code>，反之如果是 <code>GPIOB5</code> 则可以将该值替换为
<code>5</code>。</p>
</blockquote>
<h3 id="配置端口上下拉寄存器-gpiob_pud">配置端口上下拉寄存器
GPIOB_PUD</h3>
<p>将 <strong>GPIOB8</strong>
引脚配置为输出模式之后，还需要再进一步通过<strong>端口上下拉寄存器</strong>
<code>GPIOB_PUD</code>
将其进一步配置为<strong>悬空模式</strong>(默认值，即没有上下拉电阻)：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/5.png"></p>
<p>同样已知 <strong>GPIOB</strong> 寄存器的基地址为
<code>0x4800 0400</code>，而端口上下拉寄存器 <code>GPIOB_PUD</code>
的地址偏移量为 <code>0x0C</code>，从而就可以计算出其实际地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_PUD = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x0C</span> = <span class="number">0x4800</span> <span class="number">040</span>C</span><br></pre></td></tr></table></figure>
<p>该寄存器同样通过 <code>GPIOB_PUD</code> 寄存器的第 17 和第 16
两个位来进行控制：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/6.png"></p>
<p>使用时也依然需要先进行清零，然后再将其配置为 <code>00</code>
所代表的<strong>悬空模式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_PUD &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 将第 17 和 16 位清零</span></span><br><span class="line">GPIOB_PUD |= (<span class="number">0x00</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 配置第 17 和 16 位为 00</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-gpio-的输出类型">配置 GPIO 的输出类型</h2>
<p>配置 <strong>UINIO-MCU-GD32F350RBT6</strong> 的 GPIO
输出类型也可以划分为如下两个步骤：</p>
<ol type="1">
<li>配置端口输出模式寄存器
<code>GPIOx_OMODE</code>，也就是选择<strong>推挽输出</strong>还是<strong>开漏输出</strong>；</li>
<li>配置端口速度寄存器 <code>GPIOx_OSPD</code>
的输出速度等级，在这里我们选择 <code>50MHz</code> 的频率；</li>
</ol>
<h3 id="端口输出模式寄存器-gpiob_omode">端口输出模式寄存器
GPIOB_OMODE</h3>
<p>GPIO
的<strong>开漏输出</strong>模式需要外接上拉电阻，才能够输出高电平，不适用于当前的电路连接关系，在这里我们需要通过<strong>端口输出模式寄存器</strong>
<code>GPIOB_OMODE</code>，将其设置为<strong>推挽输出</strong>模式：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/7.png"></p>
<p>同样已知 <strong>GPIOB</strong> 的寄存器基地址为
<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_OMODE</code>
的地址偏移量为 <code>0x04</code>，那么 <code>GPIOB_OMODE</code>
的准确寄存器地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OMODE = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x04</span> = <span class="number">0x4800</span> <span class="number">0404</span></span><br></pre></td></tr></table></figure>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/8.png"></p>
<p>根据上图的描述可知，向 <code>GPIOB_OMODE</code> 寄存器的第 8 位写入
<code>0</code>，就可以将其配置为<strong>推挽输出模式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OMODE &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>) <span class="comment">// 将 GPIOB_OMODE 的第 8 位置为 0</span></span><br></pre></td></tr></table></figure>
<h3 id="端口速度寄存器-gpiob_ospd">端口速度寄存器 GPIOB_OSPD</h3>
<p>接下来，需要再将<strong>端口速度寄存器</strong>
<code>GPIOx_OSPD</code> 的输出频率设置为 <code>50MHz</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/9.png"></p>
<p>根据前面的计算方法，已知 <strong>GPIOB</strong> 的寄存器基地址为
<code>0x4800 0400</code>，而端口速度寄存器 <code>GPIOB_OSPD</code>
的地址偏移量为 <code>0x08</code>，则 <code>GPIOB_OSPD</code>
的准确寄存器地址，可以按照如下方式进行计算得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x08</span> = <span class="number">0x4800</span> <span class="number">0408</span></span><br></pre></td></tr></table></figure>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/10.png"></p>
<p>根据上图描述的信息，可以向 <code>GPIOB_OSPD</code> 寄存器的第 17 和
第 16 位写入 <code>10</code>（复位值），就可以将其配置为
<code>2MHz</code> 的输出速率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD |=  (<span class="number">0x02</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向第 17 和 16 位写入 10</span></span><br></pre></td></tr></table></figure>
<p>而向 <code>GPIOB_OSPD</code> 寄存器的第 17 和 第 16 位写入
<code>01</code>，则可以将其配置为 <code>10MHz</code> 的输出速率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD |=  (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向第 17 和 16 位写入 10</span></span><br></pre></td></tr></table></figure>
<p>如果向 <code>GPIOB_OSPD</code> 寄存器的第 17 和 第 16 位写入的是
<code>11</code>，则可以将其配置为 <code>50MHz</code>
的输出速率，也就是当前需要为 <strong>UINIO-MCU-GD32F350RBT6</strong> 的
<code>GPIOB</code> 配置的目标频率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OSPD &amp;=  ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)); <span class="comment">// 向第 17 和 16 位写入 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：十六进制 <code>0x03</code> 的二进制形式为
<code>0000 0011</code>，十六进制 <code>0x02</code> 的二进制形式为
<code>0000 0010</code>，十六进制 <code>0x01</code> 的二进制形式为
<code>0000 0001</code>。</p>
</blockquote>
<h2 id="控制-gpio-的输出状态">控制 GPIO 的输出状态</h2>
<p>配置好 <strong>GPIOB8</strong>
对应的<code>端口时钟</code>、<code>工作模式</code>、<code>输出类型</code>之后，就可以通过使其输出<strong>高电平</strong>点亮
LED 发光二极管，或者通过<strong>低电平</strong>熄灭 LED 发光二极管。</p>
<h3 id="端口输出控制寄存器-gpiob_octl">端口输出控制寄存器
GPIOB_OCTL</h3>
<p>根据用户手册已知 <strong>GPIOB</strong> 的寄存器基地址为
<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_OCTL</code>
的地址偏移量为 <code>0x14</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/11.png"></p>
<p>那么端口输出控制寄存器 <code>GPIOB_OCTL</code>
的实际地址，就可以通过下面的等式计算得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OCTL = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x14</span> = <span class="number">0x4800</span> <span class="number">0414</span></span><br></pre></td></tr></table></figure>
<p>通过向上图当中 <code>GPIOB_OCTL</code> 寄存器的第 8 位
<code>OCTL8</code> 位写入 <code>1</code> 或者
<code>0</code>，就可以控制相应的 GPIO
引脚输出<strong>高电平</strong>或者<strong>低电平</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_OCTL &amp;= ~ (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>); <span class="comment">// 输出低电平</span></span><br><span class="line">GPIOB_OCTL |=  (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);  <span class="comment">// 输出高电平</span></span><br></pre></td></tr></table></figure>
<h3 id="端口位操作寄存器-gpiob_bop">端口位操作寄存器 GPIOB_BOP</h3>
<p>除此之外，我们还可以通过<strong>端口位操作寄存器</strong>
<code>GPIOB_BOP</code> 来操作 GPIO 端口的状态。根据用户手册已知
<strong>GPIOB</strong> 的寄存器基地址为
<code>0x4800 0400</code>，而端口输出模式寄存器 <code>GPIOB_BOP</code>
的地址偏移量为 <code>0x18</code>：</p>
<p><img src="/Project/UINIO-MCU-GD32/5-LED/12.png"></p>
<p>那么端口输出控制寄存器 <code>GPIOB_BOP</code>
的实际地址，就可以通过下面的计算过程获得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_BOP = <span class="number">0x4800</span> <span class="number">0400</span> + <span class="number">0x18</span> = <span class="number">0x4800</span> <span class="number">0418</span></span><br></pre></td></tr></table></figure>
<p>观察可以发现 <code>GPIOB_BOP</code> 寄存器的高 16 位和低 16
位的每一位，都分别对应着一个 GPIO 引脚。其中<strong>低十六位</strong>
<span class="math inline">\(CR_{0 \sim 15}\)</span> 是置 <code>1</code>
位，而<strong>高十六位</strong> <span class="math inline">\(BOP_{0 \sim
15}\)</span> 则属于清 <code>0</code> 位：</p>
<ul>
<li><code>GPIOB_BOP</code> 寄存器的高十六位 <span class="math inline">\(CR_{0 \sim 15}\)</span>：置为 <code>1</code>
输出<strong>低电平</strong>，置 <code>0</code> 电平状态不改变；</li>
<li><code>GPIOB_BOP</code> 寄存器的低十六位 <span class="math inline">\(BOP_{0 \sim 15}\)</span>：置为 <code>1</code>
输出<strong>高电平</strong>，置 <code>0</code> 电平状态不改变；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">8</span> + <span class="number">16</span>)); <span class="comment">// 输出低电平</span></span><br><span class="line">GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);        <span class="comment">// 输出高电平</span></span><br></pre></td></tr></table></figure>
<h2 id="完整-keil-µvision-工程代码">完整 Keil µVision 工程代码</h2>
<p>在 <strong>Keil-GD32F350RBT6</strong> 工程的 <code>Driver</code>
目录下建立一个名为 <code>LED</code> 的子目录，然后分别新建
<code>LED.h</code> 和 <code>LED.c</code> 两个源文件，并且在
<code>main.c</code> 里包含 <code>LED.h</code>
头文件，全部的示例代码内容如下面所示，即
<strong>UINIO-MCU-GD32F350RBT6</strong> 工程 <code>Examples</code>
目录下的 <code>1-LED-Register</code> 工程：</p>
<h3 id="driversled.h">Drivers/LED.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_Driver_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_Driver_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_RCU_BASE (unsigned int)0x40021000U                      <span class="comment">// RCU 寄存器的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_RCU_AHBEN *(unsigned int *)(UINIO_RCU_BASE + 0x14U)     <span class="comment">// AHB 使能寄存器地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_BASE (unsigned int)0x48000400U                    <span class="comment">// GPIOB 的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_CTL *(unsigned int *)(UINIO_GPIOB_BASE + 0x00U)   <span class="comment">// GPIOB 控制寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_PUD *(unsigned int *)(UINIO_GPIOB_BASE + 0x0CU)   <span class="comment">// GPIOB 的上下拉寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OMODE *(unsigned int *)(UINIO_GPIOB_BASE + 0x04U) <span class="comment">// GPIOB 的输出模式寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OSPD *(unsigned int *)(UINIO_GPIOB_BASE + 0x08U)  <span class="comment">// GPIOB 的速度寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_OCTL *(unsigned int *)(UINIO_GPIOB_BASE + 0x14U)  <span class="comment">// GPIOB 的输出控制寄存器的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_GPIOB_BOP *(unsigned int *)(UINIO_GPIOB_BASE + 0x18U)   <span class="comment">// GPIOB 的位操作寄存器的地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// LED 相关的 GPIO 端口配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_Driver_LED_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driversled.c">Drivers/LED.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 相关的 GPIO 端口配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* AHB 总线使能寄存器 RCU_AHBEN */</span></span><br><span class="line">  UINIO_RCU_AHBEN |= (<span class="number">0x01</span> &lt;&lt; <span class="number">18</span>);         <span class="comment">// RCU_AHBEN 寄存器的第 18 位置为 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置端口控制寄存器 GPIOB_CTL */</span></span><br><span class="line">  UINIO_GPIOB_CTL &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span>*<span class="number">8</span>));     <span class="comment">// 把 GPIOB_CTL 的第 17 和 16 位置为 00</span></span><br><span class="line">  UINIO_GPIOB_CTL |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">2</span>*<span class="number">8</span>));      <span class="comment">// 配置 GPIOB_CTL 的第 17 和 16 位为 01</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置端口上下拉寄存器 GPIOB_PUD */</span></span><br><span class="line">  UINIO_GPIOB_PUD &amp;= ~(<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));   <span class="comment">// 将 GPIOB_PUD 的第 17 和 16 位清零</span></span><br><span class="line">  UINIO_GPIOB_PUD |= (<span class="number">0x00</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));    <span class="comment">// 配置 GPIOB_PUD 的第 17 和 16 位为 00</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口输出模式寄存器 GPIOB_OMODE */</span></span><br><span class="line">  UINIO_GPIOB_OMODE &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);       <span class="comment">// 将 GPIOB_OMODE 的第 8 位置为 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口速度寄存器 GPIOB_OSPD */</span></span><br><span class="line">  UINIO_GPIOB_OSPD &amp;=  (<span class="number">0x03</span> &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>));  <span class="comment">// 向 GPIOB_OSPD 的第 17 和 16 位写入 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 配置系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 配置连接 LED 的 GPIO 端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口输出控制寄存器 GPIOB_OCTL 方式控制 LED */</span></span><br><span class="line">  UINIO_GPIOB_OCTL &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);      <span class="comment">// 输出低电平，LED 熄灭</span></span><br><span class="line">  UINIO_GPIOB_OCTL |=  (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);      <span class="comment">// 输出高电平，LED 点亮</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 端口位操作寄存器 GPIOB_BOP 方式控制 LED */</span></span><br><span class="line">  UINIO_GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">8</span> + <span class="number">16</span>)); <span class="comment">// 输出低电平，LED 熄灭</span></span><br><span class="line">  UINIO_GPIOB_BOP |= (<span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);        <span class="comment">// 输出高电平，LED 点亮</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通过-gpio-固件库控制-led">通过 GPIO 固件库控制 LED</h1>
<p>本节内容将采用<strong>兆易创新</strong>官方提供的标准外设固件库
<code>GD32F3x0_Firmware_Library_V2.2.1</code> 来完成点亮 LED
的实验，这通常需要经历如下四个步骤：</p>
<ol type="1">
<li>调用 <code>rcu_periph_clock_enable()</code> 固件库函数使能 GPIO
端口对应的<strong>外设时钟</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rcu_periph_clock_enable</span><span class="params">(rcu_periph_enum periph)</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>通过 <code>gpio_mode_set()</code> 函数配置 GPIO
端口的<strong>工作模式</strong>以及设置<strong>上下拉电阻状态</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_mode_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> mode, <span class="type">uint32_t</span> pull_up_down, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>通过 <code>gpio_output_options_set()</code> 函数配置指定 GPIO
引脚的输出类型与速率：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">void</span> <span class="title function_">gpio_output_options_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint8_t</span> otype, <span class="type">uint32_t</span> speed, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>通过 <code>gpio_bit_set/write()</code> 指定 GPIO
引脚的电平状态：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> gpio_bit_set/write(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span><br></pre></td></tr></table></figure>
<h2 id="使能-gpio-外设时钟">使能 GPIO 外设时钟</h2>
<p>官方固件库 <code>Firmware\GD32F3x0_standard_peripheral\Include</code>
目录下的头文件 <code>gd32f3x0_rcu.h</code>
里，定义了一个专门用于使能<strong>外设时钟</strong>的库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rcu_periph_clock_enable</span><span class="params">(rcu_periph_enum periph)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的 <code>periph</code> 参数是一个
<code>rcu_periph_enum</code>
枚举类型的变量，其具体的定义如下面所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* peripheral clock enable */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* AHB peripherals */</span></span><br><span class="line">    RCU_DMA     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">0U</span>),                  <span class="comment">/*!&lt; DMA clock */</span></span><br><span class="line">    RCU_CRC     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">6U</span>),                  <span class="comment">/*!&lt; CRC clock */</span></span><br><span class="line">    RCU_GPIOA   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">17U</span>),                 <span class="comment">/*!&lt; GPIOA clock */</span></span><br><span class="line">    RCU_GPIOB   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">18U</span>),                 <span class="comment">/*!&lt; GPIOB clock */</span></span><br><span class="line">    RCU_GPIOC   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">19U</span>),                 <span class="comment">/*!&lt; GPIOC clock */</span></span><br><span class="line">    RCU_GPIOD   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">20U</span>),                 <span class="comment">/*!&lt; GPIOD clock */</span></span><br><span class="line">    RCU_GPIOF   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">22U</span>),                 <span class="comment">/*!&lt; GPIOF clock */</span></span><br><span class="line">    RCU_TSI     = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">24U</span>),                 <span class="comment">/*!&lt; TSI clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* APB2 peripherals */</span></span><br><span class="line">    RCU_CFGCMP  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">0U</span>),                 <span class="comment">/*!&lt; CFGCMP clock */</span></span><br><span class="line">    RCU_ADC     = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">9U</span>),                 <span class="comment">/*!&lt; ADC clock */</span></span><br><span class="line">    RCU_TIMER0  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">11U</span>),                <span class="comment">/*!&lt; TIMER0 clock */</span></span><br><span class="line">    RCU_SPI0    = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">12U</span>),                <span class="comment">/*!&lt; SPI0 clock */</span></span><br><span class="line">    RCU_USART0  = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">14U</span>),                <span class="comment">/*!&lt; USART0 clock */</span></span><br><span class="line">    RCU_TIMER14 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">16U</span>),                <span class="comment">/*!&lt; TIMER14 clock */</span></span><br><span class="line">    RCU_TIMER15 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">17U</span>),                <span class="comment">/*!&lt; TIMER15 clock */</span></span><br><span class="line">    RCU_TIMER16 = RCU_REGIDX_BIT(IDX_APB2EN, <span class="number">18U</span>),                <span class="comment">/*!&lt; TIMER16 clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* APB1 peripherals */</span></span><br><span class="line">    RCU_TIMER1  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">0U</span>),                 <span class="comment">/*!&lt; TIMER1 clock */</span></span><br><span class="line">    RCU_TIMER2  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">1U</span>),                 <span class="comment">/*!&lt; TIMER2 clock */</span></span><br><span class="line">    RCU_TIMER13 = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">8U</span>),                 <span class="comment">/*!&lt; TIMER13 clock */</span></span><br><span class="line">    RCU_WWDGT   = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">11U</span>),                <span class="comment">/*!&lt; WWDGT clock */</span></span><br><span class="line">    RCU_SPI1    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">14U</span>),                <span class="comment">/*!&lt; SPI1 clock */</span></span><br><span class="line">    RCU_USART1  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">17U</span>),                <span class="comment">/*!&lt; USART1 clock */</span></span><br><span class="line">    RCU_I2C0    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">21U</span>),                <span class="comment">/*!&lt; I2C0 clock */</span></span><br><span class="line">    RCU_I2C1    = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">22U</span>),                <span class="comment">/*!&lt; I2C1 clock */</span></span><br><span class="line">    RCU_PMU     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">28U</span>),                <span class="comment">/*!&lt; PMU clock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(GD32F350)</span></span><br><span class="line">    RCU_DAC     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">29U</span>),                <span class="comment">/*!&lt; DAC clock */</span></span><br><span class="line">    RCU_CEC     = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">30U</span>),                <span class="comment">/*!&lt; CEC clock */</span></span><br><span class="line">    RCU_TIMER5  = RCU_REGIDX_BIT(IDX_APB1EN, <span class="number">4U</span>),                 <span class="comment">/*!&lt; TIMER5 clock */</span></span><br><span class="line">    RCU_USBFS   = RCU_REGIDX_BIT(IDX_AHBEN, <span class="number">12U</span>),                 <span class="comment">/*!&lt; USBFS clock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* GD32F350 */</span></span></span><br><span class="line">    RCU_RTC     = RCU_REGIDX_BIT(IDX_BDCTL, <span class="number">15U</span>),                 <span class="comment">/*!&lt; RTC clock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RCU_ADDAPB1EN */</span></span><br><span class="line">    RCU_CTC     = RCU_REGIDX_BIT(IDX_ADDAPB1EN, <span class="number">27U</span>)              <span class="comment">/*!&lt; CTC clock */</span></span><br><span class="line">&#125; rcu_periph_enum;</span><br></pre></td></tr></table></figure>
<p>观察可以发现，如果向 <code>rcu_periph_clock_enable()</code>
函数传入上述枚举类型变量当中的<strong>枚举值</strong>
<code>RCU_GPIOB</code>，就可以使能 <strong>GPIOB</strong>
对应的外设时钟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcu_periph_clock_enable(RCU_GPIOB);</span><br></pre></td></tr></table></figure>
<h2 id="配置-gpio-模式">配置 GPIO 模式</h2>
<p>类似的，固件库
<code>Firmware\GD32F3x0_standard_peripheral\Include</code>
目录下的头文件 <code>gd32f3x0_gpio.h</code> 里定义了一个用于设置
<strong>GPIO 工作模式</strong>的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set GPIO mode */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_mode_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> mode, <span class="type">uint32_t</span> pull_up_down, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数的四个参数，分别用于
<code>设置 GPIO 分组</code>、<code>配置工作模式</code>、<code>选择上下拉状态</code>、<code>指定 GPIO 引脚</code>，具体参数选项请参考下面的源代码片断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIOx(x=A,B,C,D,F) definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA                      (GPIO_BASE + 0x00000000U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB                      (GPIO_BASE + 0x00000400U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC                      (GPIO_BASE + 0x00000800U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD                      (GPIO_BASE + 0x00000C00U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF                      (GPIO_BASE + 0x00001400U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* output mode definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_INPUT            CTL_CLTR(0)           <span class="comment">/*!&lt; input mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_OUTPUT           CTL_CLTR(1)           <span class="comment">/*!&lt; output mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_AF               CTL_CLTR(2)           <span class="comment">/*!&lt; alternate function mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MODE_ANALOG           CTL_CLTR(3)           <span class="comment">/*!&lt; analog mode */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pull-up/pull-down definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_PUPD(regval)           (BITS(0,1) &amp; ((uint32_t)(regval) &lt;&lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_NONE             PUD_PUPD(0)           <span class="comment">/*!&lt; floating mode, no pull-up and pull-down resistors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_PULLUP           PUD_PUPD(1)           <span class="comment">/*!&lt; with pull-up resistor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PUPD_PULLDOWN         PUD_PUPD(2)           <span class="comment">/*!&lt; with pull-down resistor */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO pin definitions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_0                 BIT(0)                <span class="comment">/*!&lt; GPIO pin 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_1                 BIT(1)                <span class="comment">/*!&lt; GPIO pin 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_2                 BIT(2)                <span class="comment">/*!&lt; GPIO pin 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_3                 BIT(3)                <span class="comment">/*!&lt; GPIO pin 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_4                 BIT(4)                <span class="comment">/*!&lt; GPIO pin 4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_5                 BIT(5)                <span class="comment">/*!&lt; GPIO pin 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_6                 BIT(6)                <span class="comment">/*!&lt; GPIO pin 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_7                 BIT(7)                <span class="comment">/*!&lt; GPIO pin 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_8                 BIT(8)                <span class="comment">/*!&lt; GPIO pin 8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_9                 BIT(9)                <span class="comment">/*!&lt; GPIO pin 9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_10                BIT(10)               <span class="comment">/*!&lt; GPIO pin 10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_11                BIT(11)               <span class="comment">/*!&lt; GPIO pin 11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_12                BIT(12)               <span class="comment">/*!&lt; GPIO pin 12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_13                BIT(13)               <span class="comment">/*!&lt; GPIO pin 13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_14                BIT(14)               <span class="comment">/*!&lt; GPIO pin 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_15                BIT(15)               <span class="comment">/*!&lt; GPIO pin 15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_ALL               BITS(0,15)            <span class="comment">/*!&lt; GPIO pin all */</span></span></span><br></pre></td></tr></table></figure>
<p>例如现在要配置 <strong>GPIOB8</strong>
引脚为<strong>悬空输出模式</strong>，则只需要向
<code>gpio_mode_set()</code> 函数传入相应的参数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_mode_set(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_8);</span><br></pre></td></tr></table></figure>
<h2 id="配置-gpio-输出类型与速度">配置 GPIO 输出类型与速度</h2>
<p>固件库 <code>Firmware\GD32F3x0_standard_peripheral\Include</code>
目录下的 <code>gd32f3x0_gpio.h</code> 头文件里面，同样定义有一个用于设置
<strong>GPIO 输出类型和速率</strong>的库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_output_options_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint8_t</span> otype, <span class="type">uint32_t</span> speed, <span class="type">uint32_t</span> pin)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的四个参数，则是分别用于
<code>设置 GPIO 分组</code>、<code>配置输出类型</code>、<code>最大输出速率</code>，具体的参数选项同样请参考下面的源代码片断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO output type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OTYPE_PP              ((uint8_t)(0x00U))    <span class="comment">/*!&lt; push pull mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OTYPE_OD              ((uint8_t)(0x01U))    <span class="comment">/*!&lt; open drain mode */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO output max speed value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_2MHZ           OSPD_OSPD0(0)                     <span class="comment">/*!&lt; output max speed 2MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_10MHZ          OSPD_OSPD0(1)                     <span class="comment">/*!&lt; output max speed 10MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_50MHZ          OSPD_OSPD0(3)                     <span class="comment">/*!&lt; output max speed 50MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_OSPEED_MAX            ((uint32_t)0x0000FFFFU)           <span class="comment">/*!&lt; GPIO very high output speed, max speed more than 50MHz */</span></span></span><br></pre></td></tr></table></figure>
<p>例如当前要配置 <strong>GPIOB8</strong>
引脚为<strong>推挽输出</strong>方式，其最大输出速率为
<code>50MHz</code>，则只需要向 <code>gpio_output_options_set()</code>
函数传入下面的参数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);</span><br></pre></td></tr></table></figure>
<h2 id="指定-gpio-引脚电平状态">指定 GPIO 引脚电平状态</h2>
<p>固件库的 <code>gd32f3x0_gpio.h</code>
头文件里，存在着下面三个可以用于定义 <strong>GPIO
引脚电平状态</strong>的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set GPIO pin bit */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_set</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_reset</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* write data to the specified GPIO pin */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_bit_write</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin, bit_status bit_value)</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>gpio_bit_set()</code> 和 <code>gpio_bit_reset()</code>
函数用于指定 GPIO 引脚为固定的高电平状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_bit_set(GPIOB, GPIO_PIN_8);    <span class="comment">// 指定 GPIOB8 引脚为高电平</span></span><br><span class="line">gpio_bit_reset(GPIOB, GPIO_PIN_8);  <span class="comment">// 指定 GPIOB8 引脚为低电平</span></span><br></pre></td></tr></table></figure>
<p>而 <code>gpio_bit_write()</code> 函数则可以用来灵活的设置 GPIO
引脚为高电平或者低电平状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_bit_write(GPIOB, GPIO_PIN_8, <span class="number">0</span>);  <span class="comment">// 让 GPIOB8 引脚输出低电平</span></span><br><span class="line">gpio_bit_write(GPIOB, GPIO_PIN_8, <span class="number">1</span>);  <span class="comment">// 让 GPIOB8 引脚输出高电平</span></span><br></pre></td></tr></table></figure>
<h2 id="完整-keil-µvision-工程代码-1">完整 Keil µVision 工程代码</h2>
<p>接下来，将 <strong>Keil-GD32F350RBT6</strong> 示例工程里的
<code>LED.h</code> 和 <code>LED.c</code> 以及 <code>main.c</code>
替换为使用固件库的版本，全部的示例代码内容如下面所示，即
<strong>UINIO-MCU-GD32F350RBT6</strong> 工程 <code>Examples</code>
目录下的 <code>2-LED-Library</code> 工程：</p>
<h3 id="driversled.h-1">Drivers/LED.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== UINIO_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_RCU  RCU_GPIOB   <span class="comment">// 宏定义 LED 对应的 GPIO 端口时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_PORT GPIOB       <span class="comment">// 宏定义 LED 对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_LED_PIN  GPIO_PIN_8  <span class="comment">// 宏定义 LED 对应的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// LED 关联 GPIO 引脚的配置函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_LED_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driversled.c-1">Drivers/LED.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== UINIO_LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED 对应 GPIO 引脚的配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_LED_RCU);                                                   <span class="comment">// 使能 GIPO 外设对应的 RCU 复位和时钟单元</span></span><br><span class="line">  gpio_mode_set(UINIO_LED_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, UINIO_LED_PIN);           <span class="comment">// 配置 GPIO 为浮空输出模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_LED_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_LED_PIN); <span class="comment">// 设置 GPIO 的输出模式为推挽输出，速度为 50MHz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-1">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  gpio_bit_set(UINIO_LED_PORT, UINIO_LED_PIN);             <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">  gpio_bit_reset(UINIO_LED_PORT, UINIO_LED_PIN);           <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line"></span><br><span class="line">  gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">  gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="启动文件-startup_gd32f3x0.s-剖析">启动文件 startup_gd32f3x0.s
剖析</h1>
<p>在开启进一步的标准固件库学习之前，首先需要了解
<strong>Keil-GD32F350RBT6</strong> 工程的启动顺序，其中
<code>Firmware\CMSIS\GD\GD32F3x0\Source\ARM</code> 目录下的
<code>startup_gd32f3x0.s</code> 源文件是 <strong>GD32F350RBT6</strong>
微控制器上电复位之后，执行的第一段程序（由汇编语言编写），该程序主要完成了如下几项工作：</p>
<ol type="1">
<li>配置<strong>栈</strong>信息；</li>
<li>配置<strong>堆</strong>信息；</li>
<li>映射<strong>向量表</strong>；</li>
<li>设置<strong>复位处理程序</strong>；</li>
<li>定义<strong>异常/外部中断处理程序</strong>；</li>
<li>初始化<strong>用户堆栈</strong>；</li>
</ol>
<p>在接下来的内容当中，将会根据执行顺序依次探讨
<code>startup_gd32f3x0.s</code> 当中各个代码块的功能与用途。</p>
<h2 id="配置栈信息">配置栈信息</h2>
<p><strong>栈</strong>主要用于存放<code>局部变量</code>、<code>函数调用</code>、<code>函数形式参数</code>，其<strong>由高向低生长</strong>，且容量不能超过片上
SRAM 存储器的容量大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; &lt;h&gt; Stack Configuration</span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>
<p>上面的汇编代码，开辟了一个大小为 <code>0X00000400</code> (1KB) 名称为
<code>STACK</code> 的<strong>栈</strong>，其中 <code>NOINIT</code>
表示不初始化，<code>READWRITE</code> 表示可读可写，<code>ALIGN=3</code>
表示 <span class="math inline">\(2^3 = 8\)</span> 字节对齐。最后的
<code>__initial_sp</code> 表示栈的结束地址，也就是栈顶地址。</p>
<h2 id="配置堆信息">配置堆信息</h2>
<p><strong>堆</strong>主要用于完成动态内存分配，其<strong>由低向高生长</strong>，例如
<code>malloc()</code> 函数申请的内存就位于在堆上面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br></pre></td></tr></table></figure>
<p>上面的汇编代码，开辟了一个大小为 <code>0X00000400</code> (1KB) 名称为
<code>HEAP</code> 的<strong>堆</strong>，同样的 <code>NOINIT</code>
表示不初始化，<code>READWRITE</code> 表示可读可写，<code>ALIGN=3</code>
表示 <span class="math inline">\(2^3 = 8\)</span> 字节对齐。</p>
<p>除此之外，<code>__heap_base</code> 表示堆的起始地址，而
<code>__heap_limit</code> 表示堆的结束地址。后续的
<code>PRESERVE8</code> 表示保留 8 字节对齐，而 <code>THUMB</code>
表示兼容 <strong>THUMB</strong> 指令集。</p>
<h2 id="映射向量表">映射向量表</h2>
<p><strong>向量表</strong>是一个 32 位 <code>WORD</code>
<strong>字</strong>数组，其按照 4 字节进行边界对齐，从片上 Flash
的零地址开始进行放置，这个数组保存着一系列程序的入口地址，当
<strong>GD32F350RBT6</strong>
微控制器处于不同的预定义状态时，就会通过查找向量表，进入执行对应地址的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">;               /* reset Vector Mapped to at Address 0 */</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                      ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                     ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                       ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler                 ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler                 ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler                  ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler                ; Usage Fault Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     SVC_Handler                       ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler                  ; Debug Monitor Handler</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                    ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                   ; SysTick Handler</span><br><span class="line"></span><br><span class="line">;               /* external interrupts handler */</span><br><span class="line">                DCD     WWDGT_IRQHandler                  ; 16:Window Watchdog Timer</span><br><span class="line">                DCD     LVD_IRQHandler                    ; 17:LVD through EXTI Line detect</span><br><span class="line">                DCD     RTC_IRQHandler                    ; 18:RTC through EXTI Line</span><br><span class="line">                DCD     FMC_IRQHandler                    ; 19:FMC</span><br><span class="line">                DCD     RCU_CTC_IRQHandler                ; 20:RCU and CTC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler                ; 21:EXTI Line 0 and EXTI Line 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler                ; 22:EXTI Line 2 and EXTI Line 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler               ; 23:EXTI Line 4 to EXTI Line 15</span><br><span class="line">                DCD     TSI_IRQHandler                    ; 24:TSI</span><br><span class="line">                DCD     DMA_Channel0_IRQHandler           ; 25:DMA Channel 0</span><br><span class="line">                DCD     DMA_Channel1_2_IRQHandler         ; 26:DMA Channel 1 and DMA Channel 2</span><br><span class="line">                DCD     DMA_Channel3_4_IRQHandler         ; 27:DMA Channel 3 and DMA Channel 4</span><br><span class="line">                DCD     ADC_CMP_IRQHandler                ; 28:ADC and Comparator 0-1</span><br><span class="line">                DCD     TIMER0_BRK_UP_TRG_COM_IRQHandler  ; 29:TIMER0 Break,Update,Trigger and Commutation</span><br><span class="line">                DCD     TIMER0_Channel_IRQHandler         ; 30:TIMER0 Channel Capture Compare</span><br><span class="line">                DCD     TIMER1_IRQHandler                 ; 31:TIMER1</span><br><span class="line">                DCD     TIMER2_IRQHandler                 ; 32:TIMER2</span><br><span class="line">                DCD     TIMER5_DAC_IRQHandler             ; 33:TIMER5 and DAC</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     TIMER13_IRQHandler                ; 35:TIMER13</span><br><span class="line">                DCD     TIMER14_IRQHandler                ; 36:TIMER14</span><br><span class="line">                DCD     TIMER15_IRQHandler                ; 37:TIMER15</span><br><span class="line">                DCD     TIMER16_IRQHandler                ; 38:TIMER16</span><br><span class="line">                DCD     I2C0_EV_IRQHandler                ; 39:I2C0 Event</span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; 40:I2C1 Event</span><br><span class="line">                DCD     SPI0_IRQHandler                   ; 41:SPI0</span><br><span class="line">                DCD     SPI1_IRQHandler                   ; 42:SPI1</span><br><span class="line">                DCD     USART0_IRQHandler                 ; 43:USART0</span><br><span class="line">                DCD     USART1_IRQHandler                 ; 44:USART1</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     CEC_IRQHandler                    ; 46:CEC</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     I2C0_ER_IRQHandler                ; 48:I2C0 Error</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; 50:I2C1 Error</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     USBFS_WKUP_IRQHandler             ; 58:USBFS Wakeup</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     DMA_Channel5_6_IRQHandler         ; 64:DMA Channel5 and Channel6</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     0                                 ; Reserved</span><br><span class="line">                DCD     USBFS_IRQHandler                  ; 83:USBFS</span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU     __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure>
<p>上述汇编代码中的 <code>__Vectors</code>
表示向量表的<strong>起始地址</strong>，而 <code>__Vectors_End</code>
表示向量表的<strong>结束地址</strong>。除此之外，其中的 <code>DCD</code>
指令用于<strong>分配</strong>和<strong>初始化</strong>一个或者多个以<strong>字</strong>
<code>Word</code> 为单位的内存空间，并且以 4 字节进行对齐。</p>
<h2 id="设置复位处理程序">设置复位处理程序</h2>
<p>复位处理程序是 <strong>GD32F350RBT6</strong>
上电之后首个要运行的程序，其首先会调用 <code>SystemInit</code>
函数初始化系统时钟，然后再调用 C 库函数 <code>__main</code>
进入用户定义的主函数 <code>main()</code>：</p>
<ol type="1">
<li><code>SystemInit()</code> 是一个 ARM 标准库函数，定义在
<strong>Keil-GD32F350RBT6</strong> 工程
<code>Firmware\CMSIS\GD\GD32F3x0\Source</code> 目录下的
<code>system_gd32f3x0.c</code> 当中（即 CMSIS Cortex-M4
外设接入层源文件），主要用于初始化各种系统时钟。</li>
<li><code>__main</code> 是一个标准 C
库函数，主要用于初始化用户堆栈，并且会在最后调用自定义的
<code>main()</code> 函数，这也就是 <code>main()</code> 总是作为
<strong>Keil uVision5</strong> 工程入口函数的原因所在。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">;/* reset Handler */</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler                     [WEAK]</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述源文件当中的第一句代码，用于定义一个名称为
<code>.text</code> 的只读代码段区域。</p>
</blockquote>
<h2 id="定义异常外部中断处理程序">定义异常/外部中断处理程序</h2>
<p>接下来的代码片段，定义了一系列的<strong>异常处理程序</strong>和<strong>外部中断处理程序</strong>，而这些程序的完整实现则保存在外部的
<code>.c</code>
源文件当中。当出现相关异常或者发生指定外部中断的时候，程序的执行流程就会跳转至这里指定的各种服务程序当中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">;/* dummy Exception Handlers */</span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler                 [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler                 [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler                  [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler                  [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  PendSV_Handler                    [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  SysTick_Handler                   [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line">;               /* external interrupts handler */</span><br><span class="line">                EXPORT  WWDGT_IRQHandler                  [WEAK]</span><br><span class="line">                EXPORT  LVD_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  RTC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  FMC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  RCU_CTC_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI0_1_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI2_3_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  EXTI4_15_IRQHandler               [WEAK]</span><br><span class="line">                EXPORT  TSI_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel0_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel1_2_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel3_4_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  ADC_CMP_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER0_BRK_UP_TRG_COM_IRQHandler  [WEAK]</span><br><span class="line">                EXPORT  TIMER0_Channel_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIMER1_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  TIMER2_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  TIMER5_DAC_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  TIMER13_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER14_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER15_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  TIMER16_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C0_EV_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  SPI0_IRQHandler                   [WEAK]</span><br><span class="line">                EXPORT  SPI1_IRQHandler                   [WEAK]</span><br><span class="line">                EXPORT  USART0_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  USART1_IRQHandler                 [WEAK]</span><br><span class="line">                EXPORT  CEC_IRQHandler                    [WEAK]</span><br><span class="line">                EXPORT  I2C0_ER_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler                [WEAK]</span><br><span class="line">                EXPORT  USBFS_WKUP_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  DMA_Channel5_6_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  USBFS_IRQHandler                  [WEAK]</span><br><span class="line"></span><br><span class="line">;/* external interrupts handler */</span><br><span class="line">WWDGT_IRQHandler</span><br><span class="line">LVD_IRQHandler</span><br><span class="line">RTC_IRQHandler</span><br><span class="line">FMC_IRQHandler</span><br><span class="line">RCU_CTC_IRQHandler</span><br><span class="line">EXTI0_1_IRQHandler</span><br><span class="line">EXTI2_3_IRQHandler</span><br><span class="line">EXTI4_15_IRQHandler</span><br><span class="line">TSI_IRQHandler</span><br><span class="line">DMA_Channel0_IRQHandler</span><br><span class="line">DMA_Channel1_2_IRQHandler</span><br><span class="line">DMA_Channel3_4_IRQHandler</span><br><span class="line">ADC_CMP_IRQHandler</span><br><span class="line">TIMER0_BRK_UP_TRG_COM_IRQHandler</span><br><span class="line">TIMER0_Channel_IRQHandler</span><br><span class="line">TIMER1_IRQHandler</span><br><span class="line">TIMER2_IRQHandler</span><br><span class="line">TIMER5_DAC_IRQHandler</span><br><span class="line">TIMER13_IRQHandler</span><br><span class="line">TIMER14_IRQHandler</span><br><span class="line">TIMER15_IRQHandler</span><br><span class="line">TIMER16_IRQHandler</span><br><span class="line">I2C0_EV_IRQHandler</span><br><span class="line">I2C1_EV_IRQHandler</span><br><span class="line">SPI0_IRQHandler</span><br><span class="line">SPI1_IRQHandler</span><br><span class="line">USART0_IRQHandler</span><br><span class="line">USART1_IRQHandler</span><br><span class="line">CEC_IRQHandler</span><br><span class="line">I2C0_ER_IRQHandler</span><br><span class="line">I2C1_ER_IRQHandler</span><br><span class="line">USBFS_WKUP_IRQHandler</span><br><span class="line">DMA_Channel5_6_IRQHandler</span><br><span class="line">USBFS_IRQHandler</span><br><span class="line"></span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述汇编代码当中的 <code>B .</code>
语句表示进入了一个<strong>无限循环</strong>，即通俗意义上的<strong>死循环</strong>。</p>
</blockquote>
<h2 id="初始化用户堆栈">初始化用户堆栈</h2>
<p>接着判断当前 <strong>Keil uVision5</strong> 工程是否启用有
<code>__MICROLIB</code> 库，如果有启用就赋予栈顶地址
<code>__initial_sp</code>、堆起始地址
<code>__heap_base</code>、堆结束地址
<code>__heap_limit</code>。如果没有启用，则会使用<strong>双段存储器模式</strong>，并且由用户来初始化堆栈空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">; user Initial Stack &amp; Heap</span><br><span class="line"></span><br><span class="line">                IF      :DEF:__MICROLIB</span><br><span class="line"></span><br><span class="line">                EXPORT  __initial_sp</span><br><span class="line">                EXPORT  __heap_base</span><br><span class="line">                EXPORT  __heap_limit</span><br><span class="line"></span><br><span class="line">                ELSE</span><br><span class="line"></span><br><span class="line">                IMPORT  __use_two_region_memory</span><br><span class="line">                EXPORT  __user_initial_stackheap</span><br><span class="line"></span><br><span class="line">__user_initial_stackheap PROC</span><br><span class="line">                LDR     R0, =  Heap_Mem</span><br><span class="line">                LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                LDR     R3, = Stack_Mem</span><br><span class="line">                BX      LR</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">                ENDIF</span><br><span class="line"></span><br><span class="line">                END</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述代码当中的 <code>END</code>
是一个<strong>汇编程序结束标记</strong>。</p>
</blockquote>
<h1 id="时钟配置-system_gd32f3x0.c-解析">时钟配置 system_gd32f3x0.c
解析</h1>
<p>前面已经介绍过，由汇编语言编写的<strong>系统启动文件</strong>
<code>startup_gd32f3x0.s</code> 调用了
<strong>Keil-GD32F350RBT6</strong> 工程的
<code>Firmware\CMSIS\GD\GD32F3x0\Source\system_gd32f3x0.c</code>
源文件当中，由 C 语言编写的<strong>系统初始化函数</strong>
<code>SystemInit()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      setup the microcontroller system, initialize the system</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="comment">/* configure system clock */</span></span><br><span class="line">    system_clock_config();</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该函数最终调用的是同样定义在这个源文件里的
<code>system_clock_config()</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure the system clock</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">system_clock_config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __SYSTEM_CLOCK_8M_HXTAL</span></span><br><span class="line">    system_clock_8m_hxtal();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__SYSTEM_CLOCK_108M_PLL_HXTAL)</span></span><br><span class="line">    system_clock_108m_hxtal();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    system_clock_8m_irc8m();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SYSTEM_CLOCK_8M_HXTAL */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在 <code>system_gd32f3x0.c</code>
源文件的开头位置，存在着如下针对 <strong>GDF350</strong>
系列微控制器的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (GD32F350)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSTEM_CLOCK_108M_PLL_HXTAL        (uint32_t)(108000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* GD32F350 */</span></span></span><br></pre></td></tr></table></figure>
<p>所以 <code>system_clock_config()</code>
方法最终实际调用的是该源文件中的函数
<code>system_clock_108m_hxtal()</code>，这个函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__SYSTEM_CLOCK_108M_PLL_HXTAL)</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure the system clock to 84M by PLL which selects HXTAL as its clock source</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">system_clock_108m_hxtal</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> timeout = <span class="number">0U</span>;</span><br><span class="line">    <span class="type">uint32_t</span> stab_flag = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable HXTAL */</span></span><br><span class="line">    RCU_CTL0 |= RCU_CTL0_HXTALEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until HXTAL is stable or the startup time is longer than HXTAL_STARTUP_TIMEOUT */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">        stab_flag = (RCU_CTL0 &amp; RCU_CTL0_HXTALSTB);</span><br><span class="line">    &#125; <span class="keyword">while</span>((<span class="number">0U</span> == stab_flag) &amp;&amp; (HXTAL_STARTUP_TIMEOUT != timeout));</span><br><span class="line">    <span class="comment">/* if fail */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> == (RCU_CTL0 &amp; RCU_CTL0_HXTALSTB)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* HXTAL is stable */</span></span><br><span class="line">    <span class="comment">/* AHB = SYSCLK */</span></span><br><span class="line">    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;</span><br><span class="line">    <span class="comment">/* APB2 = AHB/2 */</span></span><br><span class="line">    RCU_CFG0 |= RCU_APB2_CKAHB_DIV2;</span><br><span class="line">    <span class="comment">/* APB1 = AHB/2 */</span></span><br><span class="line">    RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PLL = HXTAL/2 * 27 = 108 MHz */</span></span><br><span class="line">    RCU_CFG0 &amp;= ~(RCU_CFG0_PLLSEL | RCU_CFG0_PLLMF | RCU_CFG0_PLLMF4 | RCU_CFG0_PLLPREDV);</span><br><span class="line">    RCU_CFG1 &amp;= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PLLMF5 | RCU_CFG1_PREDV);</span><br><span class="line">    RCU_CFG0 |= (RCU_PLLSRC_HXTAL_IRC48M | (RCU_PLL_MUL27 &amp; (~RCU_CFG1_PLLMF5)));</span><br><span class="line">    RCU_CFG1 |= (RCU_PLLPRESEL_HXTAL | RCU_PLL_PREDV2);</span><br><span class="line">    RCU_CFG1 |= (RCU_PLL_MUL27 &amp; RCU_CFG1_PLLMF5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable PLL */</span></span><br><span class="line">    RCU_CTL0 |= RCU_CTL0_PLLEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until PLL is stable */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> == (RCU_CTL0 &amp; RCU_CTL0_PLLSTB)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* select PLL as system clock */</span></span><br><span class="line">    RCU_CFG0 &amp;= ~RCU_CFG0_SCS;</span><br><span class="line">    RCU_CFG0 |= RCU_CKSYSSRC_PLL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait until PLL is selected as system clock */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> == (RCU_CFG0 &amp; RCU_SCSS_PLL)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁相环</strong>（PLL，Phase Locking
Loop）是一种反馈控制电路，其工作过程当中，当输出信号频率与输入信号频率相同时，可以使输出电压与输入电压保持固定的相位差，就像输入/输出电压的相位被锁住了一样，所以这种电路被称为锁相环。<strong>GD32F350RBT6</strong>
内部的 PLL 主要用于根据特定的外部晶振信号来生成其它频率的信号。</p>
<p><img src="/Project/UINIO-MCU-GD32/6-Clock/1.png"></p>
<p>观察可以发现，上述代码使能了 <strong>GD32F350RBT6</strong> 内部的 PLL
锁相坏，由于当前 <strong>UINIO-MCU-GD32F350RBT6</strong>
核心板的外部贴片晶振频率为
<code>8MHz</code>，所以<strong>高速外部晶体振荡器时钟</strong>
<code>HXTAL = 8MHz</code>，这样锁相环的输出频率可以按照
如下方式进行计算：</p>
<p><span class="math display">\[
PLL = \frac{HXTAL}{2} \times 27 = \frac{8MHz}{2} \times 27 = 108 MHz
\]</span></p>
<p>上述代码选择了锁相环的输出作为<strong>系统时钟</strong>
<code>SYSCLK</code>，并且将<strong>高级高性能总线</strong>（<strong>AHB</strong>，Advanced
High-performance Bus）时钟配置为了与系统时钟的频率相等：</p>
<p><span class="math display">\[
AHB = SYSCLK = 108 MHz
\]</span></p>
<p>而两条<strong>高级外设总线</strong>（<strong>APB</strong>，Advanced
Peripheral Bus）时钟频率分别为 AHB 总线时钟的二分之一：</p>
<p><span class="math display">\[
\begin{cases}
APB1 = \frac{AHB}{2} = \frac{108MHz}{2} = 54MHz \\
APB2 = \frac{AHB}{2} = \frac{108MHz}{2} = 54MHz
\end{cases}
\]</span></p>
<h1 id="系统滴答定时器-systick">系统滴答定时器 SysTick</h1>
<p><strong>SysTick 定时器</strong>是一个拥有自动重装载能力的 24
位<strong>向下计数器</strong>，所有 ARM Cortex-M4
内核微控制器都具备该定时器，从而能够方便的在不同型号微控制器之间进行代码移植。当设定
SysTick
定时器的初始值并且使能之后，每经过一个系统时钟周期，定时器的计数值就会减去
<code>1</code>，当减至 <code>0</code> 的时候，SysTick
就会自动重新装载初始值，并且继续开始计数，同时置位内部的
<code>COUNTFLAG</code>
标志位，并且触发中断（如果使能有相应的定时器中断）。</p>
<p><img src="/Project/UINIO-MCU-GD32/7-SysTick/1.png"></p>
<p>观察 <strong>GD32F350RBT6</strong>
微控制器<strong>时钟树</strong>可以发现，<code>108MHz</code> 频率的 AHB
总线时钟 <code>CK_AHB</code>，在经过 8 分频之后，默认作为了 SysTick
系统定时器的时钟源。</p>
<h2 id="使用-systick_config-配置寄存器">使用 SysTick_Config()
配置寄存器</h2>
<p>标准固件库 <code>Firmware\CMSIS\core_cm4.h</code> 源文件中的
<code>SysTick_Type</code> 结构体类型，定义了系统滴答定时器 SysTick
相关的寄存器：</p>
<p><img src="/Project/UINIO-MCU-GD32/7-SysTick/2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \brief  Structure type to access the System Timer (SysTick).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CTRL;                    <span class="comment">/*!&lt; Offset: 0x000 (R/W)  SysTick Control and Status Register */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> LOAD;                    <span class="comment">/*!&lt; Offset: 0x004 (R/W)  SysTick Reload Value Register       */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> VAL;                     <span class="comment">/*!&lt; Offset: 0x008 (R/W)  SysTick Current Value Register      */</span></span><br><span class="line">    __I  <span class="type">uint32_t</span> CALIB;                   <span class="comment">/*!&lt; Offset: 0x00C (R/ )  SysTick Calibration Register        */</span></span><br><span class="line">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure>
<p>该源文件中的 <code>SysTick_Config()</code> 函数，则是用于对上述
SysTick
相关的寄存器进行配置，在初始化和启动系统滴答定时器的同时，产生周期性的中断。概而言之，其主要完成了下面四个步骤的工作：</p>
<ol type="1">
<li>设置 <code>LOAD</code> 重载寄存器的初始值；</li>
<li>设置 SysTick 定时器中断的优先级为
<code>(1 &lt;&lt; 4) - 1 = 15</code>，即优先级为最低；</li>
<li>配置 <code>VAL</code> 寄存器，装载 SysTick 的计数值；</li>
<li>配置 <code>CTRL</code> 寄存器，使能 SysTick
的时钟源、中断、以及外设本身；</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \brief  System Tick Configuration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.</span></span><br><span class="line"><span class="comment">    Counter is in free running mode to generate periodic interrupts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \param [in]  ticks  Number of ticks between two interrupts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return          0  Function succeeded.</span></span><br><span class="line"><span class="comment">    \return          1  Function failed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \note     When the variable &lt;b&gt;__Vendor_SysTickConfig&lt;/b&gt; is set to 1, then the</span></span><br><span class="line"><span class="comment">    function &lt;b&gt;SysTick_Config&lt;/b&gt; is not included. In this case, the file &lt;b&gt;&lt;i&gt;device&lt;/i&gt;.h&lt;/b&gt;</span></span><br><span class="line"><span class="comment">    must contain a vendor-specific implementation of this function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((ticks - <span class="number">1</span>) &gt; SysTick_LOAD_RELOAD_Msk) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);    <span class="comment">/* Reload value impossible */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;LOAD  = ticks - <span class="number">1</span>;                                  <span class="comment">/* set reload register */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, (<span class="number">1</span> &lt;&lt; __NVIC_PRIO_BITS) - <span class="number">1</span>); <span class="comment">/* set Priority for SysTick Interrupt */</span></span><br><span class="line">    SysTick-&gt;VAL   = <span class="number">0</span>;                                          <span class="comment">/* Load the SysTick Counter Value */</span></span><br><span class="line">    SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk |</span><br><span class="line">                     SysTick_CTRL_TICKINT_Msk   |</span><br><span class="line">                     SysTick_CTRL_ENABLE_Msk;                    <span class="comment">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滴答定时器官方示例-systick.c">滴答定时器官方示例 systick.c</h2>
<p><strong>Keil-GD32F350RBT6</strong> 示例工程 <code>Sources</code>
目录下提供的 <code>systick.c</code> 源文件，其中的
<code>systick_config()</code> 方法就封装并且调用了上面的
<code>SysTick_Config()</code> 函数，在使能 SysTick
中断服务程序与定时器的同时，以系统时钟频率的千分之一
<code>SystemCoreClock / 1000U</code> 作为 SysTick
滴答定时器配置参数，也就是<strong>每 1 秒计数一千次，每一次 1
毫秒</strong>（如果修改为 <code>SystemCoreClock / 1000000U</code>
则可以实现微秒级的延时）。</p>
<p>而 <code>systick.c</code> 源文件当中提供的另一个函数
<code>delay_1ms()</code>，则是以 <code>count</code>
参数（单位为毫秒）进行定时计数，当 <code>volatile</code>
关键字修饰的<strong>全局变量</strong> <code>delay</code>
被自减至零的时候，就会自动退出该函数的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the systick configuration file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">uint32_t</span> delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      configure systick</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      delay a time in milliseconds</span></span><br><span class="line"><span class="comment">    \param[in]  count: count in milliseconds</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span> &#123;</span><br><span class="line">    delay = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      delay decrement</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，上面 <code>systick.c</code> 代码中定义的
<code>delay_decrement()</code> 函数，则会被
<strong>Keil-GD32F350RBT6</strong> 工程下
<code>Sources/gd32f3x0_it.h/c</code> 源文件内的 SysTick 中断服务程序
<code>SysTick_Handler()</code> 调用，具体调用代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      this function handles SysTick exception</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    delay_decrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每一次进入 SysTick
系统滴答定时器中断的时候，上面这个函数就会被调用一次，从而就完成了一次对于
<code>delay</code> 变量的自减。</p>
<h2 id="编写-main.c-测试代码">编写 main.c 测试代码</h2>
<p>接下来，将前面 <strong>LCD</strong> 示例工程当中的
<code>main.c</code> 源文件修改为如下的代码，使得 LED
发光二极管可以每间隔 1 秒钟循环进行闪烁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    gpio_bit_set(UINIO_LED_PORT, UINIO_LED_PIN);             <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_reset(UINIO_LED_PORT, UINIO_LED_PIN);           <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    delay_1ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uinio_systick_delay_usms">UINIO_SysTick_Delay_us/ms()</h2>
<p>SysTick 系统滴答定时器的 <code>counter</code> 从 <code>reload</code>
值往下递减到零的时候，<code>CTRL</code>
寄存器相应的<strong>位</strong>就会被置为
<code>1</code>，而读取该位的时候，其值又会自动被清零，所以利用这个特点就能够以非常简短的代码，实现类似于官方
SysTic 示例的定时器延时功能：</p>
<h3 id="driverssystick.h">Drivers/SysTick.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SysTick.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_SysTick_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_SysTick_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_us</span><span class="params">(__IO <span class="type">uint32_t</span> us)</span>;  <span class="comment">// 微秒级延时，参数 us 的单位为微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_ms</span><span class="params">(__IO <span class="type">uint32_t</span> ms)</span>;  <span class="comment">// 毫秒级延时，参数 ms 的单位为毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_SysTick_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driverssystick.c">Drivers/SysTick.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== SysTick.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 微秒级延时，参数 us 的单位为微秒 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_us</span> <span class="params">(__IO <span class="type">uint32_t</span> us)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> index;</span><br><span class="line">  SysTick_Config(SystemCoreClock/<span class="number">1000000U</span>);      <span class="comment">// 调用 core_cm4.h 头文件中定义的 SysTick_Config() 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; us; index++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( !((SysTick-&gt;CTRL) &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">16</span>)) );  <span class="comment">// 当计数值减小到 0 时，CRTL 寄存器相应的位会被置为 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;     <span class="comment">// 失能 SysTick 系统滴答定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毫秒级延时，参数 ms 的单位为毫秒 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_SysTick_Delay_ms</span> <span class="params">(__IO <span class="type">uint32_t</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> index;</span><br><span class="line">  SysTick_Config(SystemCoreClock/<span class="number">1000U</span>);         <span class="comment">// 调用 core_cm4.h 头文件中定义的 SysTick_Config() 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; ms; index++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( !((SysTick-&gt;CTRL) &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">16</span>)) );  <span class="comment">// 当计数值减小到 0 时，CRTL 寄存器相应的位会被置为 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;     <span class="comment">// 失能 SysTick 系统滴答定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改-main.c-测试代码">修改 main.c 测试代码</h2>
<p>这里可以修改前面的 <code>main.c</code> 源文件，通过自定义的
<code>UINIO_SysTick_Delay_us()</code> 和
<code>UINIO_SysTick_Delay_ms()</code> 函数来进行延时，从而实现相同的 LED
间隔 1 秒循环闪烁的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, SET);      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    gpio_bit_write(UINIO_LED_PORT, UINIO_LED_PIN, RESET);    <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_us(<span class="number">1000000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：本节内容涉及的全部源代码，已经保存在
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板工程 <code>Examples</code>
目录下的 <code>3-Systick</code>。</p>
</blockquote>
<h2 id="库函数修改-systick-的时钟源">库函数修改 SysTick 的时钟源</h2>
<p><strong>Keil-GD32F350RBT6</strong> 示例工程在
<code>Firmware\GD32F3x0_standard_peripheral\Source\gd32f3x0_misc.c</code>
源文件内提供有一个名为 <code>systick_clksource_set()</code>
的库函数，可以用于修改 SysTick
的时钟源，其功能与参数说明如下面表格所示：</p>
<p><img src="/Project/UINIO-MCU-GD32/7-SysTick/3.png"></p>
<p>可以看到，该库函数可以用于选择 SysTick
系统滴答定时器的时钟源，可以选择的参数有如下两个：</p>
<ul>
<li><code>SYSTICK_CLKSOURCE_HCLK</code>：系统滴答定时器时钟源来自 AHB
时钟；</li>
<li><code>SYSTICK_CLKSOURCE_HCLK_DIV8</code>: 系统滴答定时器时钟源来自
AHB 时钟 8 分频（默认）；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      set the systick clock source</span></span><br><span class="line"><span class="comment">    \param[in]  systick_clksource: the systick clock source needed to choose</span></span><br><span class="line"><span class="comment">                only one parameter can be selected which is shown as below:</span></span><br><span class="line"><span class="comment">      \arg        SYSTICK_CLKSOURCE_HCLK: systick clock source is from HCLK</span></span><br><span class="line"><span class="comment">      \arg        SYSTICK_CLKSOURCE_HCLK_DIV8: systick clock source is from HCLK/8</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_clksource_set</span><span class="params">(<span class="type">uint32_t</span> systick_clksource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(SYSTICK_CLKSOURCE_HCLK == systick_clksource) &#123;</span><br><span class="line">        <span class="comment">/* set the systick clock source from HCLK */</span></span><br><span class="line">        SysTick-&gt;CTRL |= SYSTICK_CLKSOURCE_HCLK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* set the systick clock source from HCLK/8 */</span></span><br><span class="line">        SysTick-&gt;CTRL &amp;= SYSTICK_CLKSOURCE_HCLK_DIV8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于位带-bit-band-执行位操作">基于位带 Bit Band 执行位操作</h1>
<p>嵌入式开发过程当中，经常需要进行<strong>位操作</strong>（即对一个比特位进行读写），早期的
<strong>STC51</strong> 系列单片机可以通过关键字 <code>sbit</code>
实现位操作，但是 <strong>ARM Cortex-M4</strong>
架构的微控制器并不存在类似语法，而是通过提供<strong>位带别名区</strong>到<strong>位带区</strong>的映射来实现对<strong>比特位</strong>的操作。</p>
<h2 id="位带别名区-位带区">位带别名区 → 位带区</h2>
<p><strong>ARM Cortex-M4</strong>
存储映射当中包含有<strong>位带别名区</strong>（Bit Band
Alias）和<strong>位带区</strong>（Bit Band
Region）两个区域，通过将<strong>位带别名区</strong>（Bit Band
Alias）当中的每 1 个 <code>Word</code>
<strong>字</strong>映射到<strong>位带区</strong>（Bit Band Region）里的
<code>Bit</code> <strong>位</strong>（ARM 体系结构中 1
个<strong>字</strong>的长度为 32
<strong>位</strong>），这样操作<strong>位带别名区</strong>当中的<strong>字</strong>，就等于操作<strong>位带区</strong>相应的<strong>位</strong>，具体原理可以参照下面示意图：</p>
<p><img src="/Project/UINIO-MCU-GD32/8-Bit-Band/1.png"></p>
<p>基于 <strong>ARM Cortex-M4</strong> 架构的
<strong>GD32F350RBT6</strong>
微控制器，分别在两个区域实现了<strong>位带</strong>功能（即从<strong>位带别名区</strong>到<strong>位带区</strong>的映射）：</p>
<ol type="1">
<li><strong>外设 Peripheral</strong> 的
<code>0x44000000 ~ 0x42000000</code>
地址范围属于<strong>位带别名区</strong>，而最低的
<code>0x40100000 ~ 0x40000000</code>
区别则属于<strong>位带区</strong>。</li>
<li><strong>静态随机存储器 SRAM</strong> 的
<code>0x24000000 ~ 0x22000000</code>
地址范围属于<strong>位带别名区</strong>，而最低的
<code>0x20100000 ~ 0x20000000</code>
区别则属于<strong>位带区</strong>。</li>
</ol>
<h2 id="建立通用的映射公式">建立通用的映射公式</h2>
<p>下面的公式展示了<strong>位带别名区域</strong>当中的每 1
个<strong>字</strong>，如何对应到<strong>位带区域</strong>的相应<strong>位</strong>上面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">映射到位带区目标位的别名区的字地址 = 位带别名区起始地址 + (位带区目标位所在字节的地址偏移量 × <span class="number">32</span>) + (目标位在对应字节当中的位置 × <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>根据上面的公式，位带区目标位的序号为 <code>number</code>（取值范围
<code>0 &lt;= number &lt;= 31</code>，具体由待操作的目标寄存器决定），则该比特位在别名区的对应地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标位映射到外设别名区的地址 = <span class="number">0x42000000</span> + (位带区目标位所在字节的地址 - <span class="number">0x40000000</span>) * <span class="number">8</span> * <span class="number">4</span> + (number * <span class="number">4</span>);</span><br><span class="line">目标位映射到 SRAM 别名区的地址 = <span class="number">0x22000000</span> + (位带区目标位所在字节的地址 - <span class="number">0x20000000</span>) * <span class="number">8</span> * <span class="number">4</span> + (number * <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述公式当中，因为 1 个字节有 8
位，所以需要乘以 <code>8</code>，而 1 个位膨胀之后对应着 4
个字节，所以需要再乘以 <code>4</code>。</p>
</blockquote>
<p>接下来，可以将上述的两个公式合并，成为一个用于将<strong>位带区地址</strong>
<code>address</code> 和<strong>位序号</strong> <code>bit_number</code>
转换为<strong>位带别名区地址</strong>的 <code>BITBAND()</code>
宏定义函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(address, bit_number) ((address &amp; 0xF0000000) + 0x02000000 + ((address &amp; 0x00FFFFFF) &lt;&lt; 5) + (bit_number &lt;&lt; 2)) <span class="comment">// 将位带区地址和位序号转换为位带别名区地址</span></span></span><br></pre></td></tr></table></figure>
<p>上述宏定义语句当中的 <code>address &amp; 0xF0000000</code> 用于取出
<code>4</code> 或者 <code>2</code>，并且以此来判断当前操作的是 SRAM
还是外设别名区：</p>
<ul>
<li>如果取出的是 <code>4</code>，加上 <code>0X0200 0000</code>
之后等于<strong>外设别名区的起始地址</strong>
<code>0X4200 0000</code>;</li>
<li>如果取出的是 <code>2</code>，加上 <code>0X0200 0000</code> 之后等于
<strong>SRAM 别名区的起始地址</strong> <code>0X2200 0000</code>；</li>
</ul>
<p>而上述宏定义语句当中 <code>address &amp; 0x00FF FFFF</code>
得到的结果，与减去 <code>0X2000 0000</code> 或者
<code>0X4000 0000</code> 得到的结果相同，而后续的
<code>&lt;&lt; 5</code> 以及 <code>&lt;&lt; 2</code> 则分别起到了乘以
<code>32</code> 和乘以 <code>4</code>
的作用（即两种计算方式获得的二进制、十进制、十六进制结果完全相同）：</p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 23%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">乘法与位运算的对应关系</th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>10 * 2 = 10 &lt;&lt; 1</code></td>
<td style="text-align: left;"><code>10 * 4 = 10 &lt;&lt; 2</code></td>
<td style="text-align: left;"><code>10 * 8 = 10 &lt;&lt; 3</code></td>
<td style="text-align: left;"><code>10 * 16 = 10 &lt;&lt; 4</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>10 * 32 = 10 &lt;&lt; 5</code></td>
<td style="text-align: left;"><code>10 * 64 = 10 &lt;&lt; 6</code></td>
<td style="text-align: left;"><code>10 * 108 = 10 &lt;&lt; 7</code></td>
<td style="text-align: left;"><code>10 * 256 = 10 &lt;&lt; 8</code></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 23%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">除法与位运算的对应关系</th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>10 / 2 = 10 &gt;&gt; 1</code></td>
<td style="text-align: left;"><code>10 / 4 = 10 &gt;&gt; 2</code></td>
<td style="text-align: left;"><code>10 / 8 = 10 &gt;&gt; 3</code></td>
<td style="text-align: left;"><code>10 / 16 = 10 &gt;&gt; 4</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>10 / 32 = 10 &gt;&gt; 5</code></td>
<td style="text-align: left;"><code>10 / 64 = 10 &gt;&gt; 6</code></td>
<td style="text-align: left;"><code>10 / 108 = 10 &gt;&gt; 7</code></td>
<td style="text-align: left;"><code>10 / 256 = 10 &gt;&gt; 8</code></td>
</tr>
</tbody>
</table>
<p>最后，就可以通过<strong>指针</strong>操作<strong>位带别名区</strong>的地址，进而实现对于<strong>位带区</strong>相应比特位的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_POINTER(address)         *((volatile unsigned long  *)(address))       <span class="comment">// 将地址转换为 unsigned long 类型指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(address, bit_number) ADDRESS_POINTER(BITBAND(address, bit_number)) <span class="comment">// 使用前面定义的宏定义语句 BITBAND()，将位带别名区地址转换为指针</span></span></span><br></pre></td></tr></table></figure>
<p>由于 <strong>GD32F350RBT6</strong> 微控制器的
<code>GPIOA ~ GPIOF</code> 基地址定义如下面列表所示：</p>
<ol type="1">
<li><strong>GPIOA</strong> 基地址：<code>0x4800 0000</code>；</li>
<li><strong>GPIOB</strong> 基地址：<code>0x4800 0400</code>；</li>
<li><strong>GPIOC</strong> 基地址：<code>0x4800 0800</code>；</li>
<li><strong>GPIOD</strong> 基地址：<code>0x4800 0C00</code>；</li>
<li><strong>GPIOF</strong> 基地址：<code>0x4800 1400</code>；</li>
</ol>
<p>则可以将上述 GPIO 接口所对应的<strong>端口输出控制寄存器</strong>
<code>GPIOx_OCTL</code> 以及<strong>端口输入状态寄存器</strong>
<code>GPIOx_ISTAT</code> 地址，封装为如下的宏定义语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 端口输出控制寄存器 GPIOx_OCTL 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL_ADDRESS (GPIOA + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_ADDRESS (GPIOB + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_OCTL_ADDRESS (GPIOC + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_OCTL_ADDRESS (GPIOD + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_OCTL_ADDRESS (GPIOE + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OCTL_ADDRESS (GPIOF + 0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输入状态寄存器 GPIOx_ISTAT 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ISTAT_ADDRESS (GPIOA + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ISTAT_ADDRESS (GPIOB + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ISTAT_ADDRESS (GPIOC + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ISTAT_ADDRESS (GPIOD + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ISTAT_ADDRESS (GPIOE + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ISTAT_ADDRESS (GPIOF + 0x10)</span></span><br></pre></td></tr></table></figure>
<p>上述代码当中的 <code>GPIOx</code> 已经被定义在固件库的
<code>gd32f3x0_gpio.h</code> 头文件当中，编译的时候已经由 <strong>Keil
uVision5</strong>
自动包含相关路径。接下来的时间，就可以基于上面列出的寄存器地址，进一步将它们封装为控制
GPIO 输入与输出的宏定义函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 控制 GPIOA 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_Out(number) BIT_ADDRESS(GPIOA_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_In(number)  BIT_ADDRESS(GPIOA_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOB 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_Out(number) BIT_ADDRESS(GPIOB_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_In(number)  BIT_ADDRESS(GPIOB_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOC 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_Out(number) BIT_ADDRESS(GPIOC_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_In(number)  BIT_ADDRESS(GPIOC_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOD 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_Out(number) BIT_ADDRESS(GPIOD_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_In(number)  BIT_ADDRESS(GPIOD_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOF 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_Out(number) BIT_ADDRESS(GPIOF_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_In(number)  BIT_ADDRESS(GPIOF_ISTAT_ADDRESS, number)</span></span><br></pre></td></tr></table></figure>
<h2 id="完整-keil-µvision-工程代码-2">完整 Keil µVision 工程代码</h2>
<h3 id="bitband.h">BitBand.h</h3>
<p>把上述的宏定义代码保存至 <code>Drivers/BitBand</code> 目录下的
<code>BitBand.h</code> 头文件里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== BitBand.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_BitBand_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_BitBand_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(address, bit_number) ((address &amp; 0xF0000000) + 0x02000000 + ((address &amp; 0x00FFFFFF) &lt;&lt; 5) + (bit_number &lt;&lt; 2)) <span class="comment">// 将位带区地址和位序号转换为位带别名区地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_POINTER(address)         *((volatile unsigned long  *)(address))                                               <span class="comment">// 将地址转换为 unsigned long 类型指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(address, bit_number) ADDRESS_POINTER(BITBAND(address, bit_number))                                         <span class="comment">// 使用前面定义的宏定义语句 BITBAND()，将位带别名区地址转换为指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输出控制寄存器 GPIOx_OCTL 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_OCTL_ADDRESS (GPIOA + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_ADDRESS (GPIOB + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_OCTL_ADDRESS (GPIOC + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_OCTL_ADDRESS (GPIOD + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_OCTL_ADDRESS (GPIOE + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OCTL_ADDRESS (GPIOF + 0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 端口输入状态寄存器 GPIOx_ISTAT 地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ISTAT_ADDRESS (GPIOA + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ISTAT_ADDRESS (GPIOB + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ISTAT_ADDRESS (GPIOC + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ISTAT_ADDRESS (GPIOD + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ISTAT_ADDRESS (GPIOE + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ISTAT_ADDRESS (GPIOF + 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOA 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_Out(number) BIT_ADDRESS(GPIOA_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_In(number)  BIT_ADDRESS(GPIOA_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOB 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_Out(number) BIT_ADDRESS(GPIOB_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_In(number)  BIT_ADDRESS(GPIOB_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOC 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_Out(number) BIT_ADDRESS(GPIOC_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_In(number)  BIT_ADDRESS(GPIOC_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOD 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_Out(number) BIT_ADDRESS(GPIOD_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_In(number)  BIT_ADDRESS(GPIOD_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制 GPIOF 的输入与输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_Out(number) BIT_ADDRESS(GPIOF_OCTL_ADDRESS, number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_In(number)  BIT_ADDRESS(GPIOF_ISTAT_ADDRESS, number)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_BitBand_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="main.c">main.c</h3>
<p>继续修改之前的 LED 闪烁示例工程 <code>main.c</code> 源文件，在包含
<code>BitBand.h</code> 头文件的同时，通过调用宏定义函数
<code>GPIOB_Out(8)</code> 修改 <strong>GPIOB8</strong>
引脚的电平状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/BitBand/BitBand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();  <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_LED_GPIO_Config(); <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    GPIOB_Out(<span class="number">8</span>) = <span class="number">1</span>;      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    GPIOB_Out(<span class="number">8</span>) = <span class="number">0</span>;      <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，也可以将位带操作相关的宏定义代码，更加直观的声明在
<code>main.c</code> 源文件当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偏移量 = GPIOB 基地址 0x48000400 + GPIOx_OCTL 偏移量 0x14 - 片上外设起始地址 0x40000000 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OCTL_OFFSET ((GPIOB + 0x14) - 0x40000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位带别名区的字地址 = 位带别名区起始地址 + (位带区目标位所在字节的地址偏移量 × 32) + (目标位在对应字节当中的位置 × 4) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDRESS(byte_offset, bit_number) (volatile unsigned long *)(0x42000000 + (byte_offset &lt;&lt; 5) + (bit_number &lt;&lt; 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置 GPIOB 端口指定引脚的输出状态，例如 GPIOB_OUT(8) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_OUT(number) *(BIT_ADDRESS(GPIOB_OCTL_OFFSET, number))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_LED_GPIO_Config(); <span class="comment">// 初始化 LED 相关的 GPIO 引脚</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    GPIOB_OUT(<span class="number">8</span>) = <span class="number">1</span>;      <span class="comment">// GPIOB8 输出高电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    GPIOB_OUT(<span class="number">8</span>) = <span class="number">0</span>;      <span class="comment">// GPIOB8 输出低电平</span></span><br><span class="line">    UINIO_SysTick_Delay_ms(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="gpio-输入模式与按键">GPIO 输入模式与按键</h1>
<h2 id="按键使用原理">按键使用原理</h2>
<p><strong>微动开关</strong>或者<strong>轻触按键</strong>是通过内部的<code>触点</code>与<code>弹片</code>来实现导通与截止，将其连接至
<strong>GD32F350RBT6</strong> 的 GPIO 引脚，就可以通过检测其按下之后
GPIO 引脚获取的电平状态，来判断当前是处于按下还是松开的情况：</p>
<p><img src="/Project/UINIO-MCU-GD32/9-Key/1.png"></p>
<p>当按键在被按下或者松开的时候，会由于触点上弹片的弹性作用，发生
<code>5ms ~ 10ms</code> 机械抖动，为了避免 GPIO
得到错误的状态，必须考虑采取一定的措施去消除这种抖动所带来的干扰：</p>
<ul>
<li><strong>硬件消抖</strong>：微动开关两侧并联上一枚<strong>电容</strong>，利用其充放电作用吸收抖动产生的振荡。</li>
<li><strong>软件消抖</strong>：当开关按下时，通过延时代码规避掉抖动发生的时间。</li>
</ul>
<p>首先，将一枚轻触按键 <code>SW1</code> 连接到
<strong>UINIO-MCU-GD32F350RBT6</strong> 的 <strong>GPIOB9</strong>
引脚，其中一端连接至 <code>3V3</code> 引脚，而另一端经过位号为
<code>R3</code> 的 <code>10KΩ</code> <strong>下拉电阻</strong>之后连接至
<code>GND</code> 引脚：</p>
<p><img src="/Project/UINIO-MCU-GD32/9-Key/2.png"></p>
<p>然后，使用固件库提供的工具函数，把 <strong>GPIOB9</strong>
配置为带<strong>下拉电阻</strong>的<strong>输入模式</strong>，通过检测该引脚的电平状态，就可以判断按键
<code>SW1</code>
是否被按下（按键松开为<strong>低电平</strong>，按键按下为<strong>高电平</strong>）。</p>
<h2 id="完整-keil-µvision-工程代码-3">完整 Keil µVision 工程代码</h2>
<p>如前所述，使用 GPIO
端口的输入输出功能，通常会需要经历下面三个步骤：</p>
<ol type="1">
<li>通过
<code>void rcu_periph_clock_enable(rcu_periph_enum periph);</code>
固件库函数启用 GPIO 端口对应的<strong>外设时钟</strong>。</li>
<li>通过
<code>void gpio_mode_set(uint32_t gpio_periph, uint32_t mode, uint32_t pull_up_down, uint32_t pin);</code>
固件库函数配置 GPIO 端口的<strong>工作模式</strong>（输入模式
<code>GPIO_MODE_INPUT</code>、输出模式
<code>GPIO_MODE_OUTPUT</code>、备用功能模式
<code>GPIO_MODE_AF</code>、模拟模式
<code>GPIO_MODE_ANALOG</code>），以及设置<strong>上下拉电阻状态</strong>（悬空无上下拉
<code>GPIO_PUPD_NONE</code>、带上拉电阻
<code>GPIO_PUPD_PULLUP</code>、带下拉电阻
<code>GPIO_PUPD_PULLDOWN</code>）。</li>
<li>通过
<code>void gpio_bit_toggle(uint32_t gpio_periph, uint32_t pin);</code>
固件库函数翻转 LED 对应 GPIO 引脚的电平状态。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目
<code>Examples</code> 目录下的 <strong>5-Key</strong> 工程当中。</p>
</blockquote>
<h3 id="driverskey.h">Drivers/key.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Key.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_RCU  RCU_GPIOB   <span class="comment">// 宏定义按键对应的 GPIO 端口时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PORT GPIOB       <span class="comment">// 宏定义按键对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PIN  GPIO_PIN_9  <span class="comment">// 宏定义按键对应的 GPIO 引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 调用开关对应 GPIO 引脚的配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_Scan</span><span class="params">(<span class="type">void</span>)</span>;         <span class="comment">// 按键状态扫描函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_KEY_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driverskey.c">Drivers/key.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== Key.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键对应 GPIO 引脚的配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_KEY_RCU);                                            <span class="comment">// 使能外设时钟</span></span><br><span class="line">  gpio_mode_set(UINIO_KEY_PORT, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, UINIO_KEY_PIN); <span class="comment">// 配置 GPIO 为带下拉电阻的输入模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Key_Scan</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断按键是否被按下（高电平按下，低电平松开） */</span></span><br><span class="line">  <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">    delay_1ms(<span class="number">20</span>);                                                       <span class="comment">// 延时 20 毫秒，规避按键弹片抖动时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次判断按键是否被按下 */</span></span><br><span class="line">    <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">      gpio_bit_toggle(UINIO_LED_PORT, UINIO_LED_PIN);                    <span class="comment">// 翻转 LED 对应 GPIO 引脚的电平状态</span></span><br><span class="line">      <span class="keyword">while</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET);  <span class="comment">// 判断按键是否被松开</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-2">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/Key/Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/SysTick/SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();         <span class="comment">// 滴答定时器初始化</span></span><br><span class="line">  UINIO_LED_GPIO_Config();  <span class="comment">// 配置 LED 相关的 GPIO 外设</span></span><br><span class="line">  UINIO_Key_GPIO_Config();  <span class="comment">// 配置按键相关的 GPIO 外设</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UINIO_Key_Scan();       <span class="comment">// 循环扫描按键状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="usart-通用同步异步收发器">USART 通用同步/异步收发器</h1>
<h2 id="usart-串行协议分析">USART 串行协议分析</h2>
<p><strong>通用同步/异步收发器</strong>（USART，Universal
Synchronous/Asynchronous Receiver
Transmitter）是一种基于<strong>数据帧</strong>的串行数据通信方式，每一个数据帧都会以
1 个<code>起始位</code>开始，并且以 1
个<code>停止位</code>结束，其数据帧的基本格式如下面示意图所示：</p>
<p><img src="/Project/UINIO-MCU-GD32/10-USART/1.png"></p>
<ol type="1">
<li><strong>起始位</strong>：首先发送一个起始位，通常为逻辑低电平
<code>0</code>，用于通知接收端数据即将开始发送。</li>
<li><strong>数据位</strong>：紧接着是数据位，可以有 <code>5 ~ 8</code>
位长度，按照由 <strong>LSB</strong>（最低有效位）到
<strong>MSB</strong>（最高有效位）的顺序发送。</li>
<li><strong>校验位</strong>：数据位之后是可选的奇偶校验位，用于检查数据传输过程当中，是否存在错误。</li>
<li><strong>停止位</strong>：最后是停止位，通常为逻辑高电平
<code>1</code>，用于标记数据帧传输完毕。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<strong>空闲帧</strong>与停止位一样均为<strong>高电平</strong>，如果
USART
连接断开，则下拉为<strong>低电平</strong>，从而成为<strong>断开帧</strong>。</p>
</blockquote>
<p><strong>USART</strong>
串行接口可以工作在<strong>单工</strong>（单向通信）、<strong>半双工</strong>（双向分时通信）、<strong>全双工</strong>（双向通信）模式下。每个
USART 通信设备之间的 <strong>波特率</strong>（单位为
<code>bit/s</code>，即每秒钟传送的比特位数）、<strong>数据位</strong>、<strong>停止位</strong>、<strong>奇偶校验位</strong>
必须保持一致。</p>
<p><img src="/Project/UINIO-MCU-GD32/10-USART/2.png"></p>
<p>将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板与另一款 UINIO
系列开源硬件 <a target="_blank" rel="noopener" href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>
串口调试器</a> ，参照下图的线路相互进行连接（即
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOA9</code> 和
<code>GPIOA10</code> 分别连接至 <strong>UINIO-USB-UART</strong>
串口调试器的 <code>RXD</code> 和 <code>TXD</code> 引脚），并且将后者的
Type-C 接口通过 USB 线缆连接至计算机，从而建立起与串行通信上位机软件的
USART 连接，进而可以查看到后续实验代码所打印出的测试数据。</p>
<h2 id="完整-keil-µvision-工程代码-4">完整 Keil µVision 工程代码</h2>
<p>使用 <strong>GD32F350RBT6</strong> 的片上 USART
外设进行通信，需要经历下面六个步骤：</p>
<ol type="1">
<li>使能 USART 和 GPIO 外设时钟
<code>rcu_periph_clock_enable()</code>。</li>
<li>配置 GPIO 复用模式 <code>gpio_af_set()</code>。</li>
<li>配置 GPIO 的工作模式 <code>gpio_mode_set()</code>。</li>
<li>配置 GPIO 的输出模式与速度
<code>gpio_output_options_set</code>。</li>
<li>复位 USART 外设 <code>usart_deinit()</code>，并且配置其工作参数
<code>usart_deinit()</code>、<code>usart_baudrate_set()</code>、<code>usart_parity_config()</code>、<code>usart_word_length_set()</code>、<code>usart_stop_bit_set()</code>。</li>
<li>使能 USART 串口 <code>usart_enable()</code> 及其发送功能
<code>usart_transmit_config()</code>。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目
<code>Examples</code> 目录下的 <strong>6-USART</strong> 工程当中。</p>
</blockquote>
<h3 id="driversusart.h">Drivers/USART.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART USART0             <span class="comment">// 定义 USART 外设资源</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RCU RCU_USART0     <span class="comment">// 定义 USART0 的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_AF GPIO_AF_1       <span class="comment">// 定义 GPIO 引脚的复用功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 外设时钟 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_RCU RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_RCU RCU_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 接口*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_PORT GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义 TX 和 RX 对应的 GPIO 引脚*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_TX_PIN GPIO_PIN_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_USART_RX_PIN GPIO_PIN_10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_GPIO_Config</span><span class="params">(<span class="type">uint32_t</span> band_rate)</span>; <span class="comment">// USART 外设资源配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_Data</span><span class="params">(<span class="type">char</span> ucch)</span>;            <span class="comment">// 用于发送 1 个字节的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_String</span><span class="params">(<span class="type">char</span> *ucstr)</span>;        <span class="comment">// 用于发送字符串的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_USART_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driversusart.c">Drivers/USART.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置 USART 相关的 GPIO，参数 band_rate 是波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_GPIO_Config</span><span class="params">(<span class="type">uint32_t</span> band_rate)</span> &#123;</span><br><span class="line">  <span class="comment">/* 开启时钟 */</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_TX_RCU); <span class="comment">// 使能 TX 对应 GPIO 引脚的时钟</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_RX_RCU); <span class="comment">// 使能 RX 对应 GPIO 引脚的时钟</span></span><br><span class="line">  rcu_periph_clock_enable(UINIO_USART_RCU);    <span class="comment">// 使能 USART 外设时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 GPIO 引脚的复用功能 */</span></span><br><span class="line">  gpio_af_set(UINIO_USART_TX_PORT, UINIO_USART_AF, UINIO_USART_TX_PIN);</span><br><span class="line">  gpio_af_set(UINIO_USART_RX_PORT, UINIO_USART_AF, UINIO_USART_RX_PIN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 TX 和 RX 对应 GPIO 引脚的模式与速度 */</span></span><br><span class="line">  gpio_mode_set(UINIO_USART_TX_PORT, GPIO_MODE_AF, GPIO_PUPD_PULLUP, UINIO_USART_TX_PIN);             <span class="comment">// 配置 TX 引脚为带上拉电阻的复用模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_USART_TX_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_USART_TX_PIN); <span class="comment">// 配置 TX 引脚为推挽输出，速率为 50MHZ</span></span><br><span class="line">  gpio_mode_set(UINIO_USART_RX_PORT, GPIO_MODE_AF, GPIO_PUPD_PULLUP, UINIO_USART_RX_PIN);             <span class="comment">// 配置 RX 引脚为带上拉电阻的复用模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_USART_RX_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_USART_RX_PIN); <span class="comment">// 配置 RX 引脚为推挽输出，速率为 50MHZ</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 USART 串行通信的参数 */</span></span><br><span class="line">  usart_deinit(UINIO_USART);                         <span class="comment">// 复位 USART 外设</span></span><br><span class="line">  usart_baudrate_set(UINIO_USART, band_rate);        <span class="comment">// 设置 USART 波特率</span></span><br><span class="line">  usart_parity_config(UINIO_USART, USART_PM_NONE);   <span class="comment">// 设置 USART 奇偶校验位</span></span><br><span class="line">  usart_word_length_set(UINIO_USART, USART_WL_8BIT); <span class="comment">// 设置 USART 数据位长度为 8 位</span></span><br><span class="line">  usart_stop_bit_set(UINIO_USART, USART_STB_1BIT);   <span class="comment">// 设置 USART 停止位长度为 1 位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使能和配置 USART串口 */</span></span><br><span class="line">  usart_transmit_config(UINIO_USART, USART_TRANSMIT_ENABLE); <span class="comment">// 使能 USART 发送功能</span></span><br><span class="line">  usart_enable(UINIO_USART);                                 <span class="comment">// 使能 USART 串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 USART 发送一个字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_Data</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">  usart_data_transmit(UINIO_USART, (<span class="type">uint8_t</span>)data);              <span class="comment">// 通过 USART 发送数据</span></span><br><span class="line">  <span class="keyword">while</span> (RESET == usart_flag_get(UINIO_USART, USART_FLAG_TBE)); <span class="comment">// 通过发送数据缓冲区空标志位来判断发送是否完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 USART 发送字符串 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_USART_Send_String</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 开始循环发送，当字符串为空或者指针地址为空时跳出 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">string</span> &amp;&amp; *<span class="built_in">string</span>) &#123;</span><br><span class="line">    UINIO_USART_Send_Data(*<span class="built_in">string</span>++);  <span class="comment">// 调用上面的函数，循环发送单个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过重写 C 语言 printf() 不断循环调用的 fputc() 函数，实现串口数据输出的重定向 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span> &#123;</span><br><span class="line">  UINIO_USART_Send_Data(character);    <span class="comment">// 调用上面的函数，发送单个字符</span></span><br><span class="line">  <span class="keyword">return</span> character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-3">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 配置 USART0，并将波特率设置为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> count1 = <span class="number">0</span>;       <span class="comment">// 声明短整型测试变量 count1</span></span><br><span class="line">  <span class="type">float</span> count2 = <span class="number">0.0</span>;              <span class="comment">// 声明浮点型测试变量 count2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 依次发送单个字符 `H` `a` `n` `k` */</span></span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">    UINIO_USART_Send_Data(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    UINIO_USART_Send_String(<span class="string">&quot;UinIO.com\n&quot;</span>);                   <span class="comment">// 发送字符串 UinIO.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试 printf() 串口打印重定向 */</span></span><br><span class="line">    count1++;                                                 <span class="comment">// 短整型测试变量自增 1</span></span><br><span class="line">    count2 += <span class="number">1.0F</span>;                                           <span class="comment">// 浮点型测试变量自增 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count1 = %d, count2 = %.2f \n&quot;</span>, count1, count2);  <span class="comment">// 向 USART 串行接口打印格式化信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外部中断-exti">外部中断 EXTI</h1>
<h2 id="嵌套向量中断控制-nvic">嵌套向量中断控制 NVIC</h2>
<p><strong>GD32F350RBT6</strong> 微控制器所采用的 ARM Cortex-M4
内核架构集成有<strong>嵌套式矢量型中断控制器</strong>（NVIC，Nested
Vectored Interrupt Controller），主要用于管理和处理中断：</p>
<ol type="1">
<li><strong>中断管理</strong>：当中断源产生中断信号的时候，NVIC
就会捕获处理这些信号。</li>
<li><strong>优先级处理</strong>：通过对中断优先级进行排序，NVIC
会确保高优先级的中断首先得到处理。</li>
<li><strong>中断嵌套</strong>：如果在一个中断服务程序当中，发生了另外一个更高优先级的中断，NVIC
会暂停处理当前中断，转而处理更高优先级的中断。</li>
<li><strong>向量中断</strong>：每一个中断都关联有一个固定地址的中断服务程序，当中断发生时
NVIC 就会根据这个地址去执行相应的中断服务程序。</li>
<li><strong>中断屏蔽</strong>：NVIC
允许通过编程来屏蔽某些中断，以防止它们被处理，该功能在特定情况下非常有用，例如需要执行关键任务而不希望被其它中断事件打断的时候。</li>
<li><strong>低功耗模式支持</strong>：NVIC
与微控制器的低功耗模式紧密集成，休眠模式下 NVIC 可以检测外部中断并且唤醒
MCU，从而实现在低功耗状态下的快速响应。</li>
</ol>
<h2 id="外部中断事件控制器-exti">外部中断/事件控制器 EXTI</h2>
<p><strong>外部中断/事件控制器</strong>（EXTI，External Interrupt/Event
Controller）负责检测来自于中断源的中断请求，并且通知微控制器进行处理。其包含有
24
个相互独立的边沿检测电路（每个边沿检测电路都可以独立进行配置与屏蔽），能够在微控制器内核当中产生<strong>中断请求</strong>以及<strong>唤醒事件</strong>。每一个中断都拥有
4 位的<strong>中断优先级配置位</strong>，可以提供 16
个<strong>中断优先等级</strong>，并且这些中断都拥有着
<strong>上升沿</strong>、<strong>下降沿</strong>、<strong>任意边沿</strong>
三种触发方式：</p>
<p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/1.png"></p>
<ol type="1">
<li><strong>中断线配置</strong>：配置<strong>外部中断线</strong>（EXTI
Line），也就是 MCU
当中用于接收中断请求的<strong>物理线路</strong>。</li>
<li><strong>触发条件方式</strong>：设置中断的触发方式，即
<code>上升沿</code>、<code>下降沿</code>、<code>任意边沿</code>。</li>
<li><strong>中断优先级管理</strong>：分配不同的中断优先级，确保 MCU
能够按照预期的顺序与优先级处理中断请求。</li>
<li><strong>中断请求生成与处理</strong>：当外部事件满足中断触发条件时，生成一个中断请求发送给
<strong>NVIC</strong>（嵌套向量中断控制器），后者会根据中断的优先级来决定是否响应该中断，如果需要响应，就会暂停执行当前的程序，转而将控制权移交给指定的
<strong>ISR</strong>（中断服务程序，Interrupt Service Routine）。</li>
<li><strong>中断服务程序执行</strong>：在 ISR
中断服务程序当中，可以编写代码处理外部事件。待处理完毕之后，就会将控制权返还给刚才被中断的程序，从之前暂停的位置继续运行。</li>
</ol>
<p><strong>EXTI</strong> 中断的<strong>触发源</strong>可以来自于
<code>GPIOA/B/C/F (0~15)</code> 引脚，以及
<code>LVD</code>（低电压检测）、<code>RTC</code>（实时时钟）、<code>CEC</code>（HDMI
的 CEC
控制器）、<code>CMP</code>（比较器）、<code>USB</code>、<code>USART</code>
等片上外设：</p>
<p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/2.png"></p>
<blockquote>
<p><strong>注意</strong>：上述表格当中 <strong>EXTI
中断线</strong>与<strong>触发源</strong>的对应关系非常重要。</p>
</blockquote>
<p>接下来的实验里，首先需要将一枚轻触按键 <code>SW2</code> 连接到
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <strong>GPIOA0</strong>
引脚，其中一端连接至 <code>3V3</code>，而另外一端经过位号为
<code>R5</code> 的 <code>10KΩ</code> 下拉电阻之后连接至
<code>GND</code>。然后再把 <code>LED3</code> 的一端通过限流电阻
<code>R4</code> 连接至 <strong>GPIOB8</strong> 引脚，另外一端连接到
<code>GND</code> 引脚：</p>
<p><img src="/Project/UINIO-MCU-GD32/11-Interrupt/3.png"></p>
<p>最后，再将 <strong>UINIO-MCU-GD32F350RBT6</strong> 的
<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 分别连接至
<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和
<code>TXD</code> 引脚，以便于通过上位机软件观察 USART
串口输出的调试数据。</p>
<h2 id="完整-keil-µvision-工程代码-5">完整 Keil µVision 工程代码</h2>
<p>使用 <strong>GD32F350RBT6</strong> 微控制器的 EXTI
外部中断功能，通常需要经历下面一系列步骤：</p>
<ol type="1">
<li>通过 <code>rcu_periph_clock_enable()</code> 使能 GPIO 引脚和 CGFCMP
系统配置外设时钟。</li>
<li>调用 <code>nvic_priority_group_set()</code>
配置<strong>优先级分组</strong>。</li>
<li>调用 <code>nvic_irq_enable()</code> 使能 NVIC
中断，并且配置<strong>抢占优先级</strong>和<strong>响应优先级</strong>。</li>
<li>通过 <code>syscfg_exti_line_config()</code> 将中断线与 GPIO
引脚进行连接。</li>
<li>调用 <code>exti_init()</code>
设置<strong>中断线</strong>、<strong>中断模式</strong>、<strong>触发类型</strong>。</li>
<li>使能中断线 <code>exti_interrupt_enable()</code>，并且清除中断标志位
<code>exti_interrupt_flag_clear()</code>。</li>
<li>编写已经在 <code>startup_gd32f3x0.s</code>
启动文件当中定义好名称，且参数和返回值皆为 <code>void</code>
的<strong>中断服务函数</strong>（每次中断执行完毕之后都需要清除一下中断标志位）。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目
<code>Examples</code> 目录下的 <strong>7-EXTI-Key</strong>
工程当中。</p>
</blockquote>
<h3 id="driversexti-key.h">Drivers/EXTI-Key.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== EXTI-Key.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_EXTI_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_EXTI_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PORT GPIOA       <span class="comment">// 按键对应的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_PIN  GPIO_PIN_0  <span class="comment">// 按键对应的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_RCU  RCU_GPIOA   <span class="comment">// 按键对应 GPIO 端口的外设时钟</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_PORT_SOURCE EXTI_SOURCE_GPIOA   <span class="comment">// 定义用于 EXTI 的 GPIO 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_PIN_SOURCE  EXTI_SOURCE_PIN0    <span class="comment">// 定义用于 EXTI 的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_LINE        EXTI_0              <span class="comment">// 定义 EXTI 中断线 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_IRQN        EXTI0_1_IRQn        <span class="comment">// 定义 EXTI 线 0 和线 1 中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_KEY_EXTI_IRQ_Handler EXTI0_1_IRQHandler  <span class="comment">// 定义 EXTI 中断函数的名称</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_EXTI_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 按键中断配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_EXTI_KEY_H */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上述代码当中的<strong>中断线 0 和 1</strong>
的中断服务函数名称 <code>EXTI0_1_IRQHandler</code> 已经被定义在
<code>startup_gd32f3x0.s</code> 启动文件当中。</p>
</blockquote>
<h3 id="driversexti-key.c">Drivers/EXTI-Key.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== EXTI-Key.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../EXTI-Key/EXTI-Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按键中断配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_EXTI_Key_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_KEY_RCU);  <span class="comment">// 使能按键对应的 GPIO 外设时钟</span></span><br><span class="line">  rcu_periph_clock_enable(RCU_CFGCMP);     <span class="comment">// 使能 CGFCMP 系统配置外设时钟</span></span><br><span class="line"></span><br><span class="line">  gpio_mode_set(UINIO_KEY_PORT, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, UINIO_KEY_PIN);  <span class="comment">// 配置按键对应的 GPIO 引脚为带下拉电阻的输入模式，默认为低电平</span></span><br><span class="line">  nvic_irq_enable(UINIO_KEY_EXTI_IRQN, <span class="number">3U</span>, <span class="number">3U</span>);                                       <span class="comment">// 使能 NVIC 中断，抢占优先级 1，子优先级 1</span></span><br><span class="line"></span><br><span class="line">  syscfg_exti_line_config(UINIO_KEY_EXTI_PORT_SOURCE, UINIO_KEY_EXTI_PIN_SOURCE);  <span class="comment">// 配置 GPIO 引脚作为 EXTI 外部中断</span></span><br><span class="line">  exti_init(UINIO_KEY_EXTI_LINE, EXTI_INTERRUPT, EXTI_TRIG_BOTH);                  <span class="comment">// 初始化 EXTI 外部中断线</span></span><br><span class="line">  exti_interrupt_enable(UINIO_KEY_EXTI_LINE);                                      <span class="comment">// 使能 EXTI 外部中断</span></span><br><span class="line">  exti_interrupt_flag_clear(UINIO_KEY_EXTI_LINE);                                  <span class="comment">// 清除 EXTI 外部中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按键中断处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_KEY_EXTI_IRQ_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 如果中断标志位为 1，那么表示按键被按下 */</span></span><br><span class="line">  <span class="keyword">if</span> (exti_interrupt_flag_get(UINIO_KEY_EXTI_LINE) == SET) &#123;</span><br><span class="line">    <span class="comment">/* 当按键被按下时，执行的任务 */</span></span><br><span class="line">    <span class="keyword">if</span> (gpio_input_bit_get(UINIO_KEY_PORT, UINIO_KEY_PIN) == SET) &#123;</span><br><span class="line">      gpio_bit_toggle(UINIO_LED_PORT, UINIO_LED_PIN);  <span class="comment">// 翻转 LED 电平状态</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Key Press\n&quot;</span>);                           <span class="comment">// 串口打印 Key Press</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当按键被松开时，执行的任务 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Key Release\n&quot;</span>);                         <span class="comment">// 串口打印 Key Release</span></span><br><span class="line">    &#125;</span><br><span class="line">    exti_interrupt_flag_clear(UINIO_KEY_EXTI_LINE);    <span class="comment">// 清除 EXTI 外部中断标志位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-4">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/EXTI-Key/EXTI-Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 配置优先级分组（2 位用于抢占优先级，2 位用于响应优先级） */</span></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line"></span><br><span class="line">  UINIO_LED_GPIO_Config();         <span class="comment">// 初始化 LED 对应的 GPIO 引脚资源</span></span><br><span class="line">  UINIO_EXTI_Key_GPIO_Config();    <span class="comment">// 初始化按键所对应 GPIO 引脚的中断配置</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器-timer-概览">定时器 TIMER 概览</h1>
<p><strong>GD32F350RBT6</strong>
微控制器的定时器是一个可编程的无符号<strong>计数器</strong>，支持<code>输入捕获</code>与<code>输出比较</code>，可以按照功能特性被划分为六种类型：</p>
<ol type="1">
<li><strong>高级定时器</strong>（<code>TIMER0</code>）；</li>
<li><strong>通用定时器 L0</strong>（<code>TIMER1</code> 和
<code>TIMER2</code>）；</li>
<li><strong>通用定时器 L2</strong>（<code>TIMER13</code>）；</li>
<li><strong>通用定时器 L3</strong>（<code>TIMER14</code>）；</li>
<li><strong>通用定时器 L4</strong>（<code>TIMER15</code> 和
<code>TIMER16</code>）；</li>
<li><strong>基本定时器</strong>（<code>TIMER5</code>）；</li>
</ol>
<p>也就是 1 个 <strong>16
位高级定时器</strong>（<code>TIMER0</code>），1 个 <strong>32
位通用定时器</strong>（<code>TIMER1</code>），5 个 <strong>16
位通用定时器</strong>（<code>TIMER2</code>、<code>TIMER13 ~ TIMER16</code>），1
个 <strong>16 位基本定时器</strong>（<code>TIMER5</code>）。</p>
<h2 id="高级定时器-timer0">高级定时器 TIMER0</h2>
<p><strong>高级定时器（TIMER0）</strong>属于可编程的<strong>四通道定时器</strong>，包含有
<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生
PWM
信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">高级定时器 TIMER0 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>总通道数</strong></td>
<td style="text-align: left;"><strong>4 通道</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER0</code> 是 <strong>16
位</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟、内部触发、外部输入、外部触发</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>多种计数模式</strong></td>
<td style="text-align: left;">向上计数、向下计数、中央计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>正交编码器接口</strong></td>
<td style="text-align: left;">用于追踪运动和分辨旋转方向和位置</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>霍尔传感器接口</strong></td>
<td style="text-align: left;">可以用于控制三相电机</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>每个通道可配置</strong></td>
<td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM
模式、单脉冲模式</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的死区时间</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中止输入功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td>
<td style="text-align: left;">更新事件、触发事件、比较/捕获事件、换相事件、中止事件</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>多个定时器的菊链</strong></td>
<td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>定时器的同步</strong></td>
<td style="text-align: left;">允许被选择的定时器在同一个时钟周期开始计数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>定时器主-从管理</strong></td>
<td style="text-align: left;">支持</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>高级定时器（TIMER0）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/1.png"></p>
<h2 id="通用定时器-l0---timer1-timer2">通用定时器 L0 - TIMER1,
TIMER2</h2>
<p><strong>通用定时器 L0（TIMER1,
TIMER2）</strong>同样属于可编程的<strong>四通道定时器</strong>，包含有
<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生
PWM 信号控制电机以及进行电源管理，其主要特性如下表所示：</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">高级定时器 TIMER1, TIMER2 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>总通道数</strong></td>
<td style="text-align: left;"><strong>4 通道</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER2</code> 是 <strong>16
位</strong>，<code>TIMER1</code> 是 <strong>32 位</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟、内部触发、外部输入、外部触发</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>多种计数模式</strong></td>
<td style="text-align: left;">向上计数、向下计数、中央计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>正交编码器接口</strong></td>
<td style="text-align: left;">用于追踪运动和分辨旋转方向和位置</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>霍尔传感器接口</strong></td>
<td style="text-align: left;">可以用于控制三相电机</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>每个通道可配置</strong></td>
<td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM
模式、单脉冲模式</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td>
<td style="text-align: left;">更新事件、触发事件、比较/捕获事件</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>多个定时器的菊链</strong></td>
<td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>定时器的同步</strong></td>
<td style="text-align: left;">允许被选择的定时器在同一个时钟周期开始计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>定时器主-从管理</strong></td>
<td style="text-align: left;">支持</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>通用定时器 L0（TIMER1,
TIMER2）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/2.png"></p>
<h2 id="通用定时器-l2---timer13">通用定时器 L2 - TIMER13</h2>
<p><strong>通用定时器
L2（TIMER13）</strong>属于可编程的<strong>单通道定时器</strong>，包含有
<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生
PWM 信号控制电机以及进行电源管理，其主要特性如下表所示：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">高级定时器 TIMER13 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>总通道数</strong></td>
<td style="text-align: left;"><strong>1 通道</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER13</code> 是 <strong>16
位</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数模式</strong></td>
<td style="text-align: left;">向上计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>每个通道可配置</strong></td>
<td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM
模式</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中断输出</strong></td>
<td style="text-align: left;">更新事件、比较/捕获事件</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>通用定时器
L2（TIMER13）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/3.png"></p>
<h2 id="通用定时器-l3---timer14">通用定时器 L3 - TIMER14</h2>
<p><strong>通用定时器
L3（TIMER14）</strong>属于可编程的<strong>两通道定时器</strong>，包含有
<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生
PWM
信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">高级定时器 TIMER14 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>总通道数</strong></td>
<td style="text-align: left;"><strong>2 通道</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER14</code> 是 <strong>16
位</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟、内部触发、外部输入</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数模式</strong></td>
<td style="text-align: left;">向上计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>每个通道可配置</strong></td>
<td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM
模式、单脉冲模式</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的死区时间</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中止输入功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td>
<td style="text-align: left;">更新事件、比较/捕获事件、换相事件、中止事件</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>多个定时器的菊链</strong></td>
<td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>定时器的同步</strong></td>
<td style="text-align: left;">使得一个定时器，能够同时启动多个定时器</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>定时器主-从管理</strong></td>
<td style="text-align: left;">支持</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>通用定时器
L3（TIMER14）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/4.png"></p>
<h2 id="通用定时器-l4---timer15-timer16">通用定时器 L4 - TIMER15,
TIMER16</h2>
<p><strong>通用定时器 L4（TIMER15,
TIMER16）</strong>属于可编程的<strong>单通道定时器</strong>，包含有
<strong>16 位无符号计数器</strong>，支持输入捕获与输出比较。可以用于产生
PWM
信号控制电机（包含有死区时间插入模块）以及进行电源管理，其主要特性如下表所示：</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 64%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">高级定时器 TIMER15, TIMER16 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>总通道数</strong></td>
<td style="text-align: left;"><strong>单通道</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER15</code> 和
<code>TIMER16</code> 都是 <strong>16 位</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>计数模式</strong></td>
<td style="text-align: left;">向上计数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>每个通道可配置</strong></td>
<td style="text-align: left;">输入捕获模式、输出比较模式、可编程的 PWM
模式、单脉冲模式</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的死区时间</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>可编程的计数器重复功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中止输入功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td>
<td style="text-align: left;">更新事件、比较/捕获事件、换相事件、中止事件</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>通用定时器 L4（TIMER15,
TIMER16）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/5.png"></p>
<h2 id="基本定时器---timer5">基本定时器 - TIMER5</h2>
<p><strong>基本定时器（TIMER5）</strong>包含有 <strong>16
位无符号计数器</strong>，支持输入捕获与输出比较。可以用于通用定时器，产生
DMA 请求，以及为 DAC 数模转换提供时钟，其主要特性如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">基本定时器 TIMER5 特性</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>计数器宽度</strong></td>
<td style="text-align: left;"><code>TIMER5</code> 是 <strong>16
位</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>时钟源可选</strong></td>
<td style="text-align: left;">内部时钟</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>计数模式</strong></td>
<td style="text-align: left;">向上计数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>可编程的预分频器</strong></td>
<td style="text-align: left;">16 位（运行时可以被改变）</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>自动重装载功能</strong></td>
<td style="text-align: left;">支持</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>中断输出和 DMA 请求</strong></td>
<td style="text-align: left;">更新事件</td>
</tr>
</tbody>
</table>
<p>下面的结构框图提供了<strong>基本定时器（TIMER5）</strong>的内部配置细节：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/6.png"></p>
<h1 id="基本定时器-timer5-与中断">基本定时器 TIMER5 与中断</h1>
<p>本章节内容，将会利用<strong>基本定时器</strong> <code>TIMER5</code>
以及其关联的定时器中断，来实现让 LED 每隔 1
秒不间断进行闪烁的实验。其中，定时器<strong>时钟</strong>和<strong>运行参数</strong>的配置，是两个比较重要的知识点，需要大家在实验过程当中特别留意。</p>
<h2 id="定时器时钟配置">定时器时钟配置</h2>
<p>观察下面定时器相关的<strong>时钟树</strong>，可以发现如果 <strong>APB
总线</strong>的时钟<strong>分频系数</strong>为
<code>1</code>，那么<strong>定时器时钟频率</strong>就会与 <strong>AHB
总线</strong>保持一致。否则，定时器的时钟频率会被设定为 <strong>APB
总线</strong>频率的 <strong>2 倍</strong>：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/7.png"></p>
<p>可以看到，<strong>系统时钟</strong> <code>CK_SYS</code> 在经过
<strong>AHB 预分频器</strong>之后，可以得到 AHB 总线时钟
<code>CK_AHB</code>。而这个 <code>CK_AHB</code> 再经过 <strong>APB1 和
APB2 预分频器</strong>之后，就可以得到<strong>定时器时钟</strong>
<code>CK_TIMERx</code>，具体请参考下面的计算公式：</p>
<p><span class="math display">\[
CK_{TIMERx} = \frac{CK_{AHB}}{APB_{x预分频值} \div 2}
\]</span></p>
<p>由于固件库 <code>system_gd32f3x0.c</code> 源文件的
<code>system_clock_config()</code> 函数当中，已经将
<strong>APB1</strong> 和 <strong>APB2</strong> 的预分频值设定为
<code>2</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* APB2 = AHB/2 */</span></span><br><span class="line">RCU_CFG0 |= RCU_APB2_CKAHB_DIV2;</span><br><span class="line"><span class="comment">/* APB1 = AHB/2 */</span></span><br><span class="line">RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;</span><br></pre></td></tr></table></figure>
<p>根据上面的计算公式，就可以知道<strong>定时器时钟</strong>
<code>CK_TIMERx</code> 与 <strong>AHB 总线时钟</strong>
<code>CK_AHB</code> 的时钟频率值相等：</p>
<p><span class="math display">\[
CK_{TIMERx} = \frac{CK_{AHB}}{2 \div 2} = CK_{AHB} = 108MHz
\]</span></p>
<h2 id="定时器工作参数配置">定时器工作参数配置</h2>
<p>官方固件库 <code>gd32f3x0_timer.h</code> 头文件当中定义的结构体变量
<code>timer_parameter_struct</code>，可以用于配置定时器的相关工作参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constants definitions */</span></span><br><span class="line"><span class="comment">/* TIMER init parameter struct definitions*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> prescaler;         <span class="comment">/*!&lt; prescaler value */</span></span><br><span class="line">    <span class="type">uint16_t</span> alignedmode;       <span class="comment">/*!&lt; aligned mode */</span></span><br><span class="line">    <span class="type">uint16_t</span> counterdirection;  <span class="comment">/*!&lt; counter direction */</span></span><br><span class="line">    <span class="type">uint16_t</span> clockdivision;     <span class="comment">/*!&lt; clock division value */</span></span><br><span class="line">    <span class="type">uint32_t</span> period;            <span class="comment">/*!&lt; period value */</span></span><br><span class="line">    <span class="type">uint8_t</span>  repetitioncounter; <span class="comment">/*!&lt; the counter repetition value */</span></span><br><span class="line">&#125; timer_parameter_struct;</span><br></pre></td></tr></table></figure>
<p>在下面的列表里，展示了这些参数的具体功能与用途：</p>
<ul>
<li><strong>prescaler</strong>：时钟的 16 位 预分频值，取值范围为
<code>0 ~ 65535</code>。</li>
<li><strong>alignedmode</strong>：对齐模式，可供选取的值有
<code>TIMER_COUNTER_EDGE</code>、<code>TIMER_COUNTER_CENTER_DOWN</code>、<code>TIMER_COUNTER_CENTER_UP</code>、<code>TIMER_COUNTER_CENTER_BOTH</code>。</li>
<li><strong>counterdirection</strong>：计数方向，可供选取的值有
<code>TIMER_COUNTER_UP</code> 和 <code>TIMER_COUNTER_DOWN</code>。</li>
<li><strong>period</strong>：周期，取值范围为
<code>0 ~ 65535</code>，当计数器达到周期值的时候，计数值将会清零，可以配合计数器时钟频率计算出中断时间。</li>
<li><strong>clockdivision</strong>：时钟分频因子，可供选取的值有
<code>TIMER_CKDIV_DIV1</code>、<code>TIMER_CKDIV_DIV2</code>、<code>TIMER_CKDIV_DIV4</code>，主要用于输入捕获场景。</li>
<li><strong>repetitioncounter</strong>：重复计数器值（仅限于高级定时器），取值范围为
<code>0 ~ 255</code>。</li>
</ul>
<h2 id="实验电路的搭建">实验电路的搭建</h2>
<p>类似于前面 <a href="#通过-gpio-寄存器控制-led">《通过 GPIO 固件库控制
LED》</a> 章节的实验电路，这里同样将 <code>4.7K</code> 限流电阻
<code>R1</code> 与 LED 发光二极管串联之后，再连接到
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOB8</code>
引脚（高电平点亮，低电平熄灭）：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/8.png"></p>
<p>除此之外，还需要再将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 引脚，分别连接至
<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和
<code>TXD</code> 引脚，这样就可以完成实验电路的搭建。</p>
<h2 id="完整-keil-µvision-工程代码-6">完整 Keil µVision 工程代码</h2>
<p>本节内容的实验，主要基于 16 位的<strong>基本定时器</strong>
<code>TIMER5</code> 来实现 LED 每间隔 1
秒进行闪烁的效果，完成该功能大致需要经历下面六个步骤：</p>
<ol type="1">
<li><strong>配置定时器时钟</strong>，由于固件库已经默认
<code>CK_TIMERx = CK_AHB = 108MHz</code>，所以本示例缺省该步骤。</li>
<li><strong>配置并且初始化定时器</strong>，也就是设置
<code>timer_parameter_struct</code> 结构体的成员属性，然后调用
<code>timer_init()</code> 初始化定时器。</li>
<li>调用 <code>nvic_irq_enable()</code> 设置定时器中断的优先级。</li>
<li>调用 <code>timer_interrupt_enable()</code>
使能定时器<strong>更新中断</strong>事件。</li>
<li>调用 <code>timer_enable()</code> 函数使能定时器自身。</li>
<li>自定义<strong>基本定时器 TIMER5</strong> 相关的中断服务函数
<code>TIMER5_DAC_IRQHandler()</code>，该函数名称已在启动文件
<code>startup_gd32f3x0.s</code> 进行过声明。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：本节内容所涉及的全部测试代码，已保存在
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板开源项目
<code>Examples</code> 目录下的 <strong>8-Timer-LED</strong>
工程当中。</p>
</blockquote>
<h3 id="driverstimer-led.h">Drivers/Timer-LED.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== TIMER_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_TIMER_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_RCU         RCU_TIMER5             <span class="comment">// 定时器 Timer5 时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER             TIMER5                 <span class="comment">// 定时器 Timer5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_IRQ         TIMER5_DAC_IRQn        <span class="comment">// 定时器 Timer5 中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_TIMER_IRQ_Handler TIMER5_DAC_IRQHandler  <span class="comment">// 定时器 Timer5 中断服务函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_RCU         RCU_TIMER2           // 定时器 Timer2 时钟</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER             TIMER2               // 定时器 Timer2</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_IRQ         TIMER2_IRQn          // 定时器 Timer2 中断</span></span><br><span class="line"><span class="comment">// #define UINIO_TIMER_IRQ_Handler TIMER2_IRQHandler    // 定时器 Timer2 中断服务函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Basic_Timer_Config</span><span class="params">(<span class="type">uint16_t</span> pre, <span class="type">uint16_t</span> per)</span>; <span class="comment">// 基本定时器配置函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_TIMER_LED_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driverstimer-led.c">Drivers/Timer-LED.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== TIMER_LED.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Timer-LED/Timer-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 基本定时器配置，参数 UINIO_Clock_Prescale 为时钟预分频值，参数 UINIO_Clock_Period 为时钟周期 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_Basic_Timer_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_TIMER_RCU); <span class="comment">// 使能定时器外设时钟</span></span><br><span class="line">  <span class="comment">/* CK_TIMERx = CK_AHB = 108MHz */</span></span><br><span class="line">  timer_deinit(UINIO_TIMER);                <span class="comment">// 复位定时器外设</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置定时器参数 */</span></span><br><span class="line">  timer_parameter_struct TimerParameter;                <span class="comment">// 定义 timer_parameter_struct 定时器参数结构体</span></span><br><span class="line">  TimerParameter.prescaler = UINIO_Clock_Prescale - <span class="number">1</span>;  <span class="comment">// 预分频值，由于该值从 0 开始计数，所以这里需要减去 1</span></span><br><span class="line">  TimerParameter.alignedmode = TIMER_COUNTER_EDGE;      <span class="comment">// 对齐模式，边缘对齐</span></span><br><span class="line">  TimerParameter.counterdirection = TIMER_COUNTER_UP;   <span class="comment">// 计数方向，向上计数</span></span><br><span class="line">  TimerParameter.period = UINIO_Clock_Period - <span class="number">1</span>;       <span class="comment">// 周期，同样由于该值从 0 开始计数，这里同样需要减去 1</span></span><br><span class="line">  TimerParameter.clockdivision = TIMER_CKDIV_DIV1;      <span class="comment">// 时钟分频因子</span></span><br><span class="line">  TimerParameter.repetitioncounter = <span class="number">0</span>;                 <span class="comment">// 重复计数器值，取值范围为 0 ~ 255，配置为 x 就会重复 x+1 次进入中断</span></span><br><span class="line">  timer_init(UINIO_TIMER, &amp;TimerParameter);             <span class="comment">// 初始化定时器</span></span><br><span class="line"></span><br><span class="line">  nvic_irq_enable(UINIO_TIMER_IRQ, <span class="number">3U</span>, <span class="number">3U</span>);             <span class="comment">// 配置定时器中断优先级，抢占优先级 3，子优先级 2</span></span><br><span class="line"></span><br><span class="line">  timer_interrupt_enable(UINIO_TIMER, TIMER_INT_UP);    <span class="comment">// 使能定时器更新中断</span></span><br><span class="line">  timer_enable(UINIO_TIMER);                            <span class="comment">// 使能定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 基本定时器中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_TIMER_IRQ_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断定时器中断标志位 TIMER_INT_FLAG_UP 是否置位 */</span></span><br><span class="line">  <span class="keyword">if</span> (timer_interrupt_flag_get(UINIO_TIMER, TIMER_INT_FLAG_UP) == SET) &#123;</span><br><span class="line">    timer_interrupt_flag_clear(UINIO_TIMER, TIMER_INT_FLAG_UP);  <span class="comment">// 清除定时器更新中断标志位</span></span><br><span class="line">    gpio_bit_toggle(UINIO_LED_Port, UINIO_LED_Pin);              <span class="comment">// 翻转 LED 对应 GPIO 引脚的电平状态</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UinIO.com\n&quot;</span>);                                       <span class="comment">// 串口打印调试信息 UinIO.com</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-5">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/Timer-LED/Timer-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 配置优先级分组（2 位用于抢占优先级，2 位用于响应优先级） */</span></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line"></span><br><span class="line">  UINIO_LED_GPIO_Config();         <span class="comment">// 初始化 LED 对应的 GPIO 引脚资源</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);  <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 频率(10800/108)兆赫兹 * 周期(10000)微秒 = 闪烁间隔为 1 秒 */</span></span><br><span class="line">  UINIO_Basic_Timer_Config(<span class="number">10800</span>, <span class="number">10000</span>);    <span class="comment">// 初始化基本定时器，第 1 个参数为时钟预分频值，第 2 个参数为时钟周期</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通用定时器-timer1-与-pwm">通用定时器 TIMER1 与 PWM</h1>
<h2 id="脉冲宽度调制-pwm-简介">脉冲宽度调制 PWM 简介</h2>
<p><strong>脉冲宽度调制</strong>（<strong>PWM</strong>，Pulse-width
modulation）是一种通过将电平信号分散为离散形式，从而达到调整<strong>电压</strong>和<strong>频率</strong>，乃至于<strong>平均功率</strong>的目的。</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/9.png"></p>
<p>这项技术可以用于动态控制 LED
亮度乃至于电机转速，其主要涉及到如下三个重要的参数：</p>
<ol type="1">
<li><strong>频率</strong>（Frequency）：单位时间内周期性事件的重复次数，即
PWM 在 1 秒钟之内，脉冲信号完整<strong>周期</strong>的出现次数，其值等于
<span class="math inline">\(频率 f = \frac{1}{周期
T}\)</span>，单位为<strong>赫兹</strong>。</li>
<li><strong>周期</strong>（Period）：一个完整信号<strong>周期</strong>所持续的时间，其值等于
<span class="math inline">\(周期 T = \frac{1}{频率
f}\)</span>，单位为<strong>秒</strong>。</li>
<li><strong>占空比</strong>（Duty
Cycle）：在一个完整的脉冲信号<strong>周期</strong>当中，<strong>高电平</strong>所占据的百分比值。</li>
</ol>
<h2 id="定时器-timer1-的-pwm-通道">定时器 TIMER1 的 PWM 通道</h2>
<p><strong>GD32F350RBT6</strong> 微控制器的 <code>TIMER1</code> 是一个
<strong>通用定时器</strong>，拥有四路 PWM 通道，其中的每一路通道都对应着
1 个 GPIO 引脚（需要进行复用设置）。通过下面的表格，可以发现
<code>GPIOA5</code> 引脚的复用功能 <code>AF2</code>，对应的就是
<code>TIMER1</code> 定时器的 <code>CH0</code> 通道：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/10.png"></p>
<blockquote>
<p><strong>注意</strong>：GPIO 的复用功能可以通过固件库函数
<code>void gpio_af_set(uint32_t gpio_periph, uint32_t alt_func_num, uint32_t pin)</code>
进行设置。</p>
</blockquote>
<h2 id="pwm-脉冲频率的计算">PWM 脉冲频率的计算</h2>
<p>根据下面<strong>通用定时器</strong> <code>TIMER1</code>
的结构框图，可以观察到该定时器各个通道时钟信号的来龙去脉。其中带有层叠效果的框图，表示其对应有<strong>影子寄存器</strong>：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/11.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>影子寄存器</strong>可以让指令重复使用相同的寄存器编码，但是在不同模式下，这些编码对应的是不同的物理寄存器。</p>
</blockquote>
<p>相比于之前基本定时器的实验，本实验需要将定时器配置函数
<code>UINIO_PWM_Config()</code> 的时钟分频值修改为
<code>108</code>，从而使得分频后的定时器时钟频率等于：</p>
<p><span class="math display">\[
分频后的时钟频率 PSC_{CLK} = \frac{定时器时钟频率 108MHz}{预分频值108} =
1MHz
\]</span></p>
<p>再根据下面的公式，就可以计算得到此时 PWM 脉冲宽度调制信号的输出频率为
<code>100Hz</code>：</p>
<p><span class="math display">\[
PWM 输出频率 = \frac{分频后的时钟频率 1MHz}{周期值 10000 微秒} = 100Hz
\]</span></p>
<blockquote>
<p><strong>注意</strong>：该脉冲频率远高于肉眼可以鉴别出的
<code>50Hz</code> <strong>临界闪烁频率</strong>，所以不会导致 LED
发生明显的闪烁现象，可以呈现出比较完美的呼吸灯效果。</p>
</blockquote>
<h2 id="实验电路的搭建-1">实验电路的搭建</h2>
<p>类似于之前 <a href="#基本定时器-timer5-与中断">《基本定时器 TIMER5
与中断》</a> 章节的实验电路，这里同样需要将 <code>4.7K</code> 限流电阻
<code>R1</code> 与 LED
发光二极管进行串联，有所不同之处在于这里需要将其连接至
<strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的 <code>GPIOA5</code>
引脚，然后由<strong>通用定时器</strong> <code>TIMER1</code> 的通道
<code>0</code> 输出 PWM 脉冲信号：</p>
<p><img src="/Project/UINIO-MCU-GD32/12-Timer/12.png"></p>
<p>除此之外，依然需要把 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<strong>GPIOA9</strong> 和 <strong>GPIOA10</strong> 引脚，分别连接至
<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和
<code>TXD</code> 引脚，从而能够使用串口上位机软件，查看到当前 LED
的亮灭状态调试信息。</p>
<h2 id="完整-keil-µvision-工程代码-7">完整 Keil µVision 工程代码</h2>
<p>本实验通过 PWM 输出脉冲波来实现 LED
的呼吸灯效果，大致上需要经历如下一系列的配置过程：</p>
<ol type="1">
<li>调用 <code>gpio_af_set()</code> 配置 PWM 功能对应 GPIO
引脚的复用功能。</li>
<li>使用 <code>timer_init()</code> 配置 PWM 定时器参数。</li>
<li>使用 <code>timer_channel_output_config()</code> 配置 PWM
输出通道参数。</li>
<li>通过 <code>timer_channel_output_pulse_value_config()</code>
函数将定时器 <code>TIMER1</code> 通道输出的脉冲值置为
<code>0</code>。</li>
<li>使用 <code>timer_channel_output_mode_config()</code>
配置定时器输出通道的比较模式为 PWM 模式 0。</li>
<li>使用 <code>timer_channel_output_shadow_config()</code>
失能定时器输出通道的<strong>比较影子寄存器</strong>。</li>
<li>调用 <code>timer_auto_reload_shadow_enable()</code>
使能定时器<strong>自动重载影子寄存器</strong>。</li>
<li>调用 <code>timer_enable()</code> 使能 PWM 相关的定时器。</li>
<li>循环调用 <code>timer_channel_output_pulse_value_config()</code>
函数，通过动态设定脉冲值（介于 <code>0 ~ 65535</code> 范围）实现 LED
的呼吸灯效果。</li>
</ol>
<h3 id="driverspwm-led.h">Drivers/PWM-LED.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== PWM_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_PWM_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_RCU  RCU_GPIOA   <span class="comment">// 定义 PWM 对应 GPIOA 端口的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_PORT GPIOA       <span class="comment">// 定义 PWM 对应的 GPIOA 端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_PIN  GPIO_PIN_5  <span class="comment">// 定义 PWM 对应的 GPIO 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_AF   GPIO_AF_2   <span class="comment">// 定义 PWM 对应 GPIO 引脚的复用功能 2</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_TIMER_RCU RCU_TIMER1  <span class="comment">// 定义通用定时器 TIMER1 的外设时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_TIMER     TIMER1      <span class="comment">// 定义通用定时器 TIMER1 自身</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_PWM_CHANNEL   TIMER_CH_0  <span class="comment">// 定义定时器的通道 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span>; <span class="comment">// 预定义 PWM 工作参数配置函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_LED_Breathing</span><span class="params">(<span class="type">void</span>)</span>;                                                <span class="comment">// 预定义 PWM 呼吸灯控制函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_PWM_LED_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driverspwm-led.c">Drivers/PWM-LED.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== PWM_LED.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../PWM-LED/PWM-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置 PWM 功能对应的 GPIO 引脚 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UINIO_PWM_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(UINIO_PWM_RCU);                                                   <span class="comment">// 使能 PWM 对应 GPIO 引脚的外设时钟</span></span><br><span class="line">  gpio_mode_set(UINIO_PWM_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE, UINIO_PWM_PIN);               <span class="comment">// 配置 GPIO 引脚为悬空的复用功能模式</span></span><br><span class="line">  gpio_output_options_set(UINIO_PWM_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, UINIO_PWM_PIN); <span class="comment">// 设置 GPIO 引脚的输出模式（推挽输出）与速率（50MHz）</span></span><br><span class="line">  gpio_af_set(UINIO_PWM_PORT, UINIO_PWM_AF, UINIO_PWM_PIN);                                 <span class="comment">// 设置 GPIO 引脚的复用功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置脉冲宽度调制 PWM 的工作参数，参数 UINIO_Clock_Prescale 为时钟预分频值，参数 UINIO_Clock_Period 为时钟周期 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_Config</span><span class="params">(<span class="type">uint16_t</span> UINIO_Clock_Prescale, <span class="type">uint16_t</span> UINIO_Clock_Period)</span> &#123;</span><br><span class="line">  UINIO_PWM_GPIO_Config();  <span class="comment">// 调用前面已经定义的 PWM 对应 GPIO 引脚的配置函数</span></span><br><span class="line"></span><br><span class="line">  rcu_periph_clock_enable(UINIO_PWM_TIMER_RCU);  <span class="comment">// 使能定时器 TIMER1 外设时钟</span></span><br><span class="line">  <span class="comment">/* CK_TIMERx = CK_AHB = 108MHz */</span></span><br><span class="line">  timer_deinit(UINIO_PWM_TIMER);                 <span class="comment">// 复位定时器 TIMER1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 PWM 定时器参数 TimerParameter */</span></span><br><span class="line">  timer_parameter_struct TimerParameter;               <span class="comment">// 定义 timer_parameter_struct 定时器参数结构体</span></span><br><span class="line">  TimerParameter.prescaler = UINIO_Clock_Prescale - <span class="number">1</span>; <span class="comment">// 预分频值，由于该值从 0 开始计数，所以这里需要减去 1</span></span><br><span class="line">  TimerParameter.alignedmode = TIMER_COUNTER_EDGE;     <span class="comment">// 对齐模式，边缘对齐</span></span><br><span class="line">  TimerParameter.counterdirection = TIMER_COUNTER_UP;  <span class="comment">// 计数方向，向上计数</span></span><br><span class="line">  TimerParameter.period = UINIO_Clock_Period - <span class="number">1</span>;      <span class="comment">// 周期，同样由于该值从 0 开始计数，这里同样需要减去 1</span></span><br><span class="line">  TimerParameter.clockdivision = TIMER_CKDIV_DIV1;     <span class="comment">// 时钟分频因子</span></span><br><span class="line">  TimerParameter.repetitioncounter = <span class="number">0</span>;                <span class="comment">// 重复计数器值，取值范围为 0 ~ 255，配置为 x 就会重复 x+1 次进入中断</span></span><br><span class="line">  timer_init(UINIO_PWM_TIMER, &amp;TimerParameter);        <span class="comment">// 初始化 PWM 相关的定时器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 PWM 输出通道参数 TimerOutChannel */</span></span><br><span class="line">  timer_oc_parameter_struct TimerOutChannel;                                         <span class="comment">// 输出通道配置结构体 timer_oc_parameter_struct</span></span><br><span class="line">  TimerOutChannel.ocpolarity = TIMER_OC_POLARITY_HIGH;                               <span class="comment">// 设置通道输出极性为高电平有效</span></span><br><span class="line">  TimerOutChannel.outputstate = TIMER_CCX_ENABLE;                                    <span class="comment">// 使能通道输出功能</span></span><br><span class="line">  timer_channel_output_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, &amp;TimerOutChannel); <span class="comment">// 开始配置定时器通道的输出功能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置占空比 */</span></span><br><span class="line">  timer_channel_output_pulse_value_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, <span class="number">0</span>);                  <span class="comment">// 配置定时器输出通道的脉冲值</span></span><br><span class="line">  timer_channel_output_mode_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, TIMER_OC_MODE_PWM0);        <span class="comment">// 配置定时器输出通道的比较模式为 PWM 模式 0</span></span><br><span class="line">  timer_channel_output_shadow_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, TIMER_OC_SHADOW_DISABLE); <span class="comment">// 失能定时器输出通道的比较影子寄存器</span></span><br><span class="line"></span><br><span class="line">  timer_auto_reload_shadow_enable(UINIO_PWM_TIMER); <span class="comment">// 使能定时器自动重载影子寄存器</span></span><br><span class="line">  timer_enable(UINIO_PWM_TIMER);                    <span class="comment">// 使能 PWM 相关的定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** PWM 呼吸灯控制函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_PWM_LED_Breathing</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> Direct = <span class="number">0</span>; <span class="comment">// 亮暗调节方向</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Value = <span class="number">0</span>; <span class="comment">// 脉冲值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 逐渐变亮 */</span></span><br><span class="line">  <span class="keyword">if</span> (Direct == <span class="number">0</span>) &#123;</span><br><span class="line">    Value += <span class="number">500</span>; <span class="comment">// 该值越大 LED 越亮</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get brighter...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">      Direct = <span class="number">1</span>; <span class="comment">// 切换至渐暗模式</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Switch to dark...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 逐渐变暗 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Value -= <span class="number">500</span>; <span class="comment">// 该值越小 LED 越暗</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get darker...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      Direct = <span class="number">0</span>; <span class="comment">// 切换至渐亮模式</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Switch to bright...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timer_channel_output_pulse_value_config(UINIO_PWM_TIMER, UINIO_PWM_CHANNEL, Value); <span class="comment">// 配置定时器通道输出的脉冲值</span></span><br><span class="line">  delay_1ms(<span class="number">50</span>);                                                                      <span class="comment">// 系统滴答定时器延时 50 毫秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-6">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/LED/LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/PWM-LED/PWM-LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();</span><br><span class="line"></span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2); <span class="comment">// 优先级分组</span></span><br><span class="line"></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>); <span class="comment">// 初始化 USART 串口，设置波特率为 9600</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 频率(10800/108)兆赫兹 * 周期(10000)微秒 = 亮度调整间隔为 0.01 秒 */</span></span><br><span class="line">  UINIO_PWM_Config(<span class="number">108</span>, <span class="number">10000</span>);   <span class="comment">// PWM 初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    UINIO_PWM_LED_Breathing(); <span class="comment">// 调用 PWM 呼吸灯控制函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="直接存储器存取-dma-与中断">直接存储器存取 DMA 与中断</h1>
<h2 id="dma-功能简介">DMA 功能简介</h2>
<p><strong>直接存储器存取</strong>（DMA，Direct Memory
Access）主要运用在不占用<strong>内核计算资源</strong>的情况下，进行数据的传递（<code>外设 → 存储器</code>、<code>存储器 → 外设</code>、<code>存储器 → 存储器</code>）。<strong>GD32F350RBT6</strong>
只拥有一个 DMA 控制器，其拥有 <strong>7</strong>
个通道，每个通道都用于处理各个外设的存储器访问请求，这些外设包括有
<strong>ADC</strong>、<strong>SPI</strong>、<strong>I2C</strong>、<strong>USART</strong>、<strong>DAC</strong>、<strong>I2S</strong>
以及<strong>定时器</strong>。</p>
<p><img src="/Project/UINIO-MCU-GD32/13-DMA/1.png"></p>
<p>观察上面的 DMA 功能结构框图，可以发现 DMA
控制器主要由如下四个部分组成：</p>
<ol type="1">
<li>通过 AHB 总线<strong>从接口</strong>进行 DMA 配置。</li>
<li>通过 AHB 总线<strong>主接口</strong>进行数据传输。</li>
<li>由<strong>仲裁器</strong>（Arbiter）对 DMA
请求的优先级进行管理。</li>
<li>控制存储器或者外设的状态，并且管理计数器。</li>
</ol>
<h2 id="实验电路的搭建-2">实验电路的搭建</h2>
<p>本节内容的实验，需要通过 <strong>USART</strong> 输出 DMA
传输过来的数据信息，所以依然要把 <strong>UINIO-MCU-GD32F350RBT6</strong>
核心板与另外一款 UINIO 系列开源硬件 <a target="_blank" rel="noopener" href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>
串口调试器</a> ，参照下图的线路进行相互连接：</p>
<p><img src="/Project/UINIO-MCU-GD32/10-USART/2.png"></p>
<p>也就是把 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<code>GPIOA9</code> 和 <code>GPIOA10</code> 引脚，分别连接至
<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和
<code>TXD</code> 引脚，然后将后者的 Type-C 接口通过 USB
线缆连接到计算机，进而可以借助 <strong>COMTransmit</strong>
等串口调试助手软件，查看到 DMA 传输过来的各种数据和日志信息。</p>
<h2 id="完整-keil-µvision-工程代码-8">完整 Keil µVision 工程代码</h2>
<p>当使用 DMA
进行数据传输时，会首先从<strong>源地址</strong>读取数据，然后再将读取的数据存储到<strong>目的地址</strong>，使用时通常需要遵循如下步骤：</p>
<ol type="1">
<li>通过 <code>rcu_periph_clock_enable(RCU_DMA)</code> 使能 DMA
外设时钟。</li>
<li>配置 DMA 参数结构体 <code>dma_parameter_struct</code>。</li>
<li>初始化 DMA 通道 <code>dma_init()</code>。</li>
<li>调用 <code>dma_circulation_enable/disable()</code> 和
<code>dma_memory_to_memory_enable/disable()</code> 配置 DMA
相关模式。</li>
<li>执行 <code>dma_interrupt_enable()</code> 使能 DMA 中断。</li>
<li>执行 <code>dma_channel_enable()</code> 使能 DMA 通道本身。</li>
</ol>
<h3 id="sourcesgd32f3x0_it.c">Sources/gd32f3x0_it.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== gd32f3x0_it.c ==========*/</span></span><br><span class="line"><span class="comment">/* interrupt service routines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0_it.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FlagStatus UINIO_Transfer_Complete;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Channel1_2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 判断 DMA 通道传输是否已经完成，参数 DMA_INT_FLAG_FTF 是传输完成中断标志位 */</span></span><br><span class="line">  <span class="keyword">if</span>(dma_interrupt_flag_get(DMA_CH1, DMA_INT_FLAG_FTF)) &#123;</span><br><span class="line">    dma_interrupt_flag_clear(DMA_CH1, DMA_INT_FLAG_G); <span class="comment">// 清除 DMA 通道全局中断标志位状态</span></span><br><span class="line">    UINIO_Transfer_Complete = SET;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-7">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetArrayNumber(arr_nanme)  (uint32_t)(sizeof(arr_nanme) / sizeof(*(arr_nanme)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> UINIO_String[] = <span class="string">&quot;UinIO.com : Copy current string from RAM to USART by DMA.\n&quot;</span>; <span class="comment">// 需要通过 DMA 传输给 USART 的字符串</span></span><br><span class="line">__IO FlagStatus UINIO_Transfer_Complete = RESET;                                        <span class="comment">// 固件库中预定义的枚举类型变量，取值为 SET 或者 RESET</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>);             <span class="comment">// 调用 USART 串口配置函数</span></span><br><span class="line"></span><br><span class="line">  rcu_periph_clock_enable(RCU_DMA);           <span class="comment">// 使能 DMA 相关的外部时钟</span></span><br><span class="line">  nvic_irq_enable(DMA_Channel1_2_IRQn, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 配置 DMA 中断服务程序</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 DMA 通道 */</span></span><br><span class="line">  dma_deinit(DMA_CH1);</span><br><span class="line">  dma_parameter_struct DMA_Init_Struct;</span><br><span class="line">  DMA_Init_Struct.direction    = DMA_MEMORY_TO_PERIPHERAL;         <span class="comment">// 设置 DMA 通道数据传输方向为【读取存储器写入外设】</span></span><br><span class="line">  DMA_Init_Struct.memory_addr  = (<span class="type">uint32_t</span>)UINIO_String;           <span class="comment">// 设置存储器基地址为字符串首地址</span></span><br><span class="line">  DMA_Init_Struct.memory_inc   = DMA_MEMORY_INCREASE_ENABLE;       <span class="comment">// 配置外设地址生成算法模式为递增</span></span><br><span class="line">  DMA_Init_Struct.memory_width = DMA_MEMORY_WIDTH_8BIT;            <span class="comment">// 存储器数据传输宽度为 8 位（串口每次传送 1 个字节 8 位）</span></span><br><span class="line">  DMA_Init_Struct.number       = GetArrayNumber(UINIO_String);     <span class="comment">// 设置 DMA 通道数据传输量</span></span><br><span class="line">  DMA_Init_Struct.periph_addr  = (<span class="type">uint32_t</span>)(&amp;USART_TDATA(USART0)); <span class="comment">// 设置外设基地址</span></span><br><span class="line">  DMA_Init_Struct.periph_inc   = DMA_PERIPH_INCREASE_DISABLE;      <span class="comment">// 设置外设地址生成算法为固定地址模式</span></span><br><span class="line">  DMA_Init_Struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;        <span class="comment">// 外设数据传输宽度为 8 位</span></span><br><span class="line">  DMA_Init_Struct.priority     = DMA_PRIORITY_ULTRA_HIGH;          <span class="comment">// 配置 DMA 传输通道优先级为最高</span></span><br><span class="line">  dma_init(DMA_CH1, &amp;DMA_Init_Struct);                             <span class="comment">// 开始初始化 DMA 通道 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置 DMA 模式 */</span></span><br><span class="line">  dma_circulation_disable(DMA_CH1);      <span class="comment">// 禁用 DMA 循环模式</span></span><br><span class="line">  dma_memory_to_memory_disable(DMA_CH1); <span class="comment">// 禁用存储器到存储器的 DMA 传输</span></span><br><span class="line"></span><br><span class="line">  usart_dma_transmit_config(USART0, USART_DENT_ENABLE); <span class="comment">// 使能串口 USART0 的 DMA 发送功能</span></span><br><span class="line">  dma_interrupt_enable(DMA_CH1, DMA_INT_FTF);           <span class="comment">// 使能 DMA1 通道传输完成中断</span></span><br><span class="line">  dma_channel_enable(DMA_CH1);                          <span class="comment">// 使能 DMA1 通道本身</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待传输完成 */</span></span><br><span class="line">  <span class="keyword">while</span>(RESET == UINIO_Transfer_Complete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="adc-模数转换器外设">ADC 模数转换器外设</h1>
<h2 id="adc-外设简介">ADC 外设简介</h2>
<p><strong>GD32F350RBT6</strong> 微控制器集成有 12
位逐次逼近型<strong>模数转换器</strong>（<strong>ADC</strong>，Analog
Digital Converter），可以采集来自 <strong>16</strong>
个<strong>外部通道</strong>（即 MCU 引脚）、<strong>2</strong>
个<strong>内部通道</strong>，以及<strong>电池电压</strong>
<code>VBAT</code>
通道的模拟信号。采样转换完成之后，转换结果可以按照<strong>最低/最高</strong>有效位的对齐方式，保存在相应的数据寄存器当中。</p>
<p><img src="/Project/UINIO-MCU-GD32/14-ADC/1.png"></p>
<blockquote>
<p><strong>注意</strong>：<strong>逐次逼近型 ADC</strong>
通过产生一系列比较电压，逐次与输入的模拟电压信号进行比较，以一次一次逐步接近的方式，将模似信号转换成最接近的数字信号。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 22%">
<col style="width: 14%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ADC 内部输入信号</th>
<th style="text-align: left;">功能说明</th>
<th style="text-align: left;">ADC 输入引脚定义</th>
<th style="text-align: left;">功能说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(V_{SENSE}\)</span></td>
<td style="text-align: left;">内部温度传感器输出电压。</td>
<td style="text-align: left;"><span class="math inline">\(VDDA\)</span></td>
<td style="text-align: left;">模拟电源正等于 <span class="math inline">\(V_{DD}\)</span>，<span class="math inline">\(2.6V
\le VDDA \le 3.6V\)</span>。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(V_{REFINT}\)</span></td>
<td style="text-align: left;">内部参考输出电压。</td>
<td style="text-align: left;"><span class="math inline">\(VSSA\)</span></td>
<td style="text-align: left;">模拟电源负等于 <span class="math inline">\(V_{SS}\)</span>，通过<strong>磁珠</strong>单点接入
<code>GND</code>。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(V_{BAT} /
2\)</span></td>
<td style="text-align: left;">硬件输入电压除以二。</td>
<td style="text-align: left;"><span class="math inline">\(ADCx_IN
[15:0]\)</span></td>
<td style="text-align: left;">多达 16 路外部通道。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>UINIO-MCU-GD32F350RBT6</strong>
核心板的模拟电源负引脚 <code>VSSA</code>，使用了对于 <code>100Mhz</code>
高频杂散信号存在 <code>1KΩ</code>
阻抗的<strong>磁珠</strong>进行单点接地；</p>
</blockquote>
<h2 id="adc-采样通道与模式">ADC 采样通道与模式</h2>
<p><strong>GD32F350RBT6</strong> 微控制器上的这总共 <strong>19</strong>
条 ADC 采样通道，都支持如下几种运行模式：</p>
<ul>
<li><strong>单次转换模式</strong>：每进行 1 次 ADC 转换后，ADC
就会自动停止，并将结果保存在 ADC 数据寄存器当中。 <img src="/Project/UINIO-MCU-GD32/14-ADC/2.png"></li>
<li><strong>扫描模式</strong>：用于对多个输入通道进行依次采集，ADC
会根据配置的通道采集顺序，对多个通道依次进行采样转换。 <img src="/Project/UINIO-MCU-GD32/14-ADC/3.png"></li>
<li><strong>连续转换模式</strong>：当 ADC 完成 1
次转换之后，就会启动另外 1
次转换，周而复始，直至<code>外部触发</code>或者<code>软件触发</code>停止这个转换过程。
<img src="/Project/UINIO-MCU-GD32/14-ADC/4.png"></li>
<li><strong>间断模式</strong>：用于在<strong>注入通道</strong>（即在规则通道转换时，需要强行插入的通道）和<strong>常规通道</strong>之间进行切换，ADC
会优先转换注入通道，完成之后再自动切换到常规通道进行转换。 <img src="/Project/UINIO-MCU-GD32/14-ADC/5.png"></li>
</ul>
<p>ADC
采样的触发方式主要有<strong>外部触发</strong>和<strong>软件触发</strong>两种：</p>
<ul>
<li><strong>外部触发</strong>：在外部输入信号的<code>上升沿</code> 或者
<code>下降沿</code>，都可以触发<strong>规则组</strong>或者<strong>注入组</strong>的
ADC 转换。</li>
<li><strong>软件触发</strong>：由软件控制在固定的时间点进行 ADC
转换，通常用于采集精度要求较高的场景。</li>
</ul>
<h2 id="adc-性能参数">ADC 性能参数</h2>
<p>使用 ADC 模数转换器外设的时候，需要特别注意下面三个主要性能参数：</p>
<ol type="1">
<li><strong>分辨率</strong>：表示 ADC 转换器的输出精度，单位为
<code>bit</code> 位，分辨率越高，采样精度也就越高，但是 ADC
所花费的采样转换时间就会越长。</li>
<li><strong>采样率</strong>：表示 ADC
每秒对于模拟信号进行采样的次数，单位为赫兹 <code>Hz</code> 或者
<code>样本数量Sample / 秒S</code>。采样率高就表示 ADC
能够更快的将模拟信号转换为数字信号，从而更加准确的反映模拟信号的变化。</li>
<li><strong>采样范围</strong>：是指 ADC
可以采集到的模拟电压输入信号范围，通常位于<strong>参考电压</strong>
<span class="math inline">\(V_{REF}\)</span> 范围之内，即 <span class="math inline">\(0V \le ADC \le V_{REF}\)</span>。</li>
</ol>
<h2 id="实验电路的搭建-3">实验电路的搭建</h2>
<p>本节的实验会将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<strong>GPIOC1</strong> 作为 ADC 采样引脚，分别去获取
<code>TP1</code>（连接至 <code>3V3</code>）和 <code>TP2</code>（连接至
<code>GND</code>）两个测试点的电压数据，同时仍然将核心板与另外一款 UINIO
系列开源硬件 <a target="_blank" rel="noopener" href="https://gitee.com/uinika/UINIO-USB-UART"><strong>UINIO-USB-UART</strong>
串口调试器</a> ，参照下面的示意图相互进行连接：</p>
<p><img src="/Project/UINIO-MCU-GD32/14-ADC/6.png"></p>
<p>即 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<code>GPIOA9</code> 和 <code>GPIOA10</code> 引脚，分别连接至
<strong>UINIO-USB-UART</strong> 串口调试器的 <code>RXD</code> 和
<code>TXD</code> 引脚，然后将后者的 Type-C 接口通过 USB
线缆连接到计算机，从而借助串口调试助手软件 <strong>COMTransmit</strong>
查看 ADC 采集到的数据信息。</p>
<h2 id="完整-keil-µvision-工程代码-9">完整 Keil µVision 工程代码</h2>
<p>本实验通过将 <strong>UINIO-MCU-GD32F350RBT6</strong> 核心板的
<strong>GPIOC1</strong> 作为 ADC 采样引脚，分别去获取核心板上
<code>3V3</code> 和 <code>GND</code> 引脚的电压数据，并且通过 USART
串口将这些数据打印出来。实现这个功能，需要遵循如下一系列的步骤去配置 ADC
外设：</p>
<ol type="1">
<li>使用 <code>rcu_periph_clock_enable()</code> 使能 GPIO 和 ADC
外设时钟。</li>
<li>通过 <code>rcu_adc_clock_config()</code> 配置 ADC 时钟。</li>
<li>通过 <code>gpio_mode_set()</code> 配置 GPIO
引脚为模拟输入模式。</li>
<li>配置 ADC 的<strong>特殊功能</strong>
<code>adc_special_function_config()</code>、<strong>数据对齐方式</strong>
<code>adc_data_alignment_config()</code>、<strong>分辨率</strong>
<code>adc_resolution_config()</code>、<strong>通道长度</strong>
<code>adc_channel_length_config()</code>。</li>
<li>配置 ADC 通道的触发源
<code>adc_external_trigger_source_config()</code>。</li>
<li>使能 ADC
的触发方式是<strong>软件触发</strong>还是<strong>外部触发</strong>
<code>adc_external/software_trigger_config()</code>。</li>
<li>调用 <code>adc_enable()</code> 使能 <strong>ADC 外设</strong>以及
<code>adc_calibration_enable()</code> 使能<strong>校准功能</strong>
。</li>
<li>配置 ADC <strong>规则通道组</strong>或者<strong>插入通道组</strong>
<code>adc_regular/inserted_channel_config()</code>。</li>
<li>使能 ADC <strong>外部触发</strong>或者<strong>软件触发</strong>功能
<code>adc_external/software_trigger_enable()</code>。</li>
<li>持续判断<strong>通道组转换结束标志位</strong>
<code>ADC_FLAG_EOC</code>，然后再通过
<code>adc_regular_data_read()</code> 读取范围为 <code>0 ~ 4095</code> 的
ADC 采样数据。</li>
</ol>
<p>在上面的配置过程当中，<code>adc_data_alignment_config()</code>
函数所配置的<strong>数据对齐方式</strong>是指：</p>
<ul>
<li><strong>右对齐模式</strong>：ADC
采集到的数据被右对齐到最低位，不足的位数填充
<code>0</code>，该模式可以在不损失精度的前提下，获得更好的动态范围。</li>
<li><strong>左对齐模式</strong>：ADC
采集到的数据被左对齐到最高位，不足的位数填充
<code>0</code>，虽然该模式可以提高采样的分辨率，但是会降低动态范围。</li>
</ul>
<h3 id="driversadc.h">Drivers/ADC.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== ADC.h ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UINIO_ADC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINIO_ADC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_ADC_Config</span><span class="params">(<span class="type">void</span>)</span>;                         <span class="comment">// ADC 外设配置函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">UINIO_ADC_Value</span><span class="params">(<span class="type">uint8_t</span> ADC_CHANNEL_x)</span>; <span class="comment">// 获取指定 ADC 通道的采集值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UINIO_ADC_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="driversadc.c">Drivers/ADC.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== ADC.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ADC 外设配置函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UINIO_ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  rcu_periph_clock_enable(RCU_GPIOC);        <span class="comment">// 使能 GPIOC 外设时钟</span></span><br><span class="line">  rcu_periph_clock_enable(RCU_ADC);          <span class="comment">// 使能 ADC 外设时钟</span></span><br><span class="line">  rcu_adc_clock_config(RCU_ADCCK_APB2_DIV6); <span class="comment">// 选择 APB 总线频率的 6 分频作为 ADC 的时钟源</span></span><br><span class="line"></span><br><span class="line">  gpio_mode_set(GPIOC, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, GPIO_PIN_1); <span class="comment">// 配置 GPIOC1 为不带上下拉电阻的模拟输入模式</span></span><br><span class="line"></span><br><span class="line">  adc_special_function_config(ADC_SCAN_MODE, ENABLE); <span class="comment">// 使能 ADC 特殊功能的扫描模式</span></span><br><span class="line">  adc_data_alignment_config(ADC_DATAALIGN_RIGHT);     <span class="comment">// 配置 ADC 数据对齐方式为右对齐</span></span><br><span class="line">  adc_resolution_config(ADC_RESOLUTION_12B);          <span class="comment">// 配置 ADC 分辨率为 12 位</span></span><br><span class="line">  adc_channel_length_config(ADC_REGULAR_CHANNEL, <span class="number">1</span>);  <span class="comment">// 配置规则通道组的通道长度为 1</span></span><br><span class="line"></span><br><span class="line">  adc_external_trigger_source_config(ADC_REGULAR_CHANNEL, ADC_EXTTRIG_REGULAR_NONE); <span class="comment">// 配置规则通道组的外部触发源为软件触发（规则组）</span></span><br><span class="line">  adc_external_trigger_config(ADC_REGULAR_CHANNEL, ENABLE);                          <span class="comment">// 使能 ADC 外部触发</span></span><br><span class="line"></span><br><span class="line">  adc_enable();             <span class="comment">// 使能 ADC 外设</span></span><br><span class="line">  adc_calibration_enable(); <span class="comment">// 使能 ADC 校准</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取 ADC 的值，参数 ADC_CHANNEL_x 用于指定采集通道 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">UINIO_ADC_Value</span><span class="params">(<span class="type">uint8_t</span>  ADC_CHANNEL_x)</span> &#123;</span><br><span class="line">  adc_regular_channel_config(<span class="number">0U</span>, ADC_CHANNEL_x, ADC_SAMPLETIME_55POINT5); <span class="comment">// 配置 ADC 规则通道组，选择通道 0，并且指定采样时间为 1.5 个周期</span></span><br><span class="line">  adc_software_trigger_enable(ADC_REGULAR_CHANNEL);                       <span class="comment">// 使能 ADC 软件触发功能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据 ADC 状态标志位，等待 ADC 采样完成 */</span></span><br><span class="line">  <span class="keyword">while</span> ( adc_flag_get(ADC_FLAG_EOC) == RESET ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ADC_Value = adc_regular_data_read(); <span class="comment">// 读 ADC 规则组的采样数据</span></span><br><span class="line">  <span class="keyword">return</span> ADC_Value;                                 <span class="comment">// 返回 ADC 采样数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourcesmain.c-8">Sources/main.c</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*========== main.c ==========*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f3x0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/ADC/ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Drivers/USART/USART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  systick_config();               <span class="comment">// 初始化系统滴答定时器</span></span><br><span class="line">  UINIO_USART_GPIO_Config(<span class="number">9600U</span>); <span class="comment">// 配置 USART0，并将波特率设置为 9600</span></span><br><span class="line">  UINIO_ADC_Config();             <span class="comment">// 配置 ADC 外设</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> Voltage = <span class="number">0</span>;           <span class="comment">// ADC 采集到的原始值（0 ~ 4095）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    Voltage = UINIO_ADC_Value(ADC_CHANNEL_11);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过串口打印出实际电压值 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ADC_Value = %f\n&quot;</span>,(( Voltage / <span class="number">4095.0</span> ) * <span class="number">3.3</span>) ); <span class="comment">// 接入 3.3V 采集的 ADC 值为 4095，接入 GND 采集的 ADC 值为 0</span></span><br><span class="line"></span><br><span class="line">    delay_1ms(<span class="number">1000</span>); <span class="comment">// 延时 1 秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="i2c-集成电路总线">I2C 集成电路总线</h1>
<h1 id="spi-串行外设总线">SPI 串行外设总线</h1>
</div><div class="article-licensing box"><div class="licensing-title"><p>兆易创新 UINIO-MCU-GD32F350 固件库开发指南</p><p><a href="http://www.uinio.com/Project/UINIO-MCU-GD32/">http://www.uinio.com/Project/UINIO-MCU-GD32/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hank</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-07-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Electronics/Component/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">硬件电路设计当中 の 常用分立元器件选型</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Zen/Markdown/"><span class="level-item">一篇简明扼要的 Markdown 魔法速成教程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#准备-gd32-支持包-固件库"><span class="level-left"><span class="level-item">1</span><span class="level-item">准备 GD32 支持包 &amp; 固件库</span></span></a></li><li><a class="level is-mobile" href="#测试-uinio-mcu-gd32-核心板"><span class="level-left"><span class="level-item">2</span><span class="level-item">测试 UINIO-MCU-GD32 核心板</span></span></a></li><li><a class="level is-mobile" href="#搭建-keil-uvision5-自定义工程"><span class="level-left"><span class="level-item">3</span><span class="level-item">搭建 Keil uVision5
自定义工程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#新建目录与拷贝源文件"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">新建目录与拷贝源文件</span></span></a></li><li><a class="level is-mobile" href="#创建分组与添加源文件"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">创建分组与添加源文件</span></span></a></li><li><a class="level is-mobile" href="#移除-source-目录下的冗余代码"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">移除 Source 目录下的冗余代码</span></span></a></li><li><a class="level is-mobile" href="#配置编译器路径与选项"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">配置编译器路径与选项</span></span></a></li><li><a class="level is-mobile" href="#测试工程的编译下载"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">测试工程的编译下载</span></span></a></li><li><a class="level is-mobile" href="#让-keil-uvision5-支持中文注释"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">让 Keil uVision5
支持中文注释</span></span></a></li><li><a class="level is-mobile" href="#使用-astyle-格式化源代码"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">使用 AStyle 格式化源代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mcu-微控制器系统结构概览"><span class="level-left"><span class="level-item">4</span><span class="level-item">MCU 微控制器系统结构概览</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#芯片资源简介"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">芯片资源简介</span></span></a></li><li><a class="level is-mobile" href="#arm-cortex-m4-内核架构"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">ARM Cortex-M4 内核架构</span></span></a></li><li><a class="level is-mobile" href="#gd32f350rbt6-外设架构"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">GD32F350RBT6 外设架构</span></span></a></li><li><a class="level is-mobile" href="#地址空间映射"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">地址空间映射</span></span></a></li></ul></li><li><a class="level is-mobile" href="#操作寄存器-运用固件库"><span class="level-left"><span class="level-item">5</span><span class="level-item">操作寄存器 → 运用固件库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#操作寄存器"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">操作寄存器</span></span></a></li><li><a class="level is-mobile" href="#运用库函数"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">运用库函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#通过-gpio-寄存器控制-led"><span class="level-left"><span class="level-item">6</span><span class="level-item">通过 GPIO 寄存器控制 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#开启-gpio-的端口时钟"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">开启 GPIO 的端口时钟</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ahb-总线使能寄存器-rcu_ahben"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">AHB 总线使能寄存器 RCU_AHBEN</span></span></a></li></ul></li><li><a class="level is-mobile" href="#配置-gpio-的工作模式"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">配置 GPIO 的工作模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#配置端口控制寄存器-gpiob_ctl"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">配置端口控制寄存器 GPIOB_CTL</span></span></a></li><li><a class="level is-mobile" href="#配置端口上下拉寄存器-gpiob_pud"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">配置端口上下拉寄存器
GPIOB_PUD</span></span></a></li></ul></li><li><a class="level is-mobile" href="#配置-gpio-的输出类型"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">配置 GPIO 的输出类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#端口输出模式寄存器-gpiob_omode"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">端口输出模式寄存器
GPIOB_OMODE</span></span></a></li><li><a class="level is-mobile" href="#端口速度寄存器-gpiob_ospd"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">端口速度寄存器 GPIOB_OSPD</span></span></a></li></ul></li><li><a class="level is-mobile" href="#控制-gpio-的输出状态"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">控制 GPIO 的输出状态</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#端口输出控制寄存器-gpiob_octl"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">端口输出控制寄存器
GPIOB_OCTL</span></span></a></li><li><a class="level is-mobile" href="#端口位操作寄存器-gpiob_bop"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">端口位操作寄存器 GPIOB_BOP</span></span></a></li></ul></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driversled.h"><span class="level-left"><span class="level-item">6.5.1</span><span class="level-item">Drivers/LED.h</span></span></a></li><li><a class="level is-mobile" href="#driversled.c"><span class="level-left"><span class="level-item">6.5.2</span><span class="level-item">Drivers/LED.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c"><span class="level-left"><span class="level-item">6.5.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#通过-gpio-固件库控制-led"><span class="level-left"><span class="level-item">7</span><span class="level-item">通过 GPIO 固件库控制 LED</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使能-gpio-外设时钟"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">使能 GPIO 外设时钟</span></span></a></li><li><a class="level is-mobile" href="#配置-gpio-模式"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">配置 GPIO 模式</span></span></a></li><li><a class="level is-mobile" href="#配置-gpio-输出类型与速度"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">配置 GPIO 输出类型与速度</span></span></a></li><li><a class="level is-mobile" href="#指定-gpio-引脚电平状态"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">指定 GPIO 引脚电平状态</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-1"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driversled.h-1"><span class="level-left"><span class="level-item">7.5.1</span><span class="level-item">Drivers/LED.h</span></span></a></li><li><a class="level is-mobile" href="#driversled.c-1"><span class="level-left"><span class="level-item">7.5.2</span><span class="level-item">Drivers/LED.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-1"><span class="level-left"><span class="level-item">7.5.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#启动文件-startup_gd32f3x0.s-剖析"><span class="level-left"><span class="level-item">8</span><span class="level-item">启动文件 startup_gd32f3x0.s
剖析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#配置栈信息"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">配置栈信息</span></span></a></li><li><a class="level is-mobile" href="#配置堆信息"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">配置堆信息</span></span></a></li><li><a class="level is-mobile" href="#映射向量表"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">映射向量表</span></span></a></li><li><a class="level is-mobile" href="#设置复位处理程序"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">设置复位处理程序</span></span></a></li><li><a class="level is-mobile" href="#定义异常外部中断处理程序"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">定义异常/外部中断处理程序</span></span></a></li><li><a class="level is-mobile" href="#初始化用户堆栈"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">初始化用户堆栈</span></span></a></li></ul></li><li><a class="level is-mobile" href="#时钟配置-system_gd32f3x0.c-解析"><span class="level-left"><span class="level-item">9</span><span class="level-item">时钟配置 system_gd32f3x0.c
解析</span></span></a></li><li><a class="level is-mobile" href="#系统滴答定时器-systick"><span class="level-left"><span class="level-item">10</span><span class="level-item">系统滴答定时器 SysTick</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-systick_config-配置寄存器"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">使用 SysTick_Config()
配置寄存器</span></span></a></li><li><a class="level is-mobile" href="#滴答定时器官方示例-systick.c"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">滴答定时器官方示例 systick.c</span></span></a></li><li><a class="level is-mobile" href="#编写-main.c-测试代码"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">编写 main.c 测试代码</span></span></a></li><li><a class="level is-mobile" href="#uinio_systick_delay_usms"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">UINIO_SysTick_Delay_us/ms()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driverssystick.h"><span class="level-left"><span class="level-item">10.4.1</span><span class="level-item">Drivers/SysTick.h</span></span></a></li><li><a class="level is-mobile" href="#driverssystick.c"><span class="level-left"><span class="level-item">10.4.2</span><span class="level-item">Drivers/SysTick.c</span></span></a></li></ul></li><li><a class="level is-mobile" href="#修改-main.c-测试代码"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">修改 main.c 测试代码</span></span></a></li><li><a class="level is-mobile" href="#库函数修改-systick-的时钟源"><span class="level-left"><span class="level-item">10.6</span><span class="level-item">库函数修改 SysTick 的时钟源</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基于位带-bit-band-执行位操作"><span class="level-left"><span class="level-item">11</span><span class="level-item">基于位带 Bit Band 执行位操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#位带别名区-位带区"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">位带别名区 → 位带区</span></span></a></li><li><a class="level is-mobile" href="#建立通用的映射公式"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">建立通用的映射公式</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-2"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#bitband.h"><span class="level-left"><span class="level-item">11.3.1</span><span class="level-item">BitBand.h</span></span></a></li><li><a class="level is-mobile" href="#main.c"><span class="level-left"><span class="level-item">11.3.2</span><span class="level-item">main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#gpio-输入模式与按键"><span class="level-left"><span class="level-item">12</span><span class="level-item">GPIO 输入模式与按键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#按键使用原理"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">按键使用原理</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-3"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driverskey.h"><span class="level-left"><span class="level-item">12.2.1</span><span class="level-item">Drivers/key.h</span></span></a></li><li><a class="level is-mobile" href="#driverskey.c"><span class="level-left"><span class="level-item">12.2.2</span><span class="level-item">Drivers/key.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-2"><span class="level-left"><span class="level-item">12.2.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#usart-通用同步异步收发器"><span class="level-left"><span class="level-item">13</span><span class="level-item">USART 通用同步/异步收发器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#usart-串行协议分析"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">USART 串行协议分析</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-4"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driversusart.h"><span class="level-left"><span class="level-item">13.2.1</span><span class="level-item">Drivers/USART.h</span></span></a></li><li><a class="level is-mobile" href="#driversusart.c"><span class="level-left"><span class="level-item">13.2.2</span><span class="level-item">Drivers/USART.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-3"><span class="level-left"><span class="level-item">13.2.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#外部中断-exti"><span class="level-left"><span class="level-item">14</span><span class="level-item">外部中断 EXTI</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#嵌套向量中断控制-nvic"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">嵌套向量中断控制 NVIC</span></span></a></li><li><a class="level is-mobile" href="#外部中断事件控制器-exti"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">外部中断/事件控制器 EXTI</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-5"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driversexti-key.h"><span class="level-left"><span class="level-item">14.3.1</span><span class="level-item">Drivers/EXTI-Key.h</span></span></a></li><li><a class="level is-mobile" href="#driversexti-key.c"><span class="level-left"><span class="level-item">14.3.2</span><span class="level-item">Drivers/EXTI-Key.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-4"><span class="level-left"><span class="level-item">14.3.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#定时器-timer-概览"><span class="level-left"><span class="level-item">15</span><span class="level-item">定时器 TIMER 概览</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#高级定时器-timer0"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">高级定时器 TIMER0</span></span></a></li><li><a class="level is-mobile" href="#通用定时器-l0---timer1-timer2"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">通用定时器 L0 - TIMER1,
TIMER2</span></span></a></li><li><a class="level is-mobile" href="#通用定时器-l2---timer13"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">通用定时器 L2 - TIMER13</span></span></a></li><li><a class="level is-mobile" href="#通用定时器-l3---timer14"><span class="level-left"><span class="level-item">15.4</span><span class="level-item">通用定时器 L3 - TIMER14</span></span></a></li><li><a class="level is-mobile" href="#通用定时器-l4---timer15-timer16"><span class="level-left"><span class="level-item">15.5</span><span class="level-item">通用定时器 L4 - TIMER15,
TIMER16</span></span></a></li><li><a class="level is-mobile" href="#基本定时器---timer5"><span class="level-left"><span class="level-item">15.6</span><span class="level-item">基本定时器 - TIMER5</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基本定时器-timer5-与中断"><span class="level-left"><span class="level-item">16</span><span class="level-item">基本定时器 TIMER5 与中断</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定时器时钟配置"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">定时器时钟配置</span></span></a></li><li><a class="level is-mobile" href="#定时器工作参数配置"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">定时器工作参数配置</span></span></a></li><li><a class="level is-mobile" href="#实验电路的搭建"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">实验电路的搭建</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-6"><span class="level-left"><span class="level-item">16.4</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driverstimer-led.h"><span class="level-left"><span class="level-item">16.4.1</span><span class="level-item">Drivers/Timer-LED.h</span></span></a></li><li><a class="level is-mobile" href="#driverstimer-led.c"><span class="level-left"><span class="level-item">16.4.2</span><span class="level-item">Drivers/Timer-LED.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-5"><span class="level-left"><span class="level-item">16.4.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#通用定时器-timer1-与-pwm"><span class="level-left"><span class="level-item">17</span><span class="level-item">通用定时器 TIMER1 与 PWM</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#脉冲宽度调制-pwm-简介"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">脉冲宽度调制 PWM 简介</span></span></a></li><li><a class="level is-mobile" href="#定时器-timer1-的-pwm-通道"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">定时器 TIMER1 的 PWM 通道</span></span></a></li><li><a class="level is-mobile" href="#pwm-脉冲频率的计算"><span class="level-left"><span class="level-item">17.3</span><span class="level-item">PWM 脉冲频率的计算</span></span></a></li><li><a class="level is-mobile" href="#实验电路的搭建-1"><span class="level-left"><span class="level-item">17.4</span><span class="level-item">实验电路的搭建</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-7"><span class="level-left"><span class="level-item">17.5</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driverspwm-led.h"><span class="level-left"><span class="level-item">17.5.1</span><span class="level-item">Drivers/PWM-LED.h</span></span></a></li><li><a class="level is-mobile" href="#driverspwm-led.c"><span class="level-left"><span class="level-item">17.5.2</span><span class="level-item">Drivers/PWM-LED.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-6"><span class="level-left"><span class="level-item">17.5.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#直接存储器存取-dma-与中断"><span class="level-left"><span class="level-item">18</span><span class="level-item">直接存储器存取 DMA 与中断</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dma-功能简介"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">DMA 功能简介</span></span></a></li><li><a class="level is-mobile" href="#实验电路的搭建-2"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">实验电路的搭建</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-8"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sourcesgd32f3x0_it.c"><span class="level-left"><span class="level-item">18.3.1</span><span class="level-item">Sources/gd32f3x0_it.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-7"><span class="level-left"><span class="level-item">18.3.2</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#adc-模数转换器外设"><span class="level-left"><span class="level-item">19</span><span class="level-item">ADC 模数转换器外设</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#adc-外设简介"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">ADC 外设简介</span></span></a></li><li><a class="level is-mobile" href="#adc-采样通道与模式"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">ADC 采样通道与模式</span></span></a></li><li><a class="level is-mobile" href="#adc-性能参数"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">ADC 性能参数</span></span></a></li><li><a class="level is-mobile" href="#实验电路的搭建-3"><span class="level-left"><span class="level-item">19.4</span><span class="level-item">实验电路的搭建</span></span></a></li><li><a class="level is-mobile" href="#完整-keil-µvision-工程代码-9"><span class="level-left"><span class="level-item">19.5</span><span class="level-item">完整 Keil µVision 工程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#driversadc.h"><span class="level-left"><span class="level-item">19.5.1</span><span class="level-item">Drivers/ADC.h</span></span></a></li><li><a class="level is-mobile" href="#driversadc.c"><span class="level-left"><span class="level-item">19.5.2</span><span class="level-item">Drivers/ADC.c</span></span></a></li><li><a class="level is-mobile" href="#sourcesmain.c-8"><span class="level-left"><span class="level-item">19.5.3</span><span class="level-item">Sources/main.c</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#i2c-集成电路总线"><span class="level-left"><span class="level-item">20</span><span class="level-item">I2C 集成电路总线</span></span></a></li><li><a class="level is-mobile" href="#spi-串行外设总线"><span class="level-left"><span class="level-item">21</span><span class="level-item">SPI 串行外设总线</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Design/"><span class="level-start"><span class="level-item">Design</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Electronics/"><span class="level-start"><span class="level-item">Electronics</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Embedded/"><span class="level-start"><span class="level-item">Embedded</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/English/"><span class="level-start"><span class="level-item">English</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Thinking/"><span class="level-start"><span class="level-item">Thinking</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Zen/"><span class="level-start"><span class="level-item">Zen</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%B5%E5%AD%90%E7%A1%AC%E4%BB%B6/"><span class="level-start"><span class="level-item">电子硬件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Battery/"><img src="/Electronics/Battery/logo.png" alt="关于锂离子电池选型里的一些重要细节"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-08-28T16:00:00.000Z">2024-08-29</time></p><p class="title"><a href="/Electronics/Battery/">关于锂离子电池选型里的一些重要细节</a></p><p class="categories"><a href="/categories/%E7%94%B5%E5%AD%90%E7%A1%AC%E4%BB%B6/">电子硬件</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/LTspice/"><img src="/Electronics/LTspice/logo.png" alt="如何使用新版本的 LTspice 进行模拟电路仿真"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-05-21T16:00:00.000Z">2024-05-22</time></p><p class="title"><a href="/Electronics/LTspice/">如何使用新版本的 LTspice 进行模拟电路仿真</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/SI9000/"><img src="/Electronics/SI9000/logo.png" alt="基于 Polar Si9000e 计算传输线特征阻抗的全攻略"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-04-04T16:00:00.000Z">2024-04-05</time></p><p class="title"><a href="/Electronics/SI9000/">基于 Polar Si9000e 计算传输线特征阻抗的全攻略</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Electronics/Component/"><img src="/Electronics/Component/logo.png" alt="硬件电路设计当中 の 常用分立元器件选型"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-30T16:00:00.000Z">2024-03-31</time></p><p class="title"><a href="/Electronics/Component/">硬件电路设计当中 の 常用分立元器件选型</a></p><p class="categories"><a href="/categories/Electronics/">Electronics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Project/UINIO-MCU-GD32/"><img src="/Project/UINIO-MCU-GD32/logo.png" alt="兆易创新 UINIO-MCU-GD32F350 固件库开发指南"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-17T16:00:00.000Z">2024-03-18</time></p><p class="title"><a href="/Project/UINIO-MCU-GD32/">兆易创新 UINIO-MCU-GD32F350 固件库开发指南</a></p><p class="categories"><a href="/categories/Project/">Project</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Analog-Circuit/"><span class="tag">Analog Circuit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAD/"><span class="tag">CAD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Calculus/"><span class="tag">Calculus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Circuit-Analysis/"><span class="tag">Circuit Analysis</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Circuit-Theory/"><span class="tag">Circuit Theory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Command/"><span class="tag">Command</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Component/"><span class="tag">Component</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Config/"><span class="tag">Config</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Convention/"><span class="tag">Convention</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Digital-Circuit/"><span class="tag">Digital Circuit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EDA/"><span class="tag">EDA</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Economy/"><span class="tag">Economy</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Elementary/"><span class="tag">Elementary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Encrypt/"><span class="tag">Encrypt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC-GDB/"><span class="tag">GCC/GDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Grammar/"><span class="tag">Grammar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Industry/"><span class="tag">Industry</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Instrument/"><span class="tag">Instrument</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Life/"><span class="tag">Life</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MCU/"><span class="tag">MCU</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mobile/"><span class="tag">Mobile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/New-Concept-English/"><span class="tag">New Concept English</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCB/"><span class="tag">PCB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protocol/"><span class="tag">Protocol</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python3/"><span class="tag">Python3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RFID/"><span class="tag">RFID</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Server/"><span class="tag">Server</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Simulation/"><span class="tag">Simulation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Solidity/"><span class="tag">Solidity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zen/"><span class="tag">Zen</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%B1%A0/"><span class="tag">电池</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E6%BA%90/"><span class="tag">电源</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="/images/ICP.png"> 蜀 ICP 备 2021027760 号</a><p class="is-size-7">Copyright © 2024 <span>UinIO.com</span> by Hank</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><script src="/js/math.js"></script><script id="MathJax-script" async src="/js/es5/tex-mml-chtml.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>